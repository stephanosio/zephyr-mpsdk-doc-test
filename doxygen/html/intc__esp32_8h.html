<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zephyr API Documentation: include/drivers/interrupt_controller/intc_esp32.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-zephyr.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-zephyr.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Zephyr API Documentation
   &#160;<span id="projectnumber">3.0.0-rc3</span>
   </div>
   <div id="projectbrief">A Scalable Open Source RTOS</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('intc__esp32_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">intc_esp32.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="stdint_8h_source.html">stdint.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="stdbool_8h_source.html">stdbool.h</a>&gt;</code><br />
</div>
<p><a href="intc__esp32_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structshared__vector__desc__t.html">shared_vector_desc_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector__desc__t.html">vector_desc_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structintr__handle__data__t.html">intr_handle_data_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a1bc4233beade6702b76413dd4ee6497f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#a1bc4233beade6702b76413dd4ee6497f">ESP_INTC_INTS_NUM</a>&#160;&#160;&#160;(32)</td></tr>
<tr class="separator:a1bc4233beade6702b76413dd4ee6497f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ef5952bffcb1811d4f831b98ecf42a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#ab1ef5952bffcb1811d4f831b98ecf42a">ESP_INTR_FLAG_LEVEL1</a>&#160;&#160;&#160;(1&lt;&lt;1)	/* Accept a Level 1 int vector, lowest priority */</td></tr>
<tr class="separator:ab1ef5952bffcb1811d4f831b98ecf42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4478d65d49a4f17fb77599764239e2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#a8e4478d65d49a4f17fb77599764239e2">ESP_INTR_FLAG_LEVEL2</a>&#160;&#160;&#160;(1&lt;&lt;2)	/* Accept a Level 2 int vector */</td></tr>
<tr class="separator:a8e4478d65d49a4f17fb77599764239e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ed1ea08351b07086a6e73a0487b0d8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#a88ed1ea08351b07086a6e73a0487b0d8">ESP_INTR_FLAG_LEVEL3</a>&#160;&#160;&#160;(1&lt;&lt;3)	/* Accept a Level 3 int vector */</td></tr>
<tr class="separator:a88ed1ea08351b07086a6e73a0487b0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb43226aa7d32763f17ee6a56090b322"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#abb43226aa7d32763f17ee6a56090b322">ESP_INTR_FLAG_LEVEL4</a>&#160;&#160;&#160;(1&lt;&lt;4)	/* Accept a Level 4 int vector */</td></tr>
<tr class="separator:abb43226aa7d32763f17ee6a56090b322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a1013070e7d9a06e8f08ed3f2cbca9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#a44a1013070e7d9a06e8f08ed3f2cbca9">ESP_INTR_FLAG_LEVEL5</a>&#160;&#160;&#160;(1&lt;&lt;5)	/* Accept a Level 5 int vector */</td></tr>
<tr class="separator:a44a1013070e7d9a06e8f08ed3f2cbca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8defb5130273462e32ed399dece67024"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#a8defb5130273462e32ed399dece67024">ESP_INTR_FLAG_LEVEL6</a>&#160;&#160;&#160;(1&lt;&lt;6)	/* Accept a Level 6 int vector */</td></tr>
<tr class="separator:a8defb5130273462e32ed399dece67024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e57c700cf362161d807657571280abe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#a9e57c700cf362161d807657571280abe">ESP_INTR_FLAG_NMI</a>&#160;&#160;&#160;(1&lt;&lt;7)	/* Accept a Level 7 int vector, highest priority */</td></tr>
<tr class="separator:a9e57c700cf362161d807657571280abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7bfcea2e621d81336ea6dd23310363"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#afc7bfcea2e621d81336ea6dd23310363">ESP_INTR_FLAG_SHARED</a>&#160;&#160;&#160;(1&lt;&lt;8)	/* Interrupt can be shared between ISRs */</td></tr>
<tr class="separator:afc7bfcea2e621d81336ea6dd23310363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab957dd5055fe20725624db223f9535"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#a0ab957dd5055fe20725624db223f9535">ESP_INTR_FLAG_EDGE</a>&#160;&#160;&#160;(1&lt;&lt;9)	/* Edge-triggered interrupt */</td></tr>
<tr class="separator:a0ab957dd5055fe20725624db223f9535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb8d6fa8b5e33b3503e86917bc8367b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#a3fb8d6fa8b5e33b3503e86917bc8367b">ESP_INTR_FLAG_IRAM</a>&#160;&#160;&#160;(1&lt;&lt;10)	/* ISR can be called if cache is disabled */</td></tr>
<tr class="separator:a3fb8d6fa8b5e33b3503e86917bc8367b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d024609ecd48dc17b586b91e779b88"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#a76d024609ecd48dc17b586b91e779b88">ESP_INTR_FLAG_INTRDISABLED</a>&#160;&#160;&#160;(1&lt;&lt;11)	/* Return with this interrupt disabled */</td></tr>
<tr class="separator:a76d024609ecd48dc17b586b91e779b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0bc1a2b5cc22b499e041742ae1b17b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#a9b0bc1a2b5cc22b499e041742ae1b17b">ESP_INTR_FLAG_LOWMED</a>&#160;&#160;&#160;(<a class="el" href="intc__esp32c3_8h.html#ab1ef5952bffcb1811d4f831b98ecf42a">ESP_INTR_FLAG_LEVEL1</a>|<a class="el" href="intc__esp32_8h.html#a8e4478d65d49a4f17fb77599764239e2">ESP_INTR_FLAG_LEVEL2</a>|<a class="el" href="intc__esp32_8h.html#a88ed1ea08351b07086a6e73a0487b0d8">ESP_INTR_FLAG_LEVEL3</a>)</td></tr>
<tr class="separator:a9b0bc1a2b5cc22b499e041742ae1b17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b4eee1d70d2e9cb1dc0ecb41f40aa4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#a63b4eee1d70d2e9cb1dc0ecb41f40aa4">ESP_INTR_FLAG_HIGH</a></td></tr>
<tr class="separator:a63b4eee1d70d2e9cb1dc0ecb41f40aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610949ce2bf8d7adae528f816acc5725"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#a610949ce2bf8d7adae528f816acc5725">ESP_INTR_FLAG_LEVELMASK</a></td></tr>
<tr class="separator:a610949ce2bf8d7adae528f816acc5725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff354dc48600b4dcbce4569c5d15bc1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#a2ff354dc48600b4dcbce4569c5d15bc1">ETS_INTERNAL_TIMER0_INTR_SOURCE</a>&#160;&#160;&#160;-1 /* Xtensa <a class="el" href="test__sched__timeslice__and__lock_8c.html#a4ced20aea8a1e880c43f684a920b85da">timer</a> 0 interrupt source */</td></tr>
<tr class="separator:a2ff354dc48600b4dcbce4569c5d15bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28849af2335d2c6d9e07949f8ea953d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#ad28849af2335d2c6d9e07949f8ea953d">ETS_INTERNAL_TIMER1_INTR_SOURCE</a>&#160;&#160;&#160;-2 /* Xtensa <a class="el" href="test__sched__timeslice__and__lock_8c.html#a4ced20aea8a1e880c43f684a920b85da">timer</a> 1 interrupt source */</td></tr>
<tr class="separator:ad28849af2335d2c6d9e07949f8ea953d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94487ae3c0ae2b9e4bccad6ce26d761"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#ad94487ae3c0ae2b9e4bccad6ce26d761">ETS_INTERNAL_TIMER2_INTR_SOURCE</a>&#160;&#160;&#160;-3 /* Xtensa <a class="el" href="test__sched__timeslice__and__lock_8c.html#a4ced20aea8a1e880c43f684a920b85da">timer</a> 2 interrupt source */</td></tr>
<tr class="separator:ad94487ae3c0ae2b9e4bccad6ce26d761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd02abe5015f1be30d77e1be15bd448"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#a7cd02abe5015f1be30d77e1be15bd448">ETS_INTERNAL_SW0_INTR_SOURCE</a>&#160;&#160;&#160;-4 /* Software int source 1 */</td></tr>
<tr class="separator:a7cd02abe5015f1be30d77e1be15bd448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81d606c0199b91aba7633270ca314e6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#aa81d606c0199b91aba7633270ca314e6">ETS_INTERNAL_SW1_INTR_SOURCE</a>&#160;&#160;&#160;-5 /* Software int source 2 */</td></tr>
<tr class="separator:aa81d606c0199b91aba7633270ca314e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cac8d828d3ec24b9bb58fe0cb3d59fc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#a6cac8d828d3ec24b9bb58fe0cb3d59fc">ETS_INTERNAL_PROFILING_INTR_SOURCE</a>&#160;&#160;&#160;-6 /* Int source for profiling */</td></tr>
<tr class="separator:a6cac8d828d3ec24b9bb58fe0cb3d59fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a637aa0db4839d3e945e74c56e82218f2"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#a637aa0db4839d3e945e74c56e82218f2">intr_handler_t</a>) (void *arg)</td></tr>
<tr class="separator:a637aa0db4839d3e945e74c56e82218f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aede8e7c90fd3138cf165a0eea1c920fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#aede8e7c90fd3138cf165a0eea1c920fe">esp_intr_initialize</a> (void)</td></tr>
<tr class="memdesc:aede8e7c90fd3138cf165a0eea1c920fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes interrupt table to its defaults.  <a href="intc__esp32_8h.html#aede8e7c90fd3138cf165a0eea1c920fe">More...</a><br /></td></tr>
<tr class="separator:aede8e7c90fd3138cf165a0eea1c920fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc6d38bb52a59bd024809efcb3b64f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#aafc6d38bb52a59bd024809efcb3b64f0">esp_intr_mark_shared</a> (int intno, int cpu, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> is_in_iram)</td></tr>
<tr class="memdesc:aafc6d38bb52a59bd024809efcb3b64f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark an interrupt as a shared interrupt.  <a href="intc__esp32_8h.html#aafc6d38bb52a59bd024809efcb3b64f0">More...</a><br /></td></tr>
<tr class="separator:aafc6d38bb52a59bd024809efcb3b64f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6eef593f8a838adec4d258346b087d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#aa6eef593f8a838adec4d258346b087d0">esp_intr_reserve</a> (int intno, int cpu)</td></tr>
<tr class="memdesc:aa6eef593f8a838adec4d258346b087d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve an interrupt to be used outside of this framework.  <a href="intc__esp32_8h.html#aa6eef593f8a838adec4d258346b087d0">More...</a><br /></td></tr>
<tr class="separator:aa6eef593f8a838adec4d258346b087d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480a4405ea151074f2ce4ffbab1265ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#a480a4405ea151074f2ce4ffbab1265ea">esp_intr_alloc</a> (int source, int <a class="el" href="http__parser_8h.html#ab6b306ef981f5e21bb41ea2c2dbe8cd9">flags</a>, <a class="el" href="intc__esp32_8h.html#a637aa0db4839d3e945e74c56e82218f2">intr_handler_t</a> <a class="el" href="timer_2starve_2src_2main_8c.html#ab28ee8b6412d992f77f819e17b664869">handler</a>, void *arg, struct <a class="el" href="structintr__handle__data__t.html">intr_handle_data_t</a> **ret_handle)</td></tr>
<tr class="memdesc:a480a4405ea151074f2ce4ffbab1265ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an interrupt with the given parameters.  <a href="intc__esp32_8h.html#a480a4405ea151074f2ce4ffbab1265ea">More...</a><br /></td></tr>
<tr class="separator:a480a4405ea151074f2ce4ffbab1265ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8659159ab9a4fea92d989068bb6d6f7b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#a8659159ab9a4fea92d989068bb6d6f7b">esp_intr_alloc_intrstatus</a> (int source, int <a class="el" href="http__parser_8h.html#ab6b306ef981f5e21bb41ea2c2dbe8cd9">flags</a>, <a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> intrstatusreg, <a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> intrstatusmask, <a class="el" href="intc__esp32_8h.html#a637aa0db4839d3e945e74c56e82218f2">intr_handler_t</a> <a class="el" href="timer_2starve_2src_2main_8c.html#ab28ee8b6412d992f77f819e17b664869">handler</a>, void *arg, struct <a class="el" href="structintr__handle__data__t.html">intr_handle_data_t</a> **ret_handle)</td></tr>
<tr class="memdesc:a8659159ab9a4fea92d989068bb6d6f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an interrupt with the given parameters.  <a href="intc__esp32_8h.html#a8659159ab9a4fea92d989068bb6d6f7b">More...</a><br /></td></tr>
<tr class="separator:a8659159ab9a4fea92d989068bb6d6f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90993df0cbd038640609df8c3e1957d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#a90993df0cbd038640609df8c3e1957d3">esp_intr_free</a> (struct <a class="el" href="structintr__handle__data__t.html">intr_handle_data_t</a> *handle)</td></tr>
<tr class="memdesc:a90993df0cbd038640609df8c3e1957d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable and free an interrupt.  <a href="intc__esp32_8h.html#a90993df0cbd038640609df8c3e1957d3">More...</a><br /></td></tr>
<tr class="separator:a90993df0cbd038640609df8c3e1957d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c399aafeab8bff0a49bc2b127445e10"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#a6c399aafeab8bff0a49bc2b127445e10">esp_intr_get_cpu</a> (struct <a class="el" href="structintr__handle__data__t.html">intr_handle_data_t</a> *handle)</td></tr>
<tr class="memdesc:a6c399aafeab8bff0a49bc2b127445e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get CPU number an interrupt is tied to.  <a href="intc__esp32_8h.html#a6c399aafeab8bff0a49bc2b127445e10">More...</a><br /></td></tr>
<tr class="separator:a6c399aafeab8bff0a49bc2b127445e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5261fac231a9d1428b4131da33f1ef90"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#a5261fac231a9d1428b4131da33f1ef90">esp_intr_get_intno</a> (struct <a class="el" href="structintr__handle__data__t.html">intr_handle_data_t</a> *handle)</td></tr>
<tr class="memdesc:a5261fac231a9d1428b4131da33f1ef90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the allocated interrupt for a certain handle.  <a href="intc__esp32_8h.html#a5261fac231a9d1428b4131da33f1ef90">More...</a><br /></td></tr>
<tr class="separator:a5261fac231a9d1428b4131da33f1ef90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee7a7cc9ed4f7bb6e0fa65ac7e77ba6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#a3ee7a7cc9ed4f7bb6e0fa65ac7e77ba6">esp_intr_disable</a> (struct <a class="el" href="structintr__handle__data__t.html">intr_handle_data_t</a> *handle)</td></tr>
<tr class="memdesc:a3ee7a7cc9ed4f7bb6e0fa65ac7e77ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the interrupt associated with the handle.  <a href="intc__esp32_8h.html#a3ee7a7cc9ed4f7bb6e0fa65ac7e77ba6">More...</a><br /></td></tr>
<tr class="separator:a3ee7a7cc9ed4f7bb6e0fa65ac7e77ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9ed282687252cd3a8e5c18284257ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#a3a9ed282687252cd3a8e5c18284257ff">esp_intr_enable</a> (struct <a class="el" href="structintr__handle__data__t.html">intr_handle_data_t</a> *handle)</td></tr>
<tr class="memdesc:a3a9ed282687252cd3a8e5c18284257ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the interrupt associated with the handle.  <a href="intc__esp32_8h.html#a3a9ed282687252cd3a8e5c18284257ff">More...</a><br /></td></tr>
<tr class="separator:a3a9ed282687252cd3a8e5c18284257ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1417d7a4a9faba280ac4e17c9ee60ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#af1417d7a4a9faba280ac4e17c9ee60ab">esp_intr_set_in_iram</a> (struct <a class="el" href="structintr__handle__data__t.html">intr_handle_data_t</a> *handle, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> is_in_iram)</td></tr>
<tr class="memdesc:af1417d7a4a9faba280ac4e17c9ee60ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the "in IRAM" status of the handler.  <a href="intc__esp32_8h.html#af1417d7a4a9faba280ac4e17c9ee60ab">More...</a><br /></td></tr>
<tr class="separator:af1417d7a4a9faba280ac4e17c9ee60ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63263dc3bf78c25b514f739e6381ee64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#a63263dc3bf78c25b514f739e6381ee64">esp_intr_noniram_disable</a> (void)</td></tr>
<tr class="memdesc:a63263dc3bf78c25b514f739e6381ee64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable interrupts that aren't specifically marked as running from IRAM.  <a href="intc__esp32_8h.html#a63263dc3bf78c25b514f739e6381ee64">More...</a><br /></td></tr>
<tr class="separator:a63263dc3bf78c25b514f739e6381ee64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917f8af7f0c6af92dfbd1f7689c39cae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intc__esp32_8h.html#a917f8af7f0c6af92dfbd1f7689c39cae">esp_intr_noniram_enable</a> (void)</td></tr>
<tr class="memdesc:a917f8af7f0c6af92dfbd1f7689c39cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-enable interrupts disabled by esp_intr_noniram_disable.  <a href="intc__esp32_8h.html#a917f8af7f0c6af92dfbd1f7689c39cae">More...</a><br /></td></tr>
<tr class="separator:a917f8af7f0c6af92dfbd1f7689c39cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a1bc4233beade6702b76413dd4ee6497f" name="a1bc4233beade6702b76413dd4ee6497f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc4233beade6702b76413dd4ee6497f">&#9670;&nbsp;</a></span>ESP_INTC_INTS_NUM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ESP_INTC_INTS_NUM&#160;&#160;&#160;(32)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ab957dd5055fe20725624db223f9535" name="a0ab957dd5055fe20725624db223f9535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ab957dd5055fe20725624db223f9535">&#9670;&nbsp;</a></span>ESP_INTR_FLAG_EDGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ESP_INTR_FLAG_EDGE&#160;&#160;&#160;(1&lt;&lt;9)	/* Edge-triggered interrupt */</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63b4eee1d70d2e9cb1dc0ecb41f40aa4" name="a63b4eee1d70d2e9cb1dc0ecb41f40aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b4eee1d70d2e9cb1dc0ecb41f40aa4">&#9670;&nbsp;</a></span>ESP_INTR_FLAG_HIGH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ESP_INTR_FLAG_HIGH</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">                                 (<a class="code hl_define" href="intc__esp32_8h.html#abb43226aa7d32763f17ee6a56090b322">ESP_INTR_FLAG_LEVEL4</a>|<a class="code hl_define" href="intc__esp32_8h.html#a44a1013070e7d9a06e8f08ed3f2cbca9">ESP_INTR_FLAG_LEVEL5</a>|<a class="code hl_define" href="intc__esp32_8h.html#a8defb5130273462e32ed399dece67024">ESP_INTR_FLAG_LEVEL6</a>| \</div>
<div class="line">                                 ESP_INTR_FLAG_NMI)</div>
<div class="ttc" id="aintc__esp32_8h_html_a44a1013070e7d9a06e8f08ed3f2cbca9"><div class="ttname"><a href="intc__esp32_8h.html#a44a1013070e7d9a06e8f08ed3f2cbca9">ESP_INTR_FLAG_LEVEL5</a></div><div class="ttdeci">#define ESP_INTR_FLAG_LEVEL5</div><div class="ttdef"><b>Definition:</b> intc_esp32.h:27</div></div>
<div class="ttc" id="aintc__esp32_8h_html_a8defb5130273462e32ed399dece67024"><div class="ttname"><a href="intc__esp32_8h.html#a8defb5130273462e32ed399dece67024">ESP_INTR_FLAG_LEVEL6</a></div><div class="ttdeci">#define ESP_INTR_FLAG_LEVEL6</div><div class="ttdef"><b>Definition:</b> intc_esp32.h:28</div></div>
<div class="ttc" id="aintc__esp32_8h_html_abb43226aa7d32763f17ee6a56090b322"><div class="ttname"><a href="intc__esp32_8h.html#abb43226aa7d32763f17ee6a56090b322">ESP_INTR_FLAG_LEVEL4</a></div><div class="ttdeci">#define ESP_INTR_FLAG_LEVEL4</div><div class="ttdef"><b>Definition:</b> intc_esp32.h:26</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a76d024609ecd48dc17b586b91e779b88" name="a76d024609ecd48dc17b586b91e779b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76d024609ecd48dc17b586b91e779b88">&#9670;&nbsp;</a></span>ESP_INTR_FLAG_INTRDISABLED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ESP_INTR_FLAG_INTRDISABLED&#160;&#160;&#160;(1&lt;&lt;11)	/* Return with this interrupt disabled */</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3fb8d6fa8b5e33b3503e86917bc8367b" name="a3fb8d6fa8b5e33b3503e86917bc8367b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb8d6fa8b5e33b3503e86917bc8367b">&#9670;&nbsp;</a></span>ESP_INTR_FLAG_IRAM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ESP_INTR_FLAG_IRAM&#160;&#160;&#160;(1&lt;&lt;10)	/* ISR can be called if cache is disabled */</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1ef5952bffcb1811d4f831b98ecf42a" name="ab1ef5952bffcb1811d4f831b98ecf42a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ef5952bffcb1811d4f831b98ecf42a">&#9670;&nbsp;</a></span>ESP_INTR_FLAG_LEVEL1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ESP_INTR_FLAG_LEVEL1&#160;&#160;&#160;(1&lt;&lt;1)	/* Accept a Level 1 int vector, lowest priority */</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e4478d65d49a4f17fb77599764239e2" name="a8e4478d65d49a4f17fb77599764239e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e4478d65d49a4f17fb77599764239e2">&#9670;&nbsp;</a></span>ESP_INTR_FLAG_LEVEL2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ESP_INTR_FLAG_LEVEL2&#160;&#160;&#160;(1&lt;&lt;2)	/* Accept a Level 2 int vector */</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a88ed1ea08351b07086a6e73a0487b0d8" name="a88ed1ea08351b07086a6e73a0487b0d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88ed1ea08351b07086a6e73a0487b0d8">&#9670;&nbsp;</a></span>ESP_INTR_FLAG_LEVEL3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ESP_INTR_FLAG_LEVEL3&#160;&#160;&#160;(1&lt;&lt;3)	/* Accept a Level 3 int vector */</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb43226aa7d32763f17ee6a56090b322" name="abb43226aa7d32763f17ee6a56090b322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb43226aa7d32763f17ee6a56090b322">&#9670;&nbsp;</a></span>ESP_INTR_FLAG_LEVEL4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ESP_INTR_FLAG_LEVEL4&#160;&#160;&#160;(1&lt;&lt;4)	/* Accept a Level 4 int vector */</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a44a1013070e7d9a06e8f08ed3f2cbca9" name="a44a1013070e7d9a06e8f08ed3f2cbca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44a1013070e7d9a06e8f08ed3f2cbca9">&#9670;&nbsp;</a></span>ESP_INTR_FLAG_LEVEL5</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ESP_INTR_FLAG_LEVEL5&#160;&#160;&#160;(1&lt;&lt;5)	/* Accept a Level 5 int vector */</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8defb5130273462e32ed399dece67024" name="a8defb5130273462e32ed399dece67024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8defb5130273462e32ed399dece67024">&#9670;&nbsp;</a></span>ESP_INTR_FLAG_LEVEL6</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ESP_INTR_FLAG_LEVEL6&#160;&#160;&#160;(1&lt;&lt;6)	/* Accept a Level 6 int vector */</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a610949ce2bf8d7adae528f816acc5725" name="a610949ce2bf8d7adae528f816acc5725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610949ce2bf8d7adae528f816acc5725">&#9670;&nbsp;</a></span>ESP_INTR_FLAG_LEVELMASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ESP_INTR_FLAG_LEVELMASK</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">                                 (<a class="code hl_define" href="intc__esp32_8h.html#ab1ef5952bffcb1811d4f831b98ecf42a">ESP_INTR_FLAG_LEVEL1</a>|<a class="code hl_define" href="intc__esp32_8h.html#a8e4478d65d49a4f17fb77599764239e2">ESP_INTR_FLAG_LEVEL2</a>|<a class="code hl_define" href="intc__esp32_8h.html#a88ed1ea08351b07086a6e73a0487b0d8">ESP_INTR_FLAG_LEVEL3</a>| \</div>
<div class="line">                                 ESP_INTR_FLAG_LEVEL4|<a class="code hl_define" href="intc__esp32_8h.html#a44a1013070e7d9a06e8f08ed3f2cbca9">ESP_INTR_FLAG_LEVEL5</a>|<a class="code hl_define" href="intc__esp32_8h.html#a8defb5130273462e32ed399dece67024">ESP_INTR_FLAG_LEVEL6</a>| \</div>
<div class="line">                                 ESP_INTR_FLAG_NMI)</div>
<div class="ttc" id="aintc__esp32_8h_html_a88ed1ea08351b07086a6e73a0487b0d8"><div class="ttname"><a href="intc__esp32_8h.html#a88ed1ea08351b07086a6e73a0487b0d8">ESP_INTR_FLAG_LEVEL3</a></div><div class="ttdeci">#define ESP_INTR_FLAG_LEVEL3</div><div class="ttdef"><b>Definition:</b> intc_esp32.h:25</div></div>
<div class="ttc" id="aintc__esp32_8h_html_a8e4478d65d49a4f17fb77599764239e2"><div class="ttname"><a href="intc__esp32_8h.html#a8e4478d65d49a4f17fb77599764239e2">ESP_INTR_FLAG_LEVEL2</a></div><div class="ttdeci">#define ESP_INTR_FLAG_LEVEL2</div><div class="ttdef"><b>Definition:</b> intc_esp32.h:24</div></div>
<div class="ttc" id="aintc__esp32_8h_html_ab1ef5952bffcb1811d4f831b98ecf42a"><div class="ttname"><a href="intc__esp32_8h.html#ab1ef5952bffcb1811d4f831b98ecf42a">ESP_INTR_FLAG_LEVEL1</a></div><div class="ttdeci">#define ESP_INTR_FLAG_LEVEL1</div><div class="ttdef"><b>Definition:</b> intc_esp32.h:23</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9b0bc1a2b5cc22b499e041742ae1b17b" name="a9b0bc1a2b5cc22b499e041742ae1b17b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b0bc1a2b5cc22b499e041742ae1b17b">&#9670;&nbsp;</a></span>ESP_INTR_FLAG_LOWMED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ESP_INTR_FLAG_LOWMED&#160;&#160;&#160;(<a class="el" href="intc__esp32c3_8h.html#ab1ef5952bffcb1811d4f831b98ecf42a">ESP_INTR_FLAG_LEVEL1</a>|<a class="el" href="intc__esp32_8h.html#a8e4478d65d49a4f17fb77599764239e2">ESP_INTR_FLAG_LEVEL2</a>|<a class="el" href="intc__esp32_8h.html#a88ed1ea08351b07086a6e73a0487b0d8">ESP_INTR_FLAG_LEVEL3</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e57c700cf362161d807657571280abe" name="a9e57c700cf362161d807657571280abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e57c700cf362161d807657571280abe">&#9670;&nbsp;</a></span>ESP_INTR_FLAG_NMI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ESP_INTR_FLAG_NMI&#160;&#160;&#160;(1&lt;&lt;7)	/* Accept a Level 7 int vector, highest priority */</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc7bfcea2e621d81336ea6dd23310363" name="afc7bfcea2e621d81336ea6dd23310363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7bfcea2e621d81336ea6dd23310363">&#9670;&nbsp;</a></span>ESP_INTR_FLAG_SHARED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ESP_INTR_FLAG_SHARED&#160;&#160;&#160;(1&lt;&lt;8)	/* Interrupt can be shared between ISRs */</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6cac8d828d3ec24b9bb58fe0cb3d59fc" name="a6cac8d828d3ec24b9bb58fe0cb3d59fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cac8d828d3ec24b9bb58fe0cb3d59fc">&#9670;&nbsp;</a></span>ETS_INTERNAL_PROFILING_INTR_SOURCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETS_INTERNAL_PROFILING_INTR_SOURCE&#160;&#160;&#160;-6 /* Int source for profiling */</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7cd02abe5015f1be30d77e1be15bd448" name="a7cd02abe5015f1be30d77e1be15bd448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd02abe5015f1be30d77e1be15bd448">&#9670;&nbsp;</a></span>ETS_INTERNAL_SW0_INTR_SOURCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETS_INTERNAL_SW0_INTR_SOURCE&#160;&#160;&#160;-4 /* Software int source 1 */</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa81d606c0199b91aba7633270ca314e6" name="aa81d606c0199b91aba7633270ca314e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81d606c0199b91aba7633270ca314e6">&#9670;&nbsp;</a></span>ETS_INTERNAL_SW1_INTR_SOURCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETS_INTERNAL_SW1_INTR_SOURCE&#160;&#160;&#160;-5 /* Software int source 2 */</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ff354dc48600b4dcbce4569c5d15bc1" name="a2ff354dc48600b4dcbce4569c5d15bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ff354dc48600b4dcbce4569c5d15bc1">&#9670;&nbsp;</a></span>ETS_INTERNAL_TIMER0_INTR_SOURCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETS_INTERNAL_TIMER0_INTR_SOURCE&#160;&#160;&#160;-1 /* Xtensa <a class="el" href="test__sched__timeslice__and__lock_8c.html#a4ced20aea8a1e880c43f684a920b85da">timer</a> 0 interrupt source */</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad28849af2335d2c6d9e07949f8ea953d" name="ad28849af2335d2c6d9e07949f8ea953d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28849af2335d2c6d9e07949f8ea953d">&#9670;&nbsp;</a></span>ETS_INTERNAL_TIMER1_INTR_SOURCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETS_INTERNAL_TIMER1_INTR_SOURCE&#160;&#160;&#160;-2 /* Xtensa <a class="el" href="test__sched__timeslice__and__lock_8c.html#a4ced20aea8a1e880c43f684a920b85da">timer</a> 1 interrupt source */</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad94487ae3c0ae2b9e4bccad6ce26d761" name="ad94487ae3c0ae2b9e4bccad6ce26d761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94487ae3c0ae2b9e4bccad6ce26d761">&#9670;&nbsp;</a></span>ETS_INTERNAL_TIMER2_INTR_SOURCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETS_INTERNAL_TIMER2_INTR_SOURCE&#160;&#160;&#160;-3 /* Xtensa <a class="el" href="test__sched__timeslice__and__lock_8c.html#a4ced20aea8a1e880c43f684a920b85da">timer</a> 2 interrupt source */</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a637aa0db4839d3e945e74c56e82218f2" name="a637aa0db4839d3e945e74c56e82218f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a637aa0db4839d3e945e74c56e82218f2">&#9670;&nbsp;</a></span>intr_handler_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* intr_handler_t) (void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a480a4405ea151074f2ce4ffbab1265ea" name="a480a4405ea151074f2ce4ffbab1265ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a480a4405ea151074f2ce4ffbab1265ea">&#9670;&nbsp;</a></span>esp_intr_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int esp_intr_alloc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="intc__esp32_8h.html#a637aa0db4839d3e945e74c56e82218f2">intr_handler_t</a>&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structintr__handle__data__t.html">intr_handle_data_t</a> **&#160;</td>
          <td class="paramname"><em>ret_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate an interrupt with the given parameters. </p>
<p >This finds an interrupt that matches the restrictions as given in the flags parameter, maps the given interrupt source to it and hooks up the given interrupt handler (with optional argument) as well. If needed, it can return a handle for the interrupt as well.</p>
<p >The interrupt will always be allocated on the core that runs this function.</p>
<p >If ESP_INTR_FLAG_IRAM flag is used, and handler address is not in IRAM or RTC_FAST_MEM, then ESP_ERR_INVALID_ARG is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The interrupt source. One of the *_INTR_SOURCE interrupt mux sources, as defined in <a class="el" href="esp-xtensa-intmux_8h.html">esp-xtensa-intmux.h</a>, or one of the internal ETS_INTERNAL_*_INTR_SOURCE sources as defined in this header. </td></tr>
    <tr><td class="paramname">flags</td><td>An ORred mask of the ESP_INTR_FLAG_* defines. These restrict the choice of interrupts that this routine can choose from. If this value is 0, it will default to allocating a non-shared interrupt of level 1, 2 or 3. If this is ESP_INTR_FLAG_SHARED, it will allocate a shared interrupt of level 1. Setting ESP_INTR_FLAG_INTRDISABLED will return from this function with the interrupt disabled. </td></tr>
    <tr><td class="paramname">handler</td><td>The interrupt handler. Must be NULL when an interrupt of level &gt;3 is requested, because these types of interrupts aren't C-callable. </td></tr>
    <tr><td class="paramname">arg</td><td>Optional argument for passed to the interrupt handler </td></tr>
    <tr><td class="paramname">ret_handle</td><td>Pointer to a struct <a class="el" href="structintr__handle__data__t.html">intr_handle_data_t</a> pointer to store a handle that can later be used to request details or free the interrupt. Can be NULL if no handle is required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-EINVAL if the combination of arguments is invalid. -ENODEV No free interrupt found with the specified flags 0 otherwise </dd></dl>

</div>
</div>
<a id="a8659159ab9a4fea92d989068bb6d6f7b" name="a8659159ab9a4fea92d989068bb6d6f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8659159ab9a4fea92d989068bb6d6f7b">&#9670;&nbsp;</a></span>esp_intr_alloc_intrstatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int esp_intr_alloc_intrstatus </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a>&#160;</td>
          <td class="paramname"><em>intrstatusreg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a>&#160;</td>
          <td class="paramname"><em>intrstatusmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="intc__esp32_8h.html#a637aa0db4839d3e945e74c56e82218f2">intr_handler_t</a>&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structintr__handle__data__t.html">intr_handle_data_t</a> **&#160;</td>
          <td class="paramname"><em>ret_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate an interrupt with the given parameters. </p>
<p >This essentially does the same as esp_intr_alloc, but allows specifying a register and mask combo. For shared interrupts, the handler is only called if a read from the specified register, ANDed with the mask, returns non-zero. By passing an interrupt status register address and a fitting mask, this can be used to accelerate interrupt handling in the case a shared interrupt is triggered; by checking the interrupt statuses first, the code can decide which ISRs can be skipped</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The interrupt source. One of the *_INTR_SOURCE interrupt mux sources, as defined in <a class="el" href="esp-xtensa-intmux_8h.html">esp-xtensa-intmux.h</a>, or one of the internal ETS_INTERNAL_*_INTR_SOURCE sources as defined in this header. </td></tr>
    <tr><td class="paramname">flags</td><td>An ORred mask of the ESP_INTR_FLAG_* defines. These restrict the choice of interrupts that this routine can choose from. If this value is 0, it will default to allocating a non-shared interrupt of level 1, 2 or 3. If this is ESP_INTR_FLAG_SHARED, it will allocate a shared interrupt of level 1. Setting ESP_INTR_FLAG_INTRDISABLED will return from this function with the interrupt disabled. </td></tr>
    <tr><td class="paramname">intrstatusreg</td><td>The address of an interrupt status register </td></tr>
    <tr><td class="paramname">intrstatusmask</td><td>A mask. If a read of address intrstatusreg has any of the bits that are 1 in the mask set, the ISR will be called. If not, it will be skipped. </td></tr>
    <tr><td class="paramname">handler</td><td>The interrupt handler. Must be NULL when an interrupt of level &gt;3 is requested, because these types of interrupts aren't C-callable. </td></tr>
    <tr><td class="paramname">arg</td><td>Optional argument for passed to the interrupt handler </td></tr>
    <tr><td class="paramname">ret_handle</td><td>Pointer to a struct <a class="el" href="structintr__handle__data__t.html">intr_handle_data_t</a> pointer to store a handle that can later be used to request details or free the interrupt. Can be NULL if no handle is required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-EINVAL if the combination of arguments is invalid. -ENODEV No free interrupt found with the specified flags 0 otherwise </dd></dl>

</div>
</div>
<a id="a3ee7a7cc9ed4f7bb6e0fa65ac7e77ba6" name="a3ee7a7cc9ed4f7bb6e0fa65ac7e77ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee7a7cc9ed4f7bb6e0fa65ac7e77ba6">&#9670;&nbsp;</a></span>esp_intr_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int esp_intr_disable </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structintr__handle__data__t.html">intr_handle_data_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the interrupt associated with the handle. </p>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>For local interrupts (ESP_INTERNAL_* sources), this function has to be called on the CPU the interrupt is allocated on. Other interrupts have no such restriction.</li>
<li>When several handlers sharing a same interrupt source, interrupt status bits, which are handled in the handler to be disabled, should be masked before the disabling, or handled in other enabled interrupts properly. Miss of interrupt status handling will cause infinite interrupt calls and finally system crash.</li>
</ol>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-EINVAL if the combination of arguments is invalid. 0 otherwise </dd></dl>

</div>
</div>
<a id="a3a9ed282687252cd3a8e5c18284257ff" name="a3a9ed282687252cd3a8e5c18284257ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a9ed282687252cd3a8e5c18284257ff">&#9670;&nbsp;</a></span>esp_intr_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int esp_intr_enable </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structintr__handle__data__t.html">intr_handle_data_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the interrupt associated with the handle. </p>
<dl class="section note"><dt>Note</dt><dd>For local interrupts (ESP_INTERNAL_* sources), this function has to be called on the CPU the interrupt is allocated on. Other interrupts have no such restriction.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-EINVAL if the combination of arguments is invalid. 0 otherwise </dd></dl>

</div>
</div>
<a id="a90993df0cbd038640609df8c3e1957d3" name="a90993df0cbd038640609df8c3e1957d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90993df0cbd038640609df8c3e1957d3">&#9670;&nbsp;</a></span>esp_intr_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int esp_intr_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structintr__handle__data__t.html">intr_handle_data_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable and free an interrupt. </p>
<p >Use an interrupt handle to disable the interrupt and release the resources associated with it. If the current core is not the core that registered this interrupt, this routine will be assigned to the core that allocated this interrupt, blocking and waiting until the resource is successfully released.</p>
<dl class="section note"><dt>Note</dt><dd>When the handler shares its source with other handlers, the interrupt status bits it's responsible for should be managed properly before freeing it. See <code>esp_intr_disable</code> for more details. Please do not call this function in <code>esp_ipc_call_blocking</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-EINVAL the handle is NULL 0 otherwise </dd></dl>

</div>
</div>
<a id="a6c399aafeab8bff0a49bc2b127445e10" name="a6c399aafeab8bff0a49bc2b127445e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c399aafeab8bff0a49bc2b127445e10">&#9670;&nbsp;</a></span>esp_intr_get_cpu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int esp_intr_get_cpu </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structintr__handle__data__t.html">intr_handle_data_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get CPU number an interrupt is tied to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The core number where the interrupt is allocated </dd></dl>

</div>
</div>
<a id="a5261fac231a9d1428b4131da33f1ef90" name="a5261fac231a9d1428b4131da33f1ef90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5261fac231a9d1428b4131da33f1ef90">&#9670;&nbsp;</a></span>esp_intr_get_intno()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int esp_intr_get_intno </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structintr__handle__data__t.html">intr_handle_data_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the allocated interrupt for a certain handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interrupt number </dd></dl>

</div>
</div>
<a id="aede8e7c90fd3138cf165a0eea1c920fe" name="aede8e7c90fd3138cf165a0eea1c920fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede8e7c90fd3138cf165a0eea1c920fe">&#9670;&nbsp;</a></span>esp_intr_initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esp_intr_initialize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes interrupt table to its defaults. </p>

</div>
</div>
<a id="aafc6d38bb52a59bd024809efcb3b64f0" name="aafc6d38bb52a59bd024809efcb3b64f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc6d38bb52a59bd024809efcb3b64f0">&#9670;&nbsp;</a></span>esp_intr_mark_shared()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int esp_intr_mark_shared </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>intno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_in_iram</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark an interrupt as a shared interrupt. </p>
<p >This will mark a certain interrupt on the specified CPU as an interrupt that can be used to hook shared interrupt handlers to.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intno</td><td>The number of the interrupt (0-31) </td></tr>
    <tr><td class="paramname">cpu</td><td>CPU on which the interrupt should be marked as shared (0 or 1) </td></tr>
    <tr><td class="paramname">is_in_iram</td><td>Shared interrupt is for handlers that reside in IRAM and the int can be left enabled while the flash cache is disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-EINVAL if cpu or intno is invalid 0 otherwise </dd></dl>

</div>
</div>
<a id="a63263dc3bf78c25b514f739e6381ee64" name="a63263dc3bf78c25b514f739e6381ee64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63263dc3bf78c25b514f739e6381ee64">&#9670;&nbsp;</a></span>esp_intr_noniram_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esp_intr_noniram_disable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable interrupts that aren't specifically marked as running from IRAM. </p>

</div>
</div>
<a id="a917f8af7f0c6af92dfbd1f7689c39cae" name="a917f8af7f0c6af92dfbd1f7689c39cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a917f8af7f0c6af92dfbd1f7689c39cae">&#9670;&nbsp;</a></span>esp_intr_noniram_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void esp_intr_noniram_enable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Re-enable interrupts disabled by esp_intr_noniram_disable. </p>

</div>
</div>
<a id="aa6eef593f8a838adec4d258346b087d0" name="aa6eef593f8a838adec4d258346b087d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6eef593f8a838adec4d258346b087d0">&#9670;&nbsp;</a></span>esp_intr_reserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int esp_intr_reserve </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>intno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cpu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserve an interrupt to be used outside of this framework. </p>
<p >This will mark a certain interrupt on the specified CPU as reserved, not to be allocated for any reason.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intno</td><td>The number of the interrupt (0-31) </td></tr>
    <tr><td class="paramname">cpu</td><td>CPU on which the interrupt should be marked as shared (0 or 1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-EINVAL if cpu or intno is invalid 0 otherwise </dd></dl>

</div>
</div>
<a id="af1417d7a4a9faba280ac4e17c9ee60ab" name="af1417d7a4a9faba280ac4e17c9ee60ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1417d7a4a9faba280ac4e17c9ee60ab">&#9670;&nbsp;</a></span>esp_intr_set_in_iram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int esp_intr_set_in_iram </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structintr__handle__data__t.html">intr_handle_data_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_in_iram</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the "in IRAM" status of the handler. </p>
<dl class="section note"><dt>Note</dt><dd>Does not work on shared interrupts.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus </td></tr>
    <tr><td class="paramname">is_in_iram</td><td>Whether the handler associated with this handle resides in IRAM. Handlers residing in IRAM can be called when cache is disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-EINVAL if the combination of arguments is invalid. 0 otherwise </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_4fe5cf12322eb0f9892753dc20f1484c.html">drivers</a></li><li class="navelem"><a class="el" href="dir_97674a9af03e0f9e2e6fb9f287cac07c.html">interrupt_controller</a></li><li class="navelem"><a class="el" href="intc__esp32_8h.html">intc_esp32.h</a></li>
    <li class="footer">Generated on Mon Feb 21 2022 04:59:40 for Zephyr API Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
<script type="text/javascript">
  $(function() {
    toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
    toggleButton.title = "Toggle Light/Dark Mode"
    $(document).ready(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
    // every resize will remove the button, which is why it has to be added again:
    $(window).resize(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
  })
</script>
</body>
</html>
