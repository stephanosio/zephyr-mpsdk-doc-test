<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zephyr API Documentation: include/sys/sys_heap.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-zephyr.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-zephyr.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Zephyr API Documentation
   &#160;<span id="projectnumber">3.0.0-rc3</span>
   </div>
   <div id="projectbrief">A Scalable Open Source RTOS</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('sys__heap_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">sys_heap.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;<a class="el" href="stdbool_8h_source.html">stdbool.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="include_2zephyr_2types_8h_source.html">zephyr/types.h</a>&gt;</code><br />
</div>
<p><a href="sys__heap_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsys__heap.html">sys_heap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a0b6c4f17521a4ea996f5abf15883737a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys__heap_8h.html#a0b6c4f17521a4ea996f5abf15883737a">sys_heap_realloc</a>(heap,  <a class="el" href="printk_8c.html#add9af9569af79ec26dd741fb226b38ba">ptr</a>,  bytes)&#160;&#160;&#160;	<a class="el" href="sys__heap_8h.html#a16e1408c3ad5541daac756e46b33b612">sys_heap_aligned_realloc</a>(heap, <a class="el" href="printk_8c.html#add9af9569af79ec26dd741fb226b38ba">ptr</a>, 0, bytes)</td></tr>
<tr class="separator:a0b6c4f17521a4ea996f5abf15883737a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a520768606a3c28b084cf11f8ec82fae6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys__heap_8h.html#a520768606a3c28b084cf11f8ec82fae6">sys_heap_init</a> (struct <a class="el" href="structsys__heap.html">sys_heap</a> *heap, void *mem, size_t bytes)</td></tr>
<tr class="memdesc:a520768606a3c28b084cf11f8ec82fae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize <a class="el" href="structsys__heap.html">sys_heap</a>.  <a href="sys__heap_8h.html#a520768606a3c28b084cf11f8ec82fae6">More...</a><br /></td></tr>
<tr class="separator:a520768606a3c28b084cf11f8ec82fae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8bdf02c9be5576fddbe711904a3aad"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys__heap_8h.html#a6b8bdf02c9be5576fddbe711904a3aad">sys_heap_alloc</a> (struct <a class="el" href="structsys__heap.html">sys_heap</a> *heap, size_t bytes)</td></tr>
<tr class="memdesc:a6b8bdf02c9be5576fddbe711904a3aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory from a <a class="el" href="structsys__heap.html">sys_heap</a>.  <a href="sys__heap_8h.html#a6b8bdf02c9be5576fddbe711904a3aad">More...</a><br /></td></tr>
<tr class="separator:a6b8bdf02c9be5576fddbe711904a3aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a973158860c6863e1aba8516311076"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys__heap_8h.html#a92a973158860c6863e1aba8516311076">sys_heap_aligned_alloc</a> (struct <a class="el" href="structsys__heap.html">sys_heap</a> *heap, size_t align, size_t bytes)</td></tr>
<tr class="memdesc:a92a973158860c6863e1aba8516311076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate aligned memory from a <a class="el" href="structsys__heap.html">sys_heap</a>.  <a href="sys__heap_8h.html#a92a973158860c6863e1aba8516311076">More...</a><br /></td></tr>
<tr class="separator:a92a973158860c6863e1aba8516311076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab654da64adf74e67ae12f263eb420560"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys__heap_8h.html#ab654da64adf74e67ae12f263eb420560">sys_heap_free</a> (struct <a class="el" href="structsys__heap.html">sys_heap</a> *heap, void *mem)</td></tr>
<tr class="memdesc:ab654da64adf74e67ae12f263eb420560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory into a <a class="el" href="structsys__heap.html">sys_heap</a>.  <a href="sys__heap_8h.html#ab654da64adf74e67ae12f263eb420560">More...</a><br /></td></tr>
<tr class="separator:ab654da64adf74e67ae12f263eb420560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e1408c3ad5541daac756e46b33b612"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys__heap_8h.html#a16e1408c3ad5541daac756e46b33b612">sys_heap_aligned_realloc</a> (struct <a class="el" href="structsys__heap.html">sys_heap</a> *heap, void *<a class="el" href="printk_8c.html#add9af9569af79ec26dd741fb226b38ba">ptr</a>, size_t align, size_t bytes)</td></tr>
<tr class="memdesc:a16e1408c3ad5541daac756e46b33b612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand the size of an existing allocation.  <a href="sys__heap_8h.html#a16e1408c3ad5541daac756e46b33b612">More...</a><br /></td></tr>
<tr class="separator:a16e1408c3ad5541daac756e46b33b612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8cb77365c04022181e2fc45e3fbce4a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys__heap_8h.html#af8cb77365c04022181e2fc45e3fbce4a">sys_heap_usable_size</a> (struct <a class="el" href="structsys__heap.html">sys_heap</a> *heap, void *mem)</td></tr>
<tr class="memdesc:af8cb77365c04022181e2fc45e3fbce4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return allocated memory size.  <a href="sys__heap_8h.html#af8cb77365c04022181e2fc45e3fbce4a">More...</a><br /></td></tr>
<tr class="separator:af8cb77365c04022181e2fc45e3fbce4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9330ee91a1ef439efed89528e3e2a03a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys__heap_8h.html#a9330ee91a1ef439efed89528e3e2a03a">sys_heap_validate</a> (struct <a class="el" href="structsys__heap.html">sys_heap</a> *heap)</td></tr>
<tr class="memdesc:a9330ee91a1ef439efed89528e3e2a03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate heap integrity.  <a href="sys__heap_8h.html#a9330ee91a1ef439efed89528e3e2a03a">More...</a><br /></td></tr>
<tr class="separator:a9330ee91a1ef439efed89528e3e2a03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f307f7b25e4927d3dbe650567b6308"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys__heap_8h.html#ae2f307f7b25e4927d3dbe650567b6308">sys_heap_stress</a> (void *(*alloc_fn)(void *arg, size_t bytes), void(*free_fn)(void *arg, void *<a class="el" href="kobject_8c.html#a5bf2789125fcfa98cff775cb82fbd3c9">p</a>), void *arg, size_t total_bytes, <a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> op_count, void *scratch_mem, size_t scratch_bytes, int target_percent, struct z_heap_stress_result *<a class="el" href="structresult.html">result</a>)</td></tr>
<tr class="memdesc:ae2f307f7b25e4927d3dbe650567b6308"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structsys__heap.html">sys_heap</a> stress test rig  <a href="sys__heap_8h.html#ae2f307f7b25e4927d3dbe650567b6308">More...</a><br /></td></tr>
<tr class="separator:ae2f307f7b25e4927d3dbe650567b6308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36db704bd892b657ccaa7a4cebc45e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys__heap_8h.html#af36db704bd892b657ccaa7a4cebc45e5">sys_heap_print_info</a> (struct <a class="el" href="structsys__heap.html">sys_heap</a> *heap, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> dump_chunks)</td></tr>
<tr class="memdesc:af36db704bd892b657ccaa7a4cebc45e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print heap internal structure information to the console.  <a href="sys__heap_8h.html#af36db704bd892b657ccaa7a4cebc45e5">More...</a><br /></td></tr>
<tr class="separator:af36db704bd892b657ccaa7a4cebc45e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a0b6c4f17521a4ea996f5abf15883737a" name="a0b6c4f17521a4ea996f5abf15883737a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b6c4f17521a4ea996f5abf15883737a">&#9670;&nbsp;</a></span>sys_heap_realloc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sys_heap_realloc</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">heap, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="printk_8c.html#add9af9569af79ec26dd741fb226b38ba">ptr</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bytes&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;	<a class="el" href="sys__heap_8h.html#a16e1408c3ad5541daac756e46b33b612">sys_heap_aligned_realloc</a>(heap, <a class="el" href="printk_8c.html#add9af9569af79ec26dd741fb226b38ba">ptr</a>, 0, bytes)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a92a973158860c6863e1aba8516311076" name="a92a973158860c6863e1aba8516311076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a973158860c6863e1aba8516311076">&#9670;&nbsp;</a></span>sys_heap_aligned_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * sys_heap_aligned_alloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsys__heap.html">sys_heap</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate aligned memory from a <a class="el" href="structsys__heap.html">sys_heap</a>. </p>
<p >Behaves in all ways like <a class="el" href="sys__heap_8h.html#a6b8bdf02c9be5576fddbe711904a3aad" title="Allocate memory from a sys_heap.">sys_heap_alloc()</a>, except that the returned memory (if available) will have a starting address in memory which is a multiple of the specified power-of-two alignment value in bytes. With align=0 this behaves exactly like <a class="el" href="sys__heap_8h.html#a6b8bdf02c9be5576fddbe711904a3aad" title="Allocate memory from a sys_heap.">sys_heap_alloc()</a>. The resulting memory can be returned to the heap using <a class="el" href="sys__heap_8h.html#ab654da64adf74e67ae12f263eb420560" title="Free memory into a sys_heap.">sys_heap_free()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>Heap from which to allocate </td></tr>
    <tr><td class="paramname">align</td><td>Alignment in bytes, must be a power of two </td></tr>
    <tr><td class="paramname">bytes</td><td>Number of bytes requested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to memory the caller can now use </dd></dl>

</div>
</div>
<a id="a16e1408c3ad5541daac756e46b33b612" name="a16e1408c3ad5541daac756e46b33b612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e1408c3ad5541daac756e46b33b612">&#9670;&nbsp;</a></span>sys_heap_aligned_realloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * sys_heap_aligned_realloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsys__heap.html">sys_heap</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand the size of an existing allocation. </p>
<p >Returns a pointer to a new memory region with the same contents, but a different allocated size. If the new allocation can be expanded in place, the pointer returned will be identical. Otherwise the data will be copies to a new block and the old one will be freed as per <a class="el" href="sys__heap_8h.html#ab654da64adf74e67ae12f263eb420560" title="Free memory into a sys_heap.">sys_heap_free()</a>. If the specified size is smaller than the original, the block will be truncated in place and the remaining memory returned to the heap. If the allocation of a new block fails, then NULL will be returned and the old block will not be freed or modified.</p>
<dl class="section note"><dt>Note</dt><dd>The return of a NULL on failure is a different behavior than POSIX <a class="el" href="stdlib_8h.html#ad28fed1039f35d754710633141b4edf0">realloc()</a>, which specifies that the original pointer will be returned (i.e. it is not possible to safely detect <a class="el" href="stdlib_8h.html#ad28fed1039f35d754710633141b4edf0">realloc()</a> failure in POSIX, but it is here).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>Heap from which to allocate </td></tr>
    <tr><td class="paramname">ptr</td><td>Original pointer returned from a previous allocation </td></tr>
    <tr><td class="paramname">align</td><td>Alignment in bytes, must be a power of two </td></tr>
    <tr><td class="paramname">bytes</td><td>Number of bytes requested for the new block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to memory the caller can now use, or NULL </dd></dl>

</div>
</div>
<a id="a6b8bdf02c9be5576fddbe711904a3aad" name="a6b8bdf02c9be5576fddbe711904a3aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b8bdf02c9be5576fddbe711904a3aad">&#9670;&nbsp;</a></span>sys_heap_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * sys_heap_alloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsys__heap.html">sys_heap</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory from a <a class="el" href="structsys__heap.html">sys_heap</a>. </p>
<p >Returns a pointer to a block of unused memory in the heap. This memory will not otherwise be used until it is freed with <a class="el" href="sys__heap_8h.html#ab654da64adf74e67ae12f263eb420560" title="Free memory into a sys_heap.">sys_heap_free()</a>. If no memory can be allocated, NULL will be returned. The allocated memory is guaranteed to have a starting address which is a multiple of sizeof(void *). If a bigger alignment is necessary then <a class="el" href="sys__heap_8h.html#a92a973158860c6863e1aba8516311076" title="Allocate aligned memory from a sys_heap.">sys_heap_aligned_alloc()</a> should be used instead.</p>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="structsys__heap.html">sys_heap</a> implementation is not internally synchronized. No two <a class="el" href="structsys__heap.html">sys_heap</a> functions should operate on the same heap at the same time. All locking must be provided by the user.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>Heap from which to allocate </td></tr>
    <tr><td class="paramname">bytes</td><td>Number of bytes requested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to memory the caller can now use </dd></dl>

</div>
</div>
<a id="ab654da64adf74e67ae12f263eb420560" name="ab654da64adf74e67ae12f263eb420560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab654da64adf74e67ae12f263eb420560">&#9670;&nbsp;</a></span>sys_heap_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_heap_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsys__heap.html">sys_heap</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free memory into a <a class="el" href="structsys__heap.html">sys_heap</a>. </p>
<p >De-allocates a pointer to memory previously returned from sys_heap_alloc such that it can be used for other purposes. The caller must not use the memory region after entry to this function.</p>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="structsys__heap.html">sys_heap</a> implementation is not internally synchronized. No two <a class="el" href="structsys__heap.html">sys_heap</a> functions should operate on the same heap at the same time. All locking must be provided by the user.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>Heap to which to return the memory </td></tr>
    <tr><td class="paramname">mem</td><td>A pointer previously returned from <a class="el" href="sys__heap_8h.html#a6b8bdf02c9be5576fddbe711904a3aad" title="Allocate memory from a sys_heap.">sys_heap_alloc()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a520768606a3c28b084cf11f8ec82fae6" name="a520768606a3c28b084cf11f8ec82fae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a520768606a3c28b084cf11f8ec82fae6">&#9670;&nbsp;</a></span>sys_heap_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_heap_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsys__heap.html">sys_heap</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize <a class="el" href="structsys__heap.html">sys_heap</a>. </p>
<p >Initializes a <a class="el" href="structsys__heap.html">sys_heap</a> struct to manage the specified memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>Heap to initialize </td></tr>
    <tr><td class="paramname">mem</td><td>Untyped pointer to unused memory </td></tr>
    <tr><td class="paramname">bytes</td><td>Size of region pointed to by <em>mem</em> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af36db704bd892b657ccaa7a4cebc45e5" name="af36db704bd892b657ccaa7a4cebc45e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36db704bd892b657ccaa7a4cebc45e5">&#9670;&nbsp;</a></span>sys_heap_print_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_heap_print_info </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsys__heap.html">sys_heap</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>dump_chunks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print heap internal structure information to the console. </p>
<p >Print information on the heap structure such as its size, chunk buckets, chunk list and some statistics for debugging purpose.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>Heap to print information about </td></tr>
    <tr><td class="paramname">dump_chunks</td><td>True to print the entire heap chunk list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2f307f7b25e4927d3dbe650567b6308" name="ae2f307f7b25e4927d3dbe650567b6308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f307f7b25e4927d3dbe650567b6308">&#9670;&nbsp;</a></span>sys_heap_stress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_heap_stress </td>
          <td>(</td>
          <td class="paramtype">void *(*)(void *arg, size_t bytes)&#160;</td>
          <td class="paramname"><em>alloc_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *arg, void *<a class="el" href="kobject_8c.html#a5bf2789125fcfa98cff775cb82fbd3c9">p</a>)&#160;</td>
          <td class="paramname"><em>free_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>total_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a>&#160;</td>
          <td class="paramname"><em>op_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>scratch_mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>scratch_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_percent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct z_heap_stress_result *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structsys__heap.html">sys_heap</a> stress test rig </p>
<p >Test rig for heap allocation validation. This will loop for <em>op_count</em> cycles, in each iteration making a random choice to allocate or free a pointer of randomized (power law) size based on heuristics designed to keep the heap in a state where it is near <em>target_percent</em> full. Allocation and free operations are provided by the caller as callbacks (i.e. this can in theory test any heap). Results, including counts of frees and successful/unsuccessful allocations, are returned via the <em>result</em> struct.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc_fn</td><td>Callback to perform an allocation. Passes back the <em>arg</em> parameter as a context handle. </td></tr>
    <tr><td class="paramname">free_fn</td><td>Callback to perform a free of a pointer returned from <em>alloc</em>. Passes back the <em>arg</em> parameter as a context handle. </td></tr>
    <tr><td class="paramname">arg</td><td>Context handle to pass back to the callbacks </td></tr>
    <tr><td class="paramname">total_bytes</td><td>Size of the byte array the heap was initialized in </td></tr>
    <tr><td class="paramname">op_count</td><td>How many iterations to test </td></tr>
    <tr><td class="paramname">scratch_mem</td><td>A pointer to scratch memory to be used by the test. Should be about 1/2 the size of the heap for tests that need to stress fragmentation. </td></tr>
    <tr><td class="paramname">scratch_bytes</td><td>Size of the memory pointed to by <em>scratch_mem</em> </td></tr>
    <tr><td class="paramname">target_percent</td><td>Percentage fill value (1-100) to which the random allocation choices will seek. High values will result in significant allocation failures and a very fragmented heap. </td></tr>
    <tr><td class="paramname">result</td><td>Struct into which to store test results. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8cb77365c04022181e2fc45e3fbce4a" name="af8cb77365c04022181e2fc45e3fbce4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8cb77365c04022181e2fc45e3fbce4a">&#9670;&nbsp;</a></span>sys_heap_usable_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t sys_heap_usable_size </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsys__heap.html">sys_heap</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return allocated memory size. </p>
<p >Returns the size, in bytes, of a block returned from a successful <a class="el" href="sys__heap_8h.html#a6b8bdf02c9be5576fddbe711904a3aad" title="Allocate memory from a sys_heap.">sys_heap_alloc()</a> or sys_heap_alloc_aligned() call. The value returned is the size of the heap-managed memory, which may be larger than the number of bytes requested due to allocation granularity. The heap code is guaranteed to make no access to this region of memory until a subsequent <a class="el" href="sys__heap_8h.html#ab654da64adf74e67ae12f263eb420560" title="Free memory into a sys_heap.">sys_heap_free()</a> on the same pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>Heap containing the block </td></tr>
    <tr><td class="paramname">mem</td><td>Pointer to memory allocated from this heap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size in bytes of the memory region </dd></dl>

</div>
</div>
<a id="a9330ee91a1ef439efed89528e3e2a03a" name="a9330ee91a1ef439efed89528e3e2a03a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9330ee91a1ef439efed89528e3e2a03a">&#9670;&nbsp;</a></span>sys_heap_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> sys_heap_validate </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsys__heap.html">sys_heap</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate heap integrity. </p>
<p >Validates the internal integrity of a <a class="el" href="structsys__heap.html">sys_heap</a>. Intended for unit test and validation code, though potentially useful as a user API for applications with complicated runtime reliability requirements. Note: this cannot catch every possible error, but if it returns true then the heap is in a consistent state and can correctly handle any <a class="el" href="sys__heap_8h.html#a6b8bdf02c9be5576fddbe711904a3aad" title="Allocate memory from a sys_heap.">sys_heap_alloc()</a> request and free any live pointer returned from a previou allocation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>Heap to validate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the heap is valid, otherwise false </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_317ea3797c15f4a1d9c156bc812661ca.html">sys</a></li><li class="navelem"><a class="el" href="sys__heap_8h.html">sys_heap.h</a></li>
    <li class="footer">Generated on Mon Feb 21 2022 04:59:40 for Zephyr API Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
<script type="text/javascript">
  $(function() {
    toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
    toggleButton.title = "Toggle Light/Dark Mode"
    $(document).ready(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
    // every resize will remove the button, which is why it has to be added again:
    $(window).resize(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
  })
</script>
</body>
</html>
