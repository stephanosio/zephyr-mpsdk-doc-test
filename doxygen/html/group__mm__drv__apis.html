<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zephyr API Documentation: Memory Management Driver APIs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-zephyr.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-zephyr.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Zephyr API Documentation
   &#160;<span id="projectnumber">3.0.0-rc3</span>
   </div>
   <div id="projectbrief">A Scalable Open Source RTOS</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__mm__drv__apis.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Memory Management Driver APIs</div></div>
</div><!--header-->
<div class="contents">

<p>Memory Management Driver APIs.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gafe1b7f8b4075da1b461f2a74d3142e49"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mm__drv__apis.html#gafe1b7f8b4075da1b461f2a74d3142e49">SYS_MM_MEM_CACHE_NONE</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:gafe1b7f8b4075da1b461f2a74d3142e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed12cd6841eb0fd0af1cefe1d7a6b5aa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mm__drv__apis.html#gaed12cd6841eb0fd0af1cefe1d7a6b5aa">SYS_MM_MEM_CACHE_WT</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:gaed12cd6841eb0fd0af1cefe1d7a6b5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0859fb79c8da1d1af0f38ea63064b8c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mm__drv__apis.html#gad0859fb79c8da1d1af0f38ea63064b8c">SYS_MM_MEM_CACHE_WB</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:gad0859fb79c8da1d1af0f38ea63064b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43050af5740a0449da7998b48f540817"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mm__drv__apis.html#ga43050af5740a0449da7998b48f540817">SYS_MM_MEM_CACHE_MASK</a>&#160;&#160;&#160;(<a class="el" href="group__sys-util.html#ga3a8ea58898cb58fc96013383d39f482c">BIT</a>(3) - 1)</td></tr>
<tr class="separator:ga43050af5740a0449da7998b48f540817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8547ea32c40b038daa34ee76cbaee275"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mm__drv__apis.html#ga8547ea32c40b038daa34ee76cbaee275">SYS_MM_MEM_PERM_RW</a>&#160;&#160;&#160;<a class="el" href="group__sys-util.html#ga3a8ea58898cb58fc96013383d39f482c">BIT</a>(3)</td></tr>
<tr class="separator:ga8547ea32c40b038daa34ee76cbaee275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac564b8d2148bd7c0ac07313f0fa9861c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mm__drv__apis.html#gac564b8d2148bd7c0ac07313f0fa9861c">SYS_MM_MEM_PERM_EXEC</a>&#160;&#160;&#160;<a class="el" href="group__sys-util.html#ga3a8ea58898cb58fc96013383d39f482c">BIT</a>(4)</td></tr>
<tr class="separator:gac564b8d2148bd7c0ac07313f0fa9861c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad86f6d8cbb3102ad3e8375d10cb4551c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mm__drv__apis.html#gad86f6d8cbb3102ad3e8375d10cb4551c">SYS_MM_MEM_PERM_USER</a>&#160;&#160;&#160;<a class="el" href="group__sys-util.html#ga3a8ea58898cb58fc96013383d39f482c">BIT</a>(5)</td></tr>
<tr class="separator:gad86f6d8cbb3102ad3e8375d10cb4551c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7097d4d8880cb0c3d5db7623ffc11b26"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mm__drv__apis.html#ga7097d4d8880cb0c3d5db7623ffc11b26">sys_mm_drv_map_page</a> (void *virt, <a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a> phys, <a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> <a class="el" href="http__parser_8h.html#ab6b306ef981f5e21bb41ea2c2dbe8cd9">flags</a>)</td></tr>
<tr class="memdesc:ga7097d4d8880cb0c3d5db7623ffc11b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map one physical page into the virtual address space.  <a href="group__mm__drv__apis.html#ga7097d4d8880cb0c3d5db7623ffc11b26">More...</a><br /></td></tr>
<tr class="separator:ga7097d4d8880cb0c3d5db7623ffc11b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1186a31d55b24791d800e8f0aef311da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mm__drv__apis.html#ga1186a31d55b24791d800e8f0aef311da">sys_mm_drv_map_region</a> (void *virt, <a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a> phys, size_t size, <a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> <a class="el" href="http__parser_8h.html#ab6b306ef981f5e21bb41ea2c2dbe8cd9">flags</a>)</td></tr>
<tr class="memdesc:ga1186a31d55b24791d800e8f0aef311da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a region of physical memory into the virtual address space.  <a href="group__mm__drv__apis.html#ga1186a31d55b24791d800e8f0aef311da">More...</a><br /></td></tr>
<tr class="separator:ga1186a31d55b24791d800e8f0aef311da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab36baa1ed134e5a69ea16451991b920e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mm__drv__apis.html#gab36baa1ed134e5a69ea16451991b920e">sys_mm_drv_map_array</a> (void *virt, <a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a> *phys, size_t cnt, <a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> <a class="el" href="http__parser_8h.html#ab6b306ef981f5e21bb41ea2c2dbe8cd9">flags</a>)</td></tr>
<tr class="memdesc:gab36baa1ed134e5a69ea16451991b920e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map an array of physical memory into the virtual address space.  <a href="group__mm__drv__apis.html#gab36baa1ed134e5a69ea16451991b920e">More...</a><br /></td></tr>
<tr class="separator:gab36baa1ed134e5a69ea16451991b920e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab78668dd05ab1d4d17ca5bbe3182b0eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mm__drv__apis.html#gab78668dd05ab1d4d17ca5bbe3182b0eb">sys_mm_drv_unmap_page</a> (void *virt)</td></tr>
<tr class="memdesc:gab78668dd05ab1d4d17ca5bbe3182b0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove mapping for one page of the provided virtual address.  <a href="group__mm__drv__apis.html#gab78668dd05ab1d4d17ca5bbe3182b0eb">More...</a><br /></td></tr>
<tr class="separator:gab78668dd05ab1d4d17ca5bbe3182b0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc3ed78e29aef49b7578b9090dcaacbc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mm__drv__apis.html#gadc3ed78e29aef49b7578b9090dcaacbc">sys_mm_drv_unmap_region</a> (void *virt, size_t size)</td></tr>
<tr class="memdesc:gadc3ed78e29aef49b7578b9090dcaacbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove mappings for a provided virtual address range.  <a href="group__mm__drv__apis.html#gadc3ed78e29aef49b7578b9090dcaacbc">More...</a><br /></td></tr>
<tr class="separator:gadc3ed78e29aef49b7578b9090dcaacbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabbc2184a44f8c5c8cd98bf09a2cdc0f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mm__drv__apis.html#gaabbc2184a44f8c5c8cd98bf09a2cdc0f">sys_mm_drv_page_phys_get</a> (void *virt, <a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a> *phys)</td></tr>
<tr class="memdesc:gaabbc2184a44f8c5c8cd98bf09a2cdc0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mapped physical memory address from virtual address.  <a href="group__mm__drv__apis.html#gaabbc2184a44f8c5c8cd98bf09a2cdc0f">More...</a><br /></td></tr>
<tr class="separator:gaabbc2184a44f8c5c8cd98bf09a2cdc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae46a4189560e314e96f8bee80b55b40b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mm__drv__apis.html#gae46a4189560e314e96f8bee80b55b40b">sys_mm_drv_remap_region</a> (void *virt_old, size_t size, void *virt_new)</td></tr>
<tr class="memdesc:gae46a4189560e314e96f8bee80b55b40b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap virtual pages into new address.  <a href="group__mm__drv__apis.html#gae46a4189560e314e96f8bee80b55b40b">More...</a><br /></td></tr>
<tr class="separator:gae46a4189560e314e96f8bee80b55b40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b2e4b2b359d4fcba104e43866d30d14"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mm__drv__apis.html#ga3b2e4b2b359d4fcba104e43866d30d14">sys_mm_drv_move_region</a> (void *virt_old, size_t size, void *virt_new, <a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a> phys_new)</td></tr>
<tr class="memdesc:ga3b2e4b2b359d4fcba104e43866d30d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Physically move memory, with copy.  <a href="group__mm__drv__apis.html#ga3b2e4b2b359d4fcba104e43866d30d14">More...</a><br /></td></tr>
<tr class="separator:ga3b2e4b2b359d4fcba104e43866d30d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab172793104608d2a5acae0eb40c50177"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mm__drv__apis.html#gab172793104608d2a5acae0eb40c50177">sys_mm_drv_move_array</a> (void *virt_old, size_t size, void *virt_new, <a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a> *phys_new, size_t phys_cnt)</td></tr>
<tr class="memdesc:gab172793104608d2a5acae0eb40c50177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Physically move memory, with copy.  <a href="group__mm__drv__apis.html#gab172793104608d2a5acae0eb40c50177">More...</a><br /></td></tr>
<tr class="separator:gab172793104608d2a5acae0eb40c50177"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Memory Management Driver APIs. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga43050af5740a0449da7998b48f540817" name="ga43050af5740a0449da7998b48f540817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43050af5740a0449da7998b48f540817">&#9670;&nbsp;</a></span>SYS_MM_MEM_CACHE_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYS_MM_MEM_CACHE_MASK&#160;&#160;&#160;(<a class="el" href="group__sys-util.html#ga3a8ea58898cb58fc96013383d39f482c">BIT</a>(3) - 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="system__mm_8h.html">include/drivers/mm/system_mm.h</a>&gt;</code></p>
<p >Reserved bits for cache modes </p>

</div>
</div>
<a id="gafe1b7f8b4075da1b461f2a74d3142e49" name="gafe1b7f8b4075da1b461f2a74d3142e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe1b7f8b4075da1b461f2a74d3142e49">&#9670;&nbsp;</a></span>SYS_MM_MEM_CACHE_NONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYS_MM_MEM_CACHE_NONE&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="system__mm_8h.html">include/drivers/mm/system_mm.h</a>&gt;</code></p>
<p >No caching </p>

</div>
</div>
<a id="gad0859fb79c8da1d1af0f38ea63064b8c" name="gad0859fb79c8da1d1af0f38ea63064b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0859fb79c8da1d1af0f38ea63064b8c">&#9670;&nbsp;</a></span>SYS_MM_MEM_CACHE_WB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYS_MM_MEM_CACHE_WB&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="system__mm_8h.html">include/drivers/mm/system_mm.h</a>&gt;</code></p>
<p >Full write-back caching </p>

</div>
</div>
<a id="gaed12cd6841eb0fd0af1cefe1d7a6b5aa" name="gaed12cd6841eb0fd0af1cefe1d7a6b5aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed12cd6841eb0fd0af1cefe1d7a6b5aa">&#9670;&nbsp;</a></span>SYS_MM_MEM_CACHE_WT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYS_MM_MEM_CACHE_WT&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="system__mm_8h.html">include/drivers/mm/system_mm.h</a>&gt;</code></p>
<p >Write-through caching </p>

</div>
</div>
<a id="gac564b8d2148bd7c0ac07313f0fa9861c" name="gac564b8d2148bd7c0ac07313f0fa9861c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac564b8d2148bd7c0ac07313f0fa9861c">&#9670;&nbsp;</a></span>SYS_MM_MEM_PERM_EXEC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYS_MM_MEM_PERM_EXEC&#160;&#160;&#160;<a class="el" href="group__sys-util.html#ga3a8ea58898cb58fc96013383d39f482c">BIT</a>(4)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="system__mm_8h.html">include/drivers/mm/system_mm.h</a>&gt;</code></p>
<p >Region will be executable (normally forbidden) </p>

</div>
</div>
<a id="ga8547ea32c40b038daa34ee76cbaee275" name="ga8547ea32c40b038daa34ee76cbaee275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8547ea32c40b038daa34ee76cbaee275">&#9670;&nbsp;</a></span>SYS_MM_MEM_PERM_RW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYS_MM_MEM_PERM_RW&#160;&#160;&#160;<a class="el" href="group__sys-util.html#ga3a8ea58898cb58fc96013383d39f482c">BIT</a>(3)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="system__mm_8h.html">include/drivers/mm/system_mm.h</a>&gt;</code></p>
<p >Region will have read/write access (and not read-only) </p>

</div>
</div>
<a id="gad86f6d8cbb3102ad3e8375d10cb4551c" name="gad86f6d8cbb3102ad3e8375d10cb4551c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad86f6d8cbb3102ad3e8375d10cb4551c">&#9670;&nbsp;</a></span>SYS_MM_MEM_PERM_USER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYS_MM_MEM_PERM_USER&#160;&#160;&#160;<a class="el" href="group__sys-util.html#ga3a8ea58898cb58fc96013383d39f482c">BIT</a>(5)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="system__mm_8h.html">include/drivers/mm/system_mm.h</a>&gt;</code></p>
<p >Region will be accessible to user mode (normally supervisor-only) </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab36baa1ed134e5a69ea16451991b920e" name="gab36baa1ed134e5a69ea16451991b920e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab36baa1ed134e5a69ea16451991b920e">&#9670;&nbsp;</a></span>sys_mm_drv_map_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_mm_drv_map_array </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>virt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a> *&#160;</td>
          <td class="paramname"><em>phys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="system__mm_8h.html">include/drivers/mm/system_mm.h</a>&gt;</code></p>

<p>Map an array of physical memory into the virtual address space. </p>
<p >This maps an array of physical pages into a continuous virtual address space. Behavior when providing unaligned addresses is undefined, these are assumed to be page aligned.</p>
<p >The physical memory pages are never accessed by this operation.</p>
<p >This API must be safe to call in ISRs or exception handlers. Calls to this API are assumed to be serialized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">virt</td><td>Page-aligned destination virtual address to map </td></tr>
    <tr><td class="paramname">phys</td><td>Array of pge-aligned source physical address to map </td></tr>
    <tr><td class="paramname">cnt</td><td>Number of elements in the physical page array </td></tr>
    <tr><td class="paramname">flags</td><td>Caching, access and control flags, see SYS_MM_MEM_* macros</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if successful </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>if invalid arguments are provided </td></tr>
    <tr><td class="paramname">-EFAULT</td><td>if any virtual addresses have already been mapped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7097d4d8880cb0c3d5db7623ffc11b26" name="ga7097d4d8880cb0c3d5db7623ffc11b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7097d4d8880cb0c3d5db7623ffc11b26">&#9670;&nbsp;</a></span>sys_mm_drv_map_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_mm_drv_map_page </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>virt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a>&#160;</td>
          <td class="paramname"><em>phys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="system__mm_8h.html">include/drivers/mm/system_mm.h</a>&gt;</code></p>

<p>Map one physical page into the virtual address space. </p>
<p >This maps one physical page into the virtual address space. Behavior when providing unaligned address is undefined, this is assumed to be page aligned.</p>
<p >The memory range itself is never accessed by this operation.</p>
<p >This API must be safe to call in ISRs or exception handlers. Calls to this API are assumed to be serialized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">virt</td><td>Page-aligned destination virtual address to map </td></tr>
    <tr><td class="paramname">phys</td><td>Page-aligned source physical address to map </td></tr>
    <tr><td class="paramname">flags</td><td>Caching, access and control flags, see SYS_MM_MEM_* macros</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if successful </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>if invalid arguments are provided </td></tr>
    <tr><td class="paramname">-EFAULT</td><td>if virtual address has already been mapped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1186a31d55b24791d800e8f0aef311da" name="ga1186a31d55b24791d800e8f0aef311da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1186a31d55b24791d800e8f0aef311da">&#9670;&nbsp;</a></span>sys_mm_drv_map_region()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_mm_drv_map_region </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>virt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a>&#160;</td>
          <td class="paramname"><em>phys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="system__mm_8h.html">include/drivers/mm/system_mm.h</a>&gt;</code></p>

<p>Map a region of physical memory into the virtual address space. </p>
<p >This maps a region of physical memory into the virtual address space. Behavior when providing unaligned addresses/sizes is undefined, these are assumed to be page aligned.</p>
<p >The memory range itself is never accessed by this operation.</p>
<p >This API must be safe to call in ISRs or exception handlers. Calls to this API are assumed to be serialized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">virt</td><td>Page-aligned destination virtual address to map </td></tr>
    <tr><td class="paramname">phys</td><td>Page-aligned source physical address to map </td></tr>
    <tr><td class="paramname">size</td><td>Page-aligned size of the mapped memory region in bytes </td></tr>
    <tr><td class="paramname">flags</td><td>Caching, access and control flags, see SYS_MM_MEM_* macros</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if successful </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>if invalid arguments are provided </td></tr>
    <tr><td class="paramname">-EFAULT</td><td>if any virtual addresses have already been mapped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab172793104608d2a5acae0eb40c50177" name="gab172793104608d2a5acae0eb40c50177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab172793104608d2a5acae0eb40c50177">&#9670;&nbsp;</a></span>sys_mm_drv_move_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_mm_drv_move_array </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>virt_old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>virt_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a> *&#160;</td>
          <td class="paramname"><em>phys_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>phys_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="system__mm_8h.html">include/drivers/mm/system_mm.h</a>&gt;</code></p>

<p>Physically move memory, with copy. </p>
<p >This maps a region of physical memory into the new virtual address space (<code>virt_new</code>), and copy region of size <code>size</code> from the old virtual address space (<code>virt_old</code>). The new virtual memory region is mapped from an array of physical pages.</p>
<p >Behavior when providing unaligned addresses/sizes is undefined, these are assumed to be page aligned.</p>
<p >Note that the virtual memory at both the old and new addresses must be unmapped in the memory domains of any runnable Zephyr thread as this does not deal with memory domains.</p>
<p >Note that overlapping of old and new virtual memory regions is usually not supported for simplier implementation. Refer to the actual driver to make sure if overlapping is allowed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">virt_old</td><td>Page-aligned base virtual address of existing memory </td></tr>
    <tr><td class="paramname">size</td><td>Page-aligned size of the mapped memory region in bytes </td></tr>
    <tr><td class="paramname">virt_new</td><td>Page-aligned base virtual address to which to map new physical pages </td></tr>
    <tr><td class="paramname">phys_new</td><td>Array of page-aligned physical address to contain the moved memory </td></tr>
    <tr><td class="paramname">phys_cnt</td><td>Number of elements in the physical page array</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if successful </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>if invalid arguments are provided </td></tr>
    <tr><td class="paramname">-EFAULT</td><td>if old virtual addresses are not all mapped or new virtual addresses are not all unmapped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3b2e4b2b359d4fcba104e43866d30d14" name="ga3b2e4b2b359d4fcba104e43866d30d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b2e4b2b359d4fcba104e43866d30d14">&#9670;&nbsp;</a></span>sys_mm_drv_move_region()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_mm_drv_move_region </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>virt_old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>virt_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a>&#160;</td>
          <td class="paramname"><em>phys_new</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="system__mm_8h.html">include/drivers/mm/system_mm.h</a>&gt;</code></p>

<p>Physically move memory, with copy. </p>
<p >This maps a region of physical memory into the new virtual address space (<code>virt_new</code>), and copy region of size <code>size</code> from the old virtual address space (<code>virt_old</code>). The new virtual memory region is mapped from physical memory starting at <code>phys_new</code> of size <code>size</code>.</p>
<p >Behavior when providing unaligned addresses/sizes is undefined, these are assumed to be page aligned.</p>
<p >Note that the virtual memory at both the old and new addresses must be unmapped in the memory domains of any runnable Zephyr thread as this does not deal with memory domains.</p>
<p >Note that overlapping of old and new virtual memory regions is usually not supported for simplier implementation. Refer to the actual driver to make sure if overlapping is allowed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">virt_old</td><td>Page-aligned base virtual address of existing memory </td></tr>
    <tr><td class="paramname">size</td><td>Page-aligned size of the mapped memory region in bytes </td></tr>
    <tr><td class="paramname">virt_new</td><td>Page-aligned base virtual address to which to map new physical pages </td></tr>
    <tr><td class="paramname">phys_new</td><td>Page-aligned base physical address to contain the moved memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if successful </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>if invalid arguments are provided </td></tr>
    <tr><td class="paramname">-EFAULT</td><td>if old virtual addresses are not all mapped or new virtual addresses are not all unmapped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaabbc2184a44f8c5c8cd98bf09a2cdc0f" name="gaabbc2184a44f8c5c8cd98bf09a2cdc0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabbc2184a44f8c5c8cd98bf09a2cdc0f">&#9670;&nbsp;</a></span>sys_mm_drv_page_phys_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_mm_drv_page_phys_get </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>virt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a> *&#160;</td>
          <td class="paramname"><em>phys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="system__mm_8h.html">include/drivers/mm/system_mm.h</a>&gt;</code></p>

<p>Get the mapped physical memory address from virtual address. </p>
<p >The function queries the translation tables to find the physical memory address of a mapped virtual address.</p>
<p >Behavior when providing unaligned address is undefined, this is assumed to be page aligned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">virt</td><td>Page-aligned virtual address </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">phys</td><td>Mapped physical address (can be NULL if only checking if virtual address is mapped)</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if mapping is found and valid </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>if invalid arguments are provided </td></tr>
    <tr><td class="paramname">-EFAULT</td><td>if virtual address is not mapped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae46a4189560e314e96f8bee80b55b40b" name="gae46a4189560e314e96f8bee80b55b40b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae46a4189560e314e96f8bee80b55b40b">&#9670;&nbsp;</a></span>sys_mm_drv_remap_region()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_mm_drv_remap_region </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>virt_old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>virt_new</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="system__mm_8h.html">include/drivers/mm/system_mm.h</a>&gt;</code></p>

<p>Remap virtual pages into new address. </p>
<p >This remaps a virtual memory region starting at <code>virt_old</code> of size <code>size</code> into a new virtual memory region starting at <code>virt_new</code>. In other words, physical memory at <code>virt_old</code> is remapped to appear at <code>virt_new</code>. Both addresses must be page aligned and valid.</p>
<p >Note that the virtual memory at both the old and new addresses must be unmapped in the memory domains of any runnable Zephyr thread as this does not deal with memory domains.</p>
<p >Note that overlapping of old and new virtual memory regions is usually not supported for simplier implementation. Refer to the actual driver to make sure if overlapping is allowed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">virt_old</td><td>Page-aligned base virtual address of existing memory </td></tr>
    <tr><td class="paramname">size</td><td>Page-aligned size of the mapped memory region in bytes </td></tr>
    <tr><td class="paramname">virt_new</td><td>Page-aligned base virtual address to which to remap the memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if successful </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>if invalid arguments are provided </td></tr>
    <tr><td class="paramname">-EFAULT</td><td>if old virtual addresses are not all mapped or new virtual addresses are not all unmapped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab78668dd05ab1d4d17ca5bbe3182b0eb" name="gab78668dd05ab1d4d17ca5bbe3182b0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab78668dd05ab1d4d17ca5bbe3182b0eb">&#9670;&nbsp;</a></span>sys_mm_drv_unmap_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_mm_drv_unmap_page </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>virt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="system__mm_8h.html">include/drivers/mm/system_mm.h</a>&gt;</code></p>

<p>Remove mapping for one page of the provided virtual address. </p>
<p >This unmaps one page from the virtual address space.</p>
<p >When this completes, the relevant translation table entrie will be updated as if no mapping was ever made for that memory page. No previous context needs to be preserved. This function must update mapping in all active translation tables.</p>
<p >Behavior when providing unaligned address is undefined, this is assumed to be page aligned.</p>
<p >Implementations must invalidate translation caching as necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">virt</td><td>Page-aligned virtual address to un-map</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if successful </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>if invalid arguments are provided </td></tr>
    <tr><td class="paramname">-EFAULT</td><td>if virtual address is not mapped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadc3ed78e29aef49b7578b9090dcaacbc" name="gadc3ed78e29aef49b7578b9090dcaacbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc3ed78e29aef49b7578b9090dcaacbc">&#9670;&nbsp;</a></span>sys_mm_drv_unmap_region()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_mm_drv_unmap_region </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>virt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="system__mm_8h.html">include/drivers/mm/system_mm.h</a>&gt;</code></p>

<p>Remove mappings for a provided virtual address range. </p>
<p >This unmaps pages in the provided virtual address range.</p>
<p >When this completes, the relevant translation table entries will be updated as if no mapping was ever made for that memory range. No previous context needs to be preserved. This function must update mappings in all active translation tables.</p>
<p >Behavior when providing unaligned address is undefined, this is assumed to be page aligned.</p>
<p >Implementations must invalidate translation caching as necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">virt</td><td>Page-aligned base virtual address to un-map </td></tr>
    <tr><td class="paramname">size</td><td>Page-aligned region size</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if successful </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>if invalid arguments are provided </td></tr>
    <tr><td class="paramname">-EFAULT</td><td>if virtual addresses have already been mapped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Feb 21 2022 04:59:41 for Zephyr API Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
<script type="text/javascript">
  $(function() {
    toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
    toggleButton.title = "Toggle Light/Dark Mode"
    $(document).ready(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
    // every resize will remove the button, which is why it has to be added again:
    $(window).resize(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
  })
</script>
</body>
</html>
