<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zephyr API Documentation: Work Queue APIs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-zephyr.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-zephyr.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Zephyr API Documentation
   &#160;<span id="projectnumber">3.0.0-rc3</span>
   </div>
   <div id="projectbrief">A Scalable Open Source RTOS</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__workqueue__apis.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Work Queue APIs<div class="ingroups"><a class="el" href="group__kernel__apis.html">Kernel APIs</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structk__work.html">k_work</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure used to submit work.  <a href="structk__work.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structk__work__delayable.html">k_work_delayable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure used to submit work after a delay.  <a href="structk__work__delayable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structk__work__sync.html">k_work_sync</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure holding internal state for a pending synchronous operation on a work item or queue.  <a href="structk__work__sync.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structk__work__queue__config.html">k_work_queue_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure holding optional configuration items for a work queue.  <a href="structk__work__queue__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structk__work__q.html">k_work_q</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure used to hold work until it can be processed.  <a href="structk__work__q.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structk__delayed__work.html">k_delayed_work</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga893b281f3d2bc0088650536899e17903"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#ga893b281f3d2bc0088650536899e17903">K_WORK_DELAYABLE_DEFINE</a>(<a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>,  <a class="el" href="workq_2work__queue_2src_2main_8c.html#a79d59599a7df302be796206c85bb7437">work_handler</a>)</td></tr>
<tr class="memdesc:ga893b281f3d2bc0088650536899e17903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a statically-defined delayable work item.  <a href="group__workqueue__apis.html#ga893b281f3d2bc0088650536899e17903">More...</a><br /></td></tr>
<tr class="separator:ga893b281f3d2bc0088650536899e17903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f3eac1fc56d5c9c21a3afa9b964b0bf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#ga4f3eac1fc56d5c9c21a3afa9b964b0bf">K_WORK_USER_DEFINE</a>(<a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>,  <a class="el" href="workq_2work__queue_2src_2main_8c.html#a79d59599a7df302be796206c85bb7437">work_handler</a>)&#160;&#160;&#160;	struct k_work_user <a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a> = Z_WORK_USER_INITIALIZER(<a class="el" href="workq_2work__queue_2src_2main_8c.html#a79d59599a7df302be796206c85bb7437">work_handler</a>)</td></tr>
<tr class="memdesc:ga4f3eac1fc56d5c9c21a3afa9b964b0bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a statically-defined user work item.  <a href="group__workqueue__apis.html#ga4f3eac1fc56d5c9c21a3afa9b964b0bf">More...</a><br /></td></tr>
<tr class="separator:ga4f3eac1fc56d5c9c21a3afa9b964b0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8e003eefa5dd66ba883688f9d39c333"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#gaf8e003eefa5dd66ba883688f9d39c333">K_WORK_DEFINE</a>(<a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>,  <a class="el" href="workq_2work__queue_2src_2main_8c.html#a79d59599a7df302be796206c85bb7437">work_handler</a>)&#160;&#160;&#160;	struct <a class="el" href="structk__work.html">k_work</a> <a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a> = Z_WORK_INITIALIZER(<a class="el" href="workq_2work__queue_2src_2main_8c.html#a79d59599a7df302be796206c85bb7437">work_handler</a>)</td></tr>
<tr class="memdesc:gaf8e003eefa5dd66ba883688f9d39c333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a statically-defined work item.  <a href="group__workqueue__apis.html#gaf8e003eefa5dd66ba883688f9d39c333">More...</a><br /></td></tr>
<tr class="separator:gaf8e003eefa5dd66ba883688f9d39c333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41c8a64e854c6cca3a6956079cce2826"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#ga41c8a64e854c6cca3a6956079cce2826">K_DELAYED_WORK_DEFINE</a>(<a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>,  <a class="el" href="workq_2work__queue_2src_2main_8c.html#a79d59599a7df302be796206c85bb7437">work_handler</a>)</td></tr>
<tr class="memdesc:ga41c8a64e854c6cca3a6956079cce2826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a statically-defined delayed work item.  <a href="group__workqueue__apis.html#ga41c8a64e854c6cca3a6956079cce2826">More...</a><br /></td></tr>
<tr class="separator:ga41c8a64e854c6cca3a6956079cce2826"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga5add9ef0dce306a08413c4140fc0bdda"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#ga5add9ef0dce306a08413c4140fc0bdda">k_work_handler_t</a>) (struct <a class="el" href="structk__work.html">k_work</a> *<a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>)</td></tr>
<tr class="memdesc:ga5add9ef0dce306a08413c4140fc0bdda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The signature for a work item handler function.  <a href="group__workqueue__apis.html#ga5add9ef0dce306a08413c4140fc0bdda">More...</a><br /></td></tr>
<tr class="separator:ga5add9ef0dce306a08413c4140fc0bdda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdb3f5f2225b3d5d1fe682cb97f3b328"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#gafdb3f5f2225b3d5d1fe682cb97f3b328">k_work_user_handler_t</a>) (struct k_work_user *<a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>)</td></tr>
<tr class="memdesc:gafdb3f5f2225b3d5d1fe682cb97f3b328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Work item handler function type for user work queues.  <a href="group__workqueue__apis.html#gafdb3f5f2225b3d5d1fe682cb97f3b328">More...</a><br /></td></tr>
<tr class="separator:gafdb3f5f2225b3d5d1fe682cb97f3b328"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga15b3bbe041870ee299f7e042b0305e3c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="group__workqueue__apis.html#gga15b3bbe041870ee299f7e042b0305e3cac6bee9a104cf6ee3853579f5eb15c165">K_WORK_RUNNING</a> = BIT(K_WORK_RUNNING_BIT)
, <a class="el" href="group__workqueue__apis.html#gga15b3bbe041870ee299f7e042b0305e3ca9fdc4327489bcdcca3de0ee9eed6b732">K_WORK_CANCELING</a> = BIT(K_WORK_CANCELING_BIT)
, <a class="el" href="group__workqueue__apis.html#gga15b3bbe041870ee299f7e042b0305e3caa7f8855bc9931bff79062ce53b06eb85">K_WORK_QUEUED</a> = BIT(K_WORK_QUEUED_BIT)
, <a class="el" href="group__workqueue__apis.html#gga15b3bbe041870ee299f7e042b0305e3cab4bf9e74435077b2bbfe1de1f4e80aed">K_WORK_DELAYED</a> = BIT(K_WORK_DELAYED_BIT)
 }</td></tr>
<tr class="separator:ga15b3bbe041870ee299f7e042b0305e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf20080884a2893d39cd8e862b34a2a30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#gaf20080884a2893d39cd8e862b34a2a30">k_work_init</a> (struct <a class="el" href="structk__work.html">k_work</a> *<a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>, <a class="el" href="group__workqueue__apis.html#ga5add9ef0dce306a08413c4140fc0bdda">k_work_handler_t</a> <a class="el" href="timer_2starve_2src_2main_8c.html#ab28ee8b6412d992f77f819e17b664869">handler</a>)</td></tr>
<tr class="memdesc:gaf20080884a2893d39cd8e862b34a2a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a (non-delayable) work structure.  <a href="group__workqueue__apis.html#gaf20080884a2893d39cd8e862b34a2a30">More...</a><br /></td></tr>
<tr class="separator:gaf20080884a2893d39cd8e862b34a2a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba8a8734768d768b433f9d8490e7df7b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#gaba8a8734768d768b433f9d8490e7df7b">k_work_busy_get</a> (const struct <a class="el" href="structk__work.html">k_work</a> *<a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>)</td></tr>
<tr class="memdesc:gaba8a8734768d768b433f9d8490e7df7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Busy state flags from the work item.  <a href="group__workqueue__apis.html#gaba8a8734768d768b433f9d8490e7df7b">More...</a><br /></td></tr>
<tr class="separator:gaba8a8734768d768b433f9d8490e7df7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d1d2e1d2ba2e89a560a1bdc5365d9e0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#ga0d1d2e1d2ba2e89a560a1bdc5365d9e0">k_work_is_pending</a> (const struct <a class="el" href="structk__work.html">k_work</a> *<a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>)</td></tr>
<tr class="memdesc:ga0d1d2e1d2ba2e89a560a1bdc5365d9e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether a work item is currently pending.  <a href="group__workqueue__apis.html#ga0d1d2e1d2ba2e89a560a1bdc5365d9e0">More...</a><br /></td></tr>
<tr class="separator:ga0d1d2e1d2ba2e89a560a1bdc5365d9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5353e76f73db070614f50d06d292d05c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#ga5353e76f73db070614f50d06d292d05c">k_work_submit_to_queue</a> (struct <a class="el" href="structk__work__q.html">k_work_q</a> *<a class="el" href="test__queue__loop_8c.html#a643b6f9660035f1e1098c9484d214bbd">queue</a>, struct <a class="el" href="structk__work.html">k_work</a> *<a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>)</td></tr>
<tr class="memdesc:ga5353e76f73db070614f50d06d292d05c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a work item to a queue.  <a href="group__workqueue__apis.html#ga5353e76f73db070614f50d06d292d05c">More...</a><br /></td></tr>
<tr class="separator:ga5353e76f73db070614f50d06d292d05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace61b59575093d7442f39ccb7be686d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#gace61b59575093d7442f39ccb7be686d7">k_work_submit</a> (struct <a class="el" href="structk__work.html">k_work</a> *<a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>)</td></tr>
<tr class="memdesc:gace61b59575093d7442f39ccb7be686d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a work item to the system queue.  <a href="group__workqueue__apis.html#gace61b59575093d7442f39ccb7be686d7">More...</a><br /></td></tr>
<tr class="separator:gace61b59575093d7442f39ccb7be686d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd1cda459bab538fb2d6dfd84a73b253"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#gabd1cda459bab538fb2d6dfd84a73b253">k_work_flush</a> (struct <a class="el" href="structk__work.html">k_work</a> *<a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>, struct <a class="el" href="structk__work__sync.html">k_work_sync</a> *sync)</td></tr>
<tr class="memdesc:gabd1cda459bab538fb2d6dfd84a73b253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for last-submitted instance to complete.  <a href="group__workqueue__apis.html#gabd1cda459bab538fb2d6dfd84a73b253">More...</a><br /></td></tr>
<tr class="separator:gabd1cda459bab538fb2d6dfd84a73b253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga389fe2a8fb20f9bd593cf8d990727078"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#ga389fe2a8fb20f9bd593cf8d990727078">k_work_cancel</a> (struct <a class="el" href="structk__work.html">k_work</a> *<a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>)</td></tr>
<tr class="memdesc:ga389fe2a8fb20f9bd593cf8d990727078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel a work item.  <a href="group__workqueue__apis.html#ga389fe2a8fb20f9bd593cf8d990727078">More...</a><br /></td></tr>
<tr class="separator:ga389fe2a8fb20f9bd593cf8d990727078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2b05cfe3af08f7d32c3946fa1c808f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#gab2b05cfe3af08f7d32c3946fa1c808f9">k_work_cancel_sync</a> (struct <a class="el" href="structk__work.html">k_work</a> *<a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>, struct <a class="el" href="structk__work__sync.html">k_work_sync</a> *sync)</td></tr>
<tr class="memdesc:gab2b05cfe3af08f7d32c3946fa1c808f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel a work item and wait for it to complete.  <a href="group__workqueue__apis.html#gab2b05cfe3af08f7d32c3946fa1c808f9">More...</a><br /></td></tr>
<tr class="separator:gab2b05cfe3af08f7d32c3946fa1c808f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada77d818ea9e4d07c14a960872ed5492"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#gada77d818ea9e4d07c14a960872ed5492">k_work_queue_init</a> (struct <a class="el" href="structk__work__q.html">k_work_q</a> *<a class="el" href="test__queue__loop_8c.html#a643b6f9660035f1e1098c9484d214bbd">queue</a>)</td></tr>
<tr class="memdesc:gada77d818ea9e4d07c14a960872ed5492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a work queue structure.  <a href="group__workqueue__apis.html#gada77d818ea9e4d07c14a960872ed5492">More...</a><br /></td></tr>
<tr class="separator:gada77d818ea9e4d07c14a960872ed5492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfc56554f9bfe7b52309d79660188593"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#gadfc56554f9bfe7b52309d79660188593">k_work_queue_start</a> (struct <a class="el" href="structk__work__q.html">k_work_q</a> *<a class="el" href="test__queue__loop_8c.html#a643b6f9660035f1e1098c9484d214bbd">queue</a>, <a class="el" href="arch__interface_8h.html#a3e4bde3075edb41069b258d999333b0e">k_thread_stack_t</a> *<a class="el" href="test__stack__fail_8c.html#a6856ea318b5a9498715e4444b13a1de1">stack</a>, size_t stack_size, int prio, const struct <a class="el" href="structk__work__queue__config.html">k_work_queue_config</a> *cfg)</td></tr>
<tr class="memdesc:gadfc56554f9bfe7b52309d79660188593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a work queue.  <a href="group__workqueue__apis.html#gadfc56554f9bfe7b52309d79660188593">More...</a><br /></td></tr>
<tr class="separator:gadfc56554f9bfe7b52309d79660188593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b8b496f7e7bd82d08590a07293e38d7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#ga0b8b496f7e7bd82d08590a07293e38d7">k_work_queue_thread_get</a> (struct <a class="el" href="structk__work__q.html">k_work_q</a> *<a class="el" href="test__queue__loop_8c.html#a643b6f9660035f1e1098c9484d214bbd">queue</a>)</td></tr>
<tr class="memdesc:ga0b8b496f7e7bd82d08590a07293e38d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the thread that animates a work queue.  <a href="group__workqueue__apis.html#ga0b8b496f7e7bd82d08590a07293e38d7">More...</a><br /></td></tr>
<tr class="separator:ga0b8b496f7e7bd82d08590a07293e38d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fefe3e0225ac99b47b250849f6cd863"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#ga0fefe3e0225ac99b47b250849f6cd863">k_work_queue_drain</a> (struct <a class="el" href="structk__work__q.html">k_work_q</a> *<a class="el" href="test__queue__loop_8c.html#a643b6f9660035f1e1098c9484d214bbd">queue</a>, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> plug)</td></tr>
<tr class="memdesc:ga0fefe3e0225ac99b47b250849f6cd863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the work queue has drained, optionally plugging it.  <a href="group__workqueue__apis.html#ga0fefe3e0225ac99b47b250849f6cd863">More...</a><br /></td></tr>
<tr class="separator:ga0fefe3e0225ac99b47b250849f6cd863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0463bb79af3ec470f7d3be02052139f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#gaa0463bb79af3ec470f7d3be02052139f">k_work_queue_unplug</a> (struct <a class="el" href="structk__work__q.html">k_work_q</a> *<a class="el" href="test__queue__loop_8c.html#a643b6f9660035f1e1098c9484d214bbd">queue</a>)</td></tr>
<tr class="memdesc:gaa0463bb79af3ec470f7d3be02052139f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a work queue to accept new submissions.  <a href="group__workqueue__apis.html#gaa0463bb79af3ec470f7d3be02052139f">More...</a><br /></td></tr>
<tr class="separator:gaa0463bb79af3ec470f7d3be02052139f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2876c5d82fb2340a093bc4d689a55465"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#ga2876c5d82fb2340a093bc4d689a55465">k_work_init_delayable</a> (struct <a class="el" href="structk__work__delayable.html">k_work_delayable</a> *<a class="el" href="workq_2work_2src_2main_8c.html#a0aaa7e21c7cd2159f22acc20d1860ffd">dwork</a>, <a class="el" href="group__workqueue__apis.html#ga5add9ef0dce306a08413c4140fc0bdda">k_work_handler_t</a> <a class="el" href="timer_2starve_2src_2main_8c.html#ab28ee8b6412d992f77f819e17b664869">handler</a>)</td></tr>
<tr class="memdesc:ga2876c5d82fb2340a093bc4d689a55465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a delayable work structure.  <a href="group__workqueue__apis.html#ga2876c5d82fb2340a093bc4d689a55465">More...</a><br /></td></tr>
<tr class="separator:ga2876c5d82fb2340a093bc4d689a55465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcb822a03ce7ea9ee1ed046afe31ffca"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structk__work__delayable.html">k_work_delayable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#gabcb822a03ce7ea9ee1ed046afe31ffca">k_work_delayable_from_work</a> (struct <a class="el" href="structk__work.html">k_work</a> *<a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>)</td></tr>
<tr class="memdesc:gabcb822a03ce7ea9ee1ed046afe31ffca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parent delayable work structure from a work pointer.  <a href="group__workqueue__apis.html#gabcb822a03ce7ea9ee1ed046afe31ffca">More...</a><br /></td></tr>
<tr class="separator:gabcb822a03ce7ea9ee1ed046afe31ffca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b76969667844f0981d348c9c671bc9f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#ga1b76969667844f0981d348c9c671bc9f">k_work_delayable_busy_get</a> (const struct <a class="el" href="structk__work__delayable.html">k_work_delayable</a> *<a class="el" href="workq_2work_2src_2main_8c.html#a0aaa7e21c7cd2159f22acc20d1860ffd">dwork</a>)</td></tr>
<tr class="memdesc:ga1b76969667844f0981d348c9c671bc9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Busy state flags from the delayable work item.  <a href="group__workqueue__apis.html#ga1b76969667844f0981d348c9c671bc9f">More...</a><br /></td></tr>
<tr class="separator:ga1b76969667844f0981d348c9c671bc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66e598dbc73f653cbfec03c21168df2e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#ga66e598dbc73f653cbfec03c21168df2e">k_work_delayable_is_pending</a> (const struct <a class="el" href="structk__work__delayable.html">k_work_delayable</a> *<a class="el" href="workq_2work_2src_2main_8c.html#a0aaa7e21c7cd2159f22acc20d1860ffd">dwork</a>)</td></tr>
<tr class="memdesc:ga66e598dbc73f653cbfec03c21168df2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether a delayed work item is currently pending.  <a href="group__workqueue__apis.html#ga66e598dbc73f653cbfec03c21168df2e">More...</a><br /></td></tr>
<tr class="separator:ga66e598dbc73f653cbfec03c21168df2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1772c37bc62b86180d5cf48fe3037624"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__clock__apis.html#ga9832cb0adc2d1866420e5c370a0863e2">k_ticks_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#ga1772c37bc62b86180d5cf48fe3037624">k_work_delayable_expires_get</a> (const struct <a class="el" href="structk__work__delayable.html">k_work_delayable</a> *<a class="el" href="workq_2work_2src_2main_8c.html#a0aaa7e21c7cd2159f22acc20d1860ffd">dwork</a>)</td></tr>
<tr class="memdesc:ga1772c37bc62b86180d5cf48fe3037624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the absolute tick count at which a scheduled delayable work will be submitted.  <a href="group__workqueue__apis.html#ga1772c37bc62b86180d5cf48fe3037624">More...</a><br /></td></tr>
<tr class="separator:ga1772c37bc62b86180d5cf48fe3037624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabce78598a014f3ed87730fe6a9fe61b4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__clock__apis.html#ga9832cb0adc2d1866420e5c370a0863e2">k_ticks_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#gabce78598a014f3ed87730fe6a9fe61b4">k_work_delayable_remaining_get</a> (const struct <a class="el" href="structk__work__delayable.html">k_work_delayable</a> *<a class="el" href="workq_2work_2src_2main_8c.html#a0aaa7e21c7cd2159f22acc20d1860ffd">dwork</a>)</td></tr>
<tr class="memdesc:gabce78598a014f3ed87730fe6a9fe61b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of ticks until a scheduled delayable work will be submitted.  <a href="group__workqueue__apis.html#gabce78598a014f3ed87730fe6a9fe61b4">More...</a><br /></td></tr>
<tr class="separator:gabce78598a014f3ed87730fe6a9fe61b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17f863c9f6ff2fb41dc0f3b7de4fdf23"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#ga17f863c9f6ff2fb41dc0f3b7de4fdf23">k_work_schedule_for_queue</a> (struct <a class="el" href="structk__work__q.html">k_work_q</a> *<a class="el" href="test__queue__loop_8c.html#a643b6f9660035f1e1098c9484d214bbd">queue</a>, struct <a class="el" href="structk__work__delayable.html">k_work_delayable</a> *<a class="el" href="workq_2work_2src_2main_8c.html#a0aaa7e21c7cd2159f22acc20d1860ffd">dwork</a>, <a class="el" href="structk__timeout__t.html">k_timeout_t</a> delay)</td></tr>
<tr class="memdesc:ga17f863c9f6ff2fb41dc0f3b7de4fdf23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit an idle work item to a queue after a delay.  <a href="group__workqueue__apis.html#ga17f863c9f6ff2fb41dc0f3b7de4fdf23">More...</a><br /></td></tr>
<tr class="separator:ga17f863c9f6ff2fb41dc0f3b7de4fdf23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c113ea2bc8e8e5cd7a5c8bc5ec595d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#ga5c113ea2bc8e8e5cd7a5c8bc5ec595d3">k_work_schedule</a> (struct <a class="el" href="structk__work__delayable.html">k_work_delayable</a> *<a class="el" href="workq_2work_2src_2main_8c.html#a0aaa7e21c7cd2159f22acc20d1860ffd">dwork</a>, <a class="el" href="structk__timeout__t.html">k_timeout_t</a> delay)</td></tr>
<tr class="memdesc:ga5c113ea2bc8e8e5cd7a5c8bc5ec595d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit an idle work item to the system work queue after a delay.  <a href="group__workqueue__apis.html#ga5c113ea2bc8e8e5cd7a5c8bc5ec595d3">More...</a><br /></td></tr>
<tr class="separator:ga5c113ea2bc8e8e5cd7a5c8bc5ec595d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf5db091eac19b19a4e12c0cb381f0a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#gabf5db091eac19b19a4e12c0cb381f0a8">k_work_reschedule_for_queue</a> (struct <a class="el" href="structk__work__q.html">k_work_q</a> *<a class="el" href="test__queue__loop_8c.html#a643b6f9660035f1e1098c9484d214bbd">queue</a>, struct <a class="el" href="structk__work__delayable.html">k_work_delayable</a> *<a class="el" href="workq_2work_2src_2main_8c.html#a0aaa7e21c7cd2159f22acc20d1860ffd">dwork</a>, <a class="el" href="structk__timeout__t.html">k_timeout_t</a> delay)</td></tr>
<tr class="memdesc:gabf5db091eac19b19a4e12c0cb381f0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reschedule a work item to a queue after a delay.  <a href="group__workqueue__apis.html#gabf5db091eac19b19a4e12c0cb381f0a8">More...</a><br /></td></tr>
<tr class="separator:gabf5db091eac19b19a4e12c0cb381f0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacaab408fb7c848d466ad1f069dfa648"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#gaacaab408fb7c848d466ad1f069dfa648">k_work_reschedule</a> (struct <a class="el" href="structk__work__delayable.html">k_work_delayable</a> *<a class="el" href="workq_2work_2src_2main_8c.html#a0aaa7e21c7cd2159f22acc20d1860ffd">dwork</a>, <a class="el" href="structk__timeout__t.html">k_timeout_t</a> delay)</td></tr>
<tr class="memdesc:gaacaab408fb7c848d466ad1f069dfa648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reschedule a work item to the system work queue after a delay.  <a href="group__workqueue__apis.html#gaacaab408fb7c848d466ad1f069dfa648">More...</a><br /></td></tr>
<tr class="separator:gaacaab408fb7c848d466ad1f069dfa648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad47d54e513030304be2600d75b1a965f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#gad47d54e513030304be2600d75b1a965f">k_work_flush_delayable</a> (struct <a class="el" href="structk__work__delayable.html">k_work_delayable</a> *<a class="el" href="workq_2work_2src_2main_8c.html#a0aaa7e21c7cd2159f22acc20d1860ffd">dwork</a>, struct <a class="el" href="structk__work__sync.html">k_work_sync</a> *sync)</td></tr>
<tr class="memdesc:gad47d54e513030304be2600d75b1a965f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush delayable work.  <a href="group__workqueue__apis.html#gad47d54e513030304be2600d75b1a965f">More...</a><br /></td></tr>
<tr class="separator:gad47d54e513030304be2600d75b1a965f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92355914ee178d4c3e848a1946bed3e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#ga92355914ee178d4c3e848a1946bed3e4">k_work_cancel_delayable</a> (struct <a class="el" href="structk__work__delayable.html">k_work_delayable</a> *<a class="el" href="workq_2work_2src_2main_8c.html#a0aaa7e21c7cd2159f22acc20d1860ffd">dwork</a>)</td></tr>
<tr class="memdesc:ga92355914ee178d4c3e848a1946bed3e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel delayable work.  <a href="group__workqueue__apis.html#ga92355914ee178d4c3e848a1946bed3e4">More...</a><br /></td></tr>
<tr class="separator:ga92355914ee178d4c3e848a1946bed3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e7ec237648556fc16bfda8d35f7cd86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#ga7e7ec237648556fc16bfda8d35f7cd86">k_work_cancel_delayable_sync</a> (struct <a class="el" href="structk__work__delayable.html">k_work_delayable</a> *<a class="el" href="workq_2work_2src_2main_8c.html#a0aaa7e21c7cd2159f22acc20d1860ffd">dwork</a>, struct <a class="el" href="structk__work__sync.html">k_work_sync</a> *sync)</td></tr>
<tr class="memdesc:ga7e7ec237648556fc16bfda8d35f7cd86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel delayable work and wait.  <a href="group__workqueue__apis.html#ga7e7ec237648556fc16bfda8d35f7cd86">More...</a><br /></td></tr>
<tr class="separator:ga7e7ec237648556fc16bfda8d35f7cd86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ab20a3405d7132870ee5e4b5610bfe3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#ga7ab20a3405d7132870ee5e4b5610bfe3">k_work_pending</a> (const struct <a class="el" href="structk__work.html">k_work</a> *<a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>)</td></tr>
<tr class="separator:ga7ab20a3405d7132870ee5e4b5610bfe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4b913b161ebf5958f7c42ed5e1a6c25"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#gad4b913b161ebf5958f7c42ed5e1a6c25">k_work_q_start</a> (struct <a class="el" href="structk__work__q.html">k_work_q</a> *work_q, <a class="el" href="arch__interface_8h.html#a3e4bde3075edb41069b258d999333b0e">k_thread_stack_t</a> *<a class="el" href="test__stack__fail_8c.html#a6856ea318b5a9498715e4444b13a1de1">stack</a>, size_t stack_size, int prio)</td></tr>
<tr class="separator:gad4b913b161ebf5958f7c42ed5e1a6c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf484b980ae3dbbd620b96e883c4b4fe6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#gaf484b980ae3dbbd620b96e883c4b4fe6">k_delayed_work_init</a> (struct <a class="el" href="structk__delayed__work.html">k_delayed_work</a> *<a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>, <a class="el" href="group__workqueue__apis.html#ga5add9ef0dce306a08413c4140fc0bdda">k_work_handler_t</a> <a class="el" href="timer_2starve_2src_2main_8c.html#ab28ee8b6412d992f77f819e17b664869">handler</a>)</td></tr>
<tr class="separator:gaf484b980ae3dbbd620b96e883c4b4fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d96cee1aa79b9fd01aa3ea7892f74d0"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#ga9d96cee1aa79b9fd01aa3ea7892f74d0">k_delayed_work_submit_to_queue</a> (struct <a class="el" href="structk__work__q.html">k_work_q</a> *work_q, struct <a class="el" href="structk__delayed__work.html">k_delayed_work</a> *<a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>, <a class="el" href="structk__timeout__t.html">k_timeout_t</a> delay)</td></tr>
<tr class="separator:ga9d96cee1aa79b9fd01aa3ea7892f74d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc2b985a4edddd17d1a7406d69167e0c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#gabc2b985a4edddd17d1a7406d69167e0c">k_delayed_work_submit</a> (struct <a class="el" href="structk__delayed__work.html">k_delayed_work</a> *<a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>, <a class="el" href="structk__timeout__t.html">k_timeout_t</a> delay)</td></tr>
<tr class="separator:gabc2b985a4edddd17d1a7406d69167e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00189a735a3a557118c035b7d69feeb0"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#ga00189a735a3a557118c035b7d69feeb0">k_delayed_work_cancel</a> (struct <a class="el" href="structk__delayed__work.html">k_delayed_work</a> *<a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>)</td></tr>
<tr class="separator:ga00189a735a3a557118c035b7d69feeb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47b86afff751340829339566a9932f72"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#ga47b86afff751340829339566a9932f72">k_delayed_work_pending</a> (struct <a class="el" href="structk__delayed__work.html">k_delayed_work</a> *<a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>)</td></tr>
<tr class="separator:ga47b86afff751340829339566a9932f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c5c9af0fb7c0518a87e04f110c27105"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdint_8h.html#a0c18914b3041c2f583aba76f418399c2">int32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#ga3c5c9af0fb7c0518a87e04f110c27105">k_delayed_work_remaining_get</a> (struct <a class="el" href="structk__delayed__work.html">k_delayed_work</a> *<a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>)</td></tr>
<tr class="separator:ga3c5c9af0fb7c0518a87e04f110c27105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbde6358fe7676d8a6bcf286e7802997"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__clock__apis.html#ga9832cb0adc2d1866420e5c370a0863e2">k_ticks_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#gacbde6358fe7676d8a6bcf286e7802997">k_delayed_work_expires_ticks</a> (struct <a class="el" href="structk__delayed__work.html">k_delayed_work</a> *<a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>)</td></tr>
<tr class="separator:gacbde6358fe7676d8a6bcf286e7802997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d0f51e16f52308bb258bf63b4b26915"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__clock__apis.html#ga9832cb0adc2d1866420e5c370a0863e2">k_ticks_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#ga1d0f51e16f52308bb258bf63b4b26915">k_delayed_work_remaining_ticks</a> (struct <a class="el" href="structk__delayed__work.html">k_delayed_work</a> *<a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>)</td></tr>
<tr class="separator:ga1d0f51e16f52308bb258bf63b4b26915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9de9c7a7f13cc6b325e5453e34afe62d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#ga9de9c7a7f13cc6b325e5453e34afe62d">k_work_user_init</a> (struct k_work_user *<a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>, <a class="el" href="group__workqueue__apis.html#gafdb3f5f2225b3d5d1fe682cb97f3b328">k_work_user_handler_t</a> <a class="el" href="timer_2starve_2src_2main_8c.html#ab28ee8b6412d992f77f819e17b664869">handler</a>)</td></tr>
<tr class="memdesc:ga9de9c7a7f13cc6b325e5453e34afe62d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a userspace work item.  <a href="group__workqueue__apis.html#ga9de9c7a7f13cc6b325e5453e34afe62d">More...</a><br /></td></tr>
<tr class="separator:ga9de9c7a7f13cc6b325e5453e34afe62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58d05d4127e4cd51104a1f1a87f626cd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#ga58d05d4127e4cd51104a1f1a87f626cd">k_work_user_is_pending</a> (struct k_work_user *<a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>)</td></tr>
<tr class="memdesc:ga58d05d4127e4cd51104a1f1a87f626cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a userspace work item is pending.  <a href="group__workqueue__apis.html#ga58d05d4127e4cd51104a1f1a87f626cd">More...</a><br /></td></tr>
<tr class="separator:ga58d05d4127e4cd51104a1f1a87f626cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50ae1f6f74c0bc0a41dbbf789fff8856"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#ga50ae1f6f74c0bc0a41dbbf789fff8856">k_work_user_submit_to_queue</a> (struct k_work_user_q *work_q, struct k_work_user *<a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>)</td></tr>
<tr class="memdesc:ga50ae1f6f74c0bc0a41dbbf789fff8856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a work item to a user mode workqueue.  <a href="group__workqueue__apis.html#ga50ae1f6f74c0bc0a41dbbf789fff8856">More...</a><br /></td></tr>
<tr class="separator:ga50ae1f6f74c0bc0a41dbbf789fff8856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3091bc8fab5311252e41634a97a18589"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#ga3091bc8fab5311252e41634a97a18589">k_work_user_queue_start</a> (struct k_work_user_q *work_q, <a class="el" href="arch__interface_8h.html#a3e4bde3075edb41069b258d999333b0e">k_thread_stack_t</a> *<a class="el" href="test__stack__fail_8c.html#a6856ea318b5a9498715e4444b13a1de1">stack</a>, size_t stack_size, int prio, const char *name)</td></tr>
<tr class="memdesc:ga3091bc8fab5311252e41634a97a18589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a workqueue in user mode.  <a href="group__workqueue__apis.html#ga3091bc8fab5311252e41634a97a18589">More...</a><br /></td></tr>
<tr class="separator:ga3091bc8fab5311252e41634a97a18589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga371dab33a40622bea19b07d852863443"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#ga371dab33a40622bea19b07d852863443">k_work_poll_init</a> (struct k_work_poll *<a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>, <a class="el" href="group__workqueue__apis.html#ga5add9ef0dce306a08413c4140fc0bdda">k_work_handler_t</a> <a class="el" href="timer_2starve_2src_2main_8c.html#ab28ee8b6412d992f77f819e17b664869">handler</a>)</td></tr>
<tr class="memdesc:ga371dab33a40622bea19b07d852863443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a triggered work item.  <a href="group__workqueue__apis.html#ga371dab33a40622bea19b07d852863443">More...</a><br /></td></tr>
<tr class="separator:ga371dab33a40622bea19b07d852863443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0abafd7f851e42fd3572c8438e600a53"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#ga0abafd7f851e42fd3572c8438e600a53">k_work_poll_submit_to_queue</a> (struct <a class="el" href="structk__work__q.html">k_work_q</a> *work_q, struct k_work_poll *<a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>, struct <a class="el" href="structk__poll__event.html">k_poll_event</a> *events, int num_events, <a class="el" href="structk__timeout__t.html">k_timeout_t</a> <a class="el" href="timer_2cycle64_2src_2main_8c.html#a8f4b69a82b00d7baf3f1f7d480bb7fa0">timeout</a>)</td></tr>
<tr class="memdesc:ga0abafd7f851e42fd3572c8438e600a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a triggered work item.  <a href="group__workqueue__apis.html#ga0abafd7f851e42fd3572c8438e600a53">More...</a><br /></td></tr>
<tr class="separator:ga0abafd7f851e42fd3572c8438e600a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9f222e46d72c4f98739395a0c8bb4ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#gad9f222e46d72c4f98739395a0c8bb4ea">k_work_poll_submit</a> (struct k_work_poll *<a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>, struct <a class="el" href="structk__poll__event.html">k_poll_event</a> *events, int num_events, <a class="el" href="structk__timeout__t.html">k_timeout_t</a> <a class="el" href="timer_2cycle64_2src_2main_8c.html#a8f4b69a82b00d7baf3f1f7d480bb7fa0">timeout</a>)</td></tr>
<tr class="memdesc:gad9f222e46d72c4f98739395a0c8bb4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a triggered work item to the system workqueue.  <a href="group__workqueue__apis.html#gad9f222e46d72c4f98739395a0c8bb4ea">More...</a><br /></td></tr>
<tr class="separator:gad9f222e46d72c4f98739395a0c8bb4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a19547d04dc1a202e80b752e3177215"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__workqueue__apis.html#ga2a19547d04dc1a202e80b752e3177215">k_work_poll_cancel</a> (struct k_work_poll *<a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>)</td></tr>
<tr class="memdesc:ga2a19547d04dc1a202e80b752e3177215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel a triggered work item.  <a href="group__workqueue__apis.html#ga2a19547d04dc1a202e80b752e3177215">More...</a><br /></td></tr>
<tr class="separator:ga2a19547d04dc1a202e80b752e3177215"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga41c8a64e854c6cca3a6956079cce2826" name="ga41c8a64e854c6cca3a6956079cce2826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41c8a64e854c6cca3a6956079cce2826">&#9670;&nbsp;</a></span>K_DELAYED_WORK_DEFINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define K_DELAYED_WORK_DEFINE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="workq_2work__queue_2src_2main_8c.html#a79d59599a7df302be796206c85bb7437">work_handler</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">        __DEPRECATED_MACRO \</div>
<div class="line">        struct <a class="code hl_struct" href="structk__delayed__work.html">k_delayed_work</a> <a class="code hl_variable" href="profiling_2profiling__api_2src_2main_8c.html#ab8576d2c1da058eedc28da3c8cfac6f1">work</a> = Z_DELAYED_WORK_INITIALIZER(<a class="code hl_function" href="profiling_2profiling__api_2src_2main_8c.html#a9e4959283ebcf4b85ff119e5b0c95337">work_handler</a>)</div>
<div class="ttc" id="aprofiling_2profiling__api_2src_2main_8c_html_a9e4959283ebcf4b85ff119e5b0c95337"><div class="ttname"><a href="profiling_2profiling__api_2src_2main_8c.html#a9e4959283ebcf4b85ff119e5b0c95337">work_handler</a></div><div class="ttdeci">static void work_handler(struct k_work *w)</div><div class="ttdef"><b>Definition:</b> main.c:44</div></div>
<div class="ttc" id="aprofiling_2profiling__api_2src_2main_8c_html_ab8576d2c1da058eedc28da3c8cfac6f1"><div class="ttname"><a href="profiling_2profiling__api_2src_2main_8c.html#ab8576d2c1da058eedc28da3c8cfac6f1">work</a></div><div class="ttdeci">static struct k_work work[2]</div><div class="ttdef"><b>Definition:</b> main.c:16</div></div>
<div class="ttc" id="astructk__delayed__work_html"><div class="ttname"><a href="structk__delayed__work.html">k_delayed_work</a></div><div class="ttdef"><b>Definition:</b> kernel.h:3793</div></div>
</div><!-- fragment -->
<p>Initialize a statically-defined delayed work item. </p>
<p >This macro can be used to initialize a statically-defined workqueue delayed work item, prior to its first use. For example,</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code hl_define" href="group__workqueue__apis.html#ga41c8a64e854c6cca3a6956079cce2826">K_DELAYED_WORK_DEFINE</a>(&lt;<a class="code hl_variable" href="profiling_2profiling__api_2src_2main_8c.html#ab8576d2c1da058eedc28da3c8cfac6f1">work</a>&gt;, &lt;<a class="code hl_function" href="profiling_2profiling__api_2src_2main_8c.html#a9e4959283ebcf4b85ff119e5b0c95337">work_handler</a>&gt;); </div>
<div class="ttc" id="agroup__workqueue__apis_html_ga41c8a64e854c6cca3a6956079cce2826"><div class="ttname"><a href="group__workqueue__apis.html#ga41c8a64e854c6cca3a6956079cce2826">K_DELAYED_WORK_DEFINE</a></div><div class="ttdeci">#define K_DELAYED_WORK_DEFINE(work, work_handler)</div><div class="ttdoc">Initialize a statically-defined delayed work item.</div><div class="ttdef"><b>Definition:</b> kernel.h:4117</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">work</td><td>Symbol name for delayed work item object </td></tr>
    <tr><td class="paramname">work_handler</td><td>Function to invoke each time work item is processed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf8e003eefa5dd66ba883688f9d39c333" name="gaf8e003eefa5dd66ba883688f9d39c333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8e003eefa5dd66ba883688f9d39c333">&#9670;&nbsp;</a></span>K_WORK_DEFINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define K_WORK_DEFINE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="workq_2work__queue_2src_2main_8c.html#a79d59599a7df302be796206c85bb7437">work_handler</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;	struct <a class="el" href="structk__work.html">k_work</a> <a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a> = Z_WORK_INITIALIZER(<a class="el" href="workq_2work__queue_2src_2main_8c.html#a79d59599a7df302be796206c85bb7437">work_handler</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Initialize a statically-defined work item. </p>
<p >This macro can be used to initialize a statically-defined workqueue work item, prior to its first use. For example,</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code hl_define" href="group__workqueue__apis.html#gaf8e003eefa5dd66ba883688f9d39c333">K_WORK_DEFINE</a>(&lt;<a class="code hl_variable" href="profiling_2profiling__api_2src_2main_8c.html#ab8576d2c1da058eedc28da3c8cfac6f1">work</a>&gt;, &lt;<a class="code hl_function" href="profiling_2profiling__api_2src_2main_8c.html#a9e4959283ebcf4b85ff119e5b0c95337">work_handler</a>&gt;); </div>
<div class="ttc" id="agroup__workqueue__apis_html_gaf8e003eefa5dd66ba883688f9d39c333"><div class="ttname"><a href="group__workqueue__apis.html#gaf8e003eefa5dd66ba883688f9d39c333">K_WORK_DEFINE</a></div><div class="ttdeci">#define K_WORK_DEFINE(work, work_handler)</div><div class="ttdoc">Initialize a statically-defined work item.</div><div class="ttdef"><b>Definition:</b> kernel.h:4103</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">work</td><td>Symbol name for work item object </td></tr>
    <tr><td class="paramname">work_handler</td><td>Function to invoke each time work item is processed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga893b281f3d2bc0088650536899e17903" name="ga893b281f3d2bc0088650536899e17903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga893b281f3d2bc0088650536899e17903">&#9670;&nbsp;</a></span>K_WORK_DELAYABLE_DEFINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define K_WORK_DELAYABLE_DEFINE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="workq_2work__queue_2src_2main_8c.html#a79d59599a7df302be796206c85bb7437">work_handler</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">        <span class="keyword">struct </span><a class="code hl_struct" href="structk__work__delayable.html">k_work_delayable</a> <a class="code hl_variable" href="profiling_2profiling__api_2src_2main_8c.html#ab8576d2c1da058eedc28da3c8cfac6f1">work</a> \</div>
<div class="line">          = Z_WORK_DELAYABLE_INITIALIZER(<a class="code hl_function" href="profiling_2profiling__api_2src_2main_8c.html#a9e4959283ebcf4b85ff119e5b0c95337">work_handler</a>)</div>
<div class="ttc" id="astructk__work__delayable_html"><div class="ttname"><a href="structk__work__delayable.html">k_work_delayable</a></div><div class="ttdoc">A structure used to submit work after a delay.</div><div class="ttdef"><b>Definition:</b> kernel.h:3600</div></div>
</div><!-- fragment -->
<p>Initialize a statically-defined delayable work item. </p>
<p >This macro can be used to initialize a statically-defined delayable work item, prior to its first use. For example,</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code hl_define" href="group__workqueue__apis.html#ga893b281f3d2bc0088650536899e17903">K_WORK_DELAYABLE_DEFINE</a>(&lt;<a class="code hl_variable" href="workq_2work_2src_2main_8c.html#a0aaa7e21c7cd2159f22acc20d1860ffd">dwork</a>&gt;, &lt;<a class="code hl_function" href="profiling_2profiling__api_2src_2main_8c.html#a9e4959283ebcf4b85ff119e5b0c95337">work_handler</a>&gt;); </div>
<div class="ttc" id="agroup__workqueue__apis_html_ga893b281f3d2bc0088650536899e17903"><div class="ttname"><a href="group__workqueue__apis.html#ga893b281f3d2bc0088650536899e17903">K_WORK_DELAYABLE_DEFINE</a></div><div class="ttdeci">#define K_WORK_DELAYABLE_DEFINE(work, work_handler)</div><div class="ttdoc">Initialize a statically-defined delayable work item.</div><div class="ttdef"><b>Definition:</b> kernel.h:3634</div></div>
<div class="ttc" id="aworkq_2work_2src_2main_8c_html_a0aaa7e21c7cd2159f22acc20d1860ffd"><div class="ttname"><a href="workq_2work_2src_2main_8c.html#a0aaa7e21c7cd2159f22acc20d1860ffd">dwork</a></div><div class="ttdeci">static struct k_work_delayable dwork</div><div class="ttdef"><b>Definition:</b> main.c:48</div></div>
</div><!-- fragment --><p >Note that if the runtime dependencies support initialization with <a class="el" href="group__workqueue__apis.html#ga2876c5d82fb2340a093bc4d689a55465" title="Initialize a delayable work structure.">k_work_init_delayable()</a> using that will eliminate the initialized object in ROM that is produced by this macro and copied in at system startup.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">work</td><td>Symbol name for delayable work item object </td></tr>
    <tr><td class="paramname">work_handler</td><td>Function to invoke each time work item is processed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4f3eac1fc56d5c9c21a3afa9b964b0bf" name="ga4f3eac1fc56d5c9c21a3afa9b964b0bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f3eac1fc56d5c9c21a3afa9b964b0bf">&#9670;&nbsp;</a></span>K_WORK_USER_DEFINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define K_WORK_USER_DEFINE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="workq_2work__queue_2src_2main_8c.html#a79d59599a7df302be796206c85bb7437">work_handler</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;	struct k_work_user <a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a> = Z_WORK_USER_INITIALIZER(<a class="el" href="workq_2work__queue_2src_2main_8c.html#a79d59599a7df302be796206c85bb7437">work_handler</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Initialize a statically-defined user work item. </p>
<p >This macro can be used to initialize a statically-defined user work item, prior to its first use. For example,</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code hl_define" href="group__workqueue__apis.html#ga4f3eac1fc56d5c9c21a3afa9b964b0bf">K_WORK_USER_DEFINE</a>(&lt;<a class="code hl_variable" href="profiling_2profiling__api_2src_2main_8c.html#ab8576d2c1da058eedc28da3c8cfac6f1">work</a>&gt;, &lt;<a class="code hl_function" href="profiling_2profiling__api_2src_2main_8c.html#a9e4959283ebcf4b85ff119e5b0c95337">work_handler</a>&gt;); </div>
<div class="ttc" id="agroup__workqueue__apis_html_ga4f3eac1fc56d5c9c21a3afa9b964b0bf"><div class="ttname"><a href="group__workqueue__apis.html#ga4f3eac1fc56d5c9c21a3afa9b964b0bf">K_WORK_USER_DEFINE</a></div><div class="ttdeci">#define K_WORK_USER_DEFINE(work, work_handler)</div><div class="ttdoc">Initialize a statically-defined user work item.</div><div class="ttdef"><b>Definition:</b> kernel.h:3964</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">work</td><td>Symbol name for work item object </td></tr>
    <tr><td class="paramname">work_handler</td><td>Function to invoke each time work item is processed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga5add9ef0dce306a08413c4140fc0bdda" name="ga5add9ef0dce306a08413c4140fc0bdda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5add9ef0dce306a08413c4140fc0bdda">&#9670;&nbsp;</a></span>k_work_handler_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* k_work_handler_t) (struct <a class="el" href="structk__work.html">k_work</a> *<a class="el" href="workq_2work_2src_2main_8c.html#a147e2d2d335d9181395da44aa45b7694">work</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>The signature for a work item handler function. </p>
<p >The function will be invoked by the thread animating a work queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">work</td><td>the work item that provided the handler. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafdb3f5f2225b3d5d1fe682cb97f3b328" name="gafdb3f5f2225b3d5d1fe682cb97f3b328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdb3f5f2225b3d5d1fe682cb97f3b328">&#9670;&nbsp;</a></span>k_work_user_handler_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">k_work_user_handler_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Work item handler function type for user work queues. </p>
<p >A work item's handler function is executed by a user workqueue's thread when the work item is processed by the workqueue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">work</td><td>Address of the work item. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga15b3bbe041870ee299f7e042b0305e3c" name="ga15b3bbe041870ee299f7e042b0305e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15b3bbe041870ee299f7e042b0305e3c">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga15b3bbe041870ee299f7e042b0305e3cac6bee9a104cf6ee3853579f5eb15c165" name="gga15b3bbe041870ee299f7e042b0305e3cac6bee9a104cf6ee3853579f5eb15c165"></a>K_WORK_RUNNING&#160;</td><td class="fielddoc"><p >Flag indicating a work item that is running under a work queue thread. </p>
<p >Accessed via <a class="el" href="group__workqueue__apis.html#gaba8a8734768d768b433f9d8490e7df7b" title="Busy state flags from the work item.">k_work_busy_get()</a>. May co-occur with other flags. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga15b3bbe041870ee299f7e042b0305e3ca9fdc4327489bcdcca3de0ee9eed6b732" name="gga15b3bbe041870ee299f7e042b0305e3ca9fdc4327489bcdcca3de0ee9eed6b732"></a>K_WORK_CANCELING&#160;</td><td class="fielddoc"><p >Flag indicating a work item that is being canceled. </p>
<pre class="fragment">   Accessed via k_work_busy_get().  May co-occur with other flags.
</pre> </td></tr>
<tr><td class="fieldname"><a id="gga15b3bbe041870ee299f7e042b0305e3caa7f8855bc9931bff79062ce53b06eb85" name="gga15b3bbe041870ee299f7e042b0305e3caa7f8855bc9931bff79062ce53b06eb85"></a>K_WORK_QUEUED&#160;</td><td class="fielddoc"><p >Flag indicating a work item that has been submitted to a queue but has not started running. </p>
<p >Accessed via <a class="el" href="group__workqueue__apis.html#gaba8a8734768d768b433f9d8490e7df7b" title="Busy state flags from the work item.">k_work_busy_get()</a>. May co-occur with other flags. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga15b3bbe041870ee299f7e042b0305e3cab4bf9e74435077b2bbfe1de1f4e80aed" name="gga15b3bbe041870ee299f7e042b0305e3cab4bf9e74435077b2bbfe1de1f4e80aed"></a>K_WORK_DELAYED&#160;</td><td class="fielddoc"><p >Flag indicating a delayed work item that is scheduled for submission to a queue. </p>
<p >Accessed via <a class="el" href="group__workqueue__apis.html#gaba8a8734768d768b433f9d8490e7df7b" title="Busy state flags from the work item.">k_work_busy_get()</a>. May co-occur with other flags. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga00189a735a3a557118c035b7d69feeb0" name="ga00189a735a3a557118c035b7d69feeb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00189a735a3a557118c035b7d69feeb0">&#9670;&nbsp;</a></span>k_delayed_work_cancel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int k_delayed_work_cancel </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__delayed__work.html">k_delayed_work</a> *&#160;</td>
          <td class="paramname"><em>work</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

</div>
</div>
<a id="gacbde6358fe7676d8a6bcf286e7802997" name="gacbde6358fe7676d8a6bcf286e7802997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbde6358fe7676d8a6bcf286e7802997">&#9670;&nbsp;</a></span>k_delayed_work_expires_ticks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__clock__apis.html#ga9832cb0adc2d1866420e5c370a0863e2">k_ticks_t</a> k_delayed_work_expires_ticks </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__delayed__work.html">k_delayed_work</a> *&#160;</td>
          <td class="paramname"><em>work</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

</div>
</div>
<a id="gaf484b980ae3dbbd620b96e883c4b4fe6" name="gaf484b980ae3dbbd620b96e883c4b4fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf484b980ae3dbbd620b96e883c4b4fe6">&#9670;&nbsp;</a></span>k_delayed_work_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void k_delayed_work_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__delayed__work.html">k_delayed_work</a> *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__workqueue__apis.html#ga5add9ef0dce306a08413c4140fc0bdda">k_work_handler_t</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

</div>
</div>
<a id="ga47b86afff751340829339566a9932f72" name="ga47b86afff751340829339566a9932f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47b86afff751340829339566a9932f72">&#9670;&nbsp;</a></span>k_delayed_work_pending()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> k_delayed_work_pending </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__delayed__work.html">k_delayed_work</a> *&#160;</td>
          <td class="paramname"><em>work</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

</div>
</div>
<a id="ga3c5c9af0fb7c0518a87e04f110c27105" name="ga3c5c9af0fb7c0518a87e04f110c27105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c5c9af0fb7c0518a87e04f110c27105">&#9670;&nbsp;</a></span>k_delayed_work_remaining_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdint_8h.html#a0c18914b3041c2f583aba76f418399c2">int32_t</a> k_delayed_work_remaining_get </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__delayed__work.html">k_delayed_work</a> *&#160;</td>
          <td class="paramname"><em>work</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

</div>
</div>
<a id="ga1d0f51e16f52308bb258bf63b4b26915" name="ga1d0f51e16f52308bb258bf63b4b26915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d0f51e16f52308bb258bf63b4b26915">&#9670;&nbsp;</a></span>k_delayed_work_remaining_ticks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__clock__apis.html#ga9832cb0adc2d1866420e5c370a0863e2">k_ticks_t</a> k_delayed_work_remaining_ticks </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__delayed__work.html">k_delayed_work</a> *&#160;</td>
          <td class="paramname"><em>work</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

</div>
</div>
<a id="gabc2b985a4edddd17d1a7406d69167e0c" name="gabc2b985a4edddd17d1a7406d69167e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc2b985a4edddd17d1a7406d69167e0c">&#9670;&nbsp;</a></span>k_delayed_work_submit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int k_delayed_work_submit </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__delayed__work.html">k_delayed_work</a> *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structk__timeout__t.html">k_timeout_t</a>&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

</div>
</div>
<a id="ga9d96cee1aa79b9fd01aa3ea7892f74d0" name="ga9d96cee1aa79b9fd01aa3ea7892f74d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d96cee1aa79b9fd01aa3ea7892f74d0">&#9670;&nbsp;</a></span>k_delayed_work_submit_to_queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int k_delayed_work_submit_to_queue </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__work__q.html">k_work_q</a> *&#160;</td>
          <td class="paramname"><em>work_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structk__delayed__work.html">k_delayed_work</a> *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structk__timeout__t.html">k_timeout_t</a>&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

</div>
</div>
<a id="gaba8a8734768d768b433f9d8490e7df7b" name="gaba8a8734768d768b433f9d8490e7df7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba8a8734768d768b433f9d8490e7df7b">&#9670;&nbsp;</a></span>k_work_busy_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_work_busy_get </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structk__work.html">k_work</a> *&#160;</td>
          <td class="paramname"><em>work</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Busy state flags from the work item. </p>
<p >A zero return value indicates the work item appears to be idle.</p>
<dl class="section note"><dt>Note</dt><dd>This is a live snapshot of state, which may change before the result is checked. Use locks where appropriate.</dd></dl>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">work</td><td>pointer to the work item.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a mask of flags K_WORK_DELAYED, K_WORK_QUEUED, K_WORK_RUNNING, and K_WORK_CANCELING. </dd></dl>

</div>
</div>
<a id="ga389fe2a8fb20f9bd593cf8d990727078" name="ga389fe2a8fb20f9bd593cf8d990727078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga389fe2a8fb20f9bd593cf8d990727078">&#9670;&nbsp;</a></span>k_work_cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_work_cancel </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__work.html">k_work</a> *&#160;</td>
          <td class="paramname"><em>work</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Cancel a work item. </p>
<p >This attempts to prevent a pending (non-delayable) work item from being processed by removing it from the work queue. If the item is being processed, the work item will continue to be processed, but resubmissions are rejected until cancellation completes.</p>
<p >If this returns zero cancellation is complete, otherwise something (probably a work queue thread) is still referencing the item.</p>
<p >See also <a class="el" href="group__workqueue__apis.html#gab2b05cfe3af08f7d32c3946fa1c808f9" title="Cancel a work item and wait for it to complete.">k_work_cancel_sync()</a>.</p>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">work</td><td>pointer to the work item.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="group__workqueue__apis.html#gaba8a8734768d768b433f9d8490e7df7b" title="Busy state flags from the work item.">k_work_busy_get()</a> status indicating the state of the item after all cancellation steps performed by this call are completed. </dd></dl>

</div>
</div>
<a id="ga92355914ee178d4c3e848a1946bed3e4" name="ga92355914ee178d4c3e848a1946bed3e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92355914ee178d4c3e848a1946bed3e4">&#9670;&nbsp;</a></span>k_work_cancel_delayable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_work_cancel_delayable </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__work__delayable.html">k_work_delayable</a> *&#160;</td>
          <td class="paramname"><em>dwork</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Cancel delayable work. </p>
<p >Similar to <a class="el" href="group__workqueue__apis.html#ga389fe2a8fb20f9bd593cf8d990727078" title="Cancel a work item.">k_work_cancel()</a> but for delayable work. If the work is scheduled or submitted it is canceled. This function does not wait for the cancellation to complete.</p>
<dl class="section note"><dt>Note</dt><dd>The work may still be running when this returns. Use <a class="el" href="group__workqueue__apis.html#gad47d54e513030304be2600d75b1a965f" title="Flush delayable work.">k_work_flush_delayable()</a> or <a class="el" href="group__workqueue__apis.html#ga7e7ec237648556fc16bfda8d35f7cd86" title="Cancel delayable work and wait.">k_work_cancel_delayable_sync()</a> to ensure it is not running.</dd>
<dd>
Canceling delayable work does not prevent rescheduling it. It does prevent submitting it until the cancellation completes.</dd></dl>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dwork</td><td>pointer to the delayable work item.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="group__workqueue__apis.html#ga1b76969667844f0981d348c9c671bc9f" title="Busy state flags from the delayable work item.">k_work_delayable_busy_get()</a> status indicating the state of the item after all cancellation steps performed by this call are completed. </dd></dl>

</div>
</div>
<a id="ga7e7ec237648556fc16bfda8d35f7cd86" name="ga7e7ec237648556fc16bfda8d35f7cd86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e7ec237648556fc16bfda8d35f7cd86">&#9670;&nbsp;</a></span>k_work_cancel_delayable_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> k_work_cancel_delayable_sync </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__work__delayable.html">k_work_delayable</a> *&#160;</td>
          <td class="paramname"><em>dwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structk__work__sync.html">k_work_sync</a> *&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Cancel delayable work and wait. </p>
<p >Like <a class="el" href="group__workqueue__apis.html#ga92355914ee178d4c3e848a1946bed3e4" title="Cancel delayable work.">k_work_cancel_delayable()</a> but waits until the work becomes idle.</p>
<dl class="section note"><dt>Note</dt><dd>Canceling delayable work does not prevent rescheduling it. It does prevent submitting it until the cancellation completes.</dd>
<dd>
Be careful of caller and work queue thread relative priority. If this function sleeps it will not return until the work queue thread completes the tasks that allow this thread to resume.</dd>
<dd>
Behavior is undefined if this function is invoked on <code>dwork</code> from a work queue running <code>dwork</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dwork</td><td>pointer to the delayable work item.</td></tr>
    <tr><td class="paramname">sync</td><td>pointer to an opaque item containing state related to the pending cancellation. The object must persist until the call returns, and be accessible from both the caller thread and the work queue thread. The object must not be used for any other flush or cancel operation until this one completes. On architectures with CONFIG_KERNEL_COHERENCE the object must be allocated in coherent memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if work was not idle (call had to wait for cancellation of a running handler to complete, or scheduled or submitted operations were cancelled); </td></tr>
    <tr><td class="paramname">false</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab2b05cfe3af08f7d32c3946fa1c808f9" name="gab2b05cfe3af08f7d32c3946fa1c808f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2b05cfe3af08f7d32c3946fa1c808f9">&#9670;&nbsp;</a></span>k_work_cancel_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> k_work_cancel_sync </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__work.html">k_work</a> *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structk__work__sync.html">k_work_sync</a> *&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Cancel a work item and wait for it to complete. </p>
<p >Same as <a class="el" href="group__workqueue__apis.html#ga389fe2a8fb20f9bd593cf8d990727078" title="Cancel a work item.">k_work_cancel()</a> but does not return until cancellation is complete. This can be invoked by a thread after <a class="el" href="group__workqueue__apis.html#ga389fe2a8fb20f9bd593cf8d990727078" title="Cancel a work item.">k_work_cancel()</a> to synchronize with a previous cancellation.</p>
<p >On return the work structure will be idle unless something submits it after the cancellation was complete.</p>
<dl class="section note"><dt>Note</dt><dd>Be careful of caller and work queue thread relative priority. If this function sleeps it will not return until the work queue thread completes the tasks that allow this thread to resume.</dd>
<dd>
Behavior is undefined if this function is invoked on <code>work</code> from a work queue running <code>work</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">work</td><td>pointer to the work item.</td></tr>
    <tr><td class="paramname">sync</td><td>pointer to an opaque item containing state related to the pending cancellation. The object must persist until the call returns, and be accessible from both the caller thread and the work queue thread. The object must not be used for any other flush or cancel operation until this one completes. On architectures with CONFIG_KERNEL_COHERENCE the object must be allocated in coherent memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if work was pending (call had to wait for cancellation of a running handler to complete, or scheduled or submitted operations were cancelled); </td></tr>
    <tr><td class="paramname">false</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1b76969667844f0981d348c9c671bc9f" name="ga1b76969667844f0981d348c9c671bc9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b76969667844f0981d348c9c671bc9f">&#9670;&nbsp;</a></span>k_work_delayable_busy_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_work_delayable_busy_get </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structk__work__delayable.html">k_work_delayable</a> *&#160;</td>
          <td class="paramname"><em>dwork</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Busy state flags from the delayable work item. </p>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a live snapshot of state, which may change before the result can be inspected. Use locks where appropriate.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dwork</td><td>pointer to the delayable work item.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a mask of flags K_WORK_DELAYED, K_WORK_QUEUED, K_WORK_RUNNING, and K_WORK_CANCELING. A zero return value indicates the work item appears to be idle. </dd></dl>

</div>
</div>
<a id="ga1772c37bc62b86180d5cf48fe3037624" name="ga1772c37bc62b86180d5cf48fe3037624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1772c37bc62b86180d5cf48fe3037624">&#9670;&nbsp;</a></span>k_work_delayable_expires_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__clock__apis.html#ga9832cb0adc2d1866420e5c370a0863e2">k_ticks_t</a> k_work_delayable_expires_get </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structk__work__delayable.html">k_work_delayable</a> *&#160;</td>
          <td class="paramname"><em>dwork</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Get the absolute tick count at which a scheduled delayable work will be submitted. </p>
<dl class="section note"><dt>Note</dt><dd>This is a live snapshot of state, which may change before the result can be inspected. Use locks where appropriate.</dd></dl>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dwork</td><td>pointer to the delayable work item.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the tick count when the timer that will schedule the work item will expire, or the current tick count if the work is not scheduled. </dd></dl>

</div>
</div>
<a id="gabcb822a03ce7ea9ee1ed046afe31ffca" name="gabcb822a03ce7ea9ee1ed046afe31ffca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcb822a03ce7ea9ee1ed046afe31ffca">&#9670;&nbsp;</a></span>k_work_delayable_from_work()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structk__work__delayable.html">k_work_delayable</a> * k_work_delayable_from_work </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__work.html">k_work</a> *&#160;</td>
          <td class="paramname"><em>work</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Get the parent delayable work structure from a work pointer. </p>
<p >This function is necessary when a <code>k_work_handler_t</code> function is passed to <a class="el" href="group__workqueue__apis.html#ga17f863c9f6ff2fb41dc0f3b7de4fdf23" title="Submit an idle work item to a queue after a delay.">k_work_schedule_for_queue()</a> and the handler needs to access data from the container of the containing <code><a class="el" href="structk__work__delayable.html" title="A structure used to submit work after a delay.">k_work_delayable</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">work</td><td>Address passed to the work handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address of the containing <code><a class="el" href="structk__work__delayable.html" title="A structure used to submit work after a delay.">k_work_delayable</a></code> structure. </dd></dl>

</div>
</div>
<a id="ga66e598dbc73f653cbfec03c21168df2e" name="ga66e598dbc73f653cbfec03c21168df2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66e598dbc73f653cbfec03c21168df2e">&#9670;&nbsp;</a></span>k_work_delayable_is_pending()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> k_work_delayable_is_pending </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structk__work__delayable.html">k_work_delayable</a> *&#160;</td>
          <td class="paramname"><em>dwork</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Test whether a delayed work item is currently pending. </p>
<p >Wrapper to determine whether a delayed work item is in a non-idle state.</p>
<dl class="section note"><dt>Note</dt><dd>This is a live snapshot of state, which may change before the result can be inspected. Use locks where appropriate.</dd></dl>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dwork</td><td>pointer to the delayable work item.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if <a class="el" href="group__workqueue__apis.html#ga1b76969667844f0981d348c9c671bc9f" title="Busy state flags from the delayable work item.">k_work_delayable_busy_get()</a> returns a non-zero value. </dd></dl>

</div>
</div>
<a id="gabce78598a014f3ed87730fe6a9fe61b4" name="gabce78598a014f3ed87730fe6a9fe61b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabce78598a014f3ed87730fe6a9fe61b4">&#9670;&nbsp;</a></span>k_work_delayable_remaining_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__clock__apis.html#ga9832cb0adc2d1866420e5c370a0863e2">k_ticks_t</a> k_work_delayable_remaining_get </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structk__work__delayable.html">k_work_delayable</a> *&#160;</td>
          <td class="paramname"><em>dwork</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Get the number of ticks until a scheduled delayable work will be submitted. </p>
<dl class="section note"><dt>Note</dt><dd>This is a live snapshot of state, which may change before the result can be inspected. Use locks where appropriate.</dd></dl>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dwork</td><td>pointer to the delayable work item.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of ticks until the timer that will schedule the work item will expire, or zero if the item is not scheduled. </dd></dl>

</div>
</div>
<a id="gabd1cda459bab538fb2d6dfd84a73b253" name="gabd1cda459bab538fb2d6dfd84a73b253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd1cda459bab538fb2d6dfd84a73b253">&#9670;&nbsp;</a></span>k_work_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> k_work_flush </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__work.html">k_work</a> *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structk__work__sync.html">k_work_sync</a> *&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Wait for last-submitted instance to complete. </p>
<p >Resubmissions may occur while waiting, including chained submissions (from within the handler).</p>
<dl class="section note"><dt>Note</dt><dd>Be careful of caller and work queue thread relative priority. If this function sleeps it will not return until the work queue thread completes the tasks that allow this thread to resume.</dd>
<dd>
Behavior is undefined if this function is invoked on <code>work</code> from a work queue running <code>work</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">work</td><td>pointer to the work item.</td></tr>
    <tr><td class="paramname">sync</td><td>pointer to an opaque item containing state related to the pending cancellation. The object must persist until the call returns, and be accessible from both the caller thread and the work queue thread. The object must not be used for any other flush or cancel operation until this one completes. On architectures with CONFIG_KERNEL_COHERENCE the object must be allocated in coherent memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if call had to wait for completion </td></tr>
    <tr><td class="paramname">false</td><td>if work was already idle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad47d54e513030304be2600d75b1a965f" name="gad47d54e513030304be2600d75b1a965f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad47d54e513030304be2600d75b1a965f">&#9670;&nbsp;</a></span>k_work_flush_delayable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> k_work_flush_delayable </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__work__delayable.html">k_work_delayable</a> *&#160;</td>
          <td class="paramname"><em>dwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structk__work__sync.html">k_work_sync</a> *&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Flush delayable work. </p>
<p >If the work is scheduled, it is immediately submitted. Then the caller blocks until the work completes, as with <a class="el" href="group__workqueue__apis.html#gabd1cda459bab538fb2d6dfd84a73b253" title="Wait for last-submitted instance to complete.">k_work_flush()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Be careful of caller and work queue thread relative priority. If this function sleeps it will not return until the work queue thread completes the tasks that allow this thread to resume.</dd>
<dd>
Behavior is undefined if this function is invoked on <code>dwork</code> from a work queue running <code>dwork</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dwork</td><td>pointer to the delayable work item.</td></tr>
    <tr><td class="paramname">sync</td><td>pointer to an opaque item containing state related to the pending cancellation. The object must persist until the call returns, and be accessible from both the caller thread and the work queue thread. The object must not be used for any other flush or cancel operation until this one completes. On architectures with CONFIG_KERNEL_COHERENCE the object must be allocated in coherent memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if call had to wait for completion </td></tr>
    <tr><td class="paramname">false</td><td>if work was already idle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf20080884a2893d39cd8e862b34a2a30" name="gaf20080884a2893d39cd8e862b34a2a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf20080884a2893d39cd8e862b34a2a30">&#9670;&nbsp;</a></span>k_work_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void k_work_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__work.html">k_work</a> *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__workqueue__apis.html#ga5add9ef0dce306a08413c4140fc0bdda">k_work_handler_t</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Initialize a (non-delayable) work structure. </p>
<p >This must be invoked before submitting a work structure for the first time. It need not be invoked again on the same work structure. It can be re-invoked to change the associated handler, but this must be done when the work item is idle.</p>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">work</td><td>the work structure to be initialized.</td></tr>
    <tr><td class="paramname">handler</td><td>the handler to be invoked by the work item. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2876c5d82fb2340a093bc4d689a55465" name="ga2876c5d82fb2340a093bc4d689a55465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2876c5d82fb2340a093bc4d689a55465">&#9670;&nbsp;</a></span>k_work_init_delayable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void k_work_init_delayable </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__work__delayable.html">k_work_delayable</a> *&#160;</td>
          <td class="paramname"><em>dwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__workqueue__apis.html#ga5add9ef0dce306a08413c4140fc0bdda">k_work_handler_t</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Initialize a delayable work structure. </p>
<p >This must be invoked before scheduling a delayable work structure for the first time. It need not be invoked again on the same work structure. It can be re-invoked to change the associated handler, but this must be done when the work item is idle.</p>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dwork</td><td>the delayable work structure to be initialized.</td></tr>
    <tr><td class="paramname">handler</td><td>the handler to be invoked by the work item. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0d1d2e1d2ba2e89a560a1bdc5365d9e0" name="ga0d1d2e1d2ba2e89a560a1bdc5365d9e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d1d2e1d2ba2e89a560a1bdc5365d9e0">&#9670;&nbsp;</a></span>k_work_is_pending()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> k_work_is_pending </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structk__work.html">k_work</a> *&#160;</td>
          <td class="paramname"><em>work</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Test whether a work item is currently pending. </p>
<p >Wrapper to determine whether a work item is in a non-idle dstate.</p>
<dl class="section note"><dt>Note</dt><dd>This is a live snapshot of state, which may change before the result is checked. Use locks where appropriate.</dd></dl>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">work</td><td>pointer to the work item.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if <a class="el" href="group__workqueue__apis.html#gaba8a8734768d768b433f9d8490e7df7b" title="Busy state flags from the work item.">k_work_busy_get()</a> returns a non-zero value. </dd></dl>

</div>
</div>
<a id="ga7ab20a3405d7132870ee5e4b5610bfe3" name="ga7ab20a3405d7132870ee5e4b5610bfe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ab20a3405d7132870ee5e4b5610bfe3">&#9670;&nbsp;</a></span>k_work_pending()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> k_work_pending </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structk__work.html">k_work</a> *&#160;</td>
          <td class="paramname"><em>work</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

</div>
</div>
<a id="ga2a19547d04dc1a202e80b752e3177215" name="ga2a19547d04dc1a202e80b752e3177215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a19547d04dc1a202e80b752e3177215">&#9670;&nbsp;</a></span>k_work_poll_cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_work_poll_cancel </td>
          <td>(</td>
          <td class="paramtype">struct k_work_poll *&#160;</td>
          <td class="paramname"><em>work</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Cancel a triggered work item. </p>
<p >This routine cancels the submission of triggered work item <em>work</em>. A triggered work item can only be canceled if no event triggered work submission.</p>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">work</td><td>Address of delayed work item.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Work item canceled. </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>Work item is being processed or has completed its work. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga371dab33a40622bea19b07d852863443" name="ga371dab33a40622bea19b07d852863443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga371dab33a40622bea19b07d852863443">&#9670;&nbsp;</a></span>k_work_poll_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void k_work_poll_init </td>
          <td>(</td>
          <td class="paramtype">struct k_work_poll *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__workqueue__apis.html#ga5add9ef0dce306a08413c4140fc0bdda">k_work_handler_t</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Initialize a triggered work item. </p>
<p >This routine initializes a workqueue triggered work item, prior to its first use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">work</td><td>Address of triggered work item. </td></tr>
    <tr><td class="paramname">handler</td><td>Function to invoke each time work item is processed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad9f222e46d72c4f98739395a0c8bb4ea" name="gad9f222e46d72c4f98739395a0c8bb4ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9f222e46d72c4f98739395a0c8bb4ea">&#9670;&nbsp;</a></span>k_work_poll_submit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_work_poll_submit </td>
          <td>(</td>
          <td class="paramtype">struct k_work_poll *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structk__poll__event.html">k_poll_event</a> *&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structk__timeout__t.html">k_timeout_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Submit a triggered work item to the system workqueue. </p>
<p >This routine schedules work item <em>work</em> to be processed by system workqueue when one of the given <em>events</em> is signaled. The routine initiates internal poller for the work item and then returns to the caller. Only when one of the watched events happen the work item is actually submitted to the workqueue and becomes pending.</p>
<p >Submitting a previously submitted triggered work item that is still waiting for the event cancels the existing submission and reschedules it the using the new event list. Note that this behavior is inherently subject to race conditions with the pre-existing triggered work item and work queue, so care must be taken to synchronize such resubmissions externally.</p>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Provided array of events as well as a triggered work item must not be modified until the item has been processed by the workqueue.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">work</td><td>Address of delayed work item. </td></tr>
    <tr><td class="paramname">events</td><td>An array of events which trigger the work. </td></tr>
    <tr><td class="paramname">num_events</td><td>The number of events in the array. </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout after which the work will be scheduled for execution even if not triggered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Work item started watching for events. </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>Work item is being processed or has completed its work. </td></tr>
    <tr><td class="paramname">-EADDRINUSE</td><td>Work item is pending on a different workqueue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0abafd7f851e42fd3572c8438e600a53" name="ga0abafd7f851e42fd3572c8438e600a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0abafd7f851e42fd3572c8438e600a53">&#9670;&nbsp;</a></span>k_work_poll_submit_to_queue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_work_poll_submit_to_queue </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__work__q.html">k_work_q</a> *&#160;</td>
          <td class="paramname"><em>work_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct k_work_poll *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structk__poll__event.html">k_poll_event</a> *&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structk__timeout__t.html">k_timeout_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Submit a triggered work item. </p>
<p >This routine schedules work item <em>work</em> to be processed by workqueue <em>work_q</em> when one of the given <em>events</em> is signaled. The routine initiates internal poller for the work item and then returns to the caller. Only when one of the watched events happen the work item is actually submitted to the workqueue and becomes pending.</p>
<p >Submitting a previously submitted triggered work item that is still waiting for the event cancels the existing submission and reschedules it the using the new event list. Note that this behavior is inherently subject to race conditions with the pre-existing triggered work item and work queue, so care must be taken to synchronize such resubmissions externally.</p>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Provided array of events as well as a triggered work item must be placed in persistent memory (valid until work handler execution or work cancellation) and cannot be modified after submission.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">work_q</td><td>Address of workqueue. </td></tr>
    <tr><td class="paramname">work</td><td>Address of delayed work item. </td></tr>
    <tr><td class="paramname">events</td><td>An array of events which trigger the work. </td></tr>
    <tr><td class="paramname">num_events</td><td>The number of events in the array. </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout after which the work will be scheduled for execution even if not triggered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Work item started watching for events. </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>Work item is being processed or has completed its work. </td></tr>
    <tr><td class="paramname">-EADDRINUSE</td><td>Work item is pending on a different workqueue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad4b913b161ebf5958f7c42ed5e1a6c25" name="gad4b913b161ebf5958f7c42ed5e1a6c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4b913b161ebf5958f7c42ed5e1a6c25">&#9670;&nbsp;</a></span>k_work_q_start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void k_work_q_start </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__work__q.html">k_work_q</a> *&#160;</td>
          <td class="paramname"><em>work_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="arch__interface_8h.html#a3e4bde3075edb41069b258d999333b0e">k_thread_stack_t</a> *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stack_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

</div>
</div>
<a id="ga0fefe3e0225ac99b47b250849f6cd863" name="ga0fefe3e0225ac99b47b250849f6cd863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fefe3e0225ac99b47b250849f6cd863">&#9670;&nbsp;</a></span>k_work_queue_drain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_work_queue_drain </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__work__q.html">k_work_q</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>plug</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Wait until the work queue has drained, optionally plugging it. </p>
<p >This blocks submission to the work queue except when coming from queue thread, and blocks the caller until no more work items are available in the queue.</p>
<p >If <code>plug</code> is true then submission will continue to be blocked after the drain operation completes until <a class="el" href="group__workqueue__apis.html#gaa0463bb79af3ec470f7d3be02052139f" title="Release a work queue to accept new submissions.">k_work_queue_unplug()</a> is invoked.</p>
<p >Note that work items that are delayed are not yet associated with their work queue. They must be cancelled externally if a goal is to ensure the work queue remains empty. The <code>plug</code> feature can be used to prevent delayed items from being submitted after the drain completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>pointer to the queue structure.</td></tr>
    <tr><td class="paramname">plug</td><td>if true the work queue will continue to block new submissions after all items have drained.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>if call had to wait for the drain to complete </td></tr>
    <tr><td class="paramname">0</td><td>if call did not have to wait </td></tr>
    <tr><td class="paramname">negative</td><td>if wait was interrupted or failed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gada77d818ea9e4d07c14a960872ed5492" name="gada77d818ea9e4d07c14a960872ed5492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada77d818ea9e4d07c14a960872ed5492">&#9670;&nbsp;</a></span>k_work_queue_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void k_work_queue_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__work__q.html">k_work_q</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Initialize a work queue structure. </p>
<p >This must be invoked before starting a work queue structure for the first time. It need not be invoked again on the same work queue structure.</p>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>the queue structure to be initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadfc56554f9bfe7b52309d79660188593" name="gadfc56554f9bfe7b52309d79660188593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfc56554f9bfe7b52309d79660188593">&#9670;&nbsp;</a></span>k_work_queue_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void k_work_queue_start </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__work__q.html">k_work_q</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="arch__interface_8h.html#a3e4bde3075edb41069b258d999333b0e">k_thread_stack_t</a> *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stack_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structk__work__queue__config.html">k_work_queue_config</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Initialize a work queue. </p>
<p >This configures the work queue thread and starts it running. The function should not be re-invoked on a queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>pointer to the queue structure. It must be initialized in zeroed/bss memory or with <a class="el" href="group__workqueue__apis.html#gada77d818ea9e4d07c14a960872ed5492">k_work_queue_init</a> before use.</td></tr>
    <tr><td class="paramname">stack</td><td>pointer to the work thread stack area.</td></tr>
    <tr><td class="paramname">stack_size</td><td>size of the the work thread stack area, in bytes.</td></tr>
    <tr><td class="paramname">prio</td><td>initial thread priority</td></tr>
    <tr><td class="paramname">cfg</td><td>optional additional configuration parameters. Pass <code>NULL</code> if not required, to use the defaults documented in <a class="el" href="structk__work__queue__config.html" title="A structure holding optional configuration items for a work queue.">k_work_queue_config</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0b8b496f7e7bd82d08590a07293e38d7" name="ga0b8b496f7e7bd82d08590a07293e38d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b8b496f7e7bd82d08590a07293e38d7">&#9670;&nbsp;</a></span>k_work_queue_thread_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a> k_work_queue_thread_get </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__work__q.html">k_work_q</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Access the thread that animates a work queue. </p>
<p >This is necessary to grant a work queue thread access to things the work items it will process are expected to use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>pointer to the queue structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the thread associated with the work queue. </dd></dl>

</div>
</div>
<a id="gaa0463bb79af3ec470f7d3be02052139f" name="gaa0463bb79af3ec470f7d3be02052139f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0463bb79af3ec470f7d3be02052139f">&#9670;&nbsp;</a></span>k_work_queue_unplug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_work_queue_unplug </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__work__q.html">k_work_q</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Release a work queue to accept new submissions. </p>
<p >This releases the block on new submissions placed when <a class="el" href="group__workqueue__apis.html#ga0fefe3e0225ac99b47b250849f6cd863" title="Wait until the work queue has drained, optionally plugging it.">k_work_queue_drain()</a> is invoked with the <code>plug</code> option enabled. If this is invoked before the drain completes new items may be submitted as soon as the drain completes.</p>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>pointer to the queue structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if successfully unplugged </td></tr>
    <tr><td class="paramname">-EALREADY</td><td>if the work queue was not plugged. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaacaab408fb7c848d466ad1f069dfa648" name="gaacaab408fb7c848d466ad1f069dfa648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacaab408fb7c848d466ad1f069dfa648">&#9670;&nbsp;</a></span>k_work_reschedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_work_reschedule </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__work__delayable.html">k_work_delayable</a> *&#160;</td>
          <td class="paramname"><em>dwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structk__timeout__t.html">k_timeout_t</a>&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Reschedule a work item to the system work queue after a delay. </p>
<p >This is a thin wrapper around <a class="el" href="group__workqueue__apis.html#gabf5db091eac19b19a4e12c0cb381f0a8" title="Reschedule a work item to a queue after a delay.">k_work_reschedule_for_queue()</a>, with all the API characteristcs of that function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dwork</td><td>pointer to the delayable work item.</td></tr>
    <tr><td class="paramname">delay</td><td>the time to wait before submitting the work item.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>as with <a class="el" href="group__workqueue__apis.html#gabf5db091eac19b19a4e12c0cb381f0a8" title="Reschedule a work item to a queue after a delay.">k_work_reschedule_for_queue()</a>. </dd></dl>

</div>
</div>
<a id="gabf5db091eac19b19a4e12c0cb381f0a8" name="gabf5db091eac19b19a4e12c0cb381f0a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf5db091eac19b19a4e12c0cb381f0a8">&#9670;&nbsp;</a></span>k_work_reschedule_for_queue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_work_reschedule_for_queue </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__work__q.html">k_work_q</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structk__work__delayable.html">k_work_delayable</a> *&#160;</td>
          <td class="paramname"><em>dwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structk__timeout__t.html">k_timeout_t</a>&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Reschedule a work item to a queue after a delay. </p>
<p >Unlike <a class="el" href="group__workqueue__apis.html#ga17f863c9f6ff2fb41dc0f3b7de4fdf23" title="Submit an idle work item to a queue after a delay.">k_work_schedule_for_queue()</a> this function can change the deadline of a scheduled work item, and will schedule a work item that isn't idle (e.g. is submitted or running). This function does not affect ("unsubmit") a work item that has been submitted to a queue.</p>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>the queue on which the work item should be submitted after the delay.</td></tr>
    <tr><td class="paramname">dwork</td><td>pointer to the delayable work item.</td></tr>
    <tr><td class="paramname">delay</td><td>the time to wait before submitting the work item. If <code>K_NO_WAIT</code> this is equivalent to <a class="el" href="group__workqueue__apis.html#ga5353e76f73db070614f50d06d292d05c" title="Submit a work item to a queue.">k_work_submit_to_queue()</a> after canceling any previous scheduled submission.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If delay is <code>K_NO_WAIT</code> ("no delay") the return values are as with <a class="el" href="group__workqueue__apis.html#ga5353e76f73db070614f50d06d292d05c" title="Submit a work item to a queue.">k_work_submit_to_queue()</a>.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if delay is <code>K_NO_WAIT</code> and work was already on a queue </td></tr>
    <tr><td class="paramname">1</td><td>if<ul>
<li>delay is <code>K_NO_WAIT</code> and work was not submitted but has now been queued to <code>queue</code>; or</li>
<li>delay not <code>K_NO_WAIT</code> and work has been scheduled </li>
</ul>
</td></tr>
    <tr><td class="paramname">2</td><td>if delay is <code>K_NO_WAIT</code> and work was running and has been queued to the queue that was running it </td></tr>
    <tr><td class="paramname">-EBUSY</td><td>if <code>delay</code> is <code>K_NO_WAIT</code> and <a class="el" href="group__workqueue__apis.html#ga5353e76f73db070614f50d06d292d05c" title="Submit a work item to a queue.">k_work_submit_to_queue()</a> fails with this code. </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>if <code>delay</code> is <code>K_NO_WAIT</code> and <a class="el" href="group__workqueue__apis.html#ga5353e76f73db070614f50d06d292d05c" title="Submit a work item to a queue.">k_work_submit_to_queue()</a> fails with this code. </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>if <code>delay</code> is <code>K_NO_WAIT</code> and <a class="el" href="group__workqueue__apis.html#ga5353e76f73db070614f50d06d292d05c" title="Submit a work item to a queue.">k_work_submit_to_queue()</a> fails with this code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5c113ea2bc8e8e5cd7a5c8bc5ec595d3" name="ga5c113ea2bc8e8e5cd7a5c8bc5ec595d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c113ea2bc8e8e5cd7a5c8bc5ec595d3">&#9670;&nbsp;</a></span>k_work_schedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_work_schedule </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__work__delayable.html">k_work_delayable</a> *&#160;</td>
          <td class="paramname"><em>dwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structk__timeout__t.html">k_timeout_t</a>&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Submit an idle work item to the system work queue after a delay. </p>
<p >This is a thin wrapper around <a class="el" href="group__workqueue__apis.html#ga17f863c9f6ff2fb41dc0f3b7de4fdf23" title="Submit an idle work item to a queue after a delay.">k_work_schedule_for_queue()</a>, with all the API characteristcs of that function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dwork</td><td>pointer to the delayable work item.</td></tr>
    <tr><td class="paramname">delay</td><td>the time to wait before submitting the work item. If <code>K_NO_WAIT</code> this is equivalent to <a class="el" href="group__workqueue__apis.html#ga5353e76f73db070614f50d06d292d05c" title="Submit a work item to a queue.">k_work_submit_to_queue()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>as with <a class="el" href="group__workqueue__apis.html#ga17f863c9f6ff2fb41dc0f3b7de4fdf23" title="Submit an idle work item to a queue after a delay.">k_work_schedule_for_queue()</a>. </dd></dl>

</div>
</div>
<a id="ga17f863c9f6ff2fb41dc0f3b7de4fdf23" name="ga17f863c9f6ff2fb41dc0f3b7de4fdf23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17f863c9f6ff2fb41dc0f3b7de4fdf23">&#9670;&nbsp;</a></span>k_work_schedule_for_queue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_work_schedule_for_queue </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__work__q.html">k_work_q</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structk__work__delayable.html">k_work_delayable</a> *&#160;</td>
          <td class="paramname"><em>dwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structk__timeout__t.html">k_timeout_t</a>&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Submit an idle work item to a queue after a delay. </p>
<p >Unlike <a class="el" href="group__workqueue__apis.html#gabf5db091eac19b19a4e12c0cb381f0a8" title="Reschedule a work item to a queue after a delay.">k_work_reschedule_for_queue()</a> this is a no-op if the work item is already scheduled or submitted, even if <code>delay</code> is <code>K_NO_WAIT</code>.</p>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>the queue on which the work item should be submitted after the delay.</td></tr>
    <tr><td class="paramname">dwork</td><td>pointer to the delayable work item.</td></tr>
    <tr><td class="paramname">delay</td><td>the time to wait before submitting the work item. If <code>K_NO_WAIT</code> and the work is not pending this is equivalent to <a class="el" href="group__workqueue__apis.html#ga5353e76f73db070614f50d06d292d05c" title="Submit a work item to a queue.">k_work_submit_to_queue()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if work was already scheduled or submitted. </td></tr>
    <tr><td class="paramname">1</td><td>if work has been scheduled. </td></tr>
    <tr><td class="paramname">-EBUSY</td><td>if <code>delay</code> is <code>K_NO_WAIT</code> and <a class="el" href="group__workqueue__apis.html#ga5353e76f73db070614f50d06d292d05c" title="Submit a work item to a queue.">k_work_submit_to_queue()</a> fails with this code. </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>if <code>delay</code> is <code>K_NO_WAIT</code> and <a class="el" href="group__workqueue__apis.html#ga5353e76f73db070614f50d06d292d05c" title="Submit a work item to a queue.">k_work_submit_to_queue()</a> fails with this code. </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>if <code>delay</code> is <code>K_NO_WAIT</code> and <a class="el" href="group__workqueue__apis.html#ga5353e76f73db070614f50d06d292d05c" title="Submit a work item to a queue.">k_work_submit_to_queue()</a> fails with this code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gace61b59575093d7442f39ccb7be686d7" name="gace61b59575093d7442f39ccb7be686d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace61b59575093d7442f39ccb7be686d7">&#9670;&nbsp;</a></span>k_work_submit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_work_submit </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__work.html">k_work</a> *&#160;</td>
          <td class="paramname"><em>work</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Submit a work item to the system queue. </p>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">work</td><td>pointer to the work item.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>as with <a class="el" href="group__workqueue__apis.html#ga5353e76f73db070614f50d06d292d05c" title="Submit a work item to a queue.">k_work_submit_to_queue()</a>. </dd></dl>

</div>
</div>
<a id="ga5353e76f73db070614f50d06d292d05c" name="ga5353e76f73db070614f50d06d292d05c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5353e76f73db070614f50d06d292d05c">&#9670;&nbsp;</a></span>k_work_submit_to_queue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_work_submit_to_queue </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__work__q.html">k_work_q</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structk__work.html">k_work</a> *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Submit a work item to a queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>pointer to the work queue on which the item should run. If NULL the queue from the most recent submission will be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">work</td><td>pointer to the work item.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if work was already submitted to a queue </td></tr>
    <tr><td class="paramname">1</td><td>if work was not submitted and has been queued to <code>queue</code> </td></tr>
    <tr><td class="paramname">2</td><td>if work was running and has been queued to the queue that was running it </td></tr>
    <tr><td class="paramname">-EBUSY</td><td><ul>
<li>if work submission was rejected because the work item is cancelling; or</li>
<li><code>queue</code> is draining; or</li>
<li><code>queue</code> is plugged. </li>
</ul>
</td></tr>
    <tr><td class="paramname">-EINVAL</td><td>if <code>queue</code> is null and the work item has never been run. </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>if <code>queue</code> has not been started. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9de9c7a7f13cc6b325e5453e34afe62d" name="ga9de9c7a7f13cc6b325e5453e34afe62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9de9c7a7f13cc6b325e5453e34afe62d">&#9670;&nbsp;</a></span>k_work_user_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void k_work_user_init </td>
          <td>(</td>
          <td class="paramtype">struct k_work_user *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__workqueue__apis.html#gafdb3f5f2225b3d5d1fe682cb97f3b328">k_work_user_handler_t</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Initialize a userspace work item. </p>
<p >This routine initializes a user workqueue work item, prior to its first use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">work</td><td>Address of work item. </td></tr>
    <tr><td class="paramname">handler</td><td>Function to invoke each time work item is processed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga58d05d4127e4cd51104a1f1a87f626cd" name="ga58d05d4127e4cd51104a1f1a87f626cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58d05d4127e4cd51104a1f1a87f626cd">&#9670;&nbsp;</a></span>k_work_user_is_pending()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> k_work_user_is_pending </td>
          <td>(</td>
          <td class="paramtype">struct k_work_user *&#160;</td>
          <td class="paramname"><em>work</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Check if a userspace work item is pending. </p>
<p >This routine indicates if user work item <em>work</em> is pending in a workqueue's queue.</p>
<dl class="section note"><dt>Note</dt><dd>Checking if the work is pending gives no guarantee that the work will still be pending when this information is used. It is up to the caller to make sure that this information is used in a safe manner.</dd></dl>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">work</td><td>Address of work item.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if work item is pending, or false if it is not pending. </dd></dl>

</div>
</div>
<a id="ga3091bc8fab5311252e41634a97a18589" name="ga3091bc8fab5311252e41634a97a18589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3091bc8fab5311252e41634a97a18589">&#9670;&nbsp;</a></span>k_work_user_queue_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void k_work_user_queue_start </td>
          <td>(</td>
          <td class="paramtype">struct k_work_user_q *&#160;</td>
          <td class="paramname"><em>work_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="arch__interface_8h.html#a3e4bde3075edb41069b258d999333b0e">k_thread_stack_t</a> *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stack_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Start a workqueue in user mode. </p>
<p >This works identically to <a class="el" href="group__workqueue__apis.html#gadfc56554f9bfe7b52309d79660188593" title="Initialize a work queue.">k_work_queue_start()</a> except it is callable from user mode, and the worker thread created will run in user mode. The caller must have permissions granted on both the work_q parameter's thread and queue objects, and the same restrictions on priority apply as <a class="el" href="group__thread__apis.html#gad5b0bff3102f1656089f5875d999a367" title="Create a thread.">k_thread_create()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">work_q</td><td>Address of workqueue. </td></tr>
    <tr><td class="paramname">stack</td><td>Pointer to work queue thread's stack space, as defined by <a class="el" href="group__thread__stack__api.html#gac5368ce24fdeab3863b5c8dee2ebd955" title="Declare a toplevel thread stack memory region.">K_THREAD_STACK_DEFINE()</a> </td></tr>
    <tr><td class="paramname">stack_size</td><td>Size of the work queue thread's stack (in bytes), which should either be the same constant passed to <a class="el" href="group__thread__stack__api.html#gac5368ce24fdeab3863b5c8dee2ebd955" title="Declare a toplevel thread stack memory region.">K_THREAD_STACK_DEFINE()</a> or the value of <a class="el" href="group__thread__stack__api.html#ga775f8e6b4144cfdd24f3261b6db64150" title="Return the size in bytes of a stack memory region.">K_THREAD_STACK_SIZEOF()</a>. </td></tr>
    <tr><td class="paramname">prio</td><td>Priority of the work queue's thread. </td></tr>
    <tr><td class="paramname">name</td><td>optional thread name. If not null a copy is made into the thread's name buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga50ae1f6f74c0bc0a41dbbf789fff8856" name="ga50ae1f6f74c0bc0a41dbbf789fff8856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50ae1f6f74c0bc0a41dbbf789fff8856">&#9670;&nbsp;</a></span>k_work_user_submit_to_queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int k_work_user_submit_to_queue </td>
          <td>(</td>
          <td class="paramtype">struct k_work_user_q *&#160;</td>
          <td class="paramname"><em>work_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct k_work_user *&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Submit a work item to a user mode workqueue. </p>
<p >Submits a work item to a workqueue that runs in user mode. A temporary memory allocation is made from the caller's resource pool which is freed once the worker thread consumes the <a class="el" href="structk__work.html" title="A structure used to submit work.">k_work</a> item. The workqueue thread must have memory access to the <a class="el" href="structk__work.html" title="A structure used to submit work.">k_work</a> item being submitted. The caller must have permission granted on the work_q parameter's queue object.</p>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">work_q</td><td>Address of workqueue. </td></tr>
    <tr><td class="paramname">work</td><td>Address of work item.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-EBUSY</td><td>if the work item was already in some workqueue </td></tr>
    <tr><td class="paramname">-ENOMEM</td><td>if no memory for thread resource pool allocation </td></tr>
    <tr><td class="paramname">0</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Feb 21 2022 04:59:42 for Zephyr API Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
<script type="text/javascript">
  $(function() {
    toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
    toggleButton.title = "Toggle Light/Dark Mode"
    $(document).ready(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
    // every resize will remove the button, which is why it has to be added again:
    $(window).resize(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
  })
</script>
</body>
</html>
