<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zephyr API Documentation: MBOX Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-zephyr.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-zephyr.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Zephyr API Documentation
   &#160;<span id="projectnumber">3.0.99</span>
   </div>
   <div id="projectbrief">A Scalable Open Source RTOS</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__mbox__interface.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">MBOX Interface<div class="ingroups"><a class="el" href="group__io__interfaces.html">Device Driver APIs</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>MBOX Interface.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmbox__msg.html">mbox_msg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Message struct (to hold data and its size).  <a href="structmbox__msg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmbox__channel.html">mbox_channel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a type to hold an MBOX channel.  <a href="structmbox__channel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmbox__driver__api.html">mbox_driver_api</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga9e02e3a523a63ff564ce2bb42c03aa1f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__interface.html#ga9e02e3a523a63ff564ce2bb42c03aa1f">MBOX_DT_CHANNEL_GET</a>(node_id,  name)</td></tr>
<tr class="memdesc:ga9e02e3a523a63ff564ce2bb42c03aa1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure initializer for <a class="el" href="structmbox__channel.html" title="Provides a type to hold an MBOX channel.">mbox_channel</a> from devicetree.  <a href="group__mbox__interface.html#ga9e02e3a523a63ff564ce2bb42c03aa1f">More...</a><br /></td></tr>
<tr class="separator:ga9e02e3a523a63ff564ce2bb42c03aa1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac232c8a5efbfc04dc35e7b09f4522dfc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__interface.html#gac232c8a5efbfc04dc35e7b09f4522dfc">MBOX_DT_CTLR_BY_NAME</a>(node_id,  name)&#160;&#160;&#160;	<a class="el" href="group__devicetree-generic-prop.html#ga65c90d2d96255b8569c5b869b637c2fd">DT_PHANDLE_BY_NAME</a>(node_id, mboxes, name)</td></tr>
<tr class="memdesc:gac232c8a5efbfc04dc35e7b09f4522dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the node identifier for the MBOX controller from a mboxes property by name.  <a href="group__mbox__interface.html#gac232c8a5efbfc04dc35e7b09f4522dfc">More...</a><br /></td></tr>
<tr class="separator:gac232c8a5efbfc04dc35e7b09f4522dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga509da4cf8e02135a49a8369af1a65d79"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__interface.html#ga509da4cf8e02135a49a8369af1a65d79">MBOX_DT_CHANNEL_ID_BY_NAME</a>(node_id,  name)&#160;&#160;&#160;	<a class="el" href="group__devicetree-generic-prop.html#ga79cda6ca70cc1e27b034ad096d4f4401">DT_PHA_BY_NAME_OR</a>(node_id, mboxes, name, channel, 0)</td></tr>
<tr class="memdesc:ga509da4cf8e02135a49a8369af1a65d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a MBOX channel value by name.  <a href="group__mbox__interface.html#ga509da4cf8e02135a49a8369af1a65d79">More...</a><br /></td></tr>
<tr class="separator:ga509da4cf8e02135a49a8369af1a65d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga4cb393b04d8c3ee01f795bc98ddde2ae"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__interface.html#ga4cb393b04d8c3ee01f795bc98ddde2ae">mbox_callback_t</a>) (const struct <a class="el" href="structdevice.html">device</a> *dev, <a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> channel, void *<a class="el" href="timer_2timer__api_2src_2main_8c.html#a862de962130decf51321624c10294338">user_data</a>, struct <a class="el" href="structmbox__msg.html">mbox_msg</a> *<a class="el" href="test__stack__fail_8c.html#a4bb6fa6c719fd9021449009ab8befc04">data</a>)</td></tr>
<tr class="memdesc:ga4cb393b04d8c3ee01f795bc98ddde2ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback API for incoming MBOX messages.  <a href="group__mbox__interface.html#ga4cb393b04d8c3ee01f795bc98ddde2ae">More...</a><br /></td></tr>
<tr class="separator:ga4cb393b04d8c3ee01f795bc98ddde2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a79bcdd1ed7612de9fbc72c5af35e3e"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__interface.html#ga1a79bcdd1ed7612de9fbc72c5af35e3e">mbox_send_t</a>) (const struct <a class="el" href="structdevice.html">device</a> *dev, <a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> channel, const struct <a class="el" href="structmbox__msg.html">mbox_msg</a> *<a class="el" href="timer_2cycle64_2src_2main_8c.html#aa39a15fe6277f55e2fda62d3a6bf49da">msg</a>)</td></tr>
<tr class="memdesc:ga1a79bcdd1ed7612de9fbc72c5af35e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback API to send MBOX messages.  <a href="group__mbox__interface.html#ga1a79bcdd1ed7612de9fbc72c5af35e3e">More...</a><br /></td></tr>
<tr class="separator:ga1a79bcdd1ed7612de9fbc72c5af35e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c5390b649b1a510672c8c109f0f363c"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__interface.html#ga6c5390b649b1a510672c8c109f0f363c">mbox_mtu_get_t</a>) (const struct <a class="el" href="structdevice.html">device</a> *dev)</td></tr>
<tr class="memdesc:ga6c5390b649b1a510672c8c109f0f363c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback API to get maximum data size.  <a href="group__mbox__interface.html#ga6c5390b649b1a510672c8c109f0f363c">More...</a><br /></td></tr>
<tr class="separator:ga6c5390b649b1a510672c8c109f0f363c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14a2af82968f9185f13d39bd709abcbb"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__interface.html#ga14a2af82968f9185f13d39bd709abcbb">mbox_register_callback_t</a>) (const struct <a class="el" href="structdevice.html">device</a> *dev, <a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> channel, <a class="el" href="group__mbox__interface.html#ga4cb393b04d8c3ee01f795bc98ddde2ae">mbox_callback_t</a> cb, void *<a class="el" href="timer_2timer__api_2src_2main_8c.html#a862de962130decf51321624c10294338">user_data</a>)</td></tr>
<tr class="memdesc:ga14a2af82968f9185f13d39bd709abcbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback API upon registration.  <a href="group__mbox__interface.html#ga14a2af82968f9185f13d39bd709abcbb">More...</a><br /></td></tr>
<tr class="separator:ga14a2af82968f9185f13d39bd709abcbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85d77860581e68d036cccaf17981b1c9"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__interface.html#ga85d77860581e68d036cccaf17981b1c9">mbox_set_enabled_t</a>) (const struct <a class="el" href="structdevice.html">device</a> *dev, <a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> channel, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> enable)</td></tr>
<tr class="memdesc:ga85d77860581e68d036cccaf17981b1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback API upon enablement of interrupts.  <a href="group__mbox__interface.html#ga85d77860581e68d036cccaf17981b1c9">More...</a><br /></td></tr>
<tr class="separator:ga85d77860581e68d036cccaf17981b1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2ba0939cd872198dd8ff4fd348f195f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__interface.html#gaa2ba0939cd872198dd8ff4fd348f195f">mbox_max_channels_get_t</a>) (const struct <a class="el" href="structdevice.html">device</a> *dev)</td></tr>
<tr class="memdesc:gaa2ba0939cd872198dd8ff4fd348f195f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback API to get maximum number of channels.  <a href="group__mbox__interface.html#gaa2ba0939cd872198dd8ff4fd348f195f">More...</a><br /></td></tr>
<tr class="separator:gaa2ba0939cd872198dd8ff4fd348f195f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga70253c432c8064a2760731f1d237f2b7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__interface.html#ga70253c432c8064a2760731f1d237f2b7">mbox_init_channel</a> (struct <a class="el" href="structmbox__channel.html">mbox_channel</a> *channel, const struct <a class="el" href="structdevice.html">device</a> *dev, <a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> ch_id)</td></tr>
<tr class="memdesc:ga70253c432c8064a2760731f1d237f2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a channel struct.  <a href="group__mbox__interface.html#ga70253c432c8064a2760731f1d237f2b7">More...</a><br /></td></tr>
<tr class="separator:ga70253c432c8064a2760731f1d237f2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18828e5c28201ad838ed9ba7c0afabfe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__interface.html#ga18828e5c28201ad838ed9ba7c0afabfe">mbox_send</a> (const struct <a class="el" href="structmbox__channel.html">mbox_channel</a> *channel, const struct <a class="el" href="structmbox__msg.html">mbox_msg</a> *<a class="el" href="timer_2cycle64_2src_2main_8c.html#aa39a15fe6277f55e2fda62d3a6bf49da">msg</a>)</td></tr>
<tr class="memdesc:ga18828e5c28201ad838ed9ba7c0afabfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to send a message over the MBOX device.  <a href="group__mbox__interface.html#ga18828e5c28201ad838ed9ba7c0afabfe">More...</a><br /></td></tr>
<tr class="separator:ga18828e5c28201ad838ed9ba7c0afabfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad48e48c984e70348336a896bb2835c77"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__interface.html#gad48e48c984e70348336a896bb2835c77">mbox_register_callback</a> (const struct <a class="el" href="structmbox__channel.html">mbox_channel</a> *channel, <a class="el" href="group__mbox__interface.html#ga4cb393b04d8c3ee01f795bc98ddde2ae">mbox_callback_t</a> cb, void *<a class="el" href="timer_2timer__api_2src_2main_8c.html#a862de962130decf51321624c10294338">user_data</a>)</td></tr>
<tr class="memdesc:gad48e48c984e70348336a896bb2835c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a callback function on a channel for incoming messages.  <a href="group__mbox__interface.html#gad48e48c984e70348336a896bb2835c77">More...</a><br /></td></tr>
<tr class="separator:gad48e48c984e70348336a896bb2835c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82d9def1b5c31c574d2114abcce2eb1f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__interface.html#ga82d9def1b5c31c574d2114abcce2eb1f">mbox_mtu_get</a> (const struct <a class="el" href="structdevice.html">device</a> *dev)</td></tr>
<tr class="memdesc:ga82d9def1b5c31c574d2114abcce2eb1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum number of bytes possible in an outbound message.  <a href="group__mbox__interface.html#ga82d9def1b5c31c574d2114abcce2eb1f">More...</a><br /></td></tr>
<tr class="separator:ga82d9def1b5c31c574d2114abcce2eb1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga563c6c0e2199b0608b2cd0606c46fc81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__interface.html#ga563c6c0e2199b0608b2cd0606c46fc81">mbox_set_enabled</a> (const struct <a class="el" href="structmbox__channel.html">mbox_channel</a> *channel, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> enable)</td></tr>
<tr class="memdesc:ga563c6c0e2199b0608b2cd0606c46fc81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable (disable) interrupts and callbacks for inbound channels.  <a href="group__mbox__interface.html#ga563c6c0e2199b0608b2cd0606c46fc81">More...</a><br /></td></tr>
<tr class="separator:ga563c6c0e2199b0608b2cd0606c46fc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2f8adbd5e4f7f5972b2d34cfce68bdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__interface.html#gaf2f8adbd5e4f7f5972b2d34cfce68bdb">mbox_max_channels_get</a> (const struct <a class="el" href="structdevice.html">device</a> *dev)</td></tr>
<tr class="memdesc:gaf2f8adbd5e4f7f5972b2d34cfce68bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum number of channels.  <a href="group__mbox__interface.html#gaf2f8adbd5e4f7f5972b2d34cfce68bdb">More...</a><br /></td></tr>
<tr class="separator:gaf2f8adbd5e4f7f5972b2d34cfce68bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >MBOX Interface. </p>
<div class="fragment"><div class="line">                     CPU #1        |</div>
<div class="line">+----------+                       |        +----------+</div>
<div class="line">|          +---TX9----+   +--------+--RX8---+          |</div>
<div class="line">|  dev A   |          |   |        |        |  CPU #2  |</div>
<div class="line">|          &lt;---RX8--+ |   | +------+--TX9---&gt;          |</div>
<div class="line">+----------+        | |   | |      |        +----------+</div>
<div class="line">                 +--+-v---v-+--+   |</div>
<div class="line">                 |             |   |</div>
<div class="line">                 |   MBOX dev  |   |</div>
<div class="line">                 |             |   |</div>
<div class="line">                 +--+-^---^--+-+   |</div>
<div class="line">+----------+        | |   |  |     |        +----------+</div>
<div class="line">|          &lt;---RX2--+ |   |  +-----+--TX3---&gt;          |</div>
<div class="line">|  dev B   |          |   |        |        |  CPU #3  |</div>
<div class="line">|          +---TX3----+   +--------+--RX2---+          |</div>
<div class="line">+----------+                       |        +----------+</div>
<div class="line">                                   |</div>
</div><!-- fragment --><p >An MBOX device is a peripheral capable of passing signals (and data depending on the peripheral) between CPUs and clusters in the system. Each MBOX instance is providing one or more channels, each one targeting one other CPU cluster (multiple channels can target the same cluster).</p>
<p >For example in the plot the device 'dev A' is using the TX channel 9 to signal (or send data to) the CPU #2 and it's expecting data or signals on the RX channel 8. Thus it can send the message through the channel 9, and it can register a callback on the channel 8 of the MBOX device.</p>
<p >This API supports two modes: signalling mode and data transfer mode.</p>
<p >In signalling mode:</p><ul>
<li><a class="el" href="group__mbox__interface.html#ga82d9def1b5c31c574d2114abcce2eb1f" title="Return the maximum number of bytes possible in an outbound message.">mbox_mtu_get()</a> must return 0</li>
<li><a class="el" href="group__mbox__interface.html#ga18828e5c28201ad838ed9ba7c0afabfe" title="Try to send a message over the MBOX device.">mbox_send()</a> must have (msg == NULL)</li>
<li>the callback must be called with (data == NULL)</li>
</ul>
<p >In data transfer mode:</p><ul>
<li><a class="el" href="group__mbox__interface.html#ga82d9def1b5c31c574d2114abcce2eb1f" title="Return the maximum number of bytes possible in an outbound message.">mbox_mtu_get()</a> must return a (value != 0)</li>
<li><a class="el" href="group__mbox__interface.html#ga18828e5c28201ad838ed9ba7c0afabfe" title="Try to send a message over the MBOX device.">mbox_send()</a> must have (msg != NULL)</li>
<li>the callback must be called with (data != NULL)</li>
<li>The msg content must be the same between sender and receiver </li>
</ul>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga9e02e3a523a63ff564ce2bb42c03aa1f" name="ga9e02e3a523a63ff564ce2bb42c03aa1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e02e3a523a63ff564ce2bb42c03aa1f">&#9670;&nbsp;</a></span>MBOX_DT_CHANNEL_GET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MBOX_DT_CHANNEL_GET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="mbox_8h.html">include/drivers/mbox.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">        {                                                                       \</div>
<div class="line">                .dev = <a class="code hl_define" href="group__device__model.html#ga9a65996ce21f43acb7db061e23b48ec7">DEVICE_DT_GET</a>(<a class="code hl_define" href="group__mbox__interface.html#gac232c8a5efbfc04dc35e7b09f4522dfc">MBOX_DT_CTLR_BY_NAME</a>(node_id, name)),      \</div>
<div class="line">                .id = <a class="code hl_define" href="group__mbox__interface.html#ga509da4cf8e02135a49a8369af1a65d79">MBOX_DT_CHANNEL_ID_BY_NAME</a>(node_id, name),                \</div>
<div class="line">        }</div>
<div class="ttc" id="agroup__device__model_html_ga9a65996ce21f43acb7db061e23b48ec7"><div class="ttname"><a href="group__device__model.html#ga9a65996ce21f43acb7db061e23b48ec7">DEVICE_DT_GET</a></div><div class="ttdeci">#define DEVICE_DT_GET(node_id)</div><div class="ttdoc">Get a const struct device* from a devicetree node identifier.</div><div class="ttdef"><b>Definition:</b> device.h:311</div></div>
<div class="ttc" id="agroup__mbox__interface_html_ga509da4cf8e02135a49a8369af1a65d79"><div class="ttname"><a href="group__mbox__interface.html#ga509da4cf8e02135a49a8369af1a65d79">MBOX_DT_CHANNEL_ID_BY_NAME</a></div><div class="ttdeci">#define MBOX_DT_CHANNEL_ID_BY_NAME(node_id, name)</div><div class="ttdoc">Get a MBOX channel value by name.</div><div class="ttdef"><b>Definition:</b> mbox.h:194</div></div>
<div class="ttc" id="agroup__mbox__interface_html_gac232c8a5efbfc04dc35e7b09f4522dfc"><div class="ttname"><a href="group__mbox__interface.html#gac232c8a5efbfc04dc35e7b09f4522dfc">MBOX_DT_CTLR_BY_NAME</a></div><div class="ttdeci">#define MBOX_DT_CTLR_BY_NAME(node_id, name)</div><div class="ttdoc">Get the node identifier for the MBOX controller from a mboxes property by name.</div><div class="ttdef"><b>Definition:</b> mbox.h:157</div></div>
</div><!-- fragment -->
<p>Structure initializer for <a class="el" href="structmbox__channel.html" title="Provides a type to hold an MBOX channel.">mbox_channel</a> from devicetree. </p>
<p >This helper macro expands to a static initializer for a <code><a class="el" href="structmbox__channel.html" title="Provides a type to hold an MBOX channel.">mbox_channel</a></code> by reading the relevant device controller and channel number from the devicetree.</p>
<p >Example devicetree fragment: </p><pre class="fragment">mbox1: mbox-controller@... { ... };

n: node {
        mboxes = &lt;&amp;mbox1 8&gt;,
                 &lt;&amp;mbox1 9&gt;;
        mbox-names = "tx", "rx";
};
</pre><p> Example usage: </p><pre class="fragment">const struct mbox_channel channel = MBOX_DT_CHANNEL_GET(DT_NODELABEL(n), tx);
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_id</td><td>Devicetree node identifier for the MBOX device </td></tr>
    <tr><td class="paramname">name</td><td>lowercase-and-underscores name of the mboxes element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga509da4cf8e02135a49a8369af1a65d79" name="ga509da4cf8e02135a49a8369af1a65d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga509da4cf8e02135a49a8369af1a65d79">&#9670;&nbsp;</a></span>MBOX_DT_CHANNEL_ID_BY_NAME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MBOX_DT_CHANNEL_ID_BY_NAME</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;	<a class="el" href="group__devicetree-generic-prop.html#ga79cda6ca70cc1e27b034ad096d4f4401">DT_PHA_BY_NAME_OR</a>(node_id, mboxes, name, channel, 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="mbox_8h.html">include/drivers/mbox.h</a>&gt;</code></p>

<p>Get a MBOX channel value by name. </p>
<p >Example devicetree fragment: </p><pre class="fragment">mbox1: mbox@... {
        #mbox-cells = &lt;1&gt;;
};

n: node {
    mboxes = &lt;&amp;mbox1 1&gt;,
             &lt;&amp;mbox1 6&gt;;
    mbox-names = "tx", "rx";
};
</pre><p> Bindings fragment for the mbox compatible: </p><pre class="fragment">mbox-cells:
  - channel
</pre><p> Example usage: </p><pre class="fragment">MBOX_DT_CHANNEL_ID_BY_NAME(DT_NODELABEL(n), tx) // 1
MBOX_DT_CHANNEL_ID_BY_NAME(DT_NODELABEL(n), rx) // 6
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_id</td><td>node identifier for a node with a mboxes property </td></tr>
    <tr><td class="paramname">name</td><td>lowercase-and-underscores name of a mboxes element as defined by the node's mbox-names property</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the channel value in the specifier at the named element or 0 if no channels are supported</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__devicetree-generic-prop.html#ga79cda6ca70cc1e27b034ad096d4f4401" title="Like DT_PHA_BY_NAME(), but with a fallback to default_value.">DT_PHA_BY_NAME_OR()</a> </dd></dl>

</div>
</div>
<a id="gac232c8a5efbfc04dc35e7b09f4522dfc" name="gac232c8a5efbfc04dc35e7b09f4522dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac232c8a5efbfc04dc35e7b09f4522dfc">&#9670;&nbsp;</a></span>MBOX_DT_CTLR_BY_NAME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MBOX_DT_CTLR_BY_NAME</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;	<a class="el" href="group__devicetree-generic-prop.html#ga65c90d2d96255b8569c5b869b637c2fd">DT_PHANDLE_BY_NAME</a>(node_id, mboxes, name)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="mbox_8h.html">include/drivers/mbox.h</a>&gt;</code></p>

<p>Get the node identifier for the MBOX controller from a mboxes property by name. </p>
<p >Example devicetree fragment: </p><pre class="fragment">mbox1: mbox-controller@... { ... };

n: node {
        mboxes = &lt;&amp;mbox1 8&gt;,
                 &lt;&amp;mbox1 9&gt;;
        mbox-names = "tx", "rx";
};
</pre><p> Example usage: </p><pre class="fragment">MBOX_DT_CTLR_BY_NAME(DT_NODELABEL(n), tx) // DT_NODELABEL(mbox1)
MBOX_DT_CTLR_BY_NAME(DT_NODELABEL(n), rx) // DT_NODELABEL(mbox1)
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_id</td><td>node identifier for a node with a mboxes property </td></tr>
    <tr><td class="paramname">name</td><td>lowercase-and-underscores name of a mboxes element as defined by the node's mbox-names property</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the node identifier for the MBOX controller in the named element</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__devicetree-generic-prop.html#ga65c90d2d96255b8569c5b869b637c2fd" title="Get a phandle&#39;s node identifier from a phandle array by name.">DT_PHANDLE_BY_NAME()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga4cb393b04d8c3ee01f795bc98ddde2ae" name="ga4cb393b04d8c3ee01f795bc98ddde2ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cb393b04d8c3ee01f795bc98ddde2ae">&#9670;&nbsp;</a></span>mbox_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mbox_callback_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="mbox_8h.html">include/drivers/mbox.h</a>&gt;</code></p>

<p>Callback API for incoming MBOX messages. </p>
<p >These callbacks execute in interrupt context. Therefore, use only interrupt-safe APIS. Registration of callbacks is done via <em><a class="el" href="group__mbox__interface.html#gad48e48c984e70348336a896bb2835c77" title="Register a callback function on a channel for incoming messages.">mbox_register_callback()</a></em> </p>
<p >The data parameter must be NULL in signalling mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Driver instance </td></tr>
    <tr><td class="paramname">channel</td><td>Channel ID </td></tr>
    <tr><td class="paramname">user_data</td><td>Pointer to some private data provided at registration time </td></tr>
    <tr><td class="paramname">data</td><td>Message struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa2ba0939cd872198dd8ff4fd348f195f" name="gaa2ba0939cd872198dd8ff4fd348f195f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2ba0939cd872198dd8ff4fd348f195f">&#9670;&nbsp;</a></span>mbox_max_channels_get_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mbox_max_channels_get_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="mbox_8h.html">include/drivers/mbox.h</a>&gt;</code></p>

<p>Callback API to get maximum number of channels. </p>
<p >See <em><a class="el" href="group__mbox__interface.html#gaf2f8adbd5e4f7f5972b2d34cfce68bdb" title="Return the maximum number of channels.">mbox_max_channels_get()</a></em> for argument definitions. </p>

</div>
</div>
<a id="ga6c5390b649b1a510672c8c109f0f363c" name="ga6c5390b649b1a510672c8c109f0f363c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c5390b649b1a510672c8c109f0f363c">&#9670;&nbsp;</a></span>mbox_mtu_get_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mbox_mtu_get_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="mbox_8h.html">include/drivers/mbox.h</a>&gt;</code></p>

<p>Callback API to get maximum data size. </p>
<p >See <em><a class="el" href="group__mbox__interface.html#ga82d9def1b5c31c574d2114abcce2eb1f" title="Return the maximum number of bytes possible in an outbound message.">mbox_mtu_get()</a></em> for argument definitions. </p>

</div>
</div>
<a id="ga14a2af82968f9185f13d39bd709abcbb" name="ga14a2af82968f9185f13d39bd709abcbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14a2af82968f9185f13d39bd709abcbb">&#9670;&nbsp;</a></span>mbox_register_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mbox_register_callback_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="mbox_8h.html">include/drivers/mbox.h</a>&gt;</code></p>

<p>Callback API upon registration. </p>
<p >See <em><a class="el" href="group__mbox__interface.html#gad48e48c984e70348336a896bb2835c77" title="Register a callback function on a channel for incoming messages.">mbox_register_callback()</a></em> for function description</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Driver instance </td></tr>
    <tr><td class="paramname">channel</td><td>Channel ID </td></tr>
    <tr><td class="paramname">cb</td><td>Callback function to execute on incoming message interrupts. </td></tr>
    <tr><td class="paramname">user_data</td><td>Application-specific data pointer which will be passed to the callback function when executed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See return values for <em><a class="el" href="group__mbox__interface.html#gad48e48c984e70348336a896bb2835c77" title="Register a callback function on a channel for incoming messages.">mbox_register_callback()</a></em> </dd></dl>

</div>
</div>
<a id="ga1a79bcdd1ed7612de9fbc72c5af35e3e" name="ga1a79bcdd1ed7612de9fbc72c5af35e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a79bcdd1ed7612de9fbc72c5af35e3e">&#9670;&nbsp;</a></span>mbox_send_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mbox_send_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="mbox_8h.html">include/drivers/mbox.h</a>&gt;</code></p>

<p>Callback API to send MBOX messages. </p>
<p >See <em><a class="el" href="group__mbox__interface.html#ga18828e5c28201ad838ed9ba7c0afabfe" title="Try to send a message over the MBOX device.">mbox_send()</a></em> for function description</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Driver instance </td></tr>
    <tr><td class="paramname">channel</td><td>Channel ID </td></tr>
    <tr><td class="paramname">msg</td><td>Message struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See return values for <em><a class="el" href="group__mbox__interface.html#ga18828e5c28201ad838ed9ba7c0afabfe" title="Try to send a message over the MBOX device.">mbox_send()</a></em> </dd></dl>

</div>
</div>
<a id="ga85d77860581e68d036cccaf17981b1c9" name="ga85d77860581e68d036cccaf17981b1c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85d77860581e68d036cccaf17981b1c9">&#9670;&nbsp;</a></span>mbox_set_enabled_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mbox_set_enabled_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="mbox_8h.html">include/drivers/mbox.h</a>&gt;</code></p>

<p>Callback API upon enablement of interrupts. </p>
<p >See <em><a class="el" href="group__mbox__interface.html#ga563c6c0e2199b0608b2cd0606c46fc81" title="Enable (disable) interrupts and callbacks for inbound channels.">mbox_set_enabled()</a></em> for function description</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Driver instance </td></tr>
    <tr><td class="paramname">channel</td><td>Channel ID </td></tr>
    <tr><td class="paramname">enable</td><td>Set to 0 to disable and to nonzero to enable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See return values for <em><a class="el" href="group__mbox__interface.html#ga563c6c0e2199b0608b2cd0606c46fc81" title="Enable (disable) interrupts and callbacks for inbound channels.">mbox_set_enabled()</a></em> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga70253c432c8064a2760731f1d237f2b7" name="ga70253c432c8064a2760731f1d237f2b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70253c432c8064a2760731f1d237f2b7">&#9670;&nbsp;</a></span>mbox_init_channel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mbox_init_channel </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structmbox__channel.html">mbox_channel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a>&#160;</td>
          <td class="paramname"><em>ch_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="mbox_8h.html">include/drivers/mbox.h</a>&gt;</code></p>

<p>Initialize a channel struct. </p>
<p >Initialize an <code><a class="el" href="structmbox__channel.html" title="Provides a type to hold an MBOX channel.">mbox_channel</a></code> passed by the user with a provided MBOX device and channel ID. This function is needed when the information about the device and the channel ID is not in the DT. In the DT case <a class="el" href="group__mbox__interface.html#ga9e02e3a523a63ff564ce2bb42c03aa1f" title="Structure initializer for mbox_channel from devicetree.">MBOX_DT_CHANNEL_GET()</a> must be used instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to the channel struct </td></tr>
    <tr><td class="paramname">dev</td><td>Driver instance </td></tr>
    <tr><td class="paramname">ch_id</td><td>Channel ID </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf2f8adbd5e4f7f5972b2d34cfce68bdb" name="gaf2f8adbd5e4f7f5972b2d34cfce68bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2f8adbd5e4f7f5972b2d34cfce68bdb">&#9670;&nbsp;</a></span>mbox_max_channels_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> mbox_max_channels_get </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="mbox_8h.html">include/drivers/mbox.h</a>&gt;</code></p>

<p>Return the maximum number of channels. </p>
<p >Return the maximum number of channels supported by the hardware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Driver instance pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum possible number of supported channels on success, negative value on error. </dd></dl>

</div>
</div>
<a id="ga82d9def1b5c31c574d2114abcce2eb1f" name="ga82d9def1b5c31c574d2114abcce2eb1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82d9def1b5c31c574d2114abcce2eb1f">&#9670;&nbsp;</a></span>mbox_mtu_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbox_mtu_get </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="mbox_8h.html">include/drivers/mbox.h</a>&gt;</code></p>

<p>Return the maximum number of bytes possible in an outbound message. </p>
<p >Returns the actual number of bytes that it is possible to send through an outgoing channel.</p>
<p >This number can be 0 when the driver only supports signalling or when on the receiving side the content and size of the message must be retrieved in an indirect way (i.e. probing some other peripheral, reading memory regions, etc...).</p>
<p >If this function returns 0, the msg parameter in <em><a class="el" href="group__mbox__interface.html#ga18828e5c28201ad838ed9ba7c0afabfe" title="Try to send a message over the MBOX device.">mbox_send()</a></em> is expected to be NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Driver instance pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum possible size of a message in bytes, 0 for signalling, negative value on error. </dd></dl>

</div>
</div>
<a id="gad48e48c984e70348336a896bb2835c77" name="gad48e48c984e70348336a896bb2835c77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad48e48c984e70348336a896bb2835c77">&#9670;&nbsp;</a></span>mbox_register_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int mbox_register_callback </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structmbox__channel.html">mbox_channel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mbox__interface.html#ga4cb393b04d8c3ee01f795bc98ddde2ae">mbox_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="mbox_8h.html">include/drivers/mbox.h</a>&gt;</code></p>

<p>Register a callback function on a channel for incoming messages. </p>
<p >This function doesn't assume anything concerning the status of the interrupts. Use <em><a class="el" href="group__mbox__interface.html#ga563c6c0e2199b0608b2cd0606c46fc81" title="Enable (disable) interrupts and callbacks for inbound channels.">mbox_set_enabled()</a></em> to enable or to disable the interrupts if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Channel instance pointer. </td></tr>
    <tr><td class="paramname">cb</td><td>Callback function to execute on incoming message interrupts. </td></tr>
    <tr><td class="paramname">user_data</td><td>Application-specific data pointer which will be passed to the callback function when executed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success, negative value on error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga18828e5c28201ad838ed9ba7c0afabfe" name="ga18828e5c28201ad838ed9ba7c0afabfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18828e5c28201ad838ed9ba7c0afabfe">&#9670;&nbsp;</a></span>mbox_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbox_send </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structmbox__channel.html">mbox_channel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structmbox__msg.html">mbox_msg</a> *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="mbox_8h.html">include/drivers/mbox.h</a>&gt;</code></p>

<p>Try to send a message over the MBOX device. </p>
<p >Send a message over an <code><a class="el" href="structmbox__channel.html" title="Provides a type to hold an MBOX channel.">mbox_channel</a></code>. The msg parameter must be NULL when the driver is used for signalling.</p>
<p >If the msg parameter is not NULL, this data is expected to be delivered on the receiving side using the data parameter of the receiving callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Channel instance pointer </td></tr>
    <tr><td class="paramname">msg</td><td>Pointer to the message struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-EBUSY</td><td>If the remote hasn't yet read the last data sent. </td></tr>
    <tr><td class="paramname">-EMSGSIZE</td><td>If the supplied data size is unsupported by the driver. </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>If there was a bad parameter, such as: too-large channel descriptor or the device isn't an outbound MBOX channel.</td></tr>
    <tr><td class="paramname">0</td><td>On success, negative value on error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga563c6c0e2199b0608b2cd0606c46fc81" name="ga563c6c0e2199b0608b2cd0606c46fc81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga563c6c0e2199b0608b2cd0606c46fc81">&#9670;&nbsp;</a></span>mbox_set_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbox_set_enabled </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structmbox__channel.html">mbox_channel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="mbox_8h.html">include/drivers/mbox.h</a>&gt;</code></p>

<p>Enable (disable) interrupts and callbacks for inbound channels. </p>
<p >Enable interrupt for the channel when the parameter 'enable' is set to true. Disable it otherwise.</p>
<p >Immediately after calling this function with 'enable' set to true, the channel is considered enabled and ready to receive signal and messages (even already pending), so the user must take care of installing a proper callback (if needed) using <em><a class="el" href="group__mbox__interface.html#gad48e48c984e70348336a896bb2835c77" title="Register a callback function on a channel for incoming messages.">mbox_register_callback()</a></em> on the channel before enabling it. For this reason it is recommended that all the channels are disabled at probe time.</p>
<p >Enabling a channel for which there is no installed callback is considered undefined behavior (in general the driver must take care of gracefully handling spurious interrupts with no installed callback).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Channel instance pointer. </td></tr>
    <tr><td class="paramname">enable</td><td>Set to 0 to disable and to nonzero to enable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success. </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>If it isn't an inbound channel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Mar 5 2022 05:00:47 for Zephyr API Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
<script type="text/javascript">
  $(function() {
    toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
    toggleButton.title = "Toggle Light/Dark Mode"
    $(document).ready(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
    // every resize will remove the button, which is why it has to be added again:
    $(window).resize(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
  })
</script>
</body>
</html>
