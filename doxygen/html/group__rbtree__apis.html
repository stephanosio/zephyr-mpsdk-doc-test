<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zephyr API Documentation: Balanced Red/Black Tree</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-zephyr.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-zephyr.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Zephyr API Documentation
   &#160;<span id="projectnumber">3.0.0-rc3</span>
   </div>
   <div id="projectbrief">A Scalable Open Source RTOS</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__rbtree__apis.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Balanced Red/Black Tree</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrbtree.html">rbtree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaa0a518139442a69865881f6b460b03df"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rbtree__apis.html#gaa0a518139442a69865881f6b460b03df">RB_FOR_EACH</a>(tree,  node)</td></tr>
<tr class="memdesc:gaa0a518139442a69865881f6b460b03df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk a tree in-order without recursing.  <a href="group__rbtree__apis.html#gaa0a518139442a69865881f6b460b03df">More...</a><br /></td></tr>
<tr class="separator:gaa0a518139442a69865881f6b460b03df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab03a8af066d5110cda6b7522f342b168"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rbtree__apis.html#gab03a8af066d5110cda6b7522f342b168">RB_FOR_EACH_CONTAINER</a>(tree,  node,  field)</td></tr>
<tr class="memdesc:gab03a8af066d5110cda6b7522f342b168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loop over rbtree with implicit container field logic.  <a href="group__rbtree__apis.html#gab03a8af066d5110cda6b7522f342b168">More...</a><br /></td></tr>
<tr class="separator:gab03a8af066d5110cda6b7522f342b168"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga18188fbcd2ffda5a2bc2697118d56cea"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rbtree__apis.html#ga18188fbcd2ffda5a2bc2697118d56cea">rb_lessthan_t</a>) (struct <a class="el" href="structrbnode.html">rbnode</a> *a, struct <a class="el" href="structrbnode.html">rbnode</a> *b)</td></tr>
<tr class="memdesc:ga18188fbcd2ffda5a2bc2697118d56cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Red/black tree comparison predicate.  <a href="group__rbtree__apis.html#ga18188fbcd2ffda5a2bc2697118d56cea">More...</a><br /></td></tr>
<tr class="separator:ga18188fbcd2ffda5a2bc2697118d56cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27e6996e6ed57aabb2791662960beca0"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rbtree__apis.html#ga27e6996e6ed57aabb2791662960beca0">rb_visit_t</a>) (struct <a class="el" href="structrbnode.html">rbnode</a> *node, void *cookie)</td></tr>
<tr class="separator:ga27e6996e6ed57aabb2791662960beca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6b2c6d796f333fb03e316afc42336ecf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rbtree__apis.html#ga6b2c6d796f333fb03e316afc42336ecf">rb_insert</a> (struct <a class="el" href="structrbtree.html">rbtree</a> *tree, struct <a class="el" href="structrbnode.html">rbnode</a> *node)</td></tr>
<tr class="memdesc:ga6b2c6d796f333fb03e316afc42336ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert node into tree.  <a href="group__rbtree__apis.html#ga6b2c6d796f333fb03e316afc42336ecf">More...</a><br /></td></tr>
<tr class="separator:ga6b2c6d796f333fb03e316afc42336ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8de6504411a0dbd8f4a43e9e18c53919"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rbtree__apis.html#ga8de6504411a0dbd8f4a43e9e18c53919">rb_remove</a> (struct <a class="el" href="structrbtree.html">rbtree</a> *tree, struct <a class="el" href="structrbnode.html">rbnode</a> *node)</td></tr>
<tr class="memdesc:ga8de6504411a0dbd8f4a43e9e18c53919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove node from tree.  <a href="group__rbtree__apis.html#ga8de6504411a0dbd8f4a43e9e18c53919">More...</a><br /></td></tr>
<tr class="separator:ga8de6504411a0dbd8f4a43e9e18c53919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fe1a6028e972155acc0cc72429d8dec"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structrbnode.html">rbnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rbtree__apis.html#ga2fe1a6028e972155acc0cc72429d8dec">rb_get_min</a> (struct <a class="el" href="structrbtree.html">rbtree</a> *tree)</td></tr>
<tr class="memdesc:ga2fe1a6028e972155acc0cc72429d8dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lowest-sorted member of the tree.  <a href="group__rbtree__apis.html#ga2fe1a6028e972155acc0cc72429d8dec">More...</a><br /></td></tr>
<tr class="separator:ga2fe1a6028e972155acc0cc72429d8dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga031fd9abf8ae98fe0c7519465df522f6"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structrbnode.html">rbnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rbtree__apis.html#ga031fd9abf8ae98fe0c7519465df522f6">rb_get_max</a> (struct <a class="el" href="structrbtree.html">rbtree</a> *tree)</td></tr>
<tr class="memdesc:ga031fd9abf8ae98fe0c7519465df522f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the highest-sorted member of the tree.  <a href="group__rbtree__apis.html#ga031fd9abf8ae98fe0c7519465df522f6">More...</a><br /></td></tr>
<tr class="separator:ga031fd9abf8ae98fe0c7519465df522f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga918cb502c4b636f49a73906735612b91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rbtree__apis.html#ga918cb502c4b636f49a73906735612b91">rb_contains</a> (struct <a class="el" href="structrbtree.html">rbtree</a> *tree, struct <a class="el" href="structrbnode.html">rbnode</a> *node)</td></tr>
<tr class="memdesc:ga918cb502c4b636f49a73906735612b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node is part of the tree.  <a href="group__rbtree__apis.html#ga918cb502c4b636f49a73906735612b91">More...</a><br /></td></tr>
<tr class="separator:ga918cb502c4b636f49a73906735612b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79e7c341ee876f1e6f6adaf8b1162995"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rbtree__apis.html#ga79e7c341ee876f1e6f6adaf8b1162995">rb_walk</a> (struct <a class="el" href="structrbtree.html">rbtree</a> *tree, <a class="el" href="group__rbtree__apis.html#ga27e6996e6ed57aabb2791662960beca0">rb_visit_t</a> visit_fn, void *cookie)</td></tr>
<tr class="memdesc:ga79e7c341ee876f1e6f6adaf8b1162995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk/enumerate a rbtree.  <a href="group__rbtree__apis.html#ga79e7c341ee876f1e6f6adaf8b1162995">More...</a><br /></td></tr>
<tr class="separator:ga79e7c341ee876f1e6f6adaf8b1162995"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaa0a518139442a69865881f6b460b03df" name="gaa0a518139442a69865881f6b460b03df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0a518139442a69865881f6b460b03df">&#9670;&nbsp;</a></span>RB_FOR_EACH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RB_FOR_EACH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tree, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rb_8h.html">include/sys/rb.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">struct</span> _rb_foreach __f = _RB_FOREACH_INIT(tree, node);     \</div>
<div class="line">             (node = z_rb_foreach_next(tree, &amp;__f));                    \</div>
<div class="line">             )</div>
</div><!-- fragment -->
<p>Walk a tree in-order without recursing. </p>
<p >While <a class="el" href="group__rbtree__apis.html#ga79e7c341ee876f1e6f6adaf8b1162995">rb_walk()</a> is very simple, recursing on the C stack can be clumsy for some purposes and on some architectures wastes significant memory in stack frames. This macro implements a non-recursive "foreach" loop that can iterate directly on the tree, at a moderate cost in code size.</p>
<p >Note that the resulting loop is not safe against modifications to the tree. Changes to the tree structure during the loop will produce incorrect results, as nodes may be skipped or duplicated. Unlike linked lists, no _SAFE variant exists.</p>
<p >Note also that the macro expands its arguments multiple times, so they should not be expressions with side effects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>A pointer to a struct rbtree to walk </td></tr>
    <tr><td class="paramname">node</td><td>The symbol name of a local struct rbnode* variable to use as the iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab03a8af066d5110cda6b7522f342b168" name="gab03a8af066d5110cda6b7522f342b168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab03a8af066d5110cda6b7522f342b168">&#9670;&nbsp;</a></span>RB_FOR_EACH_CONTAINER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RB_FOR_EACH_CONTAINER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tree, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">field&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rb_8h.html">include/sys/rb.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">struct</span> _rb_foreach __f = _RB_FOREACH_INIT(tree, node);        \</div>
<div class="line">                        ({<span class="keyword">struct </span><a class="code hl_struct" href="structrbnode.html">rbnode</a> *n = z_rb_foreach_next(tree, &amp;__f); \</div>
<div class="line">                         node = n ? <a class="code hl_define" href="group__sys-util.html#gac5bc561d1bfd1bf68877fe577779bd2f">CONTAINER_OF</a>(n, __typeof__(*(node)),   \</div>
<div class="line">                                         field) : NULL; }) != NULL;        \</div>
<div class="line">                         )</div>
<div class="ttc" id="agroup__sys-util_html_gac5bc561d1bfd1bf68877fe577779bd2f"><div class="ttname"><a href="group__sys-util.html#gac5bc561d1bfd1bf68877fe577779bd2f">CONTAINER_OF</a></div><div class="ttdeci">#define CONTAINER_OF(ptr, type, field)</div><div class="ttdoc">Get a pointer to a structure containing the element.</div><div class="ttdef"><b>Definition:</b> util.h:147</div></div>
<div class="ttc" id="astructrbnode_html"><div class="ttname"><a href="structrbnode.html">rbnode</a></div><div class="ttdef"><b>Definition:</b> rb.h:49</div></div>
</div><!-- fragment -->
<p>Loop over rbtree with implicit container field logic. </p>
<p >As for <a class="el" href="group__rbtree__apis.html#gaa0a518139442a69865881f6b460b03df" title="Walk a tree in-order without recursing.">RB_FOR_EACH()</a>, but "node" can have an arbitrary type containing a struct rbnode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>A pointer to a struct rbtree to walk </td></tr>
    <tr><td class="paramname">node</td><td>The symbol name of a local iterator </td></tr>
    <tr><td class="paramname">field</td><td>The field name of a struct rbnode inside node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga18188fbcd2ffda5a2bc2697118d56cea" name="ga18188fbcd2ffda5a2bc2697118d56cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18188fbcd2ffda5a2bc2697118d56cea">&#9670;&nbsp;</a></span>rb_lessthan_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rb_lessthan_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rb_8h.html">include/sys/rb.h</a>&gt;</code></p>

<p>Red/black tree comparison predicate. </p>
<p >Compares the two nodes and returns true if node A is strictly less than B according to the tree's sorting criteria, false otherwise.</p>
<p >Note that during insert, the new node being inserted will always be "A", where "B" is the existing node within the tree against which it is being compared. This trait can be used (with care!) to implement "most/least recently added" semantics between nodes which would otherwise compare as equal. </p>

</div>
</div>
<a id="ga27e6996e6ed57aabb2791662960beca0" name="ga27e6996e6ed57aabb2791662960beca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27e6996e6ed57aabb2791662960beca0">&#9670;&nbsp;</a></span>rb_visit_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* rb_visit_t) (struct <a class="el" href="structrbnode.html">rbnode</a> *node, void *cookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rb_8h.html">include/sys/rb.h</a>&gt;</code></p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga918cb502c4b636f49a73906735612b91" name="ga918cb502c4b636f49a73906735612b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga918cb502c4b636f49a73906735612b91">&#9670;&nbsp;</a></span>rb_contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> rb_contains </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrbtree.html">rbtree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrbnode.html">rbnode</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rb_8h.html">include/sys/rb.h</a>&gt;</code></p>

<p>Returns true if the given node is part of the tree. </p>
<p >Note that this does not internally dereference the node pointer (though the tree's lessthan callback might!), it just tests it for equality with items in the tree. So it's feasible to use this to implement a "set" construct by simply testing the pointer value itself. </p>

</div>
</div>
<a id="ga031fd9abf8ae98fe0c7519465df522f6" name="ga031fd9abf8ae98fe0c7519465df522f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga031fd9abf8ae98fe0c7519465df522f6">&#9670;&nbsp;</a></span>rb_get_max()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structrbnode.html">rbnode</a> * rb_get_max </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrbtree.html">rbtree</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rb_8h.html">include/sys/rb.h</a>&gt;</code></p>

<p>Returns the highest-sorted member of the tree. </p>

</div>
</div>
<a id="ga2fe1a6028e972155acc0cc72429d8dec" name="ga2fe1a6028e972155acc0cc72429d8dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fe1a6028e972155acc0cc72429d8dec">&#9670;&nbsp;</a></span>rb_get_min()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structrbnode.html">rbnode</a> * rb_get_min </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrbtree.html">rbtree</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rb_8h.html">include/sys/rb.h</a>&gt;</code></p>

<p>Returns the lowest-sorted member of the tree. </p>

</div>
</div>
<a id="ga6b2c6d796f333fb03e316afc42336ecf" name="ga6b2c6d796f333fb03e316afc42336ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b2c6d796f333fb03e316afc42336ecf">&#9670;&nbsp;</a></span>rb_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rb_insert </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrbtree.html">rbtree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrbnode.html">rbnode</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rb_8h.html">include/sys/rb.h</a>&gt;</code></p>

<p>Insert node into tree. </p>

</div>
</div>
<a id="ga8de6504411a0dbd8f4a43e9e18c53919" name="ga8de6504411a0dbd8f4a43e9e18c53919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8de6504411a0dbd8f4a43e9e18c53919">&#9670;&nbsp;</a></span>rb_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rb_remove </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrbtree.html">rbtree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrbnode.html">rbnode</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rb_8h.html">include/sys/rb.h</a>&gt;</code></p>

<p>Remove node from tree. </p>

</div>
</div>
<a id="ga79e7c341ee876f1e6f6adaf8b1162995" name="ga79e7c341ee876f1e6f6adaf8b1162995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79e7c341ee876f1e6f6adaf8b1162995">&#9670;&nbsp;</a></span>rb_walk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rb_walk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrbtree.html">rbtree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rbtree__apis.html#ga27e6996e6ed57aabb2791662960beca0">rb_visit_t</a>&#160;</td>
          <td class="paramname"><em>visit_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cookie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rb_8h.html">include/sys/rb.h</a>&gt;</code></p>

<p>Walk/enumerate a rbtree. </p>
<p >Very simple recursive enumeration. Low code size, but requiring a separate function can be clumsy for the user and there is no way to break out of the loop early. See RB_FOR_EACH for an iterative implementation. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Feb 21 2022 04:59:41 for Zephyr API Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
<script type="text/javascript">
  $(function() {
    toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
    toggleButton.title = "Toggle Light/Dark Mode"
    $(document).ready(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
    // every resize will remove the button, which is why it has to be added again:
    $(window).resize(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
  })
</script>
</body>
</html>
