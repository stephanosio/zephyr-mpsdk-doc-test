<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zephyr API Documentation: Heap APIs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-zephyr.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-zephyr.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Zephyr API Documentation
   &#160;<span id="projectnumber">3.0.0-rc3</span>
   </div>
   <div id="projectbrief">A Scalable Open Source RTOS</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__heap__apis.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Heap APIs<div class="ingroups"><a class="el" href="group__kernel__apis.html">Kernel APIs</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structk__heap.html">k_heap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga795d7f1e6d5b7b19a7a50198d7829a0f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__heap__apis.html#ga795d7f1e6d5b7b19a7a50198d7829a0f">K_HEAP_DEFINE</a>(name,  bytes)</td></tr>
<tr class="memdesc:ga795d7f1e6d5b7b19a7a50198d7829a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a static <a class="el" href="structk__heap.html">k_heap</a>.  <a href="group__heap__apis.html#ga795d7f1e6d5b7b19a7a50198d7829a0f">More...</a><br /></td></tr>
<tr class="separator:ga795d7f1e6d5b7b19a7a50198d7829a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga968f4c6a201fdf6862d62dd5d9f8d032"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__heap__apis.html#ga968f4c6a201fdf6862d62dd5d9f8d032">K_HEAP_DEFINE_NOCACHE</a>(name,  bytes)&#160;&#160;&#160;	Z_HEAP_DEFINE_IN_SECT(name, bytes, __nocache)</td></tr>
<tr class="memdesc:ga968f4c6a201fdf6862d62dd5d9f8d032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a static <a class="el" href="structk__heap.html">k_heap</a> in uncached memory.  <a href="group__heap__apis.html#ga968f4c6a201fdf6862d62dd5d9f8d032">More...</a><br /></td></tr>
<tr class="separator:ga968f4c6a201fdf6862d62dd5d9f8d032"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9273e06dc8d6a351499f2f5abfdcb39f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__heap__apis.html#ga9273e06dc8d6a351499f2f5abfdcb39f">k_heap_init</a> (struct <a class="el" href="structk__heap.html">k_heap</a> *h, void *mem, size_t bytes)</td></tr>
<tr class="memdesc:ga9273e06dc8d6a351499f2f5abfdcb39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="structk__heap.html">k_heap</a>.  <a href="group__heap__apis.html#ga9273e06dc8d6a351499f2f5abfdcb39f">More...</a><br /></td></tr>
<tr class="separator:ga9273e06dc8d6a351499f2f5abfdcb39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf77211a72441de389857bc13e10be4e6"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__heap__apis.html#gaf77211a72441de389857bc13e10be4e6">k_heap_aligned_alloc</a> (struct <a class="el" href="structk__heap.html">k_heap</a> *h, size_t align, size_t bytes, <a class="el" href="structk__timeout__t.html">k_timeout_t</a> <a class="el" href="timer_2cycle64_2src_2main_8c.html#a8f4b69a82b00d7baf3f1f7d480bb7fa0">timeout</a>)</td></tr>
<tr class="memdesc:gaf77211a72441de389857bc13e10be4e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate aligned memory from a <a class="el" href="structk__heap.html">k_heap</a>.  <a href="group__heap__apis.html#gaf77211a72441de389857bc13e10be4e6">More...</a><br /></td></tr>
<tr class="separator:gaf77211a72441de389857bc13e10be4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22b83564e50ae6177388dfe63e32a512"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__heap__apis.html#ga22b83564e50ae6177388dfe63e32a512">k_heap_alloc</a> (struct <a class="el" href="structk__heap.html">k_heap</a> *h, size_t bytes, <a class="el" href="structk__timeout__t.html">k_timeout_t</a> <a class="el" href="timer_2cycle64_2src_2main_8c.html#a8f4b69a82b00d7baf3f1f7d480bb7fa0">timeout</a>)</td></tr>
<tr class="memdesc:ga22b83564e50ae6177388dfe63e32a512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory from a <a class="el" href="structk__heap.html">k_heap</a>.  <a href="group__heap__apis.html#ga22b83564e50ae6177388dfe63e32a512">More...</a><br /></td></tr>
<tr class="separator:ga22b83564e50ae6177388dfe63e32a512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cf917a0b3d91a0101192bd4808ada9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__heap__apis.html#ga6cf917a0b3d91a0101192bd4808ada9c">k_heap_free</a> (struct <a class="el" href="structk__heap.html">k_heap</a> *h, void *mem)</td></tr>
<tr class="memdesc:ga6cf917a0b3d91a0101192bd4808ada9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory allocated by <a class="el" href="group__heap__apis.html#ga22b83564e50ae6177388dfe63e32a512" title="Allocate memory from a k_heap.">k_heap_alloc()</a>  <a href="group__heap__apis.html#ga6cf917a0b3d91a0101192bd4808ada9c">More...</a><br /></td></tr>
<tr class="separator:ga6cf917a0b3d91a0101192bd4808ada9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae16d486aa250f9c07fa6a57342bcd3b4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__heap__apis.html#gae16d486aa250f9c07fa6a57342bcd3b4">k_aligned_alloc</a> (size_t align, size_t size)</td></tr>
<tr class="memdesc:gae16d486aa250f9c07fa6a57342bcd3b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory from the heap with a specified alignment.  <a href="group__heap__apis.html#gae16d486aa250f9c07fa6a57342bcd3b4">More...</a><br /></td></tr>
<tr class="separator:gae16d486aa250f9c07fa6a57342bcd3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8edf1e63e5d5dd78d7adcfd787394ee"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__heap__apis.html#gaa8edf1e63e5d5dd78d7adcfd787394ee">k_malloc</a> (size_t size)</td></tr>
<tr class="memdesc:gaa8edf1e63e5d5dd78d7adcfd787394ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory from the heap.  <a href="group__heap__apis.html#gaa8edf1e63e5d5dd78d7adcfd787394ee">More...</a><br /></td></tr>
<tr class="separator:gaa8edf1e63e5d5dd78d7adcfd787394ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79b63cc93b3358cf82d74f40e73b69d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__heap__apis.html#ga79b63cc93b3358cf82d74f40e73b69d5">k_free</a> (void *<a class="el" href="printk_8c.html#add9af9569af79ec26dd741fb226b38ba">ptr</a>)</td></tr>
<tr class="memdesc:ga79b63cc93b3358cf82d74f40e73b69d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory allocated from heap.  <a href="group__heap__apis.html#ga79b63cc93b3358cf82d74f40e73b69d5">More...</a><br /></td></tr>
<tr class="separator:ga79b63cc93b3358cf82d74f40e73b69d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad031d50ed62d08202a5dcf992c20246c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__heap__apis.html#gad031d50ed62d08202a5dcf992c20246c">k_calloc</a> (size_t nmemb, size_t size)</td></tr>
<tr class="memdesc:gad031d50ed62d08202a5dcf992c20246c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory from heap, array style.  <a href="group__heap__apis.html#gad031d50ed62d08202a5dcf992c20246c">More...</a><br /></td></tr>
<tr class="separator:gad031d50ed62d08202a5dcf992c20246c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga795d7f1e6d5b7b19a7a50198d7829a0f" name="ga795d7f1e6d5b7b19a7a50198d7829a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga795d7f1e6d5b7b19a7a50198d7829a0f">&#9670;&nbsp;</a></span>K_HEAP_DEFINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define K_HEAP_DEFINE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bytes&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">        Z_HEAP_DEFINE_IN_SECT(name, bytes,                      \</div>
<div class="line">                              __noinit_named(kheap_buf_##name))</div>
</div><!-- fragment -->
<p>Define a static <a class="el" href="structk__heap.html">k_heap</a>. </p>
<p >This macro defines and initializes a static memory region and <a class="el" href="structk__heap.html">k_heap</a> of the requested size. After kernel start, &amp;name can be used as if <a class="el" href="group__heap__apis.html#ga9273e06dc8d6a351499f2f5abfdcb39f" title="Initialize a k_heap.">k_heap_init()</a> had been called.</p>
<p >Note that this macro enforces a minimum size on the memory region to accommodate metadata requirements. Very small heaps will be padded to fit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Symbol name for the struct <a class="el" href="structk__heap.html">k_heap</a> object </td></tr>
    <tr><td class="paramname">bytes</td><td>Size of memory region, in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga968f4c6a201fdf6862d62dd5d9f8d032" name="ga968f4c6a201fdf6862d62dd5d9f8d032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga968f4c6a201fdf6862d62dd5d9f8d032">&#9670;&nbsp;</a></span>K_HEAP_DEFINE_NOCACHE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define K_HEAP_DEFINE_NOCACHE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bytes&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;	Z_HEAP_DEFINE_IN_SECT(name, bytes, __nocache)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Define a static <a class="el" href="structk__heap.html">k_heap</a> in uncached memory. </p>
<p >This macro defines and initializes a static memory region and <a class="el" href="structk__heap.html">k_heap</a> of the requested size in uncache memory. After kernel start, &amp;name can be used as if <a class="el" href="group__heap__apis.html#ga9273e06dc8d6a351499f2f5abfdcb39f" title="Initialize a k_heap.">k_heap_init()</a> had been called.</p>
<p >Note that this macro enforces a minimum size on the memory region to accommodate metadata requirements. Very small heaps will be padded to fit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Symbol name for the struct <a class="el" href="structk__heap.html">k_heap</a> object </td></tr>
    <tr><td class="paramname">bytes</td><td>Size of memory region, in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae16d486aa250f9c07fa6a57342bcd3b4" name="gae16d486aa250f9c07fa6a57342bcd3b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae16d486aa250f9c07fa6a57342bcd3b4">&#9670;&nbsp;</a></span>k_aligned_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * k_aligned_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Allocate memory from the heap with a specified alignment. </p>
<p >This routine provides semantics similar to aligned_alloc(); memory is allocated from the heap with a specified alignment. However, one minor difference is that <a class="el" href="group__heap__apis.html#gae16d486aa250f9c07fa6a57342bcd3b4" title="Allocate memory from the heap with a specified alignment.">k_aligned_alloc()</a> accepts any non-zero <code>size</code>, wherase aligned_alloc() only accepts a <code>size</code> that is an integral multiple of <code>align</code>.</p>
<p >Above, aligned_alloc() refers to: C11 standard (ISO/IEC 9899:2011): 7.22.3.1 The aligned_alloc function (p: 347-348)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">align</td><td>Alignment of memory requested (in bytes). </td></tr>
    <tr><td class="paramname">size</td><td>Amount of memory requested (in bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address of the allocated memory if successful; otherwise NULL. </dd></dl>

</div>
</div>
<a id="gad031d50ed62d08202a5dcf992c20246c" name="gad031d50ed62d08202a5dcf992c20246c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad031d50ed62d08202a5dcf992c20246c">&#9670;&nbsp;</a></span>k_calloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * k_calloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Allocate memory from heap, array style. </p>
<p >This routine provides traditional <a class="el" href="stdlib_8h.html#a2807e26a012717736641384f91ab2563">calloc()</a> semantics. Memory is allocated from the heap memory pool and zeroed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nmemb</td><td>Number of elements in the requested array </td></tr>
    <tr><td class="paramname">size</td><td>Size of each array element (in bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address of the allocated memory if successful; otherwise NULL. </dd></dl>

</div>
</div>
<a id="ga79b63cc93b3358cf82d74f40e73b69d5" name="ga79b63cc93b3358cf82d74f40e73b69d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79b63cc93b3358cf82d74f40e73b69d5">&#9670;&nbsp;</a></span>k_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void k_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Free memory allocated from heap. </p>
<p >This routine provides traditional <a class="el" href="stdlib_8h.html#afbedc913aa4651b3c3b4b3aecd9b4711">free()</a> semantics. The memory being returned must have been allocated from the heap memory pool or k_mem_pool_malloc().</p>
<p >If <em>ptr</em> is NULL, no operation is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to previously allocated memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf77211a72441de389857bc13e10be4e6" name="gaf77211a72441de389857bc13e10be4e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf77211a72441de389857bc13e10be4e6">&#9670;&nbsp;</a></span>k_heap_aligned_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * k_heap_aligned_alloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__heap.html">k_heap</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structk__timeout__t.html">k_timeout_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Allocate aligned memory from a <a class="el" href="structk__heap.html">k_heap</a>. </p>
<p >Behaves in all ways like <a class="el" href="group__heap__apis.html#ga22b83564e50ae6177388dfe63e32a512" title="Allocate memory from a k_heap.">k_heap_alloc()</a>, except that the returned memory (if available) will have a starting address in memory which is a multiple of the specified power-of-two alignment value in bytes. The resulting memory can be returned to the heap using <a class="el" href="group__heap__apis.html#ga6cf917a0b3d91a0101192bd4808ada9c" title="Free memory allocated by k_heap_alloc()">k_heap_free()</a>.</p>
<dl class="section note"><dt>Note</dt><dd><em>timeout</em> must be set to K_NO_WAIT if called from ISR. </dd>
<dd>
When CONFIG_MULTITHREADING=n any <em>timeout</em> is treated as K_NO_WAIT.</dd></dl>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Heap from which to allocate </td></tr>
    <tr><td class="paramname">align</td><td>Alignment in bytes, must be a power of two </td></tr>
    <tr><td class="paramname">bytes</td><td>Number of bytes requested </td></tr>
    <tr><td class="paramname">timeout</td><td>How long to wait, or K_NO_WAIT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to memory the caller can now use </dd></dl>

</div>
</div>
<a id="ga22b83564e50ae6177388dfe63e32a512" name="ga22b83564e50ae6177388dfe63e32a512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22b83564e50ae6177388dfe63e32a512">&#9670;&nbsp;</a></span>k_heap_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * k_heap_alloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__heap.html">k_heap</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structk__timeout__t.html">k_timeout_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Allocate memory from a <a class="el" href="structk__heap.html">k_heap</a>. </p>
<p >Allocates and returns a memory buffer from the memory region owned by the heap. If no memory is available immediately, the call will block for the specified timeout (constructed via the standard timeout API, or K_NO_WAIT or K_FOREVER) waiting for memory to be freed. If the allocation cannot be performed by the expiration of the timeout, NULL will be returned.</p>
<dl class="section note"><dt>Note</dt><dd><em>timeout</em> must be set to K_NO_WAIT if called from ISR. </dd>
<dd>
When CONFIG_MULTITHREADING=n any <em>timeout</em> is treated as K_NO_WAIT.</dd></dl>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Heap from which to allocate </td></tr>
    <tr><td class="paramname">bytes</td><td>Desired size of block to allocate </td></tr>
    <tr><td class="paramname">timeout</td><td>How long to wait, or K_NO_WAIT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to valid heap memory, or NULL </dd></dl>

</div>
</div>
<a id="ga6cf917a0b3d91a0101192bd4808ada9c" name="ga6cf917a0b3d91a0101192bd4808ada9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cf917a0b3d91a0101192bd4808ada9c">&#9670;&nbsp;</a></span>k_heap_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void k_heap_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__heap.html">k_heap</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Free memory allocated by <a class="el" href="group__heap__apis.html#ga22b83564e50ae6177388dfe63e32a512" title="Allocate memory from a k_heap.">k_heap_alloc()</a> </p>
<p >Returns the specified memory block, which must have been returned from <a class="el" href="group__heap__apis.html#ga22b83564e50ae6177388dfe63e32a512" title="Allocate memory from a k_heap.">k_heap_alloc()</a>, to the heap for use by other callers. Passing a NULL block is legal, and has no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Heap to which to return the memory </td></tr>
    <tr><td class="paramname">mem</td><td>A valid memory block, or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9273e06dc8d6a351499f2f5abfdcb39f" name="ga9273e06dc8d6a351499f2f5abfdcb39f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9273e06dc8d6a351499f2f5abfdcb39f">&#9670;&nbsp;</a></span>k_heap_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void k_heap_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__heap.html">k_heap</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Initialize a <a class="el" href="structk__heap.html">k_heap</a>. </p>
<p >This constructs a synchronized <a class="el" href="structk__heap.html">k_heap</a> object over a memory region specified by the user. Note that while any alignment and size can be passed as valid parameters, internal alignment restrictions inside the inner <a class="el" href="structsys__heap.html">sys_heap</a> mean that not all bytes may be usable as allocated memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Heap struct to initialize </td></tr>
    <tr><td class="paramname">mem</td><td>Pointer to memory. </td></tr>
    <tr><td class="paramname">bytes</td><td>Size of memory region, in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa8edf1e63e5d5dd78d7adcfd787394ee" name="gaa8edf1e63e5d5dd78d7adcfd787394ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8edf1e63e5d5dd78d7adcfd787394ee">&#9670;&nbsp;</a></span>k_malloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * k_malloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Allocate memory from the heap. </p>
<p >This routine provides traditional <a class="el" href="stdlib_8h.html#a9c36d0fe3ec4675cbffdc9b52f5fb399">malloc()</a> semantics. Memory is allocated from the heap memory pool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Amount of memory requested (in bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address of the allocated memory if successful; otherwise NULL. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Feb 21 2022 04:59:41 for Zephyr API Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
<script type="text/javascript">
  $(function() {
    toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
    toggleButton.title = "Toggle Light/Dark Mode"
    $(document).ready(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
    // every resize will remove the button, which is why it has to be added again:
    $(window).resize(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
  })
</script>
</body>
</html>
