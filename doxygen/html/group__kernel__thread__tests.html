<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zephyr API Documentation: Threads</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-zephyr.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-zephyr.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Zephyr API Documentation
   &#160;<span id="projectnumber">3.0.0-rc3</span>
   </div>
   <div id="projectbrief">A Scalable Open Source RTOS</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__kernel__thread__tests.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Threads<div class="ingroups"><a class="el" href="group__all__tests.html">Zephyr Tests</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Thread Tests.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa4cf5403b180b184ac8882fdacacfe41"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#gaa4cf5403b180b184ac8882fdacacfe41">test_dyn_thread_perms</a> (void)</td></tr>
<tr class="memdesc:gaa4cf5403b180b184ac8882fdacacfe41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test object permission on dynamic user thread when index is reused.  <a href="group__kernel__thread__tests.html#gaa4cf5403b180b184ac8882fdacacfe41">More...</a><br /></td></tr>
<tr class="separator:gaa4cf5403b180b184ac8882fdacacfe41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bf761ad8016f16b093b4501f3e9d6d6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#ga1bf761ad8016f16b093b4501f3e9d6d6">test_kernel_create_dyn_user_thread</a> (void)</td></tr>
<tr class="memdesc:ga1bf761ad8016f16b093b4501f3e9d6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test creation of dynamic user thread under kernel thread.  <a href="group__kernel__thread__tests.html#ga1bf761ad8016f16b093b4501f3e9d6d6">More...</a><br /></td></tr>
<tr class="separator:ga1bf761ad8016f16b093b4501f3e9d6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga569312447c2d5249621adcc04261197f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#ga569312447c2d5249621adcc04261197f">test_user_create_dyn_user_thread</a> (void)</td></tr>
<tr class="memdesc:ga569312447c2d5249621adcc04261197f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test creation of dynamic user thread under user thread.  <a href="group__kernel__thread__tests.html#ga569312447c2d5249621adcc04261197f">More...</a><br /></td></tr>
<tr class="separator:ga569312447c2d5249621adcc04261197f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe47de065adaebbe9400359493c3b3a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#gabe47de065adaebbe9400359493c3b3a0">test_systhreads_main</a> (void)</td></tr>
<tr class="memdesc:gabe47de065adaebbe9400359493c3b3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify main thread.  <a href="group__kernel__thread__tests.html#gabe47de065adaebbe9400359493c3b3a0">More...</a><br /></td></tr>
<tr class="separator:gabe47de065adaebbe9400359493c3b3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2531099398db9aa32f4a54156927d70a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#ga2531099398db9aa32f4a54156927d70a">test_systhreads_idle</a> (void)</td></tr>
<tr class="memdesc:ga2531099398db9aa32f4a54156927d70a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify idle thread.  <a href="group__kernel__thread__tests.html#ga2531099398db9aa32f4a54156927d70a">More...</a><br /></td></tr>
<tr class="separator:ga2531099398db9aa32f4a54156927d70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79538830a3db1f56ccfcb27a8599c57e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#ga79538830a3db1f56ccfcb27a8599c57e">test_customdata_get_set_coop</a> (void)</td></tr>
<tr class="memdesc:ga79538830a3db1f56ccfcb27a8599c57e"><td class="mdescLeft">&#160;</td><td class="mdescRight">test thread custom data get/set from coop thread  <a href="group__kernel__thread__tests.html#ga79538830a3db1f56ccfcb27a8599c57e">More...</a><br /></td></tr>
<tr class="separator:ga79538830a3db1f56ccfcb27a8599c57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga158919fa3d2d7071a815c9d41bc94a89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#ga158919fa3d2d7071a815c9d41bc94a89">test_thread_name_get_set</a> (void)</td></tr>
<tr class="memdesc:ga158919fa3d2d7071a815c9d41bc94a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">test thread name get/set from supervisor thread  <a href="group__kernel__thread__tests.html#ga158919fa3d2d7071a815c9d41bc94a89">More...</a><br /></td></tr>
<tr class="separator:ga158919fa3d2d7071a815c9d41bc94a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cdda772bf35ca82a1f25a81c1400719"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#ga2cdda772bf35ca82a1f25a81c1400719">test_thread_name_user_get_set</a> (void)</td></tr>
<tr class="memdesc:ga2cdda772bf35ca82a1f25a81c1400719"><td class="mdescLeft">&#160;</td><td class="mdescRight">test thread name get/set from user thread  <a href="group__kernel__thread__tests.html#ga2cdda772bf35ca82a1f25a81c1400719">More...</a><br /></td></tr>
<tr class="separator:ga2cdda772bf35ca82a1f25a81c1400719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42cc694be4d6c3388c6f8aef09cc923d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#ga42cc694be4d6c3388c6f8aef09cc923d">test_customdata_get_set_preempt</a> (void)</td></tr>
<tr class="memdesc:ga42cc694be4d6c3388c6f8aef09cc923d"><td class="mdescLeft">&#160;</td><td class="mdescRight">test thread custom data get/set from preempt thread  <a href="group__kernel__thread__tests.html#ga42cc694be4d6c3388c6f8aef09cc923d">More...</a><br /></td></tr>
<tr class="separator:ga42cc694be4d6c3388c6f8aef09cc923d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42561f974da6f8588a5f8a4294ab28a3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#ga42561f974da6f8588a5f8a4294ab28a3">enter_user_mode_entry</a> (void *p1, void *p2, void *p3)</td></tr>
<tr class="memdesc:ga42561f974da6f8588a5f8a4294ab28a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test <a class="el" href="group__thread__apis.html#ga3fbe1c8a5f3ef1c25382c7d6fca35764" title="Drop a thread&#39;s privileges permanently to user mode.">k_thread_user_mode_enter()</a> to cover when userspace is not supported/enabled.  <a href="group__kernel__thread__tests.html#ga42561f974da6f8588a5f8a4294ab28a3">More...</a><br /></td></tr>
<tr class="separator:ga42561f974da6f8588a5f8a4294ab28a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80b6f4d5311d01a2ed328c12576d15ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#ga80b6f4d5311d01a2ed328c12576d15ba">test_essential_thread_operation</a> (void)</td></tr>
<tr class="memdesc:ga80b6f4d5311d01a2ed328c12576d15ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test to validate essential flag set/clear.  <a href="group__kernel__thread__tests.html#ga80b6f4d5311d01a2ed328c12576d15ba">More...</a><br /></td></tr>
<tr class="separator:ga80b6f4d5311d01a2ed328c12576d15ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55716449c1fa7ab547b33d19346e89bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#ga55716449c1fa7ab547b33d19346e89bb">test_essential_thread_abort</a> (void)</td></tr>
<tr class="memdesc:ga55716449c1fa7ab547b33d19346e89bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort an essential thread.  <a href="group__kernel__thread__tests.html#ga55716449c1fa7ab547b33d19346e89bb">More...</a><br /></td></tr>
<tr class="separator:ga55716449c1fa7ab547b33d19346e89bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga577ab12bd0b4769e5399bb3d699fc8bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#ga577ab12bd0b4769e5399bb3d699fc8bc">test_k_thread_foreach</a> (void)</td></tr>
<tr class="memdesc:ga577ab12bd0b4769e5399bb3d699fc8bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test k_thread_foreach API.  <a href="group__kernel__thread__tests.html#ga577ab12bd0b4769e5399bb3d699fc8bc">More...</a><br /></td></tr>
<tr class="separator:ga577ab12bd0b4769e5399bb3d699fc8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdcfc826ee116f4e4286617dcdb9eee5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#gabdcfc826ee116f4e4286617dcdb9eee5">test_k_thread_foreach_unlocked</a> (void)</td></tr>
<tr class="memdesc:gabdcfc826ee116f4e4286617dcdb9eee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test k_thread_foreach_unlock API.  <a href="group__kernel__thread__tests.html#gabdcfc826ee116f4e4286617dcdb9eee5">More...</a><br /></td></tr>
<tr class="separator:gabdcfc826ee116f4e4286617dcdb9eee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8855ec6f9d9b1991c4678482c3702b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#gab8855ec6f9d9b1991c4678482c3702b8">test_k_thread_foreach_null_cb</a> (void)</td></tr>
<tr class="memdesc:gab8855ec6f9d9b1991c4678482c3702b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test k_thread_foreach API with null callback.  <a href="group__kernel__thread__tests.html#gab8855ec6f9d9b1991c4678482c3702b8">More...</a><br /></td></tr>
<tr class="separator:gab8855ec6f9d9b1991c4678482c3702b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10341044263044cba59eaea1c67c426b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#ga10341044263044cba59eaea1c67c426b">test_k_thread_foreach_unlocked_null_cb</a> (void)</td></tr>
<tr class="memdesc:ga10341044263044cba59eaea1c67c426b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test k_thread_foreach_unlocked API with null callback.  <a href="group__kernel__thread__tests.html#ga10341044263044cba59eaea1c67c426b">More...</a><br /></td></tr>
<tr class="separator:ga10341044263044cba59eaea1c67c426b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dc2a496f5c9f93e437f865b99b84114"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#ga3dc2a496f5c9f93e437f865b99b84114">test_k_thread_state_str</a> (void)</td></tr>
<tr class="memdesc:ga3dc2a496f5c9f93e437f865b99b84114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test k_thread_state_str API with null callback.  <a href="group__kernel__thread__tests.html#ga3dc2a496f5c9f93e437f865b99b84114">More...</a><br /></td></tr>
<tr class="separator:ga3dc2a496f5c9f93e437f865b99b84114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab554bac6421498511eed4354fb144e6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#gab554bac6421498511eed4354fb144e6d">test_threads_abort_self</a> (void)</td></tr>
<tr class="memdesc:gab554bac6421498511eed4354fb144e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate <a class="el" href="group__thread__apis.html#ga1f44bb0307bea7a97227764ecd7bf963" title="Abort a thread.">k_thread_abort()</a> when called by current thread.  <a href="group__kernel__thread__tests.html#gab554bac6421498511eed4354fb144e6d">More...</a><br /></td></tr>
<tr class="separator:gab554bac6421498511eed4354fb144e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77747ae463b19fdc129b2e011f5061f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#ga77747ae463b19fdc129b2e011f5061f0">test_threads_abort_others</a> (void)</td></tr>
<tr class="memdesc:ga77747ae463b19fdc129b2e011f5061f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate <a class="el" href="group__thread__apis.html#ga1f44bb0307bea7a97227764ecd7bf963" title="Abort a thread.">k_thread_abort()</a> when called by other thread.  <a href="group__kernel__thread__tests.html#ga77747ae463b19fdc129b2e011f5061f0">More...</a><br /></td></tr>
<tr class="separator:ga77747ae463b19fdc129b2e011f5061f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2d3f2ac9d1fbb0e3acad6a97fa808bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#gaf2d3f2ac9d1fbb0e3acad6a97fa808bf">test_threads_abort_repeat</a> (void)</td></tr>
<tr class="memdesc:gaf2d3f2ac9d1fbb0e3acad6a97fa808bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test abort on a terminated thread.  <a href="group__kernel__thread__tests.html#gaf2d3f2ac9d1fbb0e3acad6a97fa808bf">More...</a><br /></td></tr>
<tr class="separator:gaf2d3f2ac9d1fbb0e3acad6a97fa808bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbf2a9fe917ec063b9be6767a666daa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#gacbf2a9fe917ec063b9be6767a666daa9">test_delayed_thread_abort</a> (void)</td></tr>
<tr class="memdesc:gacbf2a9fe917ec063b9be6767a666daa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test abort on delayed thread before it has started execution.  <a href="group__kernel__thread__tests.html#gacbf2a9fe917ec063b9be6767a666daa9">More...</a><br /></td></tr>
<tr class="separator:gacbf2a9fe917ec063b9be6767a666daa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2006250ab6237a25a3e47014a5baaf89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#ga2006250ab6237a25a3e47014a5baaf89">test_abort_from_isr</a> (void)</td></tr>
<tr class="memdesc:ga2006250ab6237a25a3e47014a5baaf89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Show that threads can be aborted from interrupt context by itself.  <a href="group__kernel__thread__tests.html#ga2006250ab6237a25a3e47014a5baaf89">More...</a><br /></td></tr>
<tr class="separator:ga2006250ab6237a25a3e47014a5baaf89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae36781d5ef6ff99a27935d1ff3b6490d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#gae36781d5ef6ff99a27935d1ff3b6490d">test_abort_from_isr_not_self</a> (void)</td></tr>
<tr class="memdesc:gae36781d5ef6ff99a27935d1ff3b6490d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Show that threads can be aborted from interrupt context.  <a href="group__kernel__thread__tests.html#gae36781d5ef6ff99a27935d1ff3b6490d">More...</a><br /></td></tr>
<tr class="separator:gae36781d5ef6ff99a27935d1ff3b6490d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga799a7a8d7e7936b932bace256425d361"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#ga799a7a8d7e7936b932bace256425d361">test_threads_priority_set</a> (void)</td></tr>
<tr class="memdesc:ga799a7a8d7e7936b932bace256425d361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test the <a class="el" href="group__thread__apis.html#ga24e50a60c524d1eb22fe21cdf269b6a6" title="Set a thread&#39;s priority.">k_thread_priority_set()</a> API.  <a href="group__kernel__thread__tests.html#ga799a7a8d7e7936b932bace256425d361">More...</a><br /></td></tr>
<tr class="separator:ga799a7a8d7e7936b932bace256425d361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga343cc5510709b0043c32e026ea423c8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#ga343cc5510709b0043c32e026ea423c8d">test_threads_spawn_params</a> (void)</td></tr>
<tr class="memdesc:ga343cc5510709b0043c32e026ea423c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the parameters passed to thread entry function.  <a href="group__kernel__thread__tests.html#ga343cc5510709b0043c32e026ea423c8d">More...</a><br /></td></tr>
<tr class="separator:ga343cc5510709b0043c32e026ea423c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa46408c70fe87c930cdd897d5ee9a8ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#gaa46408c70fe87c930cdd897d5ee9a8ed">test_threads_spawn_priority</a> (void)</td></tr>
<tr class="memdesc:gaa46408c70fe87c930cdd897d5ee9a8ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawn thread with higher priority.  <a href="group__kernel__thread__tests.html#gaa46408c70fe87c930cdd897d5ee9a8ed">More...</a><br /></td></tr>
<tr class="separator:gaa46408c70fe87c930cdd897d5ee9a8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7eb8d5eb8f05037424a4be7209bc7ee1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#ga7eb8d5eb8f05037424a4be7209bc7ee1">test_threads_spawn_delay</a> (void)</td></tr>
<tr class="memdesc:ga7eb8d5eb8f05037424a4be7209bc7ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawn thread with a delay.  <a href="group__kernel__thread__tests.html#ga7eb8d5eb8f05037424a4be7209bc7ee1">More...</a><br /></td></tr>
<tr class="separator:ga7eb8d5eb8f05037424a4be7209bc7ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad774bf9c86adc632d19c951abc4a6b3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#gad774bf9c86adc632d19c951abc4a6b3a">test_threads_spawn_forever</a> (void)</td></tr>
<tr class="memdesc:gad774bf9c86adc632d19c951abc4a6b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawn thread with forever delay and highest priority.  <a href="group__kernel__thread__tests.html#gad774bf9c86adc632d19c951abc4a6b3a">More...</a><br /></td></tr>
<tr class="separator:gad774bf9c86adc632d19c951abc4a6b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9456b9b5e98b9b03b4f95099c8938e83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#ga9456b9b5e98b9b03b4f95099c8938e83">test_thread_start</a> (void)</td></tr>
<tr class="memdesc:ga9456b9b5e98b9b03b4f95099c8938e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate behavior of multiple calls to <a class="el" href="group__thread__apis.html#ga88031bd9fcfcd4305bae4029a4d8416f" title="Start an inactive thread.">k_thread_start()</a>  <a href="group__kernel__thread__tests.html#ga9456b9b5e98b9b03b4f95099c8938e83">More...</a><br /></td></tr>
<tr class="separator:ga9456b9b5e98b9b03b4f95099c8938e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8566965d5c6b32bc8f4c10bfa85dd9a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#ga8566965d5c6b32bc8f4c10bfa85dd9a0">test_threads_suspend_resume_cooperative</a> (void)</td></tr>
<tr class="memdesc:ga8566965d5c6b32bc8f4c10bfa85dd9a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the suspend and resume functionality in a cooperative thread.  <a href="group__kernel__thread__tests.html#ga8566965d5c6b32bc8f4c10bfa85dd9a0">More...</a><br /></td></tr>
<tr class="separator:ga8566965d5c6b32bc8f4c10bfa85dd9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae417ad0a2b4d1c4c70f3d94206a74def"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#gae417ad0a2b4d1c4c70f3d94206a74def">test_threads_suspend_resume_preemptible</a> (void)</td></tr>
<tr class="memdesc:gae417ad0a2b4d1c4c70f3d94206a74def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the suspend and resume functionality in preemptive thread.  <a href="group__kernel__thread__tests.html#gae417ad0a2b4d1c4c70f3d94206a74def">More...</a><br /></td></tr>
<tr class="separator:gae417ad0a2b4d1c4c70f3d94206a74def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22c351635c29e98e4b17ae88e7309974"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#ga22c351635c29e98e4b17ae88e7309974">test_threads_suspend</a> (void)</td></tr>
<tr class="memdesc:ga22c351635c29e98e4b17ae88e7309974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that <a class="el" href="group__thread__apis.html#ga66cf8682fb65870eceb5e57d667a8d4e" title="Suspend a thread.">k_thread_suspend()</a> is a schedule point when called on the current thread.  <a href="group__kernel__thread__tests.html#ga22c351635c29e98e4b17ae88e7309974">More...</a><br /></td></tr>
<tr class="separator:ga22c351635c29e98e4b17ae88e7309974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab20cb01e1b51390471dda076ee9227ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#gab20cb01e1b51390471dda076ee9227ac">test_threads_suspend_timeout</a> (void)</td></tr>
<tr class="memdesc:gab20cb01e1b51390471dda076ee9227ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that <a class="el" href="group__thread__apis.html#ga66cf8682fb65870eceb5e57d667a8d4e" title="Suspend a thread.">k_thread_suspend()</a> cancels a preexisting thread timeout.  <a href="group__kernel__thread__tests.html#gab20cb01e1b51390471dda076ee9227ac">More...</a><br /></td></tr>
<tr class="separator:gab20cb01e1b51390471dda076ee9227ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cb97f38f00cf31817bfe504f2bb89b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#ga2cb97f38f00cf31817bfe504f2bb89b9">test_resume_unsuspend_thread</a> (void)</td></tr>
<tr class="memdesc:ga2cb97f38f00cf31817bfe504f2bb89b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check resume an unsuspend thread.  <a href="group__kernel__thread__tests.html#ga2cb97f38f00cf31817bfe504f2bb89b9">More...</a><br /></td></tr>
<tr class="separator:ga2cb97f38f00cf31817bfe504f2bb89b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacce189baca4b76eed4ce9d03ca6c7a7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#gacce189baca4b76eed4ce9d03ca6c7a7d">test_kdefine_preempt_thread</a> (void)</td></tr>
<tr class="memdesc:gacce189baca4b76eed4ce9d03ca6c7a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">test preempt thread initialization via K_THREAD_DEFINE  <a href="group__kernel__thread__tests.html#gacce189baca4b76eed4ce9d03ca6c7a7d">More...</a><br /></td></tr>
<tr class="separator:gacce189baca4b76eed4ce9d03ca6c7a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf64c5339cfc7f905de5ca70bed952cf8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#gaf64c5339cfc7f905de5ca70bed952cf8">test_kdefine_coop_thread</a> (void)</td></tr>
<tr class="memdesc:gaf64c5339cfc7f905de5ca70bed952cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">test coop thread initialization via K_THREAD_DEFINE  <a href="group__kernel__thread__tests.html#gaf64c5339cfc7f905de5ca70bed952cf8">More...</a><br /></td></tr>
<tr class="separator:gaf64c5339cfc7f905de5ca70bed952cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9acf92f4616243ee09db39cf5e33a907"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#ga9acf92f4616243ee09db39cf5e33a907">test_kinit_preempt_thread</a> (void)</td></tr>
<tr class="memdesc:ga9acf92f4616243ee09db39cf5e33a907"><td class="mdescLeft">&#160;</td><td class="mdescRight">test preempt thread initialization via k_thread_create  <a href="group__kernel__thread__tests.html#ga9acf92f4616243ee09db39cf5e33a907">More...</a><br /></td></tr>
<tr class="separator:ga9acf92f4616243ee09db39cf5e33a907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b7cdb52f7fdf95dde830f7afa012bdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__thread__tests.html#ga6b7cdb52f7fdf95dde830f7afa012bdf">test_kinit_coop_thread</a> (void)</td></tr>
<tr class="memdesc:ga6b7cdb52f7fdf95dde830f7afa012bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">test coop thread initialization via k_thread_create  <a href="group__kernel__thread__tests.html#ga6b7cdb52f7fdf95dde830f7afa012bdf">More...</a><br /></td></tr>
<tr class="separator:ga6b7cdb52f7fdf95dde830f7afa012bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Thread Tests. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga42561f974da6f8588a5f8a4294ab28a3" name="ga42561f974da6f8588a5f8a4294ab28a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42561f974da6f8588a5f8a4294ab28a3">&#9670;&nbsp;</a></span>enter_user_mode_entry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void enter_user_mode_entry </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="threads_2thread__apis_2src_2main_8c.html">tests/kernel/threads/thread_apis/src/main.c</a>&gt;</code></p>

<p>Test <a class="el" href="group__thread__apis.html#ga3fbe1c8a5f3ef1c25382c7d6fca35764" title="Drop a thread&#39;s privileges permanently to user mode.">k_thread_user_mode_enter()</a> to cover when userspace is not supported/enabled. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__thread__apis.html#ga3fbe1c8a5f3ef1c25382c7d6fca35764" title="Drop a thread&#39;s privileges permanently to user mode.">k_thread_user_mode_enter()</a> </dd></dl>

</div>
</div>
<a id="ga2006250ab6237a25a3e47014a5baaf89" name="ga2006250ab6237a25a3e47014a5baaf89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2006250ab6237a25a3e47014a5baaf89">&#9670;&nbsp;</a></span>test_abort_from_isr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_abort_from_isr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="test__threads__cancel__abort_8c.html">tests/kernel/threads/thread_apis/src/test_threads_cancel_abort.c</a>&gt;</code></p>

<p>Show that threads can be aborted from interrupt context by itself. </p>
<p >Spwan a thread, then enter ISR context in child thread and abort the child thread. Check if ISR completed and target thread was aborted.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__thread__apis.html#ga1f44bb0307bea7a97227764ecd7bf963" title="Abort a thread.">k_thread_abort()</a> </dd></dl>

</div>
</div>
<a id="gae36781d5ef6ff99a27935d1ff3b6490d" name="gae36781d5ef6ff99a27935d1ff3b6490d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae36781d5ef6ff99a27935d1ff3b6490d">&#9670;&nbsp;</a></span>test_abort_from_isr_not_self()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_abort_from_isr_not_self </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="test__threads__cancel__abort_8c.html">tests/kernel/threads/thread_apis/src/test_threads_cancel_abort.c</a>&gt;</code></p>

<p>Show that threads can be aborted from interrupt context. </p>
<p >Spwan a thread, then enter ISR context in main thread and abort the child thread. Check if ISR completed and target thread was aborted.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__thread__apis.html#ga1f44bb0307bea7a97227764ecd7bf963" title="Abort a thread.">k_thread_abort()</a> </dd></dl>

</div>
</div>
<a id="ga79538830a3db1f56ccfcb27a8599c57e" name="ga79538830a3db1f56ccfcb27a8599c57e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79538830a3db1f56ccfcb27a8599c57e">&#9670;&nbsp;</a></span>test_customdata_get_set_coop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_customdata_get_set_coop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="threads_2thread__apis_2src_2main_8c.html">tests/kernel/threads/thread_apis/src/main.c</a>&gt;</code></p>

<p>test thread custom data get/set from coop thread </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__thread__apis.html#ga19af063cff7b306ba28062996922740d" title="Get current thread&#39;s custom data.">k_thread_custom_data_get()</a>, <a class="el" href="group__thread__apis.html#ga4834d9b81ed60c00eee77b0d4f8ab9e4" title="Set current thread&#39;s custom data.">k_thread_custom_data_set()</a> </dd></dl>

</div>
</div>
<a id="ga42cc694be4d6c3388c6f8aef09cc923d" name="ga42cc694be4d6c3388c6f8aef09cc923d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42cc694be4d6c3388c6f8aef09cc923d">&#9670;&nbsp;</a></span>test_customdata_get_set_preempt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_customdata_get_set_preempt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="threads_2thread__apis_2src_2main_8c.html">tests/kernel/threads/thread_apis/src/main.c</a>&gt;</code></p>

<p>test thread custom data get/set from preempt thread </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__thread__apis.html#ga19af063cff7b306ba28062996922740d" title="Get current thread&#39;s custom data.">k_thread_custom_data_get()</a>, <a class="el" href="group__thread__apis.html#ga4834d9b81ed60c00eee77b0d4f8ab9e4" title="Set current thread&#39;s custom data.">k_thread_custom_data_set()</a> </dd></dl>
<p >TESTPOINT: custom data of preempt thread</p>

</div>
</div>
<a id="gacbf2a9fe917ec063b9be6767a666daa9" name="gacbf2a9fe917ec063b9be6767a666daa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbf2a9fe917ec063b9be6767a666daa9">&#9670;&nbsp;</a></span>test_delayed_thread_abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_delayed_thread_abort </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="test__threads__cancel__abort_8c.html">tests/kernel/threads/thread_apis/src/test_threads_cancel_abort.c</a>&gt;</code></p>

<p>Test abort on delayed thread before it has started execution. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__thread__apis.html#ga1f44bb0307bea7a97227764ecd7bf963" title="Abort a thread.">k_thread_abort()</a> </dd></dl>

</div>
</div>
<a id="gaa4cf5403b180b184ac8882fdacacfe41" name="gaa4cf5403b180b184ac8882fdacacfe41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4cf5403b180b184ac8882fdacacfe41">&#9670;&nbsp;</a></span>test_dyn_thread_perms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void test_dyn_thread_perms </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="threads_2dynamic__thread_2src_2main_8c.html">tests/kernel/threads/dynamic_thread/src/main.c</a>&gt;</code></p>

<p>Test object permission on dynamic user thread when index is reused. </p>
<p >This creates one dynamic thread with permissions to both semaphores so there is no fault. Then a new thread is created and will be re-using the thread index in first pass. Except the second thread does not have permission to one of the semaphore. If permissions are cleared correctly when thread is destroyed, the second should raise kernel oops. </p>

</div>
</div>
<a id="ga55716449c1fa7ab547b33d19346e89bb" name="ga55716449c1fa7ab547b33d19346e89bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55716449c1fa7ab547b33d19346e89bb">&#9670;&nbsp;</a></span>test_essential_thread_abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_essential_thread_abort </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="test__essential__thread_8c.html">tests/kernel/threads/thread_apis/src/test_essential_thread.c</a>&gt;</code></p>

<p>Abort an essential thread. </p>
<p >The kernel shall raise a fatal system error if an essential thread aborts, implement k_sys_fatal_error_handler to handle this error.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__thread__apis.html#gad503fbcca905a9266b0e154e3ded258c" title="system thread that must not abort">K_ESSENTIAL(x)</a> </dd></dl>

</div>
</div>
<a id="ga80b6f4d5311d01a2ed328c12576d15ba" name="ga80b6f4d5311d01a2ed328c12576d15ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80b6f4d5311d01a2ed328c12576d15ba">&#9670;&nbsp;</a></span>test_essential_thread_operation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_essential_thread_operation </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="test__essential__thread_8c.html">tests/kernel/threads/thread_apis/src/test_essential_thread.c</a>&gt;</code></p>

<p>Test to validate essential flag set/clear. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__thread__apis.html#gad503fbcca905a9266b0e154e3ded258c" title="system thread that must not abort">K_ESSENTIAL(x)</a> </dd></dl>

</div>
</div>
<a id="ga577ab12bd0b4769e5399bb3d699fc8bc" name="ga577ab12bd0b4769e5399bb3d699fc8bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga577ab12bd0b4769e5399bb3d699fc8bc">&#9670;&nbsp;</a></span>test_k_thread_foreach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_k_thread_foreach </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="test__kthread__for__each_8c.html">tests/kernel/threads/thread_apis/src/test_kthread_for_each.c</a>&gt;</code></p>

<p>Test k_thread_foreach API. </p>
<p >Call <a class="el" href="group__thread__apis.html#gae2596d56800769b06fc03c194a126a97" title="Iterate over all the threads in the system.">k_thread_foreach()</a> at the beginning of the test and call it again after creating a thread, See <a class="el" href="group__thread__apis.html#gae2596d56800769b06fc03c194a126a97" title="Iterate over all the threads in the system.">k_thread_foreach()</a> iterates over the newly created thread and calls the user passed callback function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__thread__apis.html#gae2596d56800769b06fc03c194a126a97" title="Iterate over all the threads in the system.">k_thread_foreach()</a> </dd></dl>

</div>
</div>
<a id="gab8855ec6f9d9b1991c4678482c3702b8" name="gab8855ec6f9d9b1991c4678482c3702b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8855ec6f9d9b1991c4678482c3702b8">&#9670;&nbsp;</a></span>test_k_thread_foreach_null_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_k_thread_foreach_null_cb </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="test__kthread__for__each_8c.html">tests/kernel/threads/thread_apis/src/test_kthread_for_each.c</a>&gt;</code></p>

<p>Test k_thread_foreach API with null callback. </p>
<p >Call <a class="el" href="group__thread__apis.html#gae2596d56800769b06fc03c194a126a97" title="Iterate over all the threads in the system.">k_thread_foreach()</a> with null callback will triger __ASSERT() and this test thread will be aborted by z_fatal_error() </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__thread__apis.html#gae2596d56800769b06fc03c194a126a97" title="Iterate over all the threads in the system.">k_thread_foreach()</a> </dd></dl>

</div>
</div>
<a id="gabdcfc826ee116f4e4286617dcdb9eee5" name="gabdcfc826ee116f4e4286617dcdb9eee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdcfc826ee116f4e4286617dcdb9eee5">&#9670;&nbsp;</a></span>test_k_thread_foreach_unlocked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_k_thread_foreach_unlocked </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="test__kthread__for__each_8c.html">tests/kernel/threads/thread_apis/src/test_kthread_for_each.c</a>&gt;</code></p>

<p>Test k_thread_foreach_unlock API. </p>
<p >Call <a class="el" href="group__thread__apis.html#ga30ef8b445a6c1b4a82651674dbb737fc" title="Iterate over all the threads in the system without locking.">k_thread_foreach_unlocked()</a> at the beginning of the test and call it again after creating a thread, See <a class="el" href="group__thread__apis.html#ga30ef8b445a6c1b4a82651674dbb737fc" title="Iterate over all the threads in the system without locking.">k_thread_foreach_unlocked()</a> iterates over the newly created thread and calls the user passed callback function. In contrast to <a class="el" href="group__thread__apis.html#gae2596d56800769b06fc03c194a126a97" title="Iterate over all the threads in the system.">k_thread_foreach()</a>, <a class="el" href="group__thread__apis.html#ga30ef8b445a6c1b4a82651674dbb737fc" title="Iterate over all the threads in the system without locking.">k_thread_foreach_unlocked()</a> allow callback function created or abort threads</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__thread__apis.html#ga30ef8b445a6c1b4a82651674dbb737fc" title="Iterate over all the threads in the system without locking.">k_thread_foreach_unlocked()</a> </dd></dl>

</div>
</div>
<a id="ga10341044263044cba59eaea1c67c426b" name="ga10341044263044cba59eaea1c67c426b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10341044263044cba59eaea1c67c426b">&#9670;&nbsp;</a></span>test_k_thread_foreach_unlocked_null_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_k_thread_foreach_unlocked_null_cb </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="test__kthread__for__each_8c.html">tests/kernel/threads/thread_apis/src/test_kthread_for_each.c</a>&gt;</code></p>

<p>Test k_thread_foreach_unlocked API with null callback. </p>
<p >Call <a class="el" href="group__thread__apis.html#ga30ef8b445a6c1b4a82651674dbb737fc" title="Iterate over all the threads in the system without locking.">k_thread_foreach_unlocked()</a> with null callback will triger __ASSERT() and this test thread will be aborted by z_fatal_error()</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__thread__apis.html#ga30ef8b445a6c1b4a82651674dbb737fc" title="Iterate over all the threads in the system without locking.">k_thread_foreach_unlocked()</a> </dd></dl>

</div>
</div>
<a id="ga3dc2a496f5c9f93e437f865b99b84114" name="ga3dc2a496f5c9f93e437f865b99b84114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3dc2a496f5c9f93e437f865b99b84114">&#9670;&nbsp;</a></span>test_k_thread_state_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_k_thread_state_str </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="test__kthread__for__each_8c.html">tests/kernel/threads/thread_apis/src/test_kthread_for_each.c</a>&gt;</code></p>

<p>Test k_thread_state_str API with null callback. </p>
<p >It's impossible to sched a thread step by step manually to experence each state from _THREAD_PRESTART to _THREAD_DEAD. To cover each line of function <a class="el" href="group__thread__apis.html#gae36c37d54522fbf8d9a34b93991e51ca" title="Get thread state string.">k_thread_state_str()</a>, set thread_state of tdata1 and check the string this function returns</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__thread__apis.html#gae36c37d54522fbf8d9a34b93991e51ca" title="Get thread state string.">k_thread_state_str()</a> </dd></dl>

</div>
</div>
<a id="gaf64c5339cfc7f905de5ca70bed952cf8" name="gaf64c5339cfc7f905de5ca70bed952cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf64c5339cfc7f905de5ca70bed952cf8">&#9670;&nbsp;</a></span>test_kdefine_coop_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_kdefine_coop_thread </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="threads_2thread__init_2src_2main_8c.html">tests/kernel/threads/thread_init/src/main.c</a>&gt;</code></p>

<p>test coop thread initialization via K_THREAD_DEFINE </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__thread__apis.html#gab3ced58648ca35788a40676e8478ecd2" title="Statically define and initialize a thread.">K_THREAD_DEFINE(x)</a> </dd></dl>

</div>
</div>
<a id="gacce189baca4b76eed4ce9d03ca6c7a7d" name="gacce189baca4b76eed4ce9d03ca6c7a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacce189baca4b76eed4ce9d03ca6c7a7d">&#9670;&nbsp;</a></span>test_kdefine_preempt_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_kdefine_preempt_thread </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="threads_2thread__init_2src_2main_8c.html">tests/kernel/threads/thread_init/src/main.c</a>&gt;</code></p>

<p>test preempt thread initialization via K_THREAD_DEFINE </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__thread__apis.html#gab3ced58648ca35788a40676e8478ecd2" title="Statically define and initialize a thread.">K_THREAD_DEFINE(x)</a> </dd></dl>

</div>
</div>
<a id="ga1bf761ad8016f16b093b4501f3e9d6d6" name="ga1bf761ad8016f16b093b4501f3e9d6d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bf761ad8016f16b093b4501f3e9d6d6">&#9670;&nbsp;</a></span>test_kernel_create_dyn_user_thread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void test_kernel_create_dyn_user_thread </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="threads_2dynamic__thread_2src_2main_8c.html">tests/kernel/threads/dynamic_thread/src/main.c</a>&gt;</code></p>

<p>Test creation of dynamic user thread under kernel thread. </p>
<p >This is a simple test to create a user thread dynamically via k_object_alloc() under a kernel thread. </p>

</div>
</div>
<a id="ga6b7cdb52f7fdf95dde830f7afa012bdf" name="ga6b7cdb52f7fdf95dde830f7afa012bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b7cdb52f7fdf95dde830f7afa012bdf">&#9670;&nbsp;</a></span>test_kinit_coop_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_kinit_coop_thread </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="threads_2thread__init_2src_2main_8c.html">tests/kernel/threads/thread_init/src/main.c</a>&gt;</code></p>

<p>test coop thread initialization via k_thread_create </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__thread__apis.html#gad5b0bff3102f1656089f5875d999a367" title="Create a thread.">k_thread_create()</a> </dd></dl>

</div>
</div>
<a id="ga9acf92f4616243ee09db39cf5e33a907" name="ga9acf92f4616243ee09db39cf5e33a907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9acf92f4616243ee09db39cf5e33a907">&#9670;&nbsp;</a></span>test_kinit_preempt_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_kinit_preempt_thread </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="threads_2thread__init_2src_2main_8c.html">tests/kernel/threads/thread_init/src/main.c</a>&gt;</code></p>

<p>test preempt thread initialization via k_thread_create </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__thread__apis.html#gad5b0bff3102f1656089f5875d999a367" title="Create a thread.">k_thread_create()</a> </dd></dl>

</div>
</div>
<a id="ga2cb97f38f00cf31817bfe504f2bb89b9" name="ga2cb97f38f00cf31817bfe504f2bb89b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cb97f38f00cf31817bfe504f2bb89b9">&#9670;&nbsp;</a></span>test_resume_unsuspend_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_resume_unsuspend_thread </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="test__threads__suspend__resume_8c.html">tests/kernel/threads/thread_apis/src/test_threads_suspend_resume.c</a>&gt;</code></p>

<p>Check resume an unsuspend thread. </p>
<p >Use <a class="el" href="group__thread__apis.html#gae36c37d54522fbf8d9a34b93991e51ca" title="Get thread state string.">k_thread_state_str()</a> to get thread state. Resume an unsuspend thread will not change the thread state. </p>

</div>
</div>
<a id="ga2531099398db9aa32f4a54156927d70a" name="ga2531099398db9aa32f4a54156927d70a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2531099398db9aa32f4a54156927d70a">&#9670;&nbsp;</a></span>test_systhreads_idle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_systhreads_idle </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="threads_2thread__apis_2src_2main_8c.html">tests/kernel/threads/thread_apis/src/main.c</a>&gt;</code></p>

<p>Verify idle thread. </p>
<p >TESTPOINT: check working thread priority should</p>

</div>
</div>
<a id="gabe47de065adaebbe9400359493c3b3a0" name="gabe47de065adaebbe9400359493c3b3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe47de065adaebbe9400359493c3b3a0">&#9670;&nbsp;</a></span>test_systhreads_main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_systhreads_main </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="threads_2thread__apis_2src_2main_8c.html">tests/kernel/threads/thread_apis/src/main.c</a>&gt;</code></p>

<p>Verify main thread. </p>

</div>
</div>
<a id="ga158919fa3d2d7071a815c9d41bc94a89" name="ga158919fa3d2d7071a815c9d41bc94a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga158919fa3d2d7071a815c9d41bc94a89">&#9670;&nbsp;</a></span>test_thread_name_get_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_thread_name_get_set </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="threads_2thread__apis_2src_2main_8c.html">tests/kernel/threads/thread_apis/src/main.c</a>&gt;</code></p>

<p>test thread name get/set from supervisor thread </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__thread__apis.html#gadebf45da56dee393164569742459dc0a" title="Get thread name.">k_thread_name_get()</a>, <a class="el" href="group__thread__apis.html#ga07b59ade055c69929ccdc08a14361794" title="Copy the thread name into a supplied buffer.">k_thread_name_copy()</a>, <a class="el" href="group__thread__apis.html#ga23107333f134b9c9a8b692374211e841" title="Set current thread name.">k_thread_name_set()</a> </dd></dl>

</div>
</div>
<a id="ga2cdda772bf35ca82a1f25a81c1400719" name="ga2cdda772bf35ca82a1f25a81c1400719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cdda772bf35ca82a1f25a81c1400719">&#9670;&nbsp;</a></span>test_thread_name_user_get_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_thread_name_user_get_set </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="threads_2thread__apis_2src_2main_8c.html">tests/kernel/threads/thread_apis/src/main.c</a>&gt;</code></p>

<p>test thread name get/set from user thread </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__thread__apis.html#ga07b59ade055c69929ccdc08a14361794" title="Copy the thread name into a supplied buffer.">k_thread_name_copy()</a>, <a class="el" href="group__thread__apis.html#ga23107333f134b9c9a8b692374211e841" title="Set current thread name.">k_thread_name_set()</a> </dd></dl>

</div>
</div>
<a id="ga9456b9b5e98b9b03b4f95099c8938e83" name="ga9456b9b5e98b9b03b4f95099c8938e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9456b9b5e98b9b03b4f95099c8938e83">&#9670;&nbsp;</a></span>test_thread_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_thread_start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="test__threads__spawn_8c.html">tests/kernel/threads/thread_apis/src/test_threads_spawn.c</a>&gt;</code></p>

<p>Validate behavior of multiple calls to <a class="el" href="group__thread__apis.html#ga88031bd9fcfcd4305bae4029a4d8416f" title="Start an inactive thread.">k_thread_start()</a> </p>
<p >Call <a class="el" href="group__thread__apis.html#ga88031bd9fcfcd4305bae4029a4d8416f" title="Start an inactive thread.">k_thread_start()</a> on an already terminated thread</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__thread__apis.html#ga88031bd9fcfcd4305bae4029a4d8416f" title="Start an inactive thread.">k_thread_start()</a> </dd></dl>

</div>
</div>
<a id="ga77747ae463b19fdc129b2e011f5061f0" name="ga77747ae463b19fdc129b2e011f5061f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77747ae463b19fdc129b2e011f5061f0">&#9670;&nbsp;</a></span>test_threads_abort_others()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_threads_abort_others </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="test__threads__cancel__abort_8c.html">tests/kernel/threads/thread_apis/src/test_threads_cancel_abort.c</a>&gt;</code></p>

<p>Validate <a class="el" href="group__thread__apis.html#ga1f44bb0307bea7a97227764ecd7bf963" title="Abort a thread.">k_thread_abort()</a> when called by other thread. </p>
<p >Create a user thread and abort the thread before its execution. Create a another user thread and abort the thread after it has started.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__thread__apis.html#ga1f44bb0307bea7a97227764ecd7bf963" title="Abort a thread.">k_thread_abort()</a> </dd></dl>
<p >TESTPOINT: check not-started thread is aborted</p>
<p >TESTPOINT: check running thread is aborted</p>

</div>
</div>
<a id="gaf2d3f2ac9d1fbb0e3acad6a97fa808bf" name="gaf2d3f2ac9d1fbb0e3acad6a97fa808bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2d3f2ac9d1fbb0e3acad6a97fa808bf">&#9670;&nbsp;</a></span>test_threads_abort_repeat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_threads_abort_repeat </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="test__threads__cancel__abort_8c.html">tests/kernel/threads/thread_apis/src/test_threads_cancel_abort.c</a>&gt;</code></p>

<p>Test abort on a terminated thread. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__thread__apis.html#ga1f44bb0307bea7a97227764ecd7bf963" title="Abort a thread.">k_thread_abort()</a> </dd></dl>

</div>
</div>
<a id="gab554bac6421498511eed4354fb144e6d" name="gab554bac6421498511eed4354fb144e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab554bac6421498511eed4354fb144e6d">&#9670;&nbsp;</a></span>test_threads_abort_self()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_threads_abort_self </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="test__threads__cancel__abort_8c.html">tests/kernel/threads/thread_apis/src/test_threads_cancel_abort.c</a>&gt;</code></p>

<p>Validate <a class="el" href="group__thread__apis.html#ga1f44bb0307bea7a97227764ecd7bf963" title="Abort a thread.">k_thread_abort()</a> when called by current thread. </p>
<p >Create a user thread and let the thread execute. Then call <a class="el" href="group__thread__apis.html#ga1f44bb0307bea7a97227764ecd7bf963" title="Abort a thread.">k_thread_abort()</a> and check if the thread is terminated. Here the main thread is also a user thread.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__thread__apis.html#ga1f44bb0307bea7a97227764ecd7bf963" title="Abort a thread.">k_thread_abort()</a> </dd></dl>
<p >TESTPOINT: spawned thread executed but abort itself</p>

</div>
</div>
<a id="ga799a7a8d7e7936b932bace256425d361" name="ga799a7a8d7e7936b932bace256425d361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga799a7a8d7e7936b932bace256425d361">&#9670;&nbsp;</a></span>test_threads_priority_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_threads_priority_set </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="test__threads__set__priority_8c.html">tests/kernel/threads/thread_apis/src/test_threads_set_priority.c</a>&gt;</code></p>

<p>Test the <a class="el" href="group__thread__apis.html#ga24e50a60c524d1eb22fe21cdf269b6a6" title="Set a thread&#39;s priority.">k_thread_priority_set()</a> API. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__thread__apis.html#ga24e50a60c524d1eb22fe21cdf269b6a6" title="Set a thread&#39;s priority.">k_thread_priority_set()</a>, <a class="el" href="group__thread__apis.html#ga3a46ed8ad2c3b12416fafe11325f82b3" title="Get a thread&#39;s priority.">k_thread_priority_get()</a> </dd></dl>

</div>
</div>
<a id="ga7eb8d5eb8f05037424a4be7209bc7ee1" name="ga7eb8d5eb8f05037424a4be7209bc7ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7eb8d5eb8f05037424a4be7209bc7ee1">&#9670;&nbsp;</a></span>test_threads_spawn_delay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_threads_spawn_delay </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="test__threads__spawn_8c.html">tests/kernel/threads/thread_apis/src/test_threads_spawn.c</a>&gt;</code></p>

<p>Spawn thread with a delay. </p>
<p >Create a user thread with delay and check if the thread entry function is executed only after the timeout occurs.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__thread__apis.html#gad5b0bff3102f1656089f5875d999a367" title="Create a thread.">k_thread_create()</a> </dd></dl>

</div>
</div>
<a id="gad774bf9c86adc632d19c951abc4a6b3a" name="gad774bf9c86adc632d19c951abc4a6b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad774bf9c86adc632d19c951abc4a6b3a">&#9670;&nbsp;</a></span>test_threads_spawn_forever()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_threads_spawn_forever </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="test__threads__spawn_8c.html">tests/kernel/threads/thread_apis/src/test_threads_spawn.c</a>&gt;</code></p>

<p>Spawn thread with forever delay and highest priority. </p>
<p >Create an user thread with forever delay and yield the current thread. Even though the current thread has yielded, the thread will not be put in ready queue since it has forever delay, the thread is explicitly started using <a class="el" href="group__thread__apis.html#ga88031bd9fcfcd4305bae4029a4d8416f" title="Start an inactive thread.">k_thread_start()</a> and checked if thread has started executing.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__thread__apis.html#gad5b0bff3102f1656089f5875d999a367" title="Create a thread.">k_thread_create()</a> </dd></dl>

</div>
</div>
<a id="ga343cc5510709b0043c32e026ea423c8d" name="ga343cc5510709b0043c32e026ea423c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga343cc5510709b0043c32e026ea423c8d">&#9670;&nbsp;</a></span>test_threads_spawn_params()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_threads_spawn_params </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="test__threads__spawn_8c.html">tests/kernel/threads/thread_apis/src/test_threads_spawn.c</a>&gt;</code></p>

<p>Check the parameters passed to thread entry function. </p>
<p >Create an user thread and pass 2 variables and a semaphore to a thread entry function. Check for the correctness of the parameters passed.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__thread__apis.html#gad5b0bff3102f1656089f5875d999a367" title="Create a thread.">k_thread_create()</a> </dd></dl>

</div>
</div>
<a id="gaa46408c70fe87c930cdd897d5ee9a8ed" name="gaa46408c70fe87c930cdd897d5ee9a8ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa46408c70fe87c930cdd897d5ee9a8ed">&#9670;&nbsp;</a></span>test_threads_spawn_priority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_threads_spawn_priority </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="test__threads__spawn_8c.html">tests/kernel/threads/thread_apis/src/test_threads_spawn.c</a>&gt;</code></p>

<p>Spawn thread with higher priority. </p>
<p >Create an user thread with priority greater than current thread and check its behavior.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__thread__apis.html#gad5b0bff3102f1656089f5875d999a367" title="Create a thread.">k_thread_create()</a> </dd></dl>

</div>
</div>
<a id="ga22c351635c29e98e4b17ae88e7309974" name="ga22c351635c29e98e4b17ae88e7309974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22c351635c29e98e4b17ae88e7309974">&#9670;&nbsp;</a></span>test_threads_suspend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_threads_suspend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="test__threads__suspend__resume_8c.html">tests/kernel/threads/thread_apis/src/test_threads_suspend_resume.c</a>&gt;</code></p>

<p>Check that <a class="el" href="group__thread__apis.html#ga66cf8682fb65870eceb5e57d667a8d4e" title="Suspend a thread.">k_thread_suspend()</a> is a schedule point when called on the current thread. </p>

</div>
</div>
<a id="ga8566965d5c6b32bc8f4c10bfa85dd9a0" name="ga8566965d5c6b32bc8f4c10bfa85dd9a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8566965d5c6b32bc8f4c10bfa85dd9a0">&#9670;&nbsp;</a></span>test_threads_suspend_resume_cooperative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_threads_suspend_resume_cooperative </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="test__threads__suspend__resume_8c.html">tests/kernel/threads/thread_apis/src/test_threads_suspend_resume.c</a>&gt;</code></p>

<p>Check the suspend and resume functionality in a cooperative thread. </p>
<p >Create a thread with the priority lower than the current thread which is cooperative and suspend it, make sure it doesn't gets scheduled, and resume and check if the entry function is executed.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__thread__apis.html#ga66cf8682fb65870eceb5e57d667a8d4e" title="Suspend a thread.">k_thread_suspend()</a>, <a class="el" href="group__thread__apis.html#ga117b26f8569ec3045ead1fad1851663d" title="Resume a suspended thread.">k_thread_resume()</a> </dd></dl>

</div>
</div>
<a id="gae417ad0a2b4d1c4c70f3d94206a74def" name="gae417ad0a2b4d1c4c70f3d94206a74def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae417ad0a2b4d1c4c70f3d94206a74def">&#9670;&nbsp;</a></span>test_threads_suspend_resume_preemptible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_threads_suspend_resume_preemptible </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="test__threads__suspend__resume_8c.html">tests/kernel/threads/thread_apis/src/test_threads_suspend_resume.c</a>&gt;</code></p>

<p>Check the suspend and resume functionality in preemptive thread. </p>
<p >Create a thread with the priority lower than the current thread which is preemptive and suspend it, make sure it doesn't gets scheduled, and resume and check if the entry function is executed.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__thread__apis.html#ga66cf8682fb65870eceb5e57d667a8d4e" title="Suspend a thread.">k_thread_suspend()</a>, <a class="el" href="group__thread__apis.html#ga117b26f8569ec3045ead1fad1851663d" title="Resume a suspended thread.">k_thread_resume()</a> </dd></dl>

</div>
</div>
<a id="gab20cb01e1b51390471dda076ee9227ac" name="gab20cb01e1b51390471dda076ee9227ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab20cb01e1b51390471dda076ee9227ac">&#9670;&nbsp;</a></span>test_threads_suspend_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_threads_suspend_timeout </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="test__threads__suspend__resume_8c.html">tests/kernel/threads/thread_apis/src/test_threads_suspend_resume.c</a>&gt;</code></p>

<p>Check that <a class="el" href="group__thread__apis.html#ga66cf8682fb65870eceb5e57d667a8d4e" title="Suspend a thread.">k_thread_suspend()</a> cancels a preexisting thread timeout. </p>
<p >Suspended threads should not wake up unexpectedly if they happened to have been sleeping when suspended. </p>

</div>
</div>
<a id="ga569312447c2d5249621adcc04261197f" name="ga569312447c2d5249621adcc04261197f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga569312447c2d5249621adcc04261197f">&#9670;&nbsp;</a></span>test_user_create_dyn_user_thread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void test_user_create_dyn_user_thread </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="threads_2dynamic__thread_2src_2main_8c.html">tests/kernel/threads/dynamic_thread/src/main.c</a>&gt;</code></p>

<p>Test creation of dynamic user thread under user thread. </p>
<p >This is a simple test to create a user thread dynamically via k_object_alloc() under a user thread. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Feb 21 2022 04:59:42 for Zephyr API Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
<script type="text/javascript">
  $(function() {
    toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
    toggleButton.title = "Toggle Light/Dark Mode"
    $(document).ready(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
    // every resize will remove the button, which is why it has to be added again:
    $(window).resize(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
  })
</script>
</body>
</html>
