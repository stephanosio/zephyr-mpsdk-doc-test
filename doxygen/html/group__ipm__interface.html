<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zephyr API Documentation: IPM Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-zephyr.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-zephyr.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Zephyr API Documentation
   &#160;<span id="projectnumber">3.0.0-rc3</span>
   </div>
   <div id="projectbrief">A Scalable Open Source RTOS</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__ipm__interface.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">IPM Interface<div class="ingroups"><a class="el" href="group__io__interfaces.html">Device Driver APIs</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>IPM Interface.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structipm__driver__api.html">ipm_driver_api</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaa9dbdfd91b0fe01297792949c19e8f70"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ipm__interface.html#gaa9dbdfd91b0fe01297792949c19e8f70">ipm_callback_t</a>) (const struct <a class="el" href="structdevice.html">device</a> *ipmdev, void *<a class="el" href="timer_2timer__api_2src_2main_8c.html#a862de962130decf51321624c10294338">user_data</a>, <a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> id, volatile void *<a class="el" href="test__stack__fail_8c.html#a4bb6fa6c719fd9021449009ab8befc04">data</a>)</td></tr>
<tr class="memdesc:gaa9dbdfd91b0fe01297792949c19e8f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback API for incoming IPM messages.  <a href="group__ipm__interface.html#gaa9dbdfd91b0fe01297792949c19e8f70">More...</a><br /></td></tr>
<tr class="separator:gaa9dbdfd91b0fe01297792949c19e8f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80e6af3109598a6cb9df0b36d1cdbca7"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ipm__interface.html#ga80e6af3109598a6cb9df0b36d1cdbca7">ipm_send_t</a>) (const struct <a class="el" href="structdevice.html">device</a> *ipmdev, int wait, <a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> id, const void *<a class="el" href="test__stack__fail_8c.html#a4bb6fa6c719fd9021449009ab8befc04">data</a>, int size)</td></tr>
<tr class="memdesc:ga80e6af3109598a6cb9df0b36d1cdbca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback API to send IPM messages.  <a href="group__ipm__interface.html#ga80e6af3109598a6cb9df0b36d1cdbca7">More...</a><br /></td></tr>
<tr class="separator:ga80e6af3109598a6cb9df0b36d1cdbca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67611ee678c0c265ba07589f1b8aea68"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ipm__interface.html#ga67611ee678c0c265ba07589f1b8aea68">ipm_max_data_size_get_t</a>) (const struct <a class="el" href="structdevice.html">device</a> *ipmdev)</td></tr>
<tr class="memdesc:ga67611ee678c0c265ba07589f1b8aea68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback API to get maximum data size.  <a href="group__ipm__interface.html#ga67611ee678c0c265ba07589f1b8aea68">More...</a><br /></td></tr>
<tr class="separator:ga67611ee678c0c265ba07589f1b8aea68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa11bc35736af40ea49b7be621b09f70d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ipm__interface.html#gaa11bc35736af40ea49b7be621b09f70d">ipm_max_id_val_get_t</a>) (const struct <a class="el" href="structdevice.html">device</a> *ipmdev)</td></tr>
<tr class="memdesc:gaa11bc35736af40ea49b7be621b09f70d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback API to get the ID's maximum value.  <a href="group__ipm__interface.html#gaa11bc35736af40ea49b7be621b09f70d">More...</a><br /></td></tr>
<tr class="separator:gaa11bc35736af40ea49b7be621b09f70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga186a1c5232ad1d06908cfee1bcb9dcab"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ipm__interface.html#ga186a1c5232ad1d06908cfee1bcb9dcab">ipm_register_callback_t</a>) (const struct <a class="el" href="structdevice.html">device</a> *port, <a class="el" href="group__ipm__interface.html#gaa9dbdfd91b0fe01297792949c19e8f70">ipm_callback_t</a> cb, void *<a class="el" href="timer_2timer__api_2src_2main_8c.html#a862de962130decf51321624c10294338">user_data</a>)</td></tr>
<tr class="memdesc:ga186a1c5232ad1d06908cfee1bcb9dcab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback API upon registration.  <a href="group__ipm__interface.html#ga186a1c5232ad1d06908cfee1bcb9dcab">More...</a><br /></td></tr>
<tr class="separator:ga186a1c5232ad1d06908cfee1bcb9dcab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1db507f3e01af8258669f18b058913ad"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ipm__interface.html#ga1db507f3e01af8258669f18b058913ad">ipm_set_enabled_t</a>) (const struct <a class="el" href="structdevice.html">device</a> *ipmdev, int enable)</td></tr>
<tr class="memdesc:ga1db507f3e01af8258669f18b058913ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback API upon enablement of interrupts.  <a href="group__ipm__interface.html#ga1db507f3e01af8258669f18b058913ad">More...</a><br /></td></tr>
<tr class="separator:ga1db507f3e01af8258669f18b058913ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8f3fe21c1a4ffd3c38b67f81749af043"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ipm__interface.html#ga8f3fe21c1a4ffd3c38b67f81749af043">ipm_send</a> (const struct <a class="el" href="structdevice.html">device</a> *ipmdev, int wait, <a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> id, const void *<a class="el" href="test__stack__fail_8c.html#a4bb6fa6c719fd9021449009ab8befc04">data</a>, int size)</td></tr>
<tr class="memdesc:ga8f3fe21c1a4ffd3c38b67f81749af043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to send a message over the IPM device.  <a href="group__ipm__interface.html#ga8f3fe21c1a4ffd3c38b67f81749af043">More...</a><br /></td></tr>
<tr class="separator:ga8f3fe21c1a4ffd3c38b67f81749af043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga557b15bc8a353483ca55888dba27493b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ipm__interface.html#ga557b15bc8a353483ca55888dba27493b">ipm_register_callback</a> (const struct <a class="el" href="structdevice.html">device</a> *ipmdev, <a class="el" href="group__ipm__interface.html#gaa9dbdfd91b0fe01297792949c19e8f70">ipm_callback_t</a> cb, void *<a class="el" href="timer_2timer__api_2src_2main_8c.html#a862de962130decf51321624c10294338">user_data</a>)</td></tr>
<tr class="memdesc:ga557b15bc8a353483ca55888dba27493b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a callback function for incoming messages.  <a href="group__ipm__interface.html#ga557b15bc8a353483ca55888dba27493b">More...</a><br /></td></tr>
<tr class="separator:ga557b15bc8a353483ca55888dba27493b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a11eecaa7254575ab6baf0783a18b5e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ipm__interface.html#ga0a11eecaa7254575ab6baf0783a18b5e">ipm_max_data_size_get</a> (const struct <a class="el" href="structdevice.html">device</a> *ipmdev)</td></tr>
<tr class="memdesc:ga0a11eecaa7254575ab6baf0783a18b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum number of bytes possible in an outbound message.  <a href="group__ipm__interface.html#ga0a11eecaa7254575ab6baf0783a18b5e">More...</a><br /></td></tr>
<tr class="separator:ga0a11eecaa7254575ab6baf0783a18b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga168fd277b7819b639baa4e630c596a7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ipm__interface.html#ga168fd277b7819b639baa4e630c596a7f">ipm_max_id_val_get</a> (const struct <a class="el" href="structdevice.html">device</a> *ipmdev)</td></tr>
<tr class="memdesc:ga168fd277b7819b639baa4e630c596a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum id value possible in an outbound message.  <a href="group__ipm__interface.html#ga168fd277b7819b639baa4e630c596a7f">More...</a><br /></td></tr>
<tr class="separator:ga168fd277b7819b639baa4e630c596a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5884fa95cb38ddfe4493eb70dafebe8b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ipm__interface.html#ga5884fa95cb38ddfe4493eb70dafebe8b">ipm_set_enabled</a> (const struct <a class="el" href="structdevice.html">device</a> *ipmdev, int enable)</td></tr>
<tr class="memdesc:ga5884fa95cb38ddfe4493eb70dafebe8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable interrupts and callbacks for inbound channels.  <a href="group__ipm__interface.html#ga5884fa95cb38ddfe4493eb70dafebe8b">More...</a><br /></td></tr>
<tr class="separator:ga5884fa95cb38ddfe4493eb70dafebe8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >IPM Interface. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaa9dbdfd91b0fe01297792949c19e8f70" name="gaa9dbdfd91b0fe01297792949c19e8f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9dbdfd91b0fe01297792949c19e8f70">&#9670;&nbsp;</a></span>ipm_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ipm_callback_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="ipm_8h.html">include/drivers/ipm.h</a>&gt;</code></p>

<p>Callback API for incoming IPM messages. </p>
<p >These callbacks execute in interrupt context. Therefore, use only interrupt-safe APIS. Registration of callbacks is done via <em>ipm_register_callback</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipmdev</td><td>Driver instance </td></tr>
    <tr><td class="paramname">user_data</td><td>Pointer to some private data provided at registration time. </td></tr>
    <tr><td class="paramname">id</td><td>Message type identifier. </td></tr>
    <tr><td class="paramname">data</td><td>Message data pointer. The correct amount of data to read out must be inferred using the message id/upper level protocol. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga67611ee678c0c265ba07589f1b8aea68" name="ga67611ee678c0c265ba07589f1b8aea68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67611ee678c0c265ba07589f1b8aea68">&#9670;&nbsp;</a></span>ipm_max_data_size_get_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ipm_max_data_size_get_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="ipm_8h.html">include/drivers/ipm.h</a>&gt;</code></p>

<p>Callback API to get maximum data size. </p>
<p >See <em><a class="el" href="group__ipm__interface.html#ga0a11eecaa7254575ab6baf0783a18b5e" title="Return the maximum number of bytes possible in an outbound message.">ipm_max_data_size_get()</a></em> for argument definitions. </p>

</div>
</div>
<a id="gaa11bc35736af40ea49b7be621b09f70d" name="gaa11bc35736af40ea49b7be621b09f70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa11bc35736af40ea49b7be621b09f70d">&#9670;&nbsp;</a></span>ipm_max_id_val_get_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ipm_max_id_val_get_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="ipm_8h.html">include/drivers/ipm.h</a>&gt;</code></p>

<p>Callback API to get the ID's maximum value. </p>
<p >See <em><a class="el" href="group__ipm__interface.html#ga168fd277b7819b639baa4e630c596a7f" title="Return the maximum id value possible in an outbound message.">ipm_max_id_val_get()</a></em> for argument definitions. </p>

</div>
</div>
<a id="ga186a1c5232ad1d06908cfee1bcb9dcab" name="ga186a1c5232ad1d06908cfee1bcb9dcab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga186a1c5232ad1d06908cfee1bcb9dcab">&#9670;&nbsp;</a></span>ipm_register_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ipm_register_callback_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="ipm_8h.html">include/drivers/ipm.h</a>&gt;</code></p>

<p>Callback API upon registration. </p>
<p >See <em><a class="el" href="group__ipm__interface.html#ga557b15bc8a353483ca55888dba27493b" title="Register a callback function for incoming messages.">ipm_register_callback()</a></em> for argument definitions. </p>

</div>
</div>
<a id="ga80e6af3109598a6cb9df0b36d1cdbca7" name="ga80e6af3109598a6cb9df0b36d1cdbca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80e6af3109598a6cb9df0b36d1cdbca7">&#9670;&nbsp;</a></span>ipm_send_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ipm_send_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="ipm_8h.html">include/drivers/ipm.h</a>&gt;</code></p>

<p>Callback API to send IPM messages. </p>
<p >See <em><a class="el" href="group__ipm__interface.html#ga8f3fe21c1a4ffd3c38b67f81749af043" title="Try to send a message over the IPM device.">ipm_send()</a></em> for argument definitions. </p>

</div>
</div>
<a id="ga1db507f3e01af8258669f18b058913ad" name="ga1db507f3e01af8258669f18b058913ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1db507f3e01af8258669f18b058913ad">&#9670;&nbsp;</a></span>ipm_set_enabled_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ipm_set_enabled_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="ipm_8h.html">include/drivers/ipm.h</a>&gt;</code></p>

<p>Callback API upon enablement of interrupts. </p>
<p >See <em><a class="el" href="group__ipm__interface.html#ga5884fa95cb38ddfe4493eb70dafebe8b" title="Enable interrupts and callbacks for inbound channels.">ipm_set_enabled()</a></em> for argument definitions. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga0a11eecaa7254575ab6baf0783a18b5e" name="ga0a11eecaa7254575ab6baf0783a18b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a11eecaa7254575ab6baf0783a18b5e">&#9670;&nbsp;</a></span>ipm_max_data_size_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ipm_max_data_size_get </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>ipmdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="ipm_8h.html">include/drivers/ipm.h</a>&gt;</code></p>

<p>Return the maximum number of bytes possible in an outbound message. </p>
<p >IPM implementations vary on the amount of data that can be sent in a single message since the data payload is typically stored in registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipmdev</td><td>Driver instance pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum possible size of a message in bytes. </dd></dl>

</div>
</div>
<a id="ga168fd277b7819b639baa4e630c596a7f" name="ga168fd277b7819b639baa4e630c596a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga168fd277b7819b639baa4e630c596a7f">&#9670;&nbsp;</a></span>ipm_max_id_val_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> ipm_max_id_val_get </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>ipmdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="ipm_8h.html">include/drivers/ipm.h</a>&gt;</code></p>

<p>Return the maximum id value possible in an outbound message. </p>
<p >Many IPM implementations store the message's ID in a register with some bits reserved for other uses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipmdev</td><td>Driver instance pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum possible value of a message ID. </dd></dl>

</div>
</div>
<a id="ga557b15bc8a353483ca55888dba27493b" name="ga557b15bc8a353483ca55888dba27493b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga557b15bc8a353483ca55888dba27493b">&#9670;&nbsp;</a></span>ipm_register_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ipm_register_callback </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>ipmdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ipm__interface.html#gaa9dbdfd91b0fe01297792949c19e8f70">ipm_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="ipm_8h.html">include/drivers/ipm.h</a>&gt;</code></p>

<p>Register a callback function for incoming messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipmdev</td><td>Driver instance pointer. </td></tr>
    <tr><td class="paramname">cb</td><td>Callback function to execute on incoming message interrupts. </td></tr>
    <tr><td class="paramname">user_data</td><td>Application-specific data pointer which will be passed to the callback function when executed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8f3fe21c1a4ffd3c38b67f81749af043" name="ga8f3fe21c1a4ffd3c38b67f81749af043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f3fe21c1a4ffd3c38b67f81749af043">&#9670;&nbsp;</a></span>ipm_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ipm_send </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>ipmdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="ipm_8h.html">include/drivers/ipm.h</a>&gt;</code></p>

<p>Try to send a message over the IPM device. </p>
<p >A message is considered consumed once the remote interrupt handler finishes. If there is deferred processing on the remote side, or if outgoing messages must be queued and wait on an event/semaphore, a high-level driver can implement that.</p>
<p >There are constraints on how much data can be sent or the maximum value of id. Use the <em>ipm_max_data_size_get</em> and <em>ipm_max_id_val_get</em> routines to determine them.</p>
<p >The <em>size</em> parameter is used only on the sending side to determine the amount of data to put in the message registers. It is not passed along to the receiving side. The upper-level protocol dictates the amount of data read back.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipmdev</td><td>Driver instance </td></tr>
    <tr><td class="paramname">wait</td><td>If nonzero, busy-wait for remote to consume the message. The message is considered consumed once the remote interrupt handler finishes. If there is deferred processing on the remote side, or you would like to queue outgoing messages and wait on an event/semaphore, you can implement that in a high-level driver </td></tr>
    <tr><td class="paramname">id</td><td>Message identifier. Values are constrained by <em>ipm_max_data_size_get</em> since many boards only allow for a subset of bits in a 32-bit register to store the ID. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the data sent in the message. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-EBUSY</td><td>If the remote hasn't yet read the last data sent. </td></tr>
    <tr><td class="paramname">-EMSGSIZE</td><td>If the supplied data size is unsupported by the driver. </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>If there was a bad parameter, such as: too-large id value. or the device isn't an outbound IPM channel. </td></tr>
    <tr><td class="paramname">0</td><td>On success. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5884fa95cb38ddfe4493eb70dafebe8b" name="ga5884fa95cb38ddfe4493eb70dafebe8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5884fa95cb38ddfe4493eb70dafebe8b">&#9670;&nbsp;</a></span>ipm_set_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ipm_set_enabled </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>ipmdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="ipm_8h.html">include/drivers/ipm.h</a>&gt;</code></p>

<p>Enable interrupts and callbacks for inbound channels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipmdev</td><td>Driver instance pointer. </td></tr>
    <tr><td class="paramname">enable</td><td>Set to 0 to disable and to nonzero to enable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success. </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>If it isn't an inbound channel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Feb 21 2022 04:59:41 for Zephyr API Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
<script type="text/javascript">
  $(function() {
    toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
    toggleButton.title = "Toggle Light/Dark Mode"
    $(document).ready(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
    // every resize will remove the button, which is why it has to be added again:
    $(window).resize(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
  })
</script>
</body>
</html>
