<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zephyr API Documentation: Device Model APIs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-zephyr.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-zephyr.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Zephyr API Documentation
   &#160;<span id="projectnumber">3.0.99</span>
   </div>
   <div id="projectbrief">A Scalable Open Source RTOS</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__device__model.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Device Model APIs</div></div>
</div><!--header-->
<div class="contents">

<p>Device Model APIs.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdevice__state.html">device_state</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime device dynamic structure (in RAM) per driver instance.  <a href="structdevice__state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdevice.html">device</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime device structure (in ROM) per driver instance.  <a href="structdevice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga5f1feab331ee737141f418030902aab0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device__model.html#ga5f1feab331ee737141f418030902aab0">DEVICE_HANDLE_SEP</a>&#160;&#160;&#160;<a class="el" href="stdint_8h.html#ad4e9955955b27624963643eac448118a">INT16_MIN</a></td></tr>
<tr class="memdesc:ga5f1feab331ee737141f418030902aab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag value used in lists of device handles to separate distinct groups.  <a href="group__device__model.html#ga5f1feab331ee737141f418030902aab0">More...</a><br /></td></tr>
<tr class="separator:ga5f1feab331ee737141f418030902aab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab83f6fdc3d5d6e68facad0ddc9f3e763"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device__model.html#gab83f6fdc3d5d6e68facad0ddc9f3e763">DEVICE_HANDLE_ENDS</a>&#160;&#160;&#160;<a class="el" href="stdint_8h.html#ac58f2c111cc9989c86db2a7dc4fd84ca">INT16_MAX</a></td></tr>
<tr class="memdesc:gab83f6fdc3d5d6e68facad0ddc9f3e763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag value used in lists of device handles to indicate the end of the list.  <a href="group__device__model.html#gab83f6fdc3d5d6e68facad0ddc9f3e763">More...</a><br /></td></tr>
<tr class="separator:gab83f6fdc3d5d6e68facad0ddc9f3e763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dd918c3a59b8afa185a4851165d2ca0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device__model.html#ga4dd918c3a59b8afa185a4851165d2ca0">DEVICE_HANDLE_NULL</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga4dd918c3a59b8afa185a4851165d2ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag value used to identify an unknown device.  <a href="group__device__model.html#ga4dd918c3a59b8afa185a4851165d2ca0">More...</a><br /></td></tr>
<tr class="separator:ga4dd918c3a59b8afa185a4851165d2ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51d735464c6c80e86ebae96b0b67947b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device__model.html#ga51d735464c6c80e86ebae96b0b67947b">DEVICE_NAME_GET</a>(name)&#160;&#160;&#160;_CONCAT(__device_, name)</td></tr>
<tr class="memdesc:ga51d735464c6c80e86ebae96b0b67947b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands to the name of a global device object.  <a href="group__device__model.html#ga51d735464c6c80e86ebae96b0b67947b">More...</a><br /></td></tr>
<tr class="separator:ga51d735464c6c80e86ebae96b0b67947b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42092d245664c3d59c30ceb4776bd642"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device__model.html#ga42092d245664c3d59c30ceb4776bd642">SYS_DEVICE_DEFINE</a>(drv_name,  init_fn,  level,  prio)&#160;&#160;&#160;	__DEPRECATED_MACRO <a class="el" href="early__sleep_2src_2main_8c.html#a080adab9e7b88edfe90c6d2115d9d06e">SYS_INIT</a>(init_fn, level, prio)</td></tr>
<tr class="memdesc:ga42092d245664c3d59c30ceb4776bd642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run an initialization function at boot at specified priority.  <a href="group__device__model.html#ga42092d245664c3d59c30ceb4776bd642">More...</a><br /></td></tr>
<tr class="separator:ga42092d245664c3d59c30ceb4776bd642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad08683c204de0996ca62b23813947009"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device__model.html#gad08683c204de0996ca62b23813947009">DEVICE_DEFINE</a>(dev_name,  drv_name,  init_fn,  pm_device,  data_ptr,  cfg_ptr,  level,  prio,  api_ptr)</td></tr>
<tr class="memdesc:gad08683c204de0996ca62b23813947009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a device object and set it up for boot time initialization.  <a href="group__device__model.html#gad08683c204de0996ca62b23813947009">More...</a><br /></td></tr>
<tr class="separator:gad08683c204de0996ca62b23813947009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad864d7a50ee45285dacd68be1e5a49ce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device__model.html#gad864d7a50ee45285dacd68be1e5a49ce">DEVICE_DT_NAME</a>(node_id)&#160;&#160;&#160;	<a class="el" href="group__devicetree-generic-prop.html#ga5e5bfc9b1a6627b3f73014329e96340f">DT_PROP_OR</a>(node_id, label, <a class="el" href="group__devicetree-generic-id.html#ga8a8ab5d12fe59787433d1add94fb1667">DT_NODE_FULL_NAME</a>(node_id))</td></tr>
<tr class="memdesc:gad864d7a50ee45285dacd68be1e5a49ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string name for a devicetree node.  <a href="group__device__model.html#gad864d7a50ee45285dacd68be1e5a49ce">More...</a><br /></td></tr>
<tr class="separator:gad864d7a50ee45285dacd68be1e5a49ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac590af7705a3223968164406a483548"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device__model.html#gaac590af7705a3223968164406a483548">DEVICE_DT_DEFINE</a>(node_id,  init_fn,  pm_device,  data_ptr,  cfg_ptr,  level,  prio,  api_ptr, ...)</td></tr>
<tr class="memdesc:gaac590af7705a3223968164406a483548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a device object from a devicetree node identifier and set it up for boot time initialization.  <a href="group__device__model.html#gaac590af7705a3223968164406a483548">More...</a><br /></td></tr>
<tr class="separator:gaac590af7705a3223968164406a483548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada5ba4aca9e0662ccebb2232c7256419"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device__model.html#gada5ba4aca9e0662ccebb2232c7256419">DEVICE_DT_INST_DEFINE</a>(inst, ...)&#160;&#160;&#160;	<a class="el" href="group__device__model.html#gaac590af7705a3223968164406a483548">DEVICE_DT_DEFINE</a>(<a class="el" href="group__devicetree-inst.html#ga219f413efba2f4c0151468b9a25a8dc1">DT_DRV_INST</a>(inst), __VA_ARGS__)</td></tr>
<tr class="memdesc:gada5ba4aca9e0662ccebb2232c7256419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="group__device__model.html#gaac590af7705a3223968164406a483548" title="Create a device object from a devicetree node identifier and set it up for boot time initialization.">DEVICE_DT_DEFINE()</a>, but uses an instance of a DT_DRV_COMPAT compatible instead of a node identifier.  <a href="group__device__model.html#gada5ba4aca9e0662ccebb2232c7256419">More...</a><br /></td></tr>
<tr class="separator:gada5ba4aca9e0662ccebb2232c7256419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ebbf17ef805817aa638f36f177a1a0e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device__model.html#ga8ebbf17ef805817aa638f36f177a1a0e">DEVICE_DT_NAME_GET</a>(node_id)&#160;&#160;&#160;<a class="el" href="group__device__model.html#ga51d735464c6c80e86ebae96b0b67947b">DEVICE_NAME_GET</a>(Z_DEVICE_DT_DEV_NAME(node_id))</td></tr>
<tr class="memdesc:ga8ebbf17ef805817aa638f36f177a1a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the global device object for <code>node_id</code>.  <a href="group__device__model.html#ga8ebbf17ef805817aa638f36f177a1a0e">More...</a><br /></td></tr>
<tr class="separator:ga8ebbf17ef805817aa638f36f177a1a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a65996ce21f43acb7db061e23b48ec7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device__model.html#ga9a65996ce21f43acb7db061e23b48ec7">DEVICE_DT_GET</a>(node_id)&#160;&#160;&#160;(&amp;<a class="el" href="group__device__model.html#ga8ebbf17ef805817aa638f36f177a1a0e">DEVICE_DT_NAME_GET</a>(node_id))</td></tr>
<tr class="memdesc:ga9a65996ce21f43acb7db061e23b48ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <code>const struct device*</code> from a devicetree node identifier.  <a href="group__device__model.html#ga9a65996ce21f43acb7db061e23b48ec7">More...</a><br /></td></tr>
<tr class="separator:ga9a65996ce21f43acb7db061e23b48ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9165e550ae175ce305eafe33390af78b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device__model.html#ga9165e550ae175ce305eafe33390af78b">DEVICE_DT_INST_GET</a>(inst)&#160;&#160;&#160;<a class="el" href="group__device__model.html#ga9a65996ce21f43acb7db061e23b48ec7">DEVICE_DT_GET</a>(<a class="el" href="group__devicetree-inst.html#ga219f413efba2f4c0151468b9a25a8dc1">DT_DRV_INST</a>(inst))</td></tr>
<tr class="memdesc:ga9165e550ae175ce305eafe33390af78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <code>const struct device*</code> for an instance of a DT_DRV_COMPAT compatible.  <a href="group__device__model.html#ga9165e550ae175ce305eafe33390af78b">More...</a><br /></td></tr>
<tr class="separator:ga9165e550ae175ce305eafe33390af78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadf3ffb63df544eb3de356ab2c5e9e3c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device__model.html#gaadf3ffb63df544eb3de356ab2c5e9e3c">DEVICE_DT_GET_ANY</a>(compat)</td></tr>
<tr class="memdesc:gaadf3ffb63df544eb3de356ab2c5e9e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <code>const struct device*</code> from a devicetree compatible.  <a href="group__device__model.html#gaadf3ffb63df544eb3de356ab2c5e9e3c">More...</a><br /></td></tr>
<tr class="separator:gaadf3ffb63df544eb3de356ab2c5e9e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39c760429534ef9ae77f3d996987cd2b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device__model.html#ga39c760429534ef9ae77f3d996987cd2b">DEVICE_DT_GET_ONE</a>(compat)</td></tr>
<tr class="memdesc:ga39c760429534ef9ae77f3d996987cd2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <code>const struct device*</code> from a devicetree compatible.  <a href="group__device__model.html#ga39c760429534ef9ae77f3d996987cd2b">More...</a><br /></td></tr>
<tr class="separator:ga39c760429534ef9ae77f3d996987cd2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ce1dbfda6847ca6c3858712e9b41989"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device__model.html#ga6ce1dbfda6847ca6c3858712e9b41989">DEVICE_DT_GET_OR_NULL</a>(node_id)</td></tr>
<tr class="memdesc:ga6ce1dbfda6847ca6c3858712e9b41989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility macro to obtain an optional reference to a device.  <a href="group__device__model.html#ga6ce1dbfda6847ca6c3858712e9b41989">More...</a><br /></td></tr>
<tr class="separator:ga6ce1dbfda6847ca6c3858712e9b41989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78e63e230be7dfe525a2de03e503be53"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device__model.html#ga78e63e230be7dfe525a2de03e503be53">DEVICE_GET</a>(name)&#160;&#160;&#160;(&amp;<a class="el" href="group__device__model.html#ga51d735464c6c80e86ebae96b0b67947b">DEVICE_NAME_GET</a>(name))</td></tr>
<tr class="memdesc:ga78e63e230be7dfe525a2de03e503be53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a pointer to a device object by name.  <a href="group__device__model.html#ga78e63e230be7dfe525a2de03e503be53">More...</a><br /></td></tr>
<tr class="separator:ga78e63e230be7dfe525a2de03e503be53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d8d574ffe22938ca58dcb74bf289428"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device__model.html#ga5d8d574ffe22938ca58dcb74bf289428">DEVICE_DECLARE</a>(name)&#160;&#160;&#160;static const struct <a class="el" href="structdevice.html">device</a> <a class="el" href="group__device__model.html#ga51d735464c6c80e86ebae96b0b67947b">DEVICE_NAME_GET</a>(name)</td></tr>
<tr class="memdesc:ga5d8d574ffe22938ca58dcb74bf289428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a static device object.  <a href="group__device__model.html#ga5d8d574ffe22938ca58dcb74bf289428">More...</a><br /></td></tr>
<tr class="separator:ga5d8d574ffe22938ca58dcb74bf289428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e50fdff086356a75b0e91179952cc8d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device__model.html#ga1e50fdff086356a75b0e91179952cc8d">SYS_INIT</a>(_init_fn,  _level,  _prio)&#160;&#160;&#160;	Z_INIT_ENTRY_DEFINE(Z_SYS_NAME(_init_fn), _init_fn, NULL, _level, _prio)</td></tr>
<tr class="memdesc:ga1e50fdff086356a75b0e91179952cc8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run an initialization function at boot at specified priority.  <a href="group__device__model.html#ga1e50fdff086356a75b0e91179952cc8d">More...</a><br /></td></tr>
<tr class="separator:ga1e50fdff086356a75b0e91179952cc8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga21415b8e9967ecd2c3d3d3b1724f93c3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="stdint_8h.html#afe270aee8d96ad7f279a4020b9d58bdf">int16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device__model.html#ga21415b8e9967ecd2c3d3d3b1724f93c3">device_handle_t</a></td></tr>
<tr class="memdesc:ga21415b8e9967ecd2c3d3d3b1724f93c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to represent a "handle" for a device.  <a href="group__device__model.html#ga21415b8e9967ecd2c3d3d3b1724f93c3">More...</a><br /></td></tr>
<tr class="separator:ga21415b8e9967ecd2c3d3d3b1724f93c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a1118e5c76c44c998f7258a7de0bfbb"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device__model.html#ga9a1118e5c76c44c998f7258a7de0bfbb">device_visitor_callback_t</a>) (const struct <a class="el" href="structdevice.html">device</a> *dev, void *context)</td></tr>
<tr class="memdesc:ga9a1118e5c76c44c998f7258a7de0bfbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prototype for functions used when iterating over a set of devices.  <a href="group__device__model.html#ga9a1118e5c76c44c998f7258a7de0bfbb">More...</a><br /></td></tr>
<tr class="separator:ga9a1118e5c76c44c998f7258a7de0bfbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga456366a9ca0a8e97484c97c279745203"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__device__model.html#ga21415b8e9967ecd2c3d3d3b1724f93c3">device_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device__model.html#ga456366a9ca0a8e97484c97c279745203">device_handle_get</a> (const struct <a class="el" href="structdevice.html">device</a> *dev)</td></tr>
<tr class="memdesc:ga456366a9ca0a8e97484c97c279745203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the handle for a given device.  <a href="group__device__model.html#ga456366a9ca0a8e97484c97c279745203">More...</a><br /></td></tr>
<tr class="separator:ga456366a9ca0a8e97484c97c279745203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73680daef9f8d7dc2541d83d09737f4a"><td class="memItemLeft" align="right" valign="top">static const struct <a class="el" href="structdevice.html">device</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device__model.html#ga73680daef9f8d7dc2541d83d09737f4a">device_from_handle</a> (<a class="el" href="group__device__model.html#ga21415b8e9967ecd2c3d3d3b1724f93c3">device_handle_t</a> dev_handle)</td></tr>
<tr class="memdesc:ga73680daef9f8d7dc2541d83d09737f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device corresponding to a handle.  <a href="group__device__model.html#ga73680daef9f8d7dc2541d83d09737f4a">More...</a><br /></td></tr>
<tr class="separator:ga73680daef9f8d7dc2541d83d09737f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2157bbfc2deecfae6514f58221663618"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="group__device__model.html#ga21415b8e9967ecd2c3d3d3b1724f93c3">device_handle_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device__model.html#ga2157bbfc2deecfae6514f58221663618">device_required_handles_get</a> (const struct <a class="el" href="structdevice.html">device</a> *dev, size_t *<a class="el" href="semaphore_2sys__sem_2src_2main_8c.html#a7624b580dc5672d7564cdc73212de784">count</a>)</td></tr>
<tr class="memdesc:ga2157bbfc2deecfae6514f58221663618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device handles for devicetree dependencies of this device.  <a href="group__device__model.html#ga2157bbfc2deecfae6514f58221663618">More...</a><br /></td></tr>
<tr class="separator:ga2157bbfc2deecfae6514f58221663618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c9ae15d3224c792b915b107b2d5d00f"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="group__device__model.html#ga21415b8e9967ecd2c3d3d3b1724f93c3">device_handle_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device__model.html#ga3c9ae15d3224c792b915b107b2d5d00f">device_supported_handles_get</a> (const struct <a class="el" href="structdevice.html">device</a> *dev, size_t *<a class="el" href="semaphore_2sys__sem_2src_2main_8c.html#a7624b580dc5672d7564cdc73212de784">count</a>)</td></tr>
<tr class="memdesc:ga3c9ae15d3224c792b915b107b2d5d00f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the set of handles that this device supports.  <a href="group__device__model.html#ga3c9ae15d3224c792b915b107b2d5d00f">More...</a><br /></td></tr>
<tr class="separator:ga3c9ae15d3224c792b915b107b2d5d00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e3b6dbb15ca28d6c94ee07702663245"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device__model.html#ga6e3b6dbb15ca28d6c94ee07702663245">device_required_foreach</a> (const struct <a class="el" href="structdevice.html">device</a> *dev, <a class="el" href="group__device__model.html#ga9a1118e5c76c44c998f7258a7de0bfbb">device_visitor_callback_t</a> visitor_cb, void *context)</td></tr>
<tr class="memdesc:ga6e3b6dbb15ca28d6c94ee07702663245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visit every device that <code>dev</code> directly requires.  <a href="group__device__model.html#ga6e3b6dbb15ca28d6c94ee07702663245">More...</a><br /></td></tr>
<tr class="separator:ga6e3b6dbb15ca28d6c94ee07702663245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5fce5e93fd6d5e13aa8b20251b82b2a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device__model.html#gaf5fce5e93fd6d5e13aa8b20251b82b2a">device_supported_foreach</a> (const struct <a class="el" href="structdevice.html">device</a> *dev, <a class="el" href="group__device__model.html#ga9a1118e5c76c44c998f7258a7de0bfbb">device_visitor_callback_t</a> visitor_cb, void *context)</td></tr>
<tr class="memdesc:gaf5fce5e93fd6d5e13aa8b20251b82b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visit every device that <code>dev</code> directly supports.  <a href="group__device__model.html#gaf5fce5e93fd6d5e13aa8b20251b82b2a">More...</a><br /></td></tr>
<tr class="separator:gaf5fce5e93fd6d5e13aa8b20251b82b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15386ca9ab38f3e30183c18f604fa835"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device__model.html#ga15386ca9ab38f3e30183c18f604fa835">device_get_binding</a> (const char *name)</td></tr>
<tr class="memdesc:ga15386ca9ab38f3e30183c18f604fa835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <code>const struct device*</code> from its <code>name</code> field.  <a href="group__device__model.html#ga15386ca9ab38f3e30183c18f604fa835">More...</a><br /></td></tr>
<tr class="separator:ga15386ca9ab38f3e30183c18f604fa835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4944bd850e90cbd52b0489f9b12edfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device__model.html#gaa4944bd850e90cbd52b0489f9b12edfb">device_is_ready</a> (const struct <a class="el" href="structdevice.html">device</a> *dev)</td></tr>
<tr class="memdesc:gaa4944bd850e90cbd52b0489f9b12edfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that a device is ready for use.  <a href="group__device__model.html#gaa4944bd850e90cbd52b0489f9b12edfb">More...</a><br /></td></tr>
<tr class="separator:gaa4944bd850e90cbd52b0489f9b12edfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga233b32dc38630069c1aee973fa52416e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device__model.html#ga233b32dc38630069c1aee973fa52416e">device_usable_check</a> (const struct <a class="el" href="structdevice.html">device</a> *dev)</td></tr>
<tr class="memdesc:ga233b32dc38630069c1aee973fa52416e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a device is ready for use.  <a href="group__device__model.html#ga233b32dc38630069c1aee973fa52416e">More...</a><br /></td></tr>
<tr class="separator:ga233b32dc38630069c1aee973fa52416e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Device Model APIs. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga5d8d574ffe22938ca58dcb74bf289428" name="ga5d8d574ffe22938ca58dcb74bf289428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d8d574ffe22938ca58dcb74bf289428">&#9670;&nbsp;</a></span>DEVICE_DECLARE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEVICE_DECLARE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name</td><td>)</td>
          <td>&#160;&#160;&#160;static const struct <a class="el" href="structdevice.html">device</a> <a class="el" href="group__device__model.html#ga51d735464c6c80e86ebae96b0b67947b">DEVICE_NAME_GET</a>(name)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="device_8h.html">include/device.h</a>&gt;</code></p>

<p>Declare a static device object. </p>
<p >This macro can be used at the top-level to declare a device, such that <a class="el" href="group__device__model.html#ga78e63e230be7dfe525a2de03e503be53" title="Obtain a pointer to a device object by name.">DEVICE_GET()</a> may be used before the full declaration in <a class="el" href="group__device__model.html#gad08683c204de0996ca62b23813947009" title="Create a device object and set it up for boot time initialization.">DEVICE_DEFINE()</a>.</p>
<p >This is often useful when configuring interrupts statically in a device's init or per-instance config function, as the init function itself is required by <a class="el" href="group__device__model.html#gad08683c204de0996ca62b23813947009" title="Create a device object and set it up for boot time initialization.">DEVICE_DEFINE()</a> and use of <a class="el" href="group__device__model.html#ga78e63e230be7dfe525a2de03e503be53" title="Obtain a pointer to a device object by name.">DEVICE_GET()</a> inside it creates a circular dependency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Device name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad08683c204de0996ca62b23813947009" name="gad08683c204de0996ca62b23813947009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad08683c204de0996ca62b23813947009">&#9670;&nbsp;</a></span>DEVICE_DEFINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEVICE_DEFINE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dev_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">drv_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">init_fn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pm_device, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cfg_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">level, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">prio, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">api_ptr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="device_8h.html">include/device.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">        Z_DEVICE_STATE_DEFINE(<a class="code hl_define" href="group__devicetree-generic-id.html#ga710cc4455dd7e738f43f750153163855">DT_INVALID_NODE</a>, dev_name) \</div>
<div class="line">        Z_DEVICE_DEFINE(<a class="code hl_define" href="group__devicetree-generic-id.html#ga710cc4455dd7e738f43f750153163855">DT_INVALID_NODE</a>, dev_name, drv_name, init_fn,   \</div>
<div class="line">                        pm_device,                                      \</div>
<div class="line">                        data_ptr, cfg_ptr, level, prio, api_ptr,        \</div>
<div class="line">                        &amp;Z_DEVICE_STATE_NAME(dev_name))</div>
<div class="ttc" id="agroup__devicetree-generic-id_html_ga710cc4455dd7e738f43f750153163855"><div class="ttname"><a href="group__devicetree-generic-id.html#ga710cc4455dd7e738f43f750153163855">DT_INVALID_NODE</a></div><div class="ttdeci">#define DT_INVALID_NODE</div><div class="ttdoc">Name for an invalid node identifier.</div><div class="ttdef"><b>Definition:</b> devicetree.h:76</div></div>
</div><!-- fragment -->
<p>Create a device object and set it up for boot time initialization. </p>
<p >This macro defines a <code>struct device</code> that is automatically configured by the kernel during system initialization. This macro should only be used when the device is not being allocated from a devicetree node. If you are allocating a device from a devicetree node, use <a class="el" href="group__device__model.html#gaac590af7705a3223968164406a483548" title="Create a device object from a devicetree node identifier and set it up for boot time initialization.">DEVICE_DT_DEFINE()</a> or <a class="el" href="group__device__model.html#gada5ba4aca9e0662ccebb2232c7256419" title="Like DEVICE_DT_DEFINE(), but uses an instance of a DT_DRV_COMPAT compatible instead of a node identif...">DEVICE_DT_INST_DEFINE()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_name</td><td>A unique token which is used in the name of the global device structure as a C identifier.</td></tr>
    <tr><td class="paramname">drv_name</td><td>A string name for the device, which will be stored in the device structure's <code>name</code> field. This name can be used to look up the device with <a class="el" href="group__device__model.html#ga15386ca9ab38f3e30183c18f604fa835" title="Get a const struct device* from its name field.">device_get_binding()</a>. This must be less than Z_DEVICE_MAX_NAME_LEN characters (including terminating NUL) in order to be looked up from user mode.</td></tr>
    <tr><td class="paramname">init_fn</td><td>Pointer to the device's initialization function, which will be run by the kernel during system initialization.</td></tr>
    <tr><td class="paramname">pm_device</td><td>Pointer to the device's power management resources, a <code>struct pm_device</code>, which will be stored in the device structure's <code>pm</code> field. Use NULL if the device does not use PM.</td></tr>
    <tr><td class="paramname">data_ptr</td><td>Pointer to the device's private mutable data, which will be stored in the device structure's <code>data</code> field.</td></tr>
    <tr><td class="paramname">cfg_ptr</td><td>Pointer to the device's private constant data, which will be stored in the device structure's <code>config</code> field.</td></tr>
    <tr><td class="paramname">level</td><td>The device's initialization level. See <a class="el" href="group__device__model.html#ga1e50fdff086356a75b0e91179952cc8d" title="Run an initialization function at boot at specified priority.">SYS_INIT()</a> for details.</td></tr>
    <tr><td class="paramname">prio</td><td>The device's priority within its initialization level. See <a class="el" href="group__device__model.html#ga1e50fdff086356a75b0e91179952cc8d" title="Run an initialization function at boot at specified priority.">SYS_INIT()</a> for details.</td></tr>
    <tr><td class="paramname">api_ptr</td><td>Pointer to the device's API structure. Can be NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaac590af7705a3223968164406a483548" name="gaac590af7705a3223968164406a483548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac590af7705a3223968164406a483548">&#9670;&nbsp;</a></span>DEVICE_DT_DEFINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEVICE_DT_DEFINE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">init_fn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pm_device, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cfg_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">level, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">prio, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">api_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="device_8h.html">include/device.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">        Z_DEVICE_STATE_DEFINE(node_id, Z_DEVICE_DT_DEV_NAME(node_id)) \</div>
<div class="line">        Z_DEVICE_DEFINE(node_id, Z_DEVICE_DT_DEV_NAME(node_id),         \</div>
<div class="line">                        <a class="code hl_define" href="group__device__model.html#gad864d7a50ee45285dacd68be1e5a49ce">DEVICE_DT_NAME</a>(node_id), init_fn,               \</div>
<div class="line">                        pm_device,                                      \</div>
<div class="line">                        data_ptr, cfg_ptr, level, prio,                 \</div>
<div class="line">                        api_ptr,                                        \</div>
<div class="line">                        &amp;Z_DEVICE_STATE_NAME(Z_DEVICE_DT_DEV_NAME(node_id)),    \</div>
<div class="line">                        __VA_ARGS__)</div>
<div class="ttc" id="agroup__device__model_html_gad864d7a50ee45285dacd68be1e5a49ce"><div class="ttname"><a href="group__device__model.html#gad864d7a50ee45285dacd68be1e5a49ce">DEVICE_DT_NAME</a></div><div class="ttdeci">#define DEVICE_DT_NAME(node_id)</div><div class="ttdoc">Return a string name for a devicetree node.</div><div class="ttdef"><b>Definition:</b> device.h:202</div></div>
</div><!-- fragment -->
<p>Create a device object from a devicetree node identifier and set it up for boot time initialization. </p>
<p >This macro defines a <code>struct device</code> that is automatically configured by the kernel during system initialization. The global device object's name as a C identifier is derived from the node's dependency ordinal. The device structure's <code>name</code> field is set to <code><a class="el" href="group__device__model.html#gad864d7a50ee45285dacd68be1e5a49ce" title="Return a string name for a devicetree node.">DEVICE_DT_NAME(node_id)</a></code>.</p>
<p >The device is declared with extern visibility, so a pointer to a global device object can be obtained with <code><a class="el" href="group__device__model.html#ga9a65996ce21f43acb7db061e23b48ec7" title="Get a const struct device* from a devicetree node identifier.">DEVICE_DT_GET(node_id)</a></code> from any source file that includes device.h. Before using the pointer, the referenced object should be checked using <a class="el" href="group__device__model.html#gaa4944bd850e90cbd52b0489f9b12edfb" title="Verify that a device is ready for use.">device_is_ready()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_id</td><td>The devicetree node identifier.</td></tr>
    <tr><td class="paramname">init_fn</td><td>Pointer to the device's initialization function, which will be run by the kernel during system initialization.</td></tr>
    <tr><td class="paramname">pm_device</td><td>Pointer to the device's power management resources, a <code>struct pm_device</code>, which will be stored in the device structure's <code>pm</code> field. Use NULL if the device does not use PM.</td></tr>
    <tr><td class="paramname">data_ptr</td><td>Pointer to the device's private mutable data, which will be stored in the device structure's <code>data</code> field.</td></tr>
    <tr><td class="paramname">cfg_ptr</td><td>Pointer to the device's private constant data, which will be stored in the device structure's <code>config</code> field.</td></tr>
    <tr><td class="paramname">level</td><td>The device's initialization level. See <a class="el" href="group__device__model.html#ga1e50fdff086356a75b0e91179952cc8d" title="Run an initialization function at boot at specified priority.">SYS_INIT()</a> for details.</td></tr>
    <tr><td class="paramname">prio</td><td>The device's priority within its initialization level. See <a class="el" href="group__device__model.html#ga1e50fdff086356a75b0e91179952cc8d" title="Run an initialization function at boot at specified priority.">SYS_INIT()</a> for details.</td></tr>
    <tr><td class="paramname">api_ptr</td><td>Pointer to the device's API structure. Can be NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9a65996ce21f43acb7db061e23b48ec7" name="ga9a65996ce21f43acb7db061e23b48ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a65996ce21f43acb7db061e23b48ec7">&#9670;&nbsp;</a></span>DEVICE_DT_GET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEVICE_DT_GET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_id</td><td>)</td>
          <td>&#160;&#160;&#160;(&amp;<a class="el" href="group__device__model.html#ga8ebbf17ef805817aa638f36f177a1a0e">DEVICE_DT_NAME_GET</a>(node_id))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="device_8h.html">include/device.h</a>&gt;</code></p>

<p>Get a <code>const struct device*</code> from a devicetree node identifier. </p>
<p >Returns a pointer to a device object created from a devicetree node, if any device was allocated by a driver.</p>
<p >If no such device was allocated, this will fail at linker time. If you get an error that looks like <code>undefined reference to __device_dts_ord_&lt;N&gt;</code>, that is what happened. Check to make sure your device driver is being compiled, usually by enabling the Kconfig options it requires.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_id</td><td>A devicetree node identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the device object created for that node </dd></dl>

</div>
</div>
<a id="gaadf3ffb63df544eb3de356ab2c5e9e3c" name="gaadf3ffb63df544eb3de356ab2c5e9e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadf3ffb63df544eb3de356ab2c5e9e3c">&#9670;&nbsp;</a></span>DEVICE_DT_GET_ANY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEVICE_DT_GET_ANY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">compat</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="device_8h.html">include/device.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">        <a class="code hl_define" href="group__sys-util.html#ga358bc3e7669c860a98839a51cd526b20">COND_CODE_1</a>(<a class="code hl_define" href="group__devicetree-generic-exist.html#ga916e11b66fdaab46e93c25241b62b52a">DT_HAS_COMPAT_STATUS_OKAY</a>(compat),                      \</div>
<div class="line">                    (<a class="code hl_define" href="group__device__model.html#ga9a65996ce21f43acb7db061e23b48ec7">DEVICE_DT_GET</a>(<a class="code hl_define" href="group__devicetree-generic-id.html#ga4858c378b098dcb7c35de1db25442acc">DT_COMPAT_GET_ANY_STATUS_OKAY</a>(compat))), \</div>
<div class="line">                    (NULL))</div>
<div class="ttc" id="agroup__device__model_html_ga9a65996ce21f43acb7db061e23b48ec7"><div class="ttname"><a href="group__device__model.html#ga9a65996ce21f43acb7db061e23b48ec7">DEVICE_DT_GET</a></div><div class="ttdeci">#define DEVICE_DT_GET(node_id)</div><div class="ttdoc">Get a const struct device* from a devicetree node identifier.</div><div class="ttdef"><b>Definition:</b> device.h:311</div></div>
<div class="ttc" id="agroup__devicetree-generic-exist_html_ga916e11b66fdaab46e93c25241b62b52a"><div class="ttname"><a href="group__devicetree-generic-exist.html#ga916e11b66fdaab46e93c25241b62b52a">DT_HAS_COMPAT_STATUS_OKAY</a></div><div class="ttdeci">#define DT_HAS_COMPAT_STATUS_OKAY(compat)</div><div class="ttdoc">Does the devicetree have a status &quot;okay&quot; node with a compatible?</div><div class="ttdef"><b>Definition:</b> devicetree.h:2117</div></div>
<div class="ttc" id="agroup__devicetree-generic-id_html_ga4858c378b098dcb7c35de1db25442acc"><div class="ttname"><a href="group__devicetree-generic-id.html#ga4858c378b098dcb7c35de1db25442acc">DT_COMPAT_GET_ANY_STATUS_OKAY</a></div><div class="ttdeci">#define DT_COMPAT_GET_ANY_STATUS_OKAY(compat)</div><div class="ttdoc">Get a node identifier for a status &quot;okay&quot; node with a compatible.</div><div class="ttdef"><b>Definition:</b> devicetree.h:425</div></div>
<div class="ttc" id="agroup__sys-util_html_ga358bc3e7669c860a98839a51cd526b20"><div class="ttname"><a href="group__sys-util.html#ga358bc3e7669c860a98839a51cd526b20">COND_CODE_1</a></div><div class="ttdeci">#define COND_CODE_1(_flag, _if_1_code, _else_code)</div><div class="ttdoc">Insert code depending on whether _flag expands to 1 or not.</div><div class="ttdef"><b>Definition:</b> util_macro.h:156</div></div>
</div><!-- fragment -->
<p>Get a <code>const struct device*</code> from a devicetree compatible. </p>
<p >If an enabled devicetree node has the given compatible and a device object was created from it, this returns a pointer to that device.</p>
<p >If there no such devices, this returns NULL.</p>
<p >If there are multiple, this returns an arbitrary one.</p>
<p >If this returns non-NULL, the device must be checked for readiness before use, e.g. with <a class="el" href="group__device__model.html#gaa4944bd850e90cbd52b0489f9b12edfb" title="Verify that a device is ready for use.">device_is_ready()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compat</td><td>lowercase-and-underscores devicetree compatible </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a device, or NULL </dd></dl>

</div>
</div>
<a id="ga39c760429534ef9ae77f3d996987cd2b" name="ga39c760429534ef9ae77f3d996987cd2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39c760429534ef9ae77f3d996987cd2b">&#9670;&nbsp;</a></span>DEVICE_DT_GET_ONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEVICE_DT_GET_ONE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">compat</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="device_8h.html">include/device.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">        <a class="code hl_define" href="group__sys-util.html#ga358bc3e7669c860a98839a51cd526b20">COND_CODE_1</a>(<a class="code hl_define" href="group__devicetree-generic-exist.html#ga916e11b66fdaab46e93c25241b62b52a">DT_HAS_COMPAT_STATUS_OKAY</a>(compat),                      \</div>
<div class="line">                    (<a class="code hl_define" href="group__device__model.html#ga9a65996ce21f43acb7db061e23b48ec7">DEVICE_DT_GET</a>(<a class="code hl_define" href="group__devicetree-generic-id.html#ga4858c378b098dcb7c35de1db25442acc">DT_COMPAT_GET_ANY_STATUS_OKAY</a>(compat))), \</div>
<div class="line">                    (<a class="code hl_define" href="group__sys-util.html#ga831cb8468911b8ebdb9b42682778e53d">ZERO_OR_COMPILE_ERROR</a>(0)))</div>
<div class="ttc" id="agroup__sys-util_html_ga831cb8468911b8ebdb9b42682778e53d"><div class="ttname"><a href="group__sys-util.html#ga831cb8468911b8ebdb9b42682778e53d">ZERO_OR_COMPILE_ERROR</a></div><div class="ttdeci">#define ZERO_OR_COMPILE_ERROR(cond)</div><div class="ttdoc">0 if cond is true-ish; causes a compile error otherwise.</div><div class="ttdef"><b>Definition:</b> util.h:78</div></div>
</div><!-- fragment -->
<p>Get a <code>const struct device*</code> from a devicetree compatible. </p>
<p >If an enabled devicetree node has the given compatible and a device object was created from it, this returns a pointer to that device.</p>
<p >If there no such devices, this will fail at compile time.</p>
<p >If there are multiple, this returns an arbitrary one.</p>
<p >If this returns non-NULL, the device must be checked for readiness before use, e.g. with <a class="el" href="group__device__model.html#gaa4944bd850e90cbd52b0489f9b12edfb" title="Verify that a device is ready for use.">device_is_ready()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compat</td><td>lowercase-and-underscores devicetree compatible </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a device </dd></dl>

</div>
</div>
<a id="ga6ce1dbfda6847ca6c3858712e9b41989" name="ga6ce1dbfda6847ca6c3858712e9b41989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ce1dbfda6847ca6c3858712e9b41989">&#9670;&nbsp;</a></span>DEVICE_DT_GET_OR_NULL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEVICE_DT_GET_OR_NULL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_id</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="device_8h.html">include/device.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">        <a class="code hl_define" href="group__sys-util.html#ga358bc3e7669c860a98839a51cd526b20">COND_CODE_1</a>(<a class="code hl_define" href="group__devicetree-generic-exist.html#ga3b769d8105c7679e1d0575a1e7f1f653">DT_NODE_HAS_STATUS</a>(node_id, okay),                  \</div>
<div class="line">                    (<a class="code hl_define" href="group__device__model.html#ga9a65996ce21f43acb7db061e23b48ec7">DEVICE_DT_GET</a>(node_id)), (NULL))</div>
<div class="ttc" id="agroup__devicetree-generic-exist_html_ga3b769d8105c7679e1d0575a1e7f1f653"><div class="ttname"><a href="group__devicetree-generic-exist.html#ga3b769d8105c7679e1d0575a1e7f1f653">DT_NODE_HAS_STATUS</a></div><div class="ttdeci">#define DT_NODE_HAS_STATUS(node_id, status)</div><div class="ttdoc">Does a node identifier refer to a node with a status?</div><div class="ttdef"><b>Definition:</b> devicetree.h:2097</div></div>
</div><!-- fragment -->
<p>Utility macro to obtain an optional reference to a device. </p>
<p >If the node identifier refers to a node with status "okay", this returns <code><a class="el" href="group__device__model.html#ga9a65996ce21f43acb7db061e23b48ec7" title="Get a const struct device* from a devicetree node identifier.">DEVICE_DT_GET(node_id)</a></code>. Otherwise, it returns NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_id</td><td>devicetree node identifier</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <code>const struct device*</code> for the node identifier, which may be NULL. </dd></dl>

</div>
</div>
<a id="gada5ba4aca9e0662ccebb2232c7256419" name="gada5ba4aca9e0662ccebb2232c7256419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada5ba4aca9e0662ccebb2232c7256419">&#9670;&nbsp;</a></span>DEVICE_DT_INST_DEFINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEVICE_DT_INST_DEFINE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">inst, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;	<a class="el" href="group__device__model.html#gaac590af7705a3223968164406a483548">DEVICE_DT_DEFINE</a>(<a class="el" href="group__devicetree-inst.html#ga219f413efba2f4c0151468b9a25a8dc1">DT_DRV_INST</a>(inst), __VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="device_8h.html">include/device.h</a>&gt;</code></p>

<p>Like <a class="el" href="group__device__model.html#gaac590af7705a3223968164406a483548" title="Create a device object from a devicetree node identifier and set it up for boot time initialization.">DEVICE_DT_DEFINE()</a>, but uses an instance of a DT_DRV_COMPAT compatible instead of a node identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inst</td><td>instance number. The <code>node_id</code> argument to DEVICE_DT_DEFINE is set to <code><a class="el" href="group__devicetree-inst.html#ga219f413efba2f4c0151468b9a25a8dc1" title="Node identifier for an instance of a DT_DRV_COMPAT compatible.">DT_DRV_INST(inst)</a></code>.</td></tr>
    <tr><td class="paramname">...</td><td>other parameters as expected by DEVICE_DT_DEFINE. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9165e550ae175ce305eafe33390af78b" name="ga9165e550ae175ce305eafe33390af78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9165e550ae175ce305eafe33390af78b">&#9670;&nbsp;</a></span>DEVICE_DT_INST_GET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEVICE_DT_INST_GET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">inst</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__device__model.html#ga9a65996ce21f43acb7db061e23b48ec7">DEVICE_DT_GET</a>(<a class="el" href="group__devicetree-inst.html#ga219f413efba2f4c0151468b9a25a8dc1">DT_DRV_INST</a>(inst))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="device_8h.html">include/device.h</a>&gt;</code></p>

<p>Get a <code>const struct device*</code> for an instance of a DT_DRV_COMPAT compatible. </p>
<p >This is equivalent to <code><a class="el" href="group__device__model.html#ga9a65996ce21f43acb7db061e23b48ec7" title="Get a const struct device* from a devicetree node identifier.">DEVICE_DT_GET(DT_DRV_INST(inst))</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inst</td><td>DT_DRV_COMPAT instance number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the device object created for that instance </dd></dl>

</div>
</div>
<a id="gad864d7a50ee45285dacd68be1e5a49ce" name="gad864d7a50ee45285dacd68be1e5a49ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad864d7a50ee45285dacd68be1e5a49ce">&#9670;&nbsp;</a></span>DEVICE_DT_NAME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEVICE_DT_NAME</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_id</td><td>)</td>
          <td>&#160;&#160;&#160;	<a class="el" href="group__devicetree-generic-prop.html#ga5e5bfc9b1a6627b3f73014329e96340f">DT_PROP_OR</a>(node_id, label, <a class="el" href="group__devicetree-generic-id.html#ga8a8ab5d12fe59787433d1add94fb1667">DT_NODE_FULL_NAME</a>(node_id))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="device_8h.html">include/device.h</a>&gt;</code></p>

<p>Return a string name for a devicetree node. </p>
<p >This macro returns a string literal usable as a device's <code>name</code> field from a devicetree node identifier.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_id</td><td>The devicetree node identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the node's "label" property, if it has one. Otherwise, the node's full name in "node-name@@unit-address" form. </dd></dl>

</div>
</div>
<a id="ga8ebbf17ef805817aa638f36f177a1a0e" name="ga8ebbf17ef805817aa638f36f177a1a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ebbf17ef805817aa638f36f177a1a0e">&#9670;&nbsp;</a></span>DEVICE_DT_NAME_GET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEVICE_DT_NAME_GET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_id</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__device__model.html#ga51d735464c6c80e86ebae96b0b67947b">DEVICE_NAME_GET</a>(Z_DEVICE_DT_DEV_NAME(node_id))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="device_8h.html">include/device.h</a>&gt;</code></p>

<p>The name of the global device object for <code>node_id</code>. </p>
<p >Returns the name of the global device structure as a C identifier. The device must be allocated using <a class="el" href="group__device__model.html#gaac590af7705a3223968164406a483548" title="Create a device object from a devicetree node identifier and set it up for boot time initialization.">DEVICE_DT_DEFINE()</a> or <a class="el" href="group__device__model.html#gada5ba4aca9e0662ccebb2232c7256419" title="Like DEVICE_DT_DEFINE(), but uses an instance of a DT_DRV_COMPAT compatible instead of a node identif...">DEVICE_DT_INST_DEFINE()</a> for this to work.</p>
<p >This macro is normally only useful within device driver source code. In other situations, you are probably looking for <a class="el" href="group__device__model.html#ga9a65996ce21f43acb7db061e23b48ec7" title="Get a const struct device* from a devicetree node identifier.">DEVICE_DT_GET()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_id</td><td>Devicetree node identifier</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The name of the device object as a C identifier </dd></dl>

</div>
</div>
<a id="ga78e63e230be7dfe525a2de03e503be53" name="ga78e63e230be7dfe525a2de03e503be53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78e63e230be7dfe525a2de03e503be53">&#9670;&nbsp;</a></span>DEVICE_GET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEVICE_GET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name</td><td>)</td>
          <td>&#160;&#160;&#160;(&amp;<a class="el" href="group__device__model.html#ga51d735464c6c80e86ebae96b0b67947b">DEVICE_NAME_GET</a>(name))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="device_8h.html">include/device.h</a>&gt;</code></p>

<p>Obtain a pointer to a device object by name. </p>
<p >Return the address of a device object created by <a class="el" href="group__device__model.html#gad08683c204de0996ca62b23813947009" title="Create a device object and set it up for boot time initialization.">DEVICE_DEFINE()</a>, using the dev_name provided to <a class="el" href="group__device__model.html#gad08683c204de0996ca62b23813947009" title="Create a device object and set it up for boot time initialization.">DEVICE_DEFINE()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The same as dev_name provided to <a class="el" href="group__device__model.html#gad08683c204de0996ca62b23813947009" title="Create a device object and set it up for boot time initialization.">DEVICE_DEFINE()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the device object created by <a class="el" href="group__device__model.html#gad08683c204de0996ca62b23813947009" title="Create a device object and set it up for boot time initialization.">DEVICE_DEFINE()</a> </dd></dl>

</div>
</div>
<a id="gab83f6fdc3d5d6e68facad0ddc9f3e763" name="gab83f6fdc3d5d6e68facad0ddc9f3e763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab83f6fdc3d5d6e68facad0ddc9f3e763">&#9670;&nbsp;</a></span>DEVICE_HANDLE_ENDS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEVICE_HANDLE_ENDS&#160;&#160;&#160;<a class="el" href="stdint_8h.html#ac58f2c111cc9989c86db2a7dc4fd84ca">INT16_MAX</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="device_8h.html">include/device.h</a>&gt;</code></p>

<p>Flag value used in lists of device handles to indicate the end of the list. </p>
<p >This is the maximum value for the device_handle_t type. </p>

</div>
</div>
<a id="ga4dd918c3a59b8afa185a4851165d2ca0" name="ga4dd918c3a59b8afa185a4851165d2ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4dd918c3a59b8afa185a4851165d2ca0">&#9670;&nbsp;</a></span>DEVICE_HANDLE_NULL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEVICE_HANDLE_NULL&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="device_8h.html">include/device.h</a>&gt;</code></p>

<p>Flag value used to identify an unknown device. </p>

</div>
</div>
<a id="ga5f1feab331ee737141f418030902aab0" name="ga5f1feab331ee737141f418030902aab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f1feab331ee737141f418030902aab0">&#9670;&nbsp;</a></span>DEVICE_HANDLE_SEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEVICE_HANDLE_SEP&#160;&#160;&#160;<a class="el" href="stdint_8h.html#ad4e9955955b27624963643eac448118a">INT16_MIN</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="device_8h.html">include/device.h</a>&gt;</code></p>

<p>Flag value used in lists of device handles to separate distinct groups. </p>
<p >This is the minimum value for the device_handle_t type. </p>

</div>
</div>
<a id="ga51d735464c6c80e86ebae96b0b67947b" name="ga51d735464c6c80e86ebae96b0b67947b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51d735464c6c80e86ebae96b0b67947b">&#9670;&nbsp;</a></span>DEVICE_NAME_GET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEVICE_NAME_GET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name</td><td>)</td>
          <td>&#160;&#160;&#160;_CONCAT(__device_, name)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="device_8h.html">include/device.h</a>&gt;</code></p>

<p>Expands to the name of a global device object. </p>
<p >Return the full name of a device object symbol created by <a class="el" href="group__device__model.html#gad08683c204de0996ca62b23813947009" title="Create a device object and set it up for boot time initialization.">DEVICE_DEFINE()</a>, using the dev_name provided to <a class="el" href="group__device__model.html#gad08683c204de0996ca62b23813947009" title="Create a device object and set it up for boot time initialization.">DEVICE_DEFINE()</a>. This is the name of the global variable storing the device structure, not a pointer to the string in the device's <code>name</code> field.</p>
<p >It is meant to be used for declaring extern symbols pointing to device objects before using the DEVICE_GET macro to get the device object.</p>
<p >This macro is normally only useful within device driver source code. In other situations, you are probably looking for <a class="el" href="group__device__model.html#ga15386ca9ab38f3e30183c18f604fa835" title="Get a const struct device* from its name field.">device_get_binding()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The same <code>dev_name</code> token given to <a class="el" href="group__device__model.html#gad08683c204de0996ca62b23813947009" title="Create a device object and set it up for boot time initialization.">DEVICE_DEFINE()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The full name of the device object defined by <a class="el" href="group__device__model.html#gad08683c204de0996ca62b23813947009" title="Create a device object and set it up for boot time initialization.">DEVICE_DEFINE()</a> </dd></dl>

</div>
</div>
<a id="ga42092d245664c3d59c30ceb4776bd642" name="ga42092d245664c3d59c30ceb4776bd642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42092d245664c3d59c30ceb4776bd642">&#9670;&nbsp;</a></span>SYS_DEVICE_DEFINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYS_DEVICE_DEFINE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">drv_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">init_fn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">level, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">prio&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;	__DEPRECATED_MACRO <a class="el" href="early__sleep_2src_2main_8c.html#a080adab9e7b88edfe90c6d2115d9d06e">SYS_INIT</a>(init_fn, level, prio)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="device_8h.html">include/device.h</a>&gt;</code></p>

<p>Run an initialization function at boot at specified priority. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__device__model.html#ga1e50fdff086356a75b0e91179952cc8d" title="Run an initialization function at boot at specified priority.">SYS_INIT()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">drv_name</td><td>A string name for the pseudo-device (unused). </td></tr>
    <tr><td class="paramname">init_fn</td><td>Pointer to the function which should run at boot time. </td></tr>
    <tr><td class="paramname">level</td><td>Initialization level to run the function in. </td></tr>
    <tr><td class="paramname">prio</td><td>Function's priority within its initialization level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1e50fdff086356a75b0e91179952cc8d" name="ga1e50fdff086356a75b0e91179952cc8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e50fdff086356a75b0e91179952cc8d">&#9670;&nbsp;</a></span>SYS_INIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYS_INIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_init_fn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_level, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_prio&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;	Z_INIT_ENTRY_DEFINE(Z_SYS_NAME(_init_fn), _init_fn, NULL, _level, _prio)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="init_8h.html">include/init.h</a>&gt;</code></p>

<p>Run an initialization function at boot at specified priority. </p>
<p >This macro lets you run a function at system boot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_init_fn</td><td>Pointer to the boot function to run</td></tr>
    <tr><td class="paramname">_level</td><td>The initialization level at which configuration occurs. Must be one of the following symbols, which are listed in the order they are performed by the kernel: <br  />
<ul>
<li>PRE_KERNEL_1: Used for initialization objects that have no dependencies, such as those that rely solely on hardware present in the processor/SOC. These objects cannot use any kernel services during configuration, since they are not yet available. <br  />
</li>
<li>PRE_KERNEL_2: Used for initialization objects that rely on objects initialized as part of the PRE_KERNEL_1 level. These objects cannot use any kernel services during configuration, since they are not yet available. <br  />
</li>
<li>POST_KERNEL: Used for initialization objects that require kernel services during configuration. <br  />
</li>
<li>POST_KERNEL_SMP: Used for initialization objects that require kernel services during configuration after SMP initialization. <br  />
</li>
<li>APPLICATION: Used for application components (i.e. non-kernel components) that need automatic configuration. These objects can use all services provided by the kernel during configuration.</li>
</ul>
</td></tr>
    <tr><td class="paramname">_prio</td><td>The initialization priority of the object, relative to other objects of the same initialization level. Specified as an integer value in the range 0 to 99; lower values indicate earlier initialization. Must be a decimal integer literal without leading zeroes or sign (e.g. 32), or an equivalent symbolic name (e.g. #define MY_INIT_PRIO 32); symbolic expressions are <em>not</em> permitted (e.g. CONFIG_KERNEL_INIT_PRIORITY_DEFAULT + 5). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga21415b8e9967ecd2c3d3d3b1724f93c3" name="ga21415b8e9967ecd2c3d3d3b1724f93c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21415b8e9967ecd2c3d3d3b1724f93c3">&#9670;&nbsp;</a></span>device_handle_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="stdint_8h.html#afe270aee8d96ad7f279a4020b9d58bdf">int16_t</a> <a class="el" href="group__device__model.html#ga21415b8e9967ecd2c3d3d3b1724f93c3">device_handle_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="device_8h.html">include/device.h</a>&gt;</code></p>

<p>Type used to represent a "handle" for a device. </p>
<p >Every struct device has an associated handle. You can get a pointer to a device structure from its handle and vice versa, but the handle uses less space than a pointer. The device.h API mainly uses handles to store lists of multiple devices in a compact way.</p>
<p >The extreme values and zero have special significance. Negative values identify functionality that does not correspond to a Zephyr device, such as the system clock or a <a class="el" href="group__device__model.html#ga1e50fdff086356a75b0e91179952cc8d" title="Run an initialization function at boot at specified priority.">SYS_INIT()</a> function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__device__model.html#ga456366a9ca0a8e97484c97c279745203" title="Get the handle for a given device.">device_handle_get()</a> </dd>
<dd>
<a class="el" href="group__device__model.html#ga73680daef9f8d7dc2541d83d09737f4a" title="Get the device corresponding to a handle.">device_from_handle()</a> </dd></dl>

</div>
</div>
<a id="ga9a1118e5c76c44c998f7258a7de0bfbb" name="ga9a1118e5c76c44c998f7258a7de0bfbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a1118e5c76c44c998f7258a7de0bfbb">&#9670;&nbsp;</a></span>device_visitor_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* device_visitor_callback_t) (const struct <a class="el" href="structdevice.html">device</a> *dev, void *context)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="device_8h.html">include/device.h</a>&gt;</code></p>

<p>Prototype for functions used when iterating over a set of devices. </p>
<p >Such a function may be used in API that identifies a set of devices and provides a visitor API supporting caller-specific interaction with each device in the set.</p>
<p >The visit is said to succeed if the visitor returns a non-negative value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>a device in the set being iterated</td></tr>
    <tr><td class="paramname">context</td><td>state used to support the visitor function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-negative number to allow walking to continue, and a negative error code to case the iteration to stop.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__device__model.html#ga6e3b6dbb15ca28d6c94ee07702663245" title="Visit every device that dev directly requires.">device_required_foreach()</a> </dd>
<dd>
<a class="el" href="group__device__model.html#gaf5fce5e93fd6d5e13aa8b20251b82b2a" title="Visit every device that dev directly supports.">device_supported_foreach()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga73680daef9f8d7dc2541d83d09737f4a" name="ga73680daef9f8d7dc2541d83d09737f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73680daef9f8d7dc2541d83d09737f4a">&#9670;&nbsp;</a></span>device_from_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const struct <a class="el" href="structdevice.html">device</a> * device_from_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__device__model.html#ga21415b8e9967ecd2c3d3d3b1724f93c3">device_handle_t</a>&#160;</td>
          <td class="paramname"><em>dev_handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="device_8h.html">include/device.h</a>&gt;</code></p>

<p>Get the device corresponding to a handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>the device handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the device that has that handle, or a null pointer if <code>dev_handle</code> does not identify a device. </dd></dl>

</div>
</div>
<a id="ga15386ca9ab38f3e30183c18f604fa835" name="ga15386ca9ab38f3e30183c18f604fa835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15386ca9ab38f3e30183c18f604fa835">&#9670;&nbsp;</a></span>device_get_binding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structdevice.html">device</a> * device_get_binding </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="device_8h.html">include/device.h</a>&gt;</code></p>

<p>Get a <code>const struct device*</code> from its <code>name</code> field. </p>
<p >This function iterates through the devices on the system. If a device with the given <code>name</code> field is found, and that device initialized successfully at boot time, this function returns a pointer to the device.</p>
<p >If no device has the given name, this function returns NULL.</p>
<p >This function also returns NULL when a device is found, but it failed to initialize successfully at boot time. (To troubleshoot this case, set a breakpoint on your device driver's initialization function.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>device name to search for. A null pointer, or a pointer to an empty string, will cause NULL to be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to device structure with the given name; NULL if the device is not found or if the device with that name's initialization function failed. </dd></dl>

</div>
</div>
<a id="ga456366a9ca0a8e97484c97c279745203" name="ga456366a9ca0a8e97484c97c279745203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga456366a9ca0a8e97484c97c279745203">&#9670;&nbsp;</a></span>device_handle_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__device__model.html#ga21415b8e9967ecd2c3d3d3b1724f93c3">device_handle_t</a> device_handle_get </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="device_8h.html">include/device.h</a>&gt;</code></p>

<p>Get the handle for a given device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>the device for which a handle is desired.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the handle for the device, or DEVICE_HANDLE_NULL if the device does not have an associated handle. </dd></dl>

</div>
</div>
<a id="gaa4944bd850e90cbd52b0489f9b12edfb" name="gaa4944bd850e90cbd52b0489f9b12edfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4944bd850e90cbd52b0489f9b12edfb">&#9670;&nbsp;</a></span>device_is_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> device_is_ready </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="device_8h.html">include/device.h</a>&gt;</code></p>

<p>Verify that a device is ready for use. </p>
<p >Indicates whether the provided device pointer is for a device known to be in a state where it can be used with its standard API.</p>
<p >This can be used with device pointers captured from <a class="el" href="group__device__model.html#ga9a65996ce21f43acb7db061e23b48ec7" title="Get a const struct device* from a devicetree node identifier.">DEVICE_DT_GET()</a>, which does not include the readiness checks of <a class="el" href="group__device__model.html#ga15386ca9ab38f3e30183c18f604fa835" title="Get a const struct device* from its name field.">device_get_binding()</a>. At minimum this means that the device has been successfully initialized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>pointer to the device in question.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If the device is ready for use. </td></tr>
    <tr><td class="paramname">false</td><td>If the device is not ready for use or if a NULL device pointer is passed as argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6e3b6dbb15ca28d6c94ee07702663245" name="ga6e3b6dbb15ca28d6c94ee07702663245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e3b6dbb15ca28d6c94ee07702663245">&#9670;&nbsp;</a></span>device_required_foreach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int device_required_foreach </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__device__model.html#ga9a1118e5c76c44c998f7258a7de0bfbb">device_visitor_callback_t</a>&#160;</td>
          <td class="paramname"><em>visitor_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="device_8h.html">include/device.h</a>&gt;</code></p>

<p>Visit every device that <code>dev</code> directly requires. </p>
<p >Zephyr maintains information about which devices are directly required by another device; for example an I2C-based sensor driver will require an I2C controller for communication. Required devices can derive from statically-defined devicetree relationships or dependencies registered at runtime.</p>
<p >This API supports operating on the set of required devices. Example uses include making sure required devices are ready before the requiring device is used, and releasing them when the requiring device is no longer needed.</p>
<p >There is no guarantee on the order in which required devices are visited.</p>
<p >If the <code>visitor</code> function returns a negative value iteration is halted, and the returned value from the visitor is returned from this function.</p>
<dl class="section note"><dt>Note</dt><dd>This API is not available to unprivileged threads.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>a device of interest. The devices that this device depends on will be used as the set of devices to visit. This parameter must not be null.</td></tr>
    <tr><td class="paramname">visitor_cb</td><td>the function that should be invoked on each device in the dependency set. This parameter must not be null.</td></tr>
    <tr><td class="paramname">context</td><td>state that is passed through to the visitor function. This parameter may be null if <code>visitor</code> tolerates a null <code>context</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of devices that were visited if all visits succeed, or the negative value returned from the first visit that did not succeed. </dd></dl>

</div>
</div>
<a id="ga2157bbfc2deecfae6514f58221663618" name="ga2157bbfc2deecfae6514f58221663618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2157bbfc2deecfae6514f58221663618">&#9670;&nbsp;</a></span>device_required_handles_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="group__device__model.html#ga21415b8e9967ecd2c3d3d3b1724f93c3">device_handle_t</a> * device_required_handles_get </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="device_8h.html">include/device.h</a>&gt;</code></p>

<p>Get the device handles for devicetree dependencies of this device. </p>
<p >This function returns a pointer to an array of device handles. The length of the array is stored in the <code>count</code> parameter.</p>
<p >The array contains a handle for each device that <code>dev</code> requires directly, as determined from the devicetree. This does not include transitive dependencies; you must recursively determine those.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>the device for which dependencies are desired.</td></tr>
    <tr><td class="paramname">count</td><td>pointer to where this function should store the length of the returned array. No value is stored if the call returns a null pointer. The value may be set to zero if the device has no devicetree dependencies.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a sequence of <code>*count</code> device handles, or a null pointer if <code>dev</code> does not have any dependency data. </dd></dl>

</div>
</div>
<a id="gaf5fce5e93fd6d5e13aa8b20251b82b2a" name="gaf5fce5e93fd6d5e13aa8b20251b82b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5fce5e93fd6d5e13aa8b20251b82b2a">&#9670;&nbsp;</a></span>device_supported_foreach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int device_supported_foreach </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__device__model.html#ga9a1118e5c76c44c998f7258a7de0bfbb">device_visitor_callback_t</a>&#160;</td>
          <td class="paramname"><em>visitor_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="device_8h.html">include/device.h</a>&gt;</code></p>

<p>Visit every device that <code>dev</code> directly supports. </p>
<p >Zephyr maintains information about which devices are directly supported by another device; for example an I2C controller will support an I2C-based sensor driver. Supported devices can derive from statically-defined devicetree relationships.</p>
<p >This API supports operating on the set of supported devices. Example uses include iterating over the devices connected to a regulator when it is powered on.</p>
<p >There is no guarantee on the order in which required devices are visited.</p>
<p >If the <code>visitor</code> function returns a negative value iteration is halted, and the returned value from the visitor is returned from this function.</p>
<dl class="section note"><dt>Note</dt><dd>This API is not available to unprivileged threads.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>a device of interest. The devices that this device supports will be used as the set of devices to visit. This parameter must not be null.</td></tr>
    <tr><td class="paramname">visitor_cb</td><td>the function that should be invoked on each device in the support set. This parameter must not be null.</td></tr>
    <tr><td class="paramname">context</td><td>state that is passed through to the visitor function. This parameter may be null if <code>visitor</code> tolerates a null <code>context</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of devices that were visited if all visits succeed, or the negative value returned from the first visit that did not succeed. </dd></dl>

</div>
</div>
<a id="ga3c9ae15d3224c792b915b107b2d5d00f" name="ga3c9ae15d3224c792b915b107b2d5d00f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c9ae15d3224c792b915b107b2d5d00f">&#9670;&nbsp;</a></span>device_supported_handles_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="group__device__model.html#ga21415b8e9967ecd2c3d3d3b1724f93c3">device_handle_t</a> * device_supported_handles_get </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="device_8h.html">include/device.h</a>&gt;</code></p>

<p>Get the set of handles that this device supports. </p>
<p >This function returns a pointer to an array of device handles. The length of the array is stored in the <code>count</code> parameter.</p>
<p >The array contains a handle for each device that <code>dev</code> "supports" &ndash; that is, devices that require <code>dev</code> directly &ndash; as determined from the devicetree. This does not include transitive dependencies; you must recursively determine those.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>the device for which supports are desired.</td></tr>
    <tr><td class="paramname">count</td><td>pointer to where this function should store the length of the returned array. No value is stored if the call returns a null pointer. The value may be set to zero if nothing in the devicetree depends on <code>dev</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a sequence of <code>*count</code> device handles, or a null pointer if <code>dev</code> does not have any dependency data. </dd></dl>

</div>
</div>
<a id="ga233b32dc38630069c1aee973fa52416e" name="ga233b32dc38630069c1aee973fa52416e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga233b32dc38630069c1aee973fa52416e">&#9670;&nbsp;</a></span>device_usable_check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int device_usable_check </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="device_8h.html">include/device.h</a>&gt;</code></p>

<p>Determine whether a device is ready for use. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__device__model.html#gaa4944bd850e90cbd52b0489f9b12edfb" title="Verify that a device is ready for use.">device_is_ready()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Device instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If device is usable. </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>If device is not usable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Mar 5 2022 05:00:46 for Zephyr API Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
<script type="text/javascript">
  $(function() {
    toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
    toggleButton.title = "Toggle Light/Dark Mode"
    $(document).ready(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
    // every resize will remove the button, which is why it has to be added again:
    $(window).resize(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
  })
</script>
</body>
</html>
