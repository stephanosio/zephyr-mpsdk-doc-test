<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zephyr API Documentation: include/drivers/pcie/endpoint/pcie_ep.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-zephyr.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-zephyr.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Zephyr API Documentation
   &#160;<span id="projectnumber">3.0.0-rc3</span>
   </div>
   <div id="projectbrief">A Scalable Open Source RTOS</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('pcie__ep_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">pcie_ep.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Public APIs for the PCIe EP drivers.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;device.h&gt;</code><br />
<code>#include &lt;<a class="el" href="init_8h_source.html">init.h</a>&gt;</code><br />
<code>#include &lt;kernel.h&gt;</code><br />
<code>#include &lt;<a class="el" href="stdint_8h_source.html">stdint.h</a>&gt;</code><br />
</div>
<p><a href="pcie__ep_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcie__ep__driver__api.html">pcie_ep_driver_api</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af83085eb5819572854d919e5813253bf"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcie__ep_8h.html#af83085eb5819572854d919e5813253bf">pcie_ep_reset_callback_t</a>) (void *arg)</td></tr>
<tr class="memdesc:af83085eb5819572854d919e5813253bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback API for PCIe reset interrupts.  <a href="pcie__ep_8h.html#af83085eb5819572854d919e5813253bf">More...</a><br /></td></tr>
<tr class="separator:af83085eb5819572854d919e5813253bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa7c51648c5a1663dd4dec689727a510b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcie__ep_8h.html#aa7c51648c5a1663dd4dec689727a510b">pcie_ob_mem_type</a> { <a class="el" href="pcie__ep_8h.html#aa7c51648c5a1663dd4dec689727a510ba52b8bd55168f44c7c4a6a3d36824d286">PCIE_OB_ANYMEM</a>
, <a class="el" href="pcie__ep_8h.html#aa7c51648c5a1663dd4dec689727a510ba5312fb052e8dafaab224a4b554292e74">PCIE_OB_LOWMEM</a>
, <a class="el" href="pcie__ep_8h.html#aa7c51648c5a1663dd4dec689727a510ba13da19c9fa1732e72fa8add58da33ebb">PCIE_OB_HIGHMEM</a>
 }</td></tr>
<tr class="separator:aa7c51648c5a1663dd4dec689727a510b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0e572125869b246d4968ee164f3800"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcie__ep_8h.html#aba0e572125869b246d4968ee164f3800">pci_ep_irq_type</a> { <a class="el" href="pcie__ep_8h.html#aba0e572125869b246d4968ee164f3800ad90da0a62096ef8a4fc7d230afd0d44d">PCIE_EP_IRQ_LEGACY</a>
, <a class="el" href="pcie__ep_8h.html#aba0e572125869b246d4968ee164f3800a267b658ad2587fd0d57664197daeb318">PCIE_EP_IRQ_MSI</a>
, <a class="el" href="pcie__ep_8h.html#aba0e572125869b246d4968ee164f3800a55cad2c5812c9c7c14476ff000199ad4">PCIE_EP_IRQ_MSIX</a>
 }</td></tr>
<tr class="separator:aba0e572125869b246d4968ee164f3800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2605f2fb5676ded5f125712681d458"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcie__ep_8h.html#acd2605f2fb5676ded5f125712681d458">xfer_direction</a> { <a class="el" href="pcie__ep_8h.html#acd2605f2fb5676ded5f125712681d458af2c2a8166d85d21e036a4a2015df803e">HOST_TO_DEVICE</a>
, <a class="el" href="pcie__ep_8h.html#acd2605f2fb5676ded5f125712681d458a4c419a2c450c4d954c3768631870480a">DEVICE_TO_HOST</a>
 }</td></tr>
<tr class="separator:acd2605f2fb5676ded5f125712681d458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0f0f4693b7d11b973bfd62ac1b35cd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcie__ep_8h.html#a7b0f0f4693b7d11b973bfd62ac1b35cd">pcie_reset</a> { <a class="el" href="pcie__ep_8h.html#a7b0f0f4693b7d11b973bfd62ac1b35cda532057b4dab53d2e86701394ead62ea7">PCIE_PERST</a>
, <a class="el" href="pcie__ep_8h.html#a7b0f0f4693b7d11b973bfd62ac1b35cda7d94ae3f1fbdd486102559a450f01dee">PCIE_PERST_INB</a>
, <a class="el" href="pcie__ep_8h.html#a7b0f0f4693b7d11b973bfd62ac1b35cda6dcb2d2f5ad3624bda5ca25d2e38a47a">PCIE_FLR</a>
, <a class="el" href="pcie__ep_8h.html#a7b0f0f4693b7d11b973bfd62ac1b35cda2c60bd39ac112aad31d1299900f0795a">PCIE_RESET_MAX</a>
 }</td></tr>
<tr class="separator:a7b0f0f4693b7d11b973bfd62ac1b35cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad35d42579500a959bb3275cd65b04a42"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcie__ep_8h.html#ad35d42579500a959bb3275cd65b04a42">pcie_ep_conf_read</a> (const struct <a class="el" href="structdevice.html">device</a> *dev, <a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> offset, <a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> *<a class="el" href="test__stack__fail_8c.html#a4bb6fa6c719fd9021449009ab8befc04">data</a>)</td></tr>
<tr class="memdesc:ad35d42579500a959bb3275cd65b04a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read PCIe EP configuration space.  <a href="pcie__ep_8h.html#ad35d42579500a959bb3275cd65b04a42">More...</a><br /></td></tr>
<tr class="separator:ad35d42579500a959bb3275cd65b04a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3f4de13956fbd7ed71acbd387f781a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcie__ep_8h.html#a8d3f4de13956fbd7ed71acbd387f781a">pcie_ep_conf_write</a> (const struct <a class="el" href="structdevice.html">device</a> *dev, <a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> offset, <a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> <a class="el" href="test__stack__fail_8c.html#a4bb6fa6c719fd9021449009ab8befc04">data</a>)</td></tr>
<tr class="memdesc:a8d3f4de13956fbd7ed71acbd387f781a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write PCIe EP configuration space.  <a href="pcie__ep_8h.html#a8d3f4de13956fbd7ed71acbd387f781a">More...</a><br /></td></tr>
<tr class="separator:a8d3f4de13956fbd7ed71acbd387f781a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bcff5f22fd32e0b2c3c3c509038b2db"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcie__ep_8h.html#a7bcff5f22fd32e0b2c3c3c509038b2db">pcie_ep_map_addr</a> (const struct <a class="el" href="structdevice.html">device</a> *dev, <a class="el" href="stdint_8h.html#a2095b9bffea4b2656950c6c0419edbf1">uint64_t</a> pcie_addr, <a class="el" href="stdint_8h.html#a2095b9bffea4b2656950c6c0419edbf1">uint64_t</a> *mapped_addr, <a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> size, enum <a class="el" href="pcie__ep_8h.html#aa7c51648c5a1663dd4dec689727a510b">pcie_ob_mem_type</a> ob_mem_type)</td></tr>
<tr class="memdesc:a7bcff5f22fd32e0b2c3c3c509038b2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a host memory buffer to PCIe outbound region.  <a href="pcie__ep_8h.html#a7bcff5f22fd32e0b2c3c3c509038b2db">More...</a><br /></td></tr>
<tr class="separator:a7bcff5f22fd32e0b2c3c3c509038b2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ee4ed9ceb42462c95da8bbf3dfc8f7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcie__ep_8h.html#a07ee4ed9ceb42462c95da8bbf3dfc8f7">pcie_ep_unmap_addr</a> (const struct <a class="el" href="structdevice.html">device</a> *dev, <a class="el" href="stdint_8h.html#a2095b9bffea4b2656950c6c0419edbf1">uint64_t</a> mapped_addr)</td></tr>
<tr class="memdesc:a07ee4ed9ceb42462c95da8bbf3dfc8f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove mapping to PCIe outbound region.  <a href="pcie__ep_8h.html#a07ee4ed9ceb42462c95da8bbf3dfc8f7">More...</a><br /></td></tr>
<tr class="separator:a07ee4ed9ceb42462c95da8bbf3dfc8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec421e689d4d72b0bf8a34fe8303b103"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcie__ep_8h.html#aec421e689d4d72b0bf8a34fe8303b103">pcie_ep_raise_irq</a> (const struct <a class="el" href="structdevice.html">device</a> *dev, enum <a class="el" href="pcie__ep_8h.html#aba0e572125869b246d4968ee164f3800">pci_ep_irq_type</a> irq_type, <a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> irq_num)</td></tr>
<tr class="memdesc:aec421e689d4d72b0bf8a34fe8303b103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise interrupt to Host.  <a href="pcie__ep_8h.html#aec421e689d4d72b0bf8a34fe8303b103">More...</a><br /></td></tr>
<tr class="separator:aec421e689d4d72b0bf8a34fe8303b103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9cc8364703bb58e96642d1250dc410"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcie__ep_8h.html#a4e9cc8364703bb58e96642d1250dc410">pcie_ep_register_reset_cb</a> (const struct <a class="el" href="structdevice.html">device</a> *dev, enum <a class="el" href="pcie__ep_8h.html#a7b0f0f4693b7d11b973bfd62ac1b35cd">pcie_reset</a> reset, <a class="el" href="pcie__ep_8h.html#af83085eb5819572854d919e5813253bf">pcie_ep_reset_callback_t</a> cb, void *arg)</td></tr>
<tr class="memdesc:a4e9cc8364703bb58e96642d1250dc410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register callback function for reset interrupts.  <a href="pcie__ep_8h.html#a4e9cc8364703bb58e96642d1250dc410">More...</a><br /></td></tr>
<tr class="separator:a4e9cc8364703bb58e96642d1250dc410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c450e4f9d65aade3f912b72b38ed04d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcie__ep_8h.html#a7c450e4f9d65aade3f912b72b38ed04d">pcie_ep_dma_xfer</a> (const struct <a class="el" href="structdevice.html">device</a> *dev, <a class="el" href="stdint_8h.html#a2095b9bffea4b2656950c6c0419edbf1">uint64_t</a> mapped_addr, <a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a> local_addr, <a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> size, const enum <a class="el" href="pcie__ep_8h.html#acd2605f2fb5676ded5f125712681d458">xfer_direction</a> dir)</td></tr>
<tr class="memdesc:a7c450e4f9d65aade3f912b72b38ed04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data transfer between mapped Host memory and device memory with "System DMA". The term "System DMA" is used to clarify that we are not talking about dedicated "PCIe DMA"; rather the one which does not understand PCIe address directly, and uses the mapped Host memory.  <a href="pcie__ep_8h.html#a7c450e4f9d65aade3f912b72b38ed04d">More...</a><br /></td></tr>
<tr class="separator:a7c450e4f9d65aade3f912b72b38ed04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e46d51c49ce6cb6b0c7ad7f8010292"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcie__ep_8h.html#ac7e46d51c49ce6cb6b0c7ad7f8010292">pcie_ep_xfer_data_memcpy</a> (const struct <a class="el" href="structdevice.html">device</a> *dev, <a class="el" href="stdint_8h.html#a2095b9bffea4b2656950c6c0419edbf1">uint64_t</a> pcie_addr, <a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a> *local_addr, <a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> size, enum <a class="el" href="pcie__ep_8h.html#aa7c51648c5a1663dd4dec689727a510b">pcie_ob_mem_type</a> ob_mem_type, enum <a class="el" href="pcie__ep_8h.html#acd2605f2fb5676ded5f125712681d458">xfer_direction</a> dir)</td></tr>
<tr class="memdesc:ac7e46d51c49ce6cb6b0c7ad7f8010292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data transfer using memcpy.  <a href="pcie__ep_8h.html#ac7e46d51c49ce6cb6b0c7ad7f8010292">More...</a><br /></td></tr>
<tr class="separator:ac7e46d51c49ce6cb6b0c7ad7f8010292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe495f60e94341e88cc267a879918fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcie__ep_8h.html#acfe495f60e94341e88cc267a879918fc">pcie_ep_xfer_data_dma</a> (const struct <a class="el" href="structdevice.html">device</a> *dev, <a class="el" href="stdint_8h.html#a2095b9bffea4b2656950c6c0419edbf1">uint64_t</a> pcie_addr, <a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a> *local_addr, <a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> size, enum <a class="el" href="pcie__ep_8h.html#aa7c51648c5a1663dd4dec689727a510b">pcie_ob_mem_type</a> ob_mem_type, enum <a class="el" href="pcie__ep_8h.html#acd2605f2fb5676ded5f125712681d458">xfer_direction</a> dir)</td></tr>
<tr class="memdesc:acfe495f60e94341e88cc267a879918fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data transfer using system DMA.  <a href="pcie__ep_8h.html#acfe495f60e94341e88cc267a879918fc">More...</a><br /></td></tr>
<tr class="separator:acfe495f60e94341e88cc267a879918fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Public APIs for the PCIe EP drivers. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="af83085eb5819572854d919e5813253bf" name="af83085eb5819572854d919e5813253bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af83085eb5819572854d919e5813253bf">&#9670;&nbsp;</a></span>pcie_ep_reset_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcie_ep_reset_callback_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback API for PCIe reset interrupts. </p>
<p >These callbacks execute in interrupt context. Therefore, use only interrupt-safe APIS. Registration of callbacks is done via <em>pcie_ep_register_reset_cb</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>Pointer provided at registration time, later to be passed back as argument to callback function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aba0e572125869b246d4968ee164f3800" name="aba0e572125869b246d4968ee164f3800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba0e572125869b246d4968ee164f3800">&#9670;&nbsp;</a></span>pci_ep_irq_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="pcie__ep_8h.html#aba0e572125869b246d4968ee164f3800">pci_ep_irq_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aba0e572125869b246d4968ee164f3800ad90da0a62096ef8a4fc7d230afd0d44d" name="aba0e572125869b246d4968ee164f3800ad90da0a62096ef8a4fc7d230afd0d44d"></a>PCIE_EP_IRQ_LEGACY&#160;</td><td class="fielddoc"><p >Raise Legacy interrupt </p>
</td></tr>
<tr><td class="fieldname"><a id="aba0e572125869b246d4968ee164f3800a267b658ad2587fd0d57664197daeb318" name="aba0e572125869b246d4968ee164f3800a267b658ad2587fd0d57664197daeb318"></a>PCIE_EP_IRQ_MSI&#160;</td><td class="fielddoc"><p >Raise MSI interrupt </p>
</td></tr>
<tr><td class="fieldname"><a id="aba0e572125869b246d4968ee164f3800a55cad2c5812c9c7c14476ff000199ad4" name="aba0e572125869b246d4968ee164f3800a55cad2c5812c9c7c14476ff000199ad4"></a>PCIE_EP_IRQ_MSIX&#160;</td><td class="fielddoc"><p >Raise MSIX interrupt </p>
</td></tr>
</table>

</div>
</div>
<a id="aa7c51648c5a1663dd4dec689727a510b" name="aa7c51648c5a1663dd4dec689727a510b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7c51648c5a1663dd4dec689727a510b">&#9670;&nbsp;</a></span>pcie_ob_mem_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="pcie__ep_8h.html#aa7c51648c5a1663dd4dec689727a510b">pcie_ob_mem_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa7c51648c5a1663dd4dec689727a510ba52b8bd55168f44c7c4a6a3d36824d286" name="aa7c51648c5a1663dd4dec689727a510ba52b8bd55168f44c7c4a6a3d36824d286"></a>PCIE_OB_ANYMEM&#160;</td><td class="fielddoc"><p >PCIe OB window within any address range </p>
</td></tr>
<tr><td class="fieldname"><a id="aa7c51648c5a1663dd4dec689727a510ba5312fb052e8dafaab224a4b554292e74" name="aa7c51648c5a1663dd4dec689727a510ba5312fb052e8dafaab224a4b554292e74"></a>PCIE_OB_LOWMEM&#160;</td><td class="fielddoc"><p >PCIe OB window within 32-bit address range </p>
</td></tr>
<tr><td class="fieldname"><a id="aa7c51648c5a1663dd4dec689727a510ba13da19c9fa1732e72fa8add58da33ebb" name="aa7c51648c5a1663dd4dec689727a510ba13da19c9fa1732e72fa8add58da33ebb"></a>PCIE_OB_HIGHMEM&#160;</td><td class="fielddoc"><p >PCIe OB window above 32-bit address range </p>
</td></tr>
</table>

</div>
</div>
<a id="a7b0f0f4693b7d11b973bfd62ac1b35cd" name="a7b0f0f4693b7d11b973bfd62ac1b35cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b0f0f4693b7d11b973bfd62ac1b35cd">&#9670;&nbsp;</a></span>pcie_reset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="pcie__ep_8h.html#a7b0f0f4693b7d11b973bfd62ac1b35cd">pcie_reset</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7b0f0f4693b7d11b973bfd62ac1b35cda532057b4dab53d2e86701394ead62ea7" name="a7b0f0f4693b7d11b973bfd62ac1b35cda532057b4dab53d2e86701394ead62ea7"></a>PCIE_PERST&#160;</td><td class="fielddoc"><p >Cold reset </p>
</td></tr>
<tr><td class="fieldname"><a id="a7b0f0f4693b7d11b973bfd62ac1b35cda7d94ae3f1fbdd486102559a450f01dee" name="a7b0f0f4693b7d11b973bfd62ac1b35cda7d94ae3f1fbdd486102559a450f01dee"></a>PCIE_PERST_INB&#160;</td><td class="fielddoc"><p >Inband hot reset </p>
</td></tr>
<tr><td class="fieldname"><a id="a7b0f0f4693b7d11b973bfd62ac1b35cda6dcb2d2f5ad3624bda5ca25d2e38a47a" name="a7b0f0f4693b7d11b973bfd62ac1b35cda6dcb2d2f5ad3624bda5ca25d2e38a47a"></a>PCIE_FLR&#160;</td><td class="fielddoc"><p >Functional Level Reset </p>
</td></tr>
<tr><td class="fieldname"><a id="a7b0f0f4693b7d11b973bfd62ac1b35cda2c60bd39ac112aad31d1299900f0795a" name="a7b0f0f4693b7d11b973bfd62ac1b35cda2c60bd39ac112aad31d1299900f0795a"></a>PCIE_RESET_MAX&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="acd2605f2fb5676ded5f125712681d458" name="acd2605f2fb5676ded5f125712681d458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd2605f2fb5676ded5f125712681d458">&#9670;&nbsp;</a></span>xfer_direction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="pcie__ep_8h.html#acd2605f2fb5676ded5f125712681d458">xfer_direction</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acd2605f2fb5676ded5f125712681d458af2c2a8166d85d21e036a4a2015df803e" name="acd2605f2fb5676ded5f125712681d458af2c2a8166d85d21e036a4a2015df803e"></a>HOST_TO_DEVICE&#160;</td><td class="fielddoc"><p >Read from Host </p>
</td></tr>
<tr><td class="fieldname"><a id="acd2605f2fb5676ded5f125712681d458a4c419a2c450c4d954c3768631870480a" name="acd2605f2fb5676ded5f125712681d458a4c419a2c450c4d954c3768631870480a"></a>DEVICE_TO_HOST&#160;</td><td class="fielddoc"><p >Write to Host </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad35d42579500a959bb3275cd65b04a42" name="ad35d42579500a959bb3275cd65b04a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad35d42579500a959bb3275cd65b04a42">&#9670;&nbsp;</a></span>pcie_ep_conf_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int pcie_ep_conf_read </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read PCIe EP configuration space. </p>
<p >This API reads EP's own configuration space</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Pointer to the device structure for the driver instance </td></tr>
    <tr><td class="paramname">offset</td><td>Offset within configuration space </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to data read from the offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, negative errno code if failure. </dd></dl>

</div>
</div>
<a id="a8d3f4de13956fbd7ed71acbd387f781a" name="a8d3f4de13956fbd7ed71acbd387f781a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d3f4de13956fbd7ed71acbd387f781a">&#9670;&nbsp;</a></span>pcie_ep_conf_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pcie_ep_conf_write </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a>&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write PCIe EP configuration space. </p>
<p >This API writes EP's own configuration space</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Pointer to the device structure for the driver instance </td></tr>
    <tr><td class="paramname">offset</td><td>Offset within configuration space </td></tr>
    <tr><td class="paramname">data</td><td>Data to be written at the offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c450e4f9d65aade3f912b72b38ed04d" name="a7c450e4f9d65aade3f912b72b38ed04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c450e4f9d65aade3f912b72b38ed04d">&#9670;&nbsp;</a></span>pcie_ep_dma_xfer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int pcie_ep_dma_xfer </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a2095b9bffea4b2656950c6c0419edbf1">uint64_t</a>&#160;</td>
          <td class="paramname"><em>mapped_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a>&#160;</td>
          <td class="paramname"><em>local_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="pcie__ep_8h.html#acd2605f2fb5676ded5f125712681d458">xfer_direction</a>&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Data transfer between mapped Host memory and device memory with "System DMA". The term "System DMA" is used to clarify that we are not talking about dedicated "PCIe DMA"; rather the one which does not understand PCIe address directly, and uses the mapped Host memory. </p>
<p >If DMA controller is available in the EP device, this API can be used to achieve data transfer between mapped Host memory, i.e. outbound memory and EP device's local memory with DMA</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Pointer to the device structure for the driver instance </td></tr>
    <tr><td class="paramname">mapped_addr</td><td>Mapped Host memory address </td></tr>
    <tr><td class="paramname">local_addr</td><td>Device memory address </td></tr>
    <tr><td class="paramname">size</td><td>DMA transfer length (bytes) </td></tr>
    <tr><td class="paramname">dir</td><td>Direction of DMA transfer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, negative errno code if failure. </dd></dl>

</div>
</div>
<a id="a7bcff5f22fd32e0b2c3c3c509038b2db" name="a7bcff5f22fd32e0b2c3c3c509038b2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bcff5f22fd32e0b2c3c3c509038b2db">&#9670;&nbsp;</a></span>pcie_ep_map_addr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int pcie_ep_map_addr </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a2095b9bffea4b2656950c6c0419edbf1">uint64_t</a>&#160;</td>
          <td class="paramname"><em>pcie_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a2095b9bffea4b2656950c6c0419edbf1">uint64_t</a> *&#160;</td>
          <td class="paramname"><em>mapped_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="pcie__ep_8h.html#aa7c51648c5a1663dd4dec689727a510b">pcie_ob_mem_type</a>&#160;</td>
          <td class="paramname"><em>ob_mem_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map a host memory buffer to PCIe outbound region. </p>
<p >This API maps a host memory buffer to PCIe outbound region, It is left to EP driver to manage multiple mappings through multiple PCIe outbound regions if supported by SoC</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Pointer to the device structure for the driver instance </td></tr>
    <tr><td class="paramname">pcie_addr</td><td>Host memory buffer address to be mapped </td></tr>
    <tr><td class="paramname">mapped_addr</td><td>Mapped PCIe outbound region address </td></tr>
    <tr><td class="paramname">size</td><td>Host memory buffer size (bytes) </td></tr>
    <tr><td class="paramname">ob_mem_type</td><td>Hint if lowmem/highmem outbound region has to be used, this is useful in cases where bus master cannot generate more than 32-bit address; it becomes essential to use lowmem outbound region</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mapped size : If mapped size is less than requested size, then requestor has to call the same API again to map the unmapped host buffer after data transfer is done with mapped size. This situation may arise because of the mapping alignment requirements.</dd>
<dd>
Negative errno code if failure. </dd></dl>

</div>
</div>
<a id="aec421e689d4d72b0bf8a34fe8303b103" name="aec421e689d4d72b0bf8a34fe8303b103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec421e689d4d72b0bf8a34fe8303b103">&#9670;&nbsp;</a></span>pcie_ep_raise_irq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int pcie_ep_raise_irq </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="pcie__ep_8h.html#aba0e572125869b246d4968ee164f3800">pci_ep_irq_type</a>&#160;</td>
          <td class="paramname"><em>irq_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a>&#160;</td>
          <td class="paramname"><em>irq_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Raise interrupt to Host. </p>
<p >This API raises interrupt to Host</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Pointer to the device structure for the driver instance </td></tr>
    <tr><td class="paramname">irq_type</td><td>Type of Interrupt be raised (legacy, MSI or MSI-X) </td></tr>
    <tr><td class="paramname">irq_num</td><td>MSI or MSI-X interrupt number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, negative errno code if failure. </dd></dl>

</div>
</div>
<a id="a4e9cc8364703bb58e96642d1250dc410" name="a4e9cc8364703bb58e96642d1250dc410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e9cc8364703bb58e96642d1250dc410">&#9670;&nbsp;</a></span>pcie_ep_register_reset_cb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int pcie_ep_register_reset_cb </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="pcie__ep_8h.html#a7b0f0f4693b7d11b973bfd62ac1b35cd">pcie_reset</a>&#160;</td>
          <td class="paramname"><em>reset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pcie__ep_8h.html#af83085eb5819572854d919e5813253bf">pcie_ep_reset_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register callback function for reset interrupts. </p>
<p >If reset interrupts are handled by device, this API can be used to register callback function, which will be executed part of corresponding PCIe reset handler</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Pointer to the device structure for the driver instance </td></tr>
    <tr><td class="paramname">reset</td><td>Reset interrupt type </td></tr>
    <tr><td class="paramname">cb</td><td>Callback function being registered </td></tr>
    <tr><td class="paramname">arg</td><td>Argument to be passed back to callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, negative errno code if failure. </dd></dl>

</div>
</div>
<a id="a07ee4ed9ceb42462c95da8bbf3dfc8f7" name="a07ee4ed9ceb42462c95da8bbf3dfc8f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ee4ed9ceb42462c95da8bbf3dfc8f7">&#9670;&nbsp;</a></span>pcie_ep_unmap_addr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pcie_ep_unmap_addr </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a2095b9bffea4b2656950c6c0419edbf1">uint64_t</a>&#160;</td>
          <td class="paramname"><em>mapped_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove mapping to PCIe outbound region. </p>
<p >This API removes mapping to PCIe outbound region. Mapped PCIe outbound region address is given as argument to figure out the outbound region to be unmapped</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Pointer to the device structure for the driver instance </td></tr>
    <tr><td class="paramname">mapped_addr</td><td>PCIe outbound region address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfe495f60e94341e88cc267a879918fc" name="acfe495f60e94341e88cc267a879918fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe495f60e94341e88cc267a879918fc">&#9670;&nbsp;</a></span>pcie_ep_xfer_data_dma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcie_ep_xfer_data_dma </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a2095b9bffea4b2656950c6c0419edbf1">uint64_t</a>&#160;</td>
          <td class="paramname"><em>pcie_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a> *&#160;</td>
          <td class="paramname"><em>local_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="pcie__ep_8h.html#aa7c51648c5a1663dd4dec689727a510b">pcie_ob_mem_type</a>&#160;</td>
          <td class="paramname"><em>ob_mem_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="pcie__ep_8h.html#acd2605f2fb5676ded5f125712681d458">xfer_direction</a>&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data transfer using system DMA. </p>
<p >Helper API to achieve data transfer with system DMA through PCIe outbound memory, this API is based off pcie_ep_xfer_data_memcpy, here we use "system dma" instead of memcpy</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Pointer to the device structure for the driver instance </td></tr>
    <tr><td class="paramname">pcie_addr</td><td>Host memory buffer address </td></tr>
    <tr><td class="paramname">local_addr</td><td>Local memory buffer address </td></tr>
    <tr><td class="paramname">size</td><td>Data transfer size (bytes) </td></tr>
    <tr><td class="paramname">ob_mem_type</td><td>Hint if lowmem/highmem outbound region has to be used (PCIE_OB_LOWMEM / PCIE_OB_HIGHMEM / PCIE_OB_ANYMEM) </td></tr>
    <tr><td class="paramname">dir</td><td>Data transfer direction (HOST_TO_DEVICE / DEVICE_TO_HOST)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, negative errno code if failure. </dd></dl>

</div>
</div>
<a id="ac7e46d51c49ce6cb6b0c7ad7f8010292" name="ac7e46d51c49ce6cb6b0c7ad7f8010292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e46d51c49ce6cb6b0c7ad7f8010292">&#9670;&nbsp;</a></span>pcie_ep_xfer_data_memcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcie_ep_xfer_data_memcpy </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a2095b9bffea4b2656950c6c0419edbf1">uint64_t</a>&#160;</td>
          <td class="paramname"><em>pcie_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a> *&#160;</td>
          <td class="paramname"><em>local_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="pcie__ep_8h.html#aa7c51648c5a1663dd4dec689727a510b">pcie_ob_mem_type</a>&#160;</td>
          <td class="paramname"><em>ob_mem_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="pcie__ep_8h.html#acd2605f2fb5676ded5f125712681d458">xfer_direction</a>&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data transfer using memcpy. </p>
<p >Helper API to achieve data transfer with memcpy through PCIe outbound memory</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Pointer to the device structure for the driver instance </td></tr>
    <tr><td class="paramname">pcie_addr</td><td>Host memory buffer address </td></tr>
    <tr><td class="paramname">local_addr</td><td>Local memory buffer address </td></tr>
    <tr><td class="paramname">size</td><td>Data transfer size (bytes) </td></tr>
    <tr><td class="paramname">ob_mem_type</td><td>Hint if lowmem/highmem outbound region has to be used (PCIE_OB_LOWMEM / PCIE_OB_HIGHMEM / PCIE_OB_ANYMEM), should be PCIE_OB_LOWMEM if bus master cannot generate more than 32-bit address </td></tr>
    <tr><td class="paramname">dir</td><td>Data transfer direction (HOST_TO_DEVICE / DEVICE_TO_HOST)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, negative errno code if failure. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_4fe5cf12322eb0f9892753dc20f1484c.html">drivers</a></li><li class="navelem"><a class="el" href="dir_c53ab2a99d211ceb14df6f4f5cbc32f7.html">pcie</a></li><li class="navelem"><a class="el" href="dir_1d33c67dd082f6bd8d2a3afb17fa5011.html">endpoint</a></li><li class="navelem"><a class="el" href="pcie__ep_8h.html">pcie_ep.h</a></li>
    <li class="footer">Generated on Mon Feb 21 2022 04:59:40 for Zephyr API Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
<script type="text/javascript">
  $(function() {
    toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
    toggleButton.title = "Toggle Light/Dark Mode"
    $(document).ready(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
    // every resize will remove the button, which is why it has to be added again:
    $(window).resize(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
  })
</script>
</body>
</html>
