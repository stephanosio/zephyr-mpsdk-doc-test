<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zephyr API Documentation: Thread APIs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-zephyr.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-zephyr.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Zephyr API Documentation
   &#160;<span id="projectnumber">3.0.99</span>
   </div>
   <div id="projectbrief">A Scalable Open Source RTOS</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__thread__apis.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Thread APIs<div class="ingroups"><a class="el" href="group__kernel__apis.html">Kernel APIs</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structk__thread.html">k_thread</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gad503fbcca905a9266b0e154e3ded258c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#gad503fbcca905a9266b0e154e3ded258c">K_ESSENTIAL</a>&#160;&#160;&#160;(<a class="el" href="group__sys-util.html#ga3a8ea58898cb58fc96013383d39f482c">BIT</a>(0))</td></tr>
<tr class="memdesc:gad503fbcca905a9266b0e154e3ded258c"><td class="mdescLeft">&#160;</td><td class="mdescRight">system thread that must not abort  <a href="group__thread__apis.html#gad503fbcca905a9266b0e154e3ded258c">More...</a><br /></td></tr>
<tr class="separator:gad503fbcca905a9266b0e154e3ded258c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab18cf1e8728e7adf53db2ae4bbcdd951"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#gab18cf1e8728e7adf53db2ae4bbcdd951">K_FP_REGS</a>&#160;&#160;&#160;(<a class="el" href="group__sys-util.html#ga3a8ea58898cb58fc96013383d39f482c">BIT</a>(1))</td></tr>
<tr class="memdesc:gab18cf1e8728e7adf53db2ae4bbcdd951"><td class="mdescLeft">&#160;</td><td class="mdescRight">FPU registers are managed by context switch.  <a href="group__thread__apis.html#gab18cf1e8728e7adf53db2ae4bbcdd951">More...</a><br /></td></tr>
<tr class="separator:gab18cf1e8728e7adf53db2ae4bbcdd951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb5340339892f22301e02697c6039ccc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#gacb5340339892f22301e02697c6039ccc">K_USER</a>&#160;&#160;&#160;(<a class="el" href="group__sys-util.html#ga3a8ea58898cb58fc96013383d39f482c">BIT</a>(2))</td></tr>
<tr class="memdesc:gacb5340339892f22301e02697c6039ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">user mode thread  <a href="group__thread__apis.html#gacb5340339892f22301e02697c6039ccc">More...</a><br /></td></tr>
<tr class="separator:gacb5340339892f22301e02697c6039ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1788a413a055745d1de71b4da7c2eb2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#gaa1788a413a055745d1de71b4da7c2eb2">K_INHERIT_PERMS</a>&#160;&#160;&#160;(<a class="el" href="group__sys-util.html#ga3a8ea58898cb58fc96013383d39f482c">BIT</a>(3))</td></tr>
<tr class="memdesc:gaa1788a413a055745d1de71b4da7c2eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inherit Permissions.  <a href="group__thread__apis.html#gaa1788a413a055745d1de71b4da7c2eb2">More...</a><br /></td></tr>
<tr class="separator:gaa1788a413a055745d1de71b4da7c2eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbdb579370978fe07e4a863a84bd8bee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#gacbdb579370978fe07e4a863a84bd8bee">K_CALLBACK_STATE</a>&#160;&#160;&#160;(<a class="el" href="group__sys-util.html#ga3a8ea58898cb58fc96013383d39f482c">BIT</a>(4))</td></tr>
<tr class="memdesc:gacbdb579370978fe07e4a863a84bd8bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback item state.  <a href="group__thread__apis.html#gacbdb579370978fe07e4a863a84bd8bee">More...</a><br /></td></tr>
<tr class="separator:gacbdb579370978fe07e4a863a84bd8bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafec540511e6d2e0a074a5bfb515c53b0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#gafec540511e6d2e0a074a5bfb515c53b0">k_thread_access_grant</a>(<a class="el" href="timeout__order_8c.html#a2ff5187d48101eb303964e1b8983beb4">thread</a>, ...)&#160;&#160;&#160;	<a class="el" href="group__sys-util.html#ga1a2b2aa21d7cc37f33e6a62abd2ae340">FOR_EACH_FIXED_ARG</a>(<a class="el" href="group__usermode__apis.html#ga94087bedf96fe2a2bea437d3d585ca22">k_object_access_grant</a>, (;), <a class="el" href="timeout__order_8c.html#a2ff5187d48101eb303964e1b8983beb4">thread</a>, __VA_ARGS__)</td></tr>
<tr class="memdesc:gafec540511e6d2e0a074a5bfb515c53b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grant a thread access to a set of kernel objects.  <a href="group__thread__apis.html#gafec540511e6d2e0a074a5bfb515c53b0">More...</a><br /></td></tr>
<tr class="separator:gafec540511e6d2e0a074a5bfb515c53b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3ced58648ca35788a40676e8478ecd2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#gab3ced58648ca35788a40676e8478ecd2">K_THREAD_DEFINE</a>(name,  stack_size,  entry,  p1,  p2,  p3,  prio,  options,  delay)</td></tr>
<tr class="memdesc:gab3ced58648ca35788a40676e8478ecd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically define and initialize a thread.  <a href="group__thread__apis.html#gab3ced58648ca35788a40676e8478ecd2">More...</a><br /></td></tr>
<tr class="separator:gab3ced58648ca35788a40676e8478ecd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf9f23a6ff9dae76af56f25b373e74c75"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#gaf9f23a6ff9dae76af56f25b373e74c75">k_thread_user_cb_t</a>) (const struct <a class="el" href="structk__thread.html">k_thread</a> *<a class="el" href="timeout__order_8c.html#a2ff5187d48101eb303964e1b8983beb4">thread</a>, void *<a class="el" href="timer_2timer__api_2src_2main_8c.html#a862de962130decf51321624c10294338">user_data</a>)</td></tr>
<tr class="separator:gaf9f23a6ff9dae76af56f25b373e74c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae2596d56800769b06fc03c194a126a97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#gae2596d56800769b06fc03c194a126a97">k_thread_foreach</a> (<a class="el" href="group__thread__apis.html#gaf9f23a6ff9dae76af56f25b373e74c75">k_thread_user_cb_t</a> user_cb, void *<a class="el" href="timer_2timer__api_2src_2main_8c.html#a862de962130decf51321624c10294338">user_data</a>)</td></tr>
<tr class="memdesc:gae2596d56800769b06fc03c194a126a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all the threads in the system.  <a href="group__thread__apis.html#gae2596d56800769b06fc03c194a126a97">More...</a><br /></td></tr>
<tr class="separator:gae2596d56800769b06fc03c194a126a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30ef8b445a6c1b4a82651674dbb737fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#ga30ef8b445a6c1b4a82651674dbb737fc">k_thread_foreach_unlocked</a> (<a class="el" href="group__thread__apis.html#gaf9f23a6ff9dae76af56f25b373e74c75">k_thread_user_cb_t</a> user_cb, void *<a class="el" href="timer_2timer__api_2src_2main_8c.html#a862de962130decf51321624c10294338">user_data</a>)</td></tr>
<tr class="memdesc:ga30ef8b445a6c1b4a82651674dbb737fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all the threads in the system without locking.  <a href="group__thread__apis.html#ga30ef8b445a6c1b4a82651674dbb737fc">More...</a><br /></td></tr>
<tr class="separator:ga30ef8b445a6c1b4a82651674dbb737fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5b0bff3102f1656089f5875d999a367"><td class="memItemLeft" align="right" valign="top"><a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#gad5b0bff3102f1656089f5875d999a367">k_thread_create</a> (struct <a class="el" href="structk__thread.html">k_thread</a> *new_thread, <a class="el" href="arch__interface_8h.html#a3e4bde3075edb41069b258d999333b0e">k_thread_stack_t</a> *<a class="el" href="test__stack__fail_8c.html#a6856ea318b5a9498715e4444b13a1de1">stack</a>, size_t stack_size, <a class="el" href="arch__interface_8h.html#af1bd193a26c6e6a8658140185cae42e1">k_thread_entry_t</a> entry, void *p1, void *p2, void *p3, int prio, <a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> options, <a class="el" href="structk__timeout__t.html">k_timeout_t</a> delay)</td></tr>
<tr class="memdesc:gad5b0bff3102f1656089f5875d999a367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a thread.  <a href="group__thread__apis.html#gad5b0bff3102f1656089f5875d999a367">More...</a><br /></td></tr>
<tr class="separator:gad5b0bff3102f1656089f5875d999a367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fbe1c8a5f3ef1c25382c7d6fca35764"><td class="memItemLeft" align="right" valign="top">FUNC_NORETURN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#ga3fbe1c8a5f3ef1c25382c7d6fca35764">k_thread_user_mode_enter</a> (<a class="el" href="arch__interface_8h.html#af1bd193a26c6e6a8658140185cae42e1">k_thread_entry_t</a> entry, void *p1, void *p2, void *p3)</td></tr>
<tr class="memdesc:ga3fbe1c8a5f3ef1c25382c7d6fca35764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop a thread's privileges permanently to user mode.  <a href="group__thread__apis.html#ga3fbe1c8a5f3ef1c25382c7d6fca35764">More...</a><br /></td></tr>
<tr class="separator:ga3fbe1c8a5f3ef1c25382c7d6fca35764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f46c06833add2a2e0ddb7242f06702c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#ga3f46c06833add2a2e0ddb7242f06702c">k_thread_heap_assign</a> (struct <a class="el" href="structk__thread.html">k_thread</a> *<a class="el" href="timeout__order_8c.html#a2ff5187d48101eb303964e1b8983beb4">thread</a>, struct <a class="el" href="structk__heap.html">k_heap</a> *heap)</td></tr>
<tr class="memdesc:ga3f46c06833add2a2e0ddb7242f06702c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a resource memory pool to a thread.  <a href="group__thread__apis.html#ga3f46c06833add2a2e0ddb7242f06702c">More...</a><br /></td></tr>
<tr class="separator:ga3f46c06833add2a2e0ddb7242f06702c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga220d22dc35115fcdc0badb262e7a019d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#ga220d22dc35115fcdc0badb262e7a019d">k_thread_system_pool_assign</a> (struct <a class="el" href="structk__thread.html">k_thread</a> *<a class="el" href="timeout__order_8c.html#a2ff5187d48101eb303964e1b8983beb4">thread</a>)</td></tr>
<tr class="memdesc:ga220d22dc35115fcdc0badb262e7a019d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the system heap as a thread's resource pool.  <a href="group__thread__apis.html#ga220d22dc35115fcdc0badb262e7a019d">More...</a><br /></td></tr>
<tr class="separator:ga220d22dc35115fcdc0badb262e7a019d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40a733561eb1f64dcaae0e01b167d233"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#ga40a733561eb1f64dcaae0e01b167d233">k_thread_join</a> (struct <a class="el" href="structk__thread.html">k_thread</a> *<a class="el" href="timeout__order_8c.html#a2ff5187d48101eb303964e1b8983beb4">thread</a>, <a class="el" href="structk__timeout__t.html">k_timeout_t</a> <a class="el" href="timer_2cycle64_2src_2main_8c.html#a8f4b69a82b00d7baf3f1f7d480bb7fa0">timeout</a>)</td></tr>
<tr class="memdesc:ga40a733561eb1f64dcaae0e01b167d233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep until a thread exits.  <a href="group__thread__apis.html#ga40a733561eb1f64dcaae0e01b167d233">More...</a><br /></td></tr>
<tr class="separator:ga40a733561eb1f64dcaae0e01b167d233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48d4b041790454da4d68ac8711f29657"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a0c18914b3041c2f583aba76f418399c2">int32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#ga48d4b041790454da4d68ac8711f29657">k_sleep</a> (<a class="el" href="structk__timeout__t.html">k_timeout_t</a> <a class="el" href="timer_2cycle64_2src_2main_8c.html#a8f4b69a82b00d7baf3f1f7d480bb7fa0">timeout</a>)</td></tr>
<tr class="memdesc:ga48d4b041790454da4d68ac8711f29657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the current thread to sleep.  <a href="group__thread__apis.html#ga48d4b041790454da4d68ac8711f29657">More...</a><br /></td></tr>
<tr class="separator:ga48d4b041790454da4d68ac8711f29657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51307cdfe153ab3e918b18755d97c5d9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdint_8h.html#a0c18914b3041c2f583aba76f418399c2">int32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#ga51307cdfe153ab3e918b18755d97c5d9">k_msleep</a> (<a class="el" href="stdint_8h.html#a0c18914b3041c2f583aba76f418399c2">int32_t</a> <a class="el" href="kobject_8c.html#a14afa64cf434f39c0f93fedf0e2616d9">ms</a>)</td></tr>
<tr class="memdesc:ga51307cdfe153ab3e918b18755d97c5d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the current thread to sleep.  <a href="group__thread__apis.html#ga51307cdfe153ab3e918b18755d97c5d9">More...</a><br /></td></tr>
<tr class="separator:ga51307cdfe153ab3e918b18755d97c5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeac56bb072ce295b9fdc372ab8cee67e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a0c18914b3041c2f583aba76f418399c2">int32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#gaeac56bb072ce295b9fdc372ab8cee67e">k_usleep</a> (<a class="el" href="stdint_8h.html#a0c18914b3041c2f583aba76f418399c2">int32_t</a> us)</td></tr>
<tr class="memdesc:gaeac56bb072ce295b9fdc372ab8cee67e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the current thread to sleep with microsecond resolution.  <a href="group__thread__apis.html#gaeac56bb072ce295b9fdc372ab8cee67e">More...</a><br /></td></tr>
<tr class="separator:gaeac56bb072ce295b9fdc372ab8cee67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga550b642e071480323e589866abb99c22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#ga550b642e071480323e589866abb99c22">k_busy_wait</a> (<a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> usec_to_wait)</td></tr>
<tr class="memdesc:ga550b642e071480323e589866abb99c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cause the current thread to busy wait.  <a href="group__thread__apis.html#ga550b642e071480323e589866abb99c22">More...</a><br /></td></tr>
<tr class="separator:ga550b642e071480323e589866abb99c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08a3484c33444ecedc2d71d78495a295"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#ga08a3484c33444ecedc2d71d78495a295">k_yield</a> (void)</td></tr>
<tr class="memdesc:ga08a3484c33444ecedc2d71d78495a295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield the current thread.  <a href="group__thread__apis.html#ga08a3484c33444ecedc2d71d78495a295">More...</a><br /></td></tr>
<tr class="separator:ga08a3484c33444ecedc2d71d78495a295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9275a019c8ff3c7fe49a81f8c078157e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#ga9275a019c8ff3c7fe49a81f8c078157e">k_wakeup</a> (<a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a> <a class="el" href="timeout__order_8c.html#a2ff5187d48101eb303964e1b8983beb4">thread</a>)</td></tr>
<tr class="memdesc:ga9275a019c8ff3c7fe49a81f8c078157e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wake up a sleeping thread.  <a href="group__thread__apis.html#ga9275a019c8ff3c7fe49a81f8c078157e">More...</a><br /></td></tr>
<tr class="separator:ga9275a019c8ff3c7fe49a81f8c078157e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ef1ed0fb9513df8096ede1e52fc76b2"><td class="memItemLeft" align="right" valign="top">static __attribute_const__ <a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#ga7ef1ed0fb9513df8096ede1e52fc76b2">k_current_get</a> (void)</td></tr>
<tr class="memdesc:ga7ef1ed0fb9513df8096ede1e52fc76b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get thread ID of the current thread.  <a href="group__thread__apis.html#ga7ef1ed0fb9513df8096ede1e52fc76b2">More...</a><br /></td></tr>
<tr class="separator:ga7ef1ed0fb9513df8096ede1e52fc76b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f44bb0307bea7a97227764ecd7bf963"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#ga1f44bb0307bea7a97227764ecd7bf963">k_thread_abort</a> (<a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a> <a class="el" href="timeout__order_8c.html#a2ff5187d48101eb303964e1b8983beb4">thread</a>)</td></tr>
<tr class="memdesc:ga1f44bb0307bea7a97227764ecd7bf963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort a thread.  <a href="group__thread__apis.html#ga1f44bb0307bea7a97227764ecd7bf963">More...</a><br /></td></tr>
<tr class="separator:ga1f44bb0307bea7a97227764ecd7bf963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88031bd9fcfcd4305bae4029a4d8416f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#ga88031bd9fcfcd4305bae4029a4d8416f">k_thread_start</a> (<a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a> <a class="el" href="timeout__order_8c.html#a2ff5187d48101eb303964e1b8983beb4">thread</a>)</td></tr>
<tr class="memdesc:ga88031bd9fcfcd4305bae4029a4d8416f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an inactive thread.  <a href="group__thread__apis.html#ga88031bd9fcfcd4305bae4029a4d8416f">More...</a><br /></td></tr>
<tr class="separator:ga88031bd9fcfcd4305bae4029a4d8416f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80013f10d12ccdffbbd88cee048f1c21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__clock__apis.html#ga9832cb0adc2d1866420e5c370a0863e2">k_ticks_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#ga80013f10d12ccdffbbd88cee048f1c21">k_thread_timeout_expires_ticks</a> (const struct <a class="el" href="structk__thread.html">k_thread</a> *<a class="el" href="test__sched__timeslice__and__lock_8c.html#a858810a6da56663cf4e01aecb4f6e8aa">t</a>)</td></tr>
<tr class="memdesc:ga80013f10d12ccdffbbd88cee048f1c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get time when a thread wakes up, in system ticks.  <a href="group__thread__apis.html#ga80013f10d12ccdffbbd88cee048f1c21">More...</a><br /></td></tr>
<tr class="separator:ga80013f10d12ccdffbbd88cee048f1c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cb4126c8e4f62bd44f3dd03f2e4a423"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__clock__apis.html#ga9832cb0adc2d1866420e5c370a0863e2">k_ticks_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#ga4cb4126c8e4f62bd44f3dd03f2e4a423">k_thread_timeout_remaining_ticks</a> (const struct <a class="el" href="structk__thread.html">k_thread</a> *<a class="el" href="test__sched__timeslice__and__lock_8c.html#a858810a6da56663cf4e01aecb4f6e8aa">t</a>)</td></tr>
<tr class="memdesc:ga4cb4126c8e4f62bd44f3dd03f2e4a423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get time remaining before a thread wakes up, in system ticks.  <a href="group__thread__apis.html#ga4cb4126c8e4f62bd44f3dd03f2e4a423">More...</a><br /></td></tr>
<tr class="separator:ga4cb4126c8e4f62bd44f3dd03f2e4a423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a46ed8ad2c3b12416fafe11325f82b3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#ga3a46ed8ad2c3b12416fafe11325f82b3">k_thread_priority_get</a> (<a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a> <a class="el" href="timeout__order_8c.html#a2ff5187d48101eb303964e1b8983beb4">thread</a>)</td></tr>
<tr class="memdesc:ga3a46ed8ad2c3b12416fafe11325f82b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a thread's priority.  <a href="group__thread__apis.html#ga3a46ed8ad2c3b12416fafe11325f82b3">More...</a><br /></td></tr>
<tr class="separator:ga3a46ed8ad2c3b12416fafe11325f82b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24e50a60c524d1eb22fe21cdf269b6a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#ga24e50a60c524d1eb22fe21cdf269b6a6">k_thread_priority_set</a> (<a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a> <a class="el" href="timeout__order_8c.html#a2ff5187d48101eb303964e1b8983beb4">thread</a>, int prio)</td></tr>
<tr class="memdesc:ga24e50a60c524d1eb22fe21cdf269b6a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a thread's priority.  <a href="group__thread__apis.html#ga24e50a60c524d1eb22fe21cdf269b6a6">More...</a><br /></td></tr>
<tr class="separator:ga24e50a60c524d1eb22fe21cdf269b6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad887f16c1dd6f3247682a83beb22d1ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#gad887f16c1dd6f3247682a83beb22d1ce">k_thread_deadline_set</a> (<a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a> <a class="el" href="timeout__order_8c.html#a2ff5187d48101eb303964e1b8983beb4">thread</a>, int deadline)</td></tr>
<tr class="memdesc:gad887f16c1dd6f3247682a83beb22d1ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set deadline expiration time for scheduler.  <a href="group__thread__apis.html#gad887f16c1dd6f3247682a83beb22d1ce">More...</a><br /></td></tr>
<tr class="separator:gad887f16c1dd6f3247682a83beb22d1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80b9c58df6600c7e79f16756c128f44c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#ga80b9c58df6600c7e79f16756c128f44c">k_thread_cpu_mask_clear</a> (<a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a> <a class="el" href="timeout__order_8c.html#a2ff5187d48101eb303964e1b8983beb4">thread</a>)</td></tr>
<tr class="memdesc:ga80b9c58df6600c7e79f16756c128f44c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all CPU enable masks to zero.  <a href="group__thread__apis.html#ga80b9c58df6600c7e79f16756c128f44c">More...</a><br /></td></tr>
<tr class="separator:ga80b9c58df6600c7e79f16756c128f44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedcfeb0964ae72611791241580b2119d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#gaedcfeb0964ae72611791241580b2119d">k_thread_cpu_mask_enable_all</a> (<a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a> <a class="el" href="timeout__order_8c.html#a2ff5187d48101eb303964e1b8983beb4">thread</a>)</td></tr>
<tr class="memdesc:gaedcfeb0964ae72611791241580b2119d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all CPU enable masks to one.  <a href="group__thread__apis.html#gaedcfeb0964ae72611791241580b2119d">More...</a><br /></td></tr>
<tr class="separator:gaedcfeb0964ae72611791241580b2119d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga306587604a7496db8059bd395fd90fc0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#ga306587604a7496db8059bd395fd90fc0">k_thread_cpu_mask_enable</a> (<a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a> <a class="el" href="timeout__order_8c.html#a2ff5187d48101eb303964e1b8983beb4">thread</a>, int cpu)</td></tr>
<tr class="memdesc:ga306587604a7496db8059bd395fd90fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable thread to run on specified CPU.  <a href="group__thread__apis.html#ga306587604a7496db8059bd395fd90fc0">More...</a><br /></td></tr>
<tr class="separator:ga306587604a7496db8059bd395fd90fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89e6c07ac112da75b2ef115d1a557d44"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#ga89e6c07ac112da75b2ef115d1a557d44">k_thread_cpu_mask_disable</a> (<a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a> <a class="el" href="timeout__order_8c.html#a2ff5187d48101eb303964e1b8983beb4">thread</a>, int cpu)</td></tr>
<tr class="memdesc:ga89e6c07ac112da75b2ef115d1a557d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevent thread to run on specified CPU.  <a href="group__thread__apis.html#ga89e6c07ac112da75b2ef115d1a557d44">More...</a><br /></td></tr>
<tr class="separator:ga89e6c07ac112da75b2ef115d1a557d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66cf8682fb65870eceb5e57d667a8d4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#ga66cf8682fb65870eceb5e57d667a8d4e">k_thread_suspend</a> (<a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a> <a class="el" href="timeout__order_8c.html#a2ff5187d48101eb303964e1b8983beb4">thread</a>)</td></tr>
<tr class="memdesc:ga66cf8682fb65870eceb5e57d667a8d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend a thread.  <a href="group__thread__apis.html#ga66cf8682fb65870eceb5e57d667a8d4e">More...</a><br /></td></tr>
<tr class="separator:ga66cf8682fb65870eceb5e57d667a8d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga117b26f8569ec3045ead1fad1851663d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#ga117b26f8569ec3045ead1fad1851663d">k_thread_resume</a> (<a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a> <a class="el" href="timeout__order_8c.html#a2ff5187d48101eb303964e1b8983beb4">thread</a>)</td></tr>
<tr class="memdesc:ga117b26f8569ec3045ead1fad1851663d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume a suspended thread.  <a href="group__thread__apis.html#ga117b26f8569ec3045ead1fad1851663d">More...</a><br /></td></tr>
<tr class="separator:ga117b26f8569ec3045ead1fad1851663d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga877c1bfeffbf8f097d1656f9e10a66e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#ga877c1bfeffbf8f097d1656f9e10a66e8">k_sched_time_slice_set</a> (<a class="el" href="stdint_8h.html#a0c18914b3041c2f583aba76f418399c2">int32_t</a> slice, int prio)</td></tr>
<tr class="memdesc:ga877c1bfeffbf8f097d1656f9e10a66e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set time-slicing period and scope.  <a href="group__thread__apis.html#ga877c1bfeffbf8f097d1656f9e10a66e8">More...</a><br /></td></tr>
<tr class="separator:ga877c1bfeffbf8f097d1656f9e10a66e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f0c5d0b9f279b12a4ad97db0c116a5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#ga4f0c5d0b9f279b12a4ad97db0c116a5f">k_sched_lock</a> (void)</td></tr>
<tr class="memdesc:ga4f0c5d0b9f279b12a4ad97db0c116a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the scheduler.  <a href="group__thread__apis.html#ga4f0c5d0b9f279b12a4ad97db0c116a5f">More...</a><br /></td></tr>
<tr class="separator:ga4f0c5d0b9f279b12a4ad97db0c116a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b26f64523cc4c36522cc828ccf85580"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#ga7b26f64523cc4c36522cc828ccf85580">k_sched_unlock</a> (void)</td></tr>
<tr class="memdesc:ga7b26f64523cc4c36522cc828ccf85580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the scheduler.  <a href="group__thread__apis.html#ga7b26f64523cc4c36522cc828ccf85580">More...</a><br /></td></tr>
<tr class="separator:ga7b26f64523cc4c36522cc828ccf85580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4834d9b81ed60c00eee77b0d4f8ab9e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#ga4834d9b81ed60c00eee77b0d4f8ab9e4">k_thread_custom_data_set</a> (void *value)</td></tr>
<tr class="memdesc:ga4834d9b81ed60c00eee77b0d4f8ab9e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set current thread's custom data.  <a href="group__thread__apis.html#ga4834d9b81ed60c00eee77b0d4f8ab9e4">More...</a><br /></td></tr>
<tr class="separator:ga4834d9b81ed60c00eee77b0d4f8ab9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19af063cff7b306ba28062996922740d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#ga19af063cff7b306ba28062996922740d">k_thread_custom_data_get</a> (void)</td></tr>
<tr class="memdesc:ga19af063cff7b306ba28062996922740d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current thread's custom data.  <a href="group__thread__apis.html#ga19af063cff7b306ba28062996922740d">More...</a><br /></td></tr>
<tr class="separator:ga19af063cff7b306ba28062996922740d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23107333f134b9c9a8b692374211e841"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#ga23107333f134b9c9a8b692374211e841">k_thread_name_set</a> (<a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a> <a class="el" href="timeout__order_8c.html#a2ff5187d48101eb303964e1b8983beb4">thread</a>, const char *str)</td></tr>
<tr class="memdesc:ga23107333f134b9c9a8b692374211e841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set current thread name.  <a href="group__thread__apis.html#ga23107333f134b9c9a8b692374211e841">More...</a><br /></td></tr>
<tr class="separator:ga23107333f134b9c9a8b692374211e841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadebf45da56dee393164569742459dc0a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#gadebf45da56dee393164569742459dc0a">k_thread_name_get</a> (<a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a> <a class="el" href="timeout__order_8c.html#a2ff5187d48101eb303964e1b8983beb4">thread</a>)</td></tr>
<tr class="memdesc:gadebf45da56dee393164569742459dc0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get thread name.  <a href="group__thread__apis.html#gadebf45da56dee393164569742459dc0a">More...</a><br /></td></tr>
<tr class="separator:gadebf45da56dee393164569742459dc0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07b59ade055c69929ccdc08a14361794"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#ga07b59ade055c69929ccdc08a14361794">k_thread_name_copy</a> (<a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a> <a class="el" href="timeout__order_8c.html#a2ff5187d48101eb303964e1b8983beb4">thread</a>, char *buf, size_t size)</td></tr>
<tr class="memdesc:ga07b59ade055c69929ccdc08a14361794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the thread name into a supplied buffer.  <a href="group__thread__apis.html#ga07b59ade055c69929ccdc08a14361794">More...</a><br /></td></tr>
<tr class="separator:ga07b59ade055c69929ccdc08a14361794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae36c37d54522fbf8d9a34b93991e51ca"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__apis.html#gae36c37d54522fbf8d9a34b93991e51ca">k_thread_state_str</a> (<a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a> thread_id)</td></tr>
<tr class="memdesc:gae36c37d54522fbf8d9a34b93991e51ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get thread state string.  <a href="group__thread__apis.html#gae36c37d54522fbf8d9a34b93991e51ca">More...</a><br /></td></tr>
<tr class="separator:gae36c37d54522fbf8d9a34b93991e51ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gacbdb579370978fe07e4a863a84bd8bee" name="gacbdb579370978fe07e4a863a84bd8bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbdb579370978fe07e4a863a84bd8bee">&#9670;&nbsp;</a></span>K_CALLBACK_STATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define K_CALLBACK_STATE&#160;&#160;&#160;(<a class="el" href="group__sys-util.html#ga3a8ea58898cb58fc96013383d39f482c">BIT</a>(4))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Callback item state. </p>
<p >This is a single bit of state reserved for "callback manager" utilities (p4wq initially) who need to track operations invoked from within a user-provided callback they have been invoked. Effectively it serves as a tiny bit of zero-overhead TLS data. </p>

</div>
</div>
<a id="gad503fbcca905a9266b0e154e3ded258c" name="gad503fbcca905a9266b0e154e3ded258c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad503fbcca905a9266b0e154e3ded258c">&#9670;&nbsp;</a></span>K_ESSENTIAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define K_ESSENTIAL&#160;&#160;&#160;(<a class="el" href="group__sys-util.html#ga3a8ea58898cb58fc96013383d39f482c">BIT</a>(0))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>system thread that must not abort </p>

</div>
</div>
<a id="gab18cf1e8728e7adf53db2ae4bbcdd951" name="gab18cf1e8728e7adf53db2ae4bbcdd951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab18cf1e8728e7adf53db2ae4bbcdd951">&#9670;&nbsp;</a></span>K_FP_REGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define K_FP_REGS&#160;&#160;&#160;(<a class="el" href="group__sys-util.html#ga3a8ea58898cb58fc96013383d39f482c">BIT</a>(1))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>FPU registers are managed by context switch. </p>
<p >This option indicates that the thread uses the CPU's floating point registers. This instructs the kernel to take additional steps to save and restore the contents of these registers when scheduling the thread. No effect if </p><pre class="fragment">embed:rst:inline :kconfig:option:`CONFIG_FPU_SHARING` </pre><p> is not enabled. </p>

</div>
</div>
<a id="gaa1788a413a055745d1de71b4da7c2eb2" name="gaa1788a413a055745d1de71b4da7c2eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1788a413a055745d1de71b4da7c2eb2">&#9670;&nbsp;</a></span>K_INHERIT_PERMS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define K_INHERIT_PERMS&#160;&#160;&#160;(<a class="el" href="group__sys-util.html#ga3a8ea58898cb58fc96013383d39f482c">BIT</a>(3))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Inherit Permissions. </p>
<p >Indicates that the thread being created should inherit all kernel object permissions from the thread that created it. No effect if </p><pre class="fragment">embed:rst:inline :kconfig:option:`CONFIG_USERSPACE` </pre><p> is not enabled. </p>

</div>
</div>
<a id="gafec540511e6d2e0a074a5bfb515c53b0" name="gafec540511e6d2e0a074a5bfb515c53b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafec540511e6d2e0a074a5bfb515c53b0">&#9670;&nbsp;</a></span>k_thread_access_grant</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define k_thread_access_grant</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="timeout__order_8c.html#a2ff5187d48101eb303964e1b8983beb4">thread</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;	<a class="el" href="group__sys-util.html#ga1a2b2aa21d7cc37f33e6a62abd2ae340">FOR_EACH_FIXED_ARG</a>(<a class="el" href="group__usermode__apis.html#ga94087bedf96fe2a2bea437d3d585ca22">k_object_access_grant</a>, (;), <a class="el" href="timeout__order_8c.html#a2ff5187d48101eb303964e1b8983beb4">thread</a>, __VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Grant a thread access to a set of kernel objects. </p>
<p >This is a convenience function. For the provided thread, grant access to the remaining arguments, which must be pointers to kernel objects.</p>
<p >The thread object must be initialized (i.e. running). The objects don't need to be. Note that NULL shouldn't be passed as an argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>Thread to grant access to objects </td></tr>
    <tr><td class="paramname">...</td><td>list of kernel object pointers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab3ced58648ca35788a40676e8478ecd2" name="gab3ced58648ca35788a40676e8478ecd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3ced58648ca35788a40676e8478ecd2">&#9670;&nbsp;</a></span>K_THREAD_DEFINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define K_THREAD_DEFINE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">stack_size, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">entry, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p3, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">prio, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">options, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">delay&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">        <a class="code hl_define" href="group__thread__stack__api.html#gac5368ce24fdeab3863b5c8dee2ebd955">K_THREAD_STACK_DEFINE</a>(_k_thread_stack_##name, stack_size);       \</div>
<div class="line">        struct <a class="code hl_struct" href="structk__thread.html">k_thread</a> _k_thread_obj_##name;                            \</div>
<div class="line">        STRUCT_SECTION_ITERABLE(_static_thread_data, _k_thread_data_##name) = \</div>
<div class="line">                Z_THREAD_INITIALIZER(&amp;_k_thread_obj_##name,              \</div>
<div class="line">                                    _k_thread_stack_##name, stack_size,  \</div>
<div class="line">                                entry, p1, p2, p3, prio, options, delay, \</div>
<div class="line">                                NULL, name);                                     \</div>
<div class="line">        const <a class="code hl_struct" href="structk__thread.html">k_tid_t</a> name = (<a class="code hl_typedef" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a>)&amp;_k_thread_obj_##name</div>
<div class="ttc" id="agroup__thread__stack__api_html_gac5368ce24fdeab3863b5c8dee2ebd955"><div class="ttname"><a href="group__thread__stack__api.html#gac5368ce24fdeab3863b5c8dee2ebd955">K_THREAD_STACK_DEFINE</a></div><div class="ttdeci">#define K_THREAD_STACK_DEFINE(sym, size)</div><div class="ttdoc">Declare a toplevel thread stack memory region.</div><div class="ttdef"><b>Definition:</b> thread_stack.h:521</div></div>
<div class="ttc" id="akernel_2thread_8h_html_a6379f5a1f19ffbc262a6877c4f6e3647"><div class="ttname"><a href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a></div><div class="ttdeci">struct k_thread * k_tid_t</div><div class="ttdef"><b>Definition:</b> thread.h:313</div></div>
<div class="ttc" id="astructk__thread_html"><div class="ttname"><a href="structk__thread.html">k_thread</a></div><div class="ttdef"><b>Definition:</b> thread.h:216</div></div>
</div><!-- fragment -->
<p>Statically define and initialize a thread. </p>
<p >The thread may be scheduled for immediate execution or a delayed start.</p>
<p >Thread options are architecture-specific, and can include K_ESSENTIAL, K_FP_REGS, and K_SSE_REGS. Multiple options may be specified by separating them using "|" (the logical OR operator).</p>
<p >The ID of the thread can be accessed using:</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <a class="code hl_struct" href="structk__thread.html">k_tid_t &lt;name&gt;</a>; </div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the thread. </td></tr>
    <tr><td class="paramname">stack_size</td><td>Stack size in bytes. </td></tr>
    <tr><td class="paramname">entry</td><td>Thread entry function. </td></tr>
    <tr><td class="paramname">p1</td><td>1st entry point parameter. </td></tr>
    <tr><td class="paramname">p2</td><td>2nd entry point parameter. </td></tr>
    <tr><td class="paramname">p3</td><td>3rd entry point parameter. </td></tr>
    <tr><td class="paramname">prio</td><td>Thread priority. </td></tr>
    <tr><td class="paramname">options</td><td>Thread options. </td></tr>
    <tr><td class="paramname">delay</td><td>Scheduling delay (in milliseconds), zero for no delay. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacb5340339892f22301e02697c6039ccc" name="gacb5340339892f22301e02697c6039ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb5340339892f22301e02697c6039ccc">&#9670;&nbsp;</a></span>K_USER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define K_USER&#160;&#160;&#160;(<a class="el" href="group__sys-util.html#ga3a8ea58898cb58fc96013383d39f482c">BIT</a>(2))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>user mode thread </p>
<p >This thread has dropped from supervisor mode to user mode and consequently has additional restrictions </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaf9f23a6ff9dae76af56f25b373e74c75" name="gaf9f23a6ff9dae76af56f25b373e74c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9f23a6ff9dae76af56f25b373e74c75">&#9670;&nbsp;</a></span>k_thread_user_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* k_thread_user_cb_t) (const struct <a class="el" href="structk__thread.html">k_thread</a> *<a class="el" href="timeout__order_8c.html#a2ff5187d48101eb303964e1b8983beb4">thread</a>, void *<a class="el" href="timer_2timer__api_2src_2main_8c.html#a862de962130decf51321624c10294338">user_data</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga550b642e071480323e589866abb99c22" name="ga550b642e071480323e589866abb99c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga550b642e071480323e589866abb99c22">&#9670;&nbsp;</a></span>k_busy_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void k_busy_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a>&#160;</td>
          <td class="paramname"><em>usec_to_wait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Cause the current thread to busy wait. </p>
<p >This routine causes the current thread to execute a "do nothing" loop for <em>usec_to_wait</em> microseconds.</p>
<dl class="section note"><dt>Note</dt><dd>The clock used for the microsecond-resolution delay here may be skewed relative to the clock used for system timeouts like <a class="el" href="group__thread__apis.html#ga48d4b041790454da4d68ac8711f29657" title="Put the current thread to sleep.">k_sleep()</a>. For example k_busy_wait(1000) may take slightly more or less time than k_sleep(K_MSEC(1)), with the offset dependent on clock tolerances. </dd></dl>

</div>
</div>
<a id="ga7ef1ed0fb9513df8096ede1e52fc76b2" name="ga7ef1ed0fb9513df8096ede1e52fc76b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ef1ed0fb9513df8096ede1e52fc76b2">&#9670;&nbsp;</a></span>k_current_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __attribute_const__ <a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a> k_current_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Get thread ID of the current thread. </p>
<dl class="section return"><dt>Returns</dt><dd>ID of current thread. </dd></dl>

</div>
</div>
<a id="ga51307cdfe153ab3e918b18755d97c5d9" name="ga51307cdfe153ab3e918b18755d97c5d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51307cdfe153ab3e918b18755d97c5d9">&#9670;&nbsp;</a></span>k_msleep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdint_8h.html#a0c18914b3041c2f583aba76f418399c2">int32_t</a> k_msleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a0c18914b3041c2f583aba76f418399c2">int32_t</a>&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Put the current thread to sleep. </p>
<p >This routine puts the current thread to sleep for <em>duration</em> milliseconds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>Number of milliseconds to sleep.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if the requested time has elapsed or the number of milliseconds left to sleep, if thread was woken up by <a class="el" href="group__thread__apis.html#ga9275a019c8ff3c7fe49a81f8c078157e">k_wakeup</a> call. </dd></dl>

</div>
</div>
<a id="ga4f0c5d0b9f279b12a4ad97db0c116a5f" name="ga4f0c5d0b9f279b12a4ad97db0c116a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f0c5d0b9f279b12a4ad97db0c116a5f">&#9670;&nbsp;</a></span>k_sched_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void k_sched_lock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Lock the scheduler. </p>
<p >This routine prevents the current thread from being preempted by another thread by instructing the scheduler to treat it as a cooperative thread. If the thread subsequently performs an operation that makes it unready, it will be context switched out in the normal manner. When the thread again becomes the current thread, its non-preemptible status is maintained.</p>
<p >This routine can be called recursively.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__thread__apis.html#ga4f0c5d0b9f279b12a4ad97db0c116a5f" title="Lock the scheduler.">k_sched_lock()</a> and <a class="el" href="group__thread__apis.html#ga7b26f64523cc4c36522cc828ccf85580" title="Unlock the scheduler.">k_sched_unlock()</a> should normally be used when the operation being performed can be safely interrupted by ISRs. However, if the amount of processing involved is very small, better performance may be obtained by using <a class="el" href="group__isr__apis.html#ga19fdde73c3b02fcca6cf1d1e67631228" title="Lock interrupts.">irq_lock()</a> and <a class="el" href="group__isr__apis.html#ga646045943b3b2a130738bcc48867bf57" title="Unlock interrupts.">irq_unlock()</a>. </dd></dl>

</div>
</div>
<a id="ga877c1bfeffbf8f097d1656f9e10a66e8" name="ga877c1bfeffbf8f097d1656f9e10a66e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga877c1bfeffbf8f097d1656f9e10a66e8">&#9670;&nbsp;</a></span>k_sched_time_slice_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void k_sched_time_slice_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a0c18914b3041c2f583aba76f418399c2">int32_t</a>&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Set time-slicing period and scope. </p>
<p >This routine specifies how the scheduler will perform time slicing of preemptible threads.</p>
<p >To enable time slicing, <em>slice</em> must be non-zero. The scheduler ensures that no thread runs for more than the specified time limit before other threads of that priority are given a chance to execute. Any thread whose priority is higher than <em>prio</em> is exempted, and may execute as long as desired without being preempted due to time slicing.</p>
<p >Time slicing only limits the maximum amount of time a thread may continuously execute. Once the scheduler selects a thread for execution, there is no minimum guaranteed time the thread will execute before threads of greater or equal priority are scheduled.</p>
<p >When the current thread is the only one of that priority eligible for execution, this routine has no effect; the thread is immediately rescheduled after the slice period expires.</p>
<p >To disable timeslicing, set both <em>slice</em> and <em>prio</em> to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Maximum time slice length (in milliseconds). </td></tr>
    <tr><td class="paramname">prio</td><td>Highest thread priority level eligible for time slicing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7b26f64523cc4c36522cc828ccf85580" name="ga7b26f64523cc4c36522cc828ccf85580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b26f64523cc4c36522cc828ccf85580">&#9670;&nbsp;</a></span>k_sched_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void k_sched_unlock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Unlock the scheduler. </p>
<p >This routine reverses the effect of a previous call to <a class="el" href="group__thread__apis.html#ga4f0c5d0b9f279b12a4ad97db0c116a5f" title="Lock the scheduler.">k_sched_lock()</a>. A thread must call the routine once for each time it called <a class="el" href="group__thread__apis.html#ga4f0c5d0b9f279b12a4ad97db0c116a5f" title="Lock the scheduler.">k_sched_lock()</a> before the thread becomes preemptible. </p>

</div>
</div>
<a id="ga48d4b041790454da4d68ac8711f29657" name="ga48d4b041790454da4d68ac8711f29657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48d4b041790454da4d68ac8711f29657">&#9670;&nbsp;</a></span>k_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a0c18914b3041c2f583aba76f418399c2">int32_t</a> k_sleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structk__timeout__t.html">k_timeout_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Put the current thread to sleep. </p>
<p >This routine puts the current thread to sleep for <em>duration</em>, specified as a <a class="el" href="structk__timeout__t.html" title="Kernel timeout type.">k_timeout_t</a> object.</p>
<dl class="section note"><dt>Note</dt><dd>if <em>timeout</em> is set to K_FOREVER then the thread is suspended.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Desired duration of sleep.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if the requested time has elapsed or the number of milliseconds left to sleep, if thread was woken up by <a class="el" href="group__thread__apis.html#ga9275a019c8ff3c7fe49a81f8c078157e">k_wakeup</a> call. </dd></dl>

</div>
</div>
<a id="ga1f44bb0307bea7a97227764ecd7bf963" name="ga1f44bb0307bea7a97227764ecd7bf963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f44bb0307bea7a97227764ecd7bf963">&#9670;&nbsp;</a></span>k_thread_abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void k_thread_abort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a>&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Abort a thread. </p>
<p >This routine permanently stops execution of <em>thread</em>. The thread is taken off all kernel queues it is part of (i.e. the ready queue, the timeout queue, or a kernel object wait queue). However, any kernel resources the thread might currently own (such as mutexes or memory blocks) are not released. It is the responsibility of the caller of this routine to ensure all necessary cleanup is performed.</p>
<p >After <a class="el" href="group__thread__apis.html#ga1f44bb0307bea7a97227764ecd7bf963" title="Abort a thread.">k_thread_abort()</a> returns, the thread is guaranteed not to be running or to become runnable anywhere on the system. Normally this is done via blocking the caller (in the same manner as <a class="el" href="group__thread__apis.html#ga40a733561eb1f64dcaae0e01b167d233" title="Sleep until a thread exits.">k_thread_join()</a>), but in interrupt context on SMP systems the implementation is required to spin for threads that are running on other CPUs. Note that as specified, this means that on SMP platforms it is possible for application code to create a deadlock condition by simultaneously aborting a cycle of threads using at least one termination from interrupt context. Zephyr cannot detect all such conditions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>ID of thread to abort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga80b9c58df6600c7e79f16756c128f44c" name="ga80b9c58df6600c7e79f16756c128f44c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80b9c58df6600c7e79f16756c128f44c">&#9670;&nbsp;</a></span>k_thread_cpu_mask_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_thread_cpu_mask_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a>&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Sets all CPU enable masks to zero. </p>
<p >After this returns, the thread will no longer be schedulable on any CPUs. The thread must not be currently runnable.</p>
<dl class="section note"><dt>Note</dt><dd>You should enable <pre class="fragment">embed:rst:inline :kconfig:option:`CONFIG_SCHED_DEADLINE` </pre> in your project configuration.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>Thread to operate upon </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, otherwise error code </dd></dl>

</div>
</div>
<a id="ga89e6c07ac112da75b2ef115d1a557d44" name="ga89e6c07ac112da75b2ef115d1a557d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89e6c07ac112da75b2ef115d1a557d44">&#9670;&nbsp;</a></span>k_thread_cpu_mask_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_thread_cpu_mask_disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cpu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Prevent thread to run on specified CPU. </p>
<p >The thread must not be currently runnable.</p>
<dl class="section note"><dt>Note</dt><dd>You should enable <pre class="fragment">embed:rst:inline :kconfig:option:`CONFIG_SCHED_DEADLINE` </pre> in your project configuration.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>Thread to operate upon </td></tr>
    <tr><td class="paramname">cpu</td><td>CPU index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, otherwise error code </dd></dl>

</div>
</div>
<a id="ga306587604a7496db8059bd395fd90fc0" name="ga306587604a7496db8059bd395fd90fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga306587604a7496db8059bd395fd90fc0">&#9670;&nbsp;</a></span>k_thread_cpu_mask_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_thread_cpu_mask_enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cpu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Enable thread to run on specified CPU. </p>
<p >The thread must not be currently runnable.</p>
<dl class="section note"><dt>Note</dt><dd>You should enable <pre class="fragment">embed:rst:inline :kconfig:option:`CONFIG_SCHED_DEADLINE` </pre> in your project configuration.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>Thread to operate upon </td></tr>
    <tr><td class="paramname">cpu</td><td>CPU index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, otherwise error code </dd></dl>

</div>
</div>
<a id="gaedcfeb0964ae72611791241580b2119d" name="gaedcfeb0964ae72611791241580b2119d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedcfeb0964ae72611791241580b2119d">&#9670;&nbsp;</a></span>k_thread_cpu_mask_enable_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_thread_cpu_mask_enable_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a>&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Sets all CPU enable masks to one. </p>
<p >After this returns, the thread will be schedulable on any CPU. The thread must not be currently runnable.</p>
<dl class="section note"><dt>Note</dt><dd>You should enable <pre class="fragment">embed:rst:inline :kconfig:option:`CONFIG_SCHED_DEADLINE` </pre> in your project configuration.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>Thread to operate upon </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, otherwise error code </dd></dl>

</div>
</div>
<a id="gad5b0bff3102f1656089f5875d999a367" name="gad5b0bff3102f1656089f5875d999a367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5b0bff3102f1656089f5875d999a367">&#9670;&nbsp;</a></span>k_thread_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a> k_thread_create </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__thread.html">k_thread</a> *&#160;</td>
          <td class="paramname"><em>new_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="arch__interface_8h.html#a3e4bde3075edb41069b258d999333b0e">k_thread_stack_t</a> *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stack_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="arch__interface_8h.html#af1bd193a26c6e6a8658140185cae42e1">k_thread_entry_t</a>&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structk__timeout__t.html">k_timeout_t</a>&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Create a thread. </p>
<p >This routine initializes a thread, then schedules it for execution.</p>
<p >The new thread may be scheduled for immediate execution or a delayed start. If the newly spawned thread does not have a delayed start the kernel scheduler may preempt the current thread to allow the new thread to execute.</p>
<p >Thread options are architecture-specific, and can include K_ESSENTIAL, K_FP_REGS, and K_SSE_REGS. Multiple options may be specified by separating them using "|" (the logical OR operator).</p>
<p >Stack objects passed to this function must be originally defined with either of these macros in order to be portable:</p>
<ul>
<li><a class="el" href="group__thread__stack__api.html#gac5368ce24fdeab3863b5c8dee2ebd955" title="Declare a toplevel thread stack memory region.">K_THREAD_STACK_DEFINE()</a> - For stacks that may support either user or supervisor threads.</li>
<li><a class="el" href="threads_2thread__stack_2src_2main_8c.html#a72c0793eec55b1d100382b62b7d3c06d">K_KERNEL_STACK_DEFINE()</a> - For stacks that may support supervisor threads only. These stacks use less memory if CONFIG_USERSPACE is enabled.</li>
</ul>
<p >The stack_size parameter has constraints. It must either be:</p>
<ul>
<li>The original size value passed to <a class="el" href="group__thread__stack__api.html#gac5368ce24fdeab3863b5c8dee2ebd955" title="Declare a toplevel thread stack memory region.">K_THREAD_STACK_DEFINE()</a> or <a class="el" href="threads_2thread__stack_2src_2main_8c.html#a72c0793eec55b1d100382b62b7d3c06d">K_KERNEL_STACK_DEFINE()</a></li>
<li>The return value of <a class="el" href="group__thread__stack__api.html#ga775f8e6b4144cfdd24f3261b6db64150" title="Return the size in bytes of a stack memory region.">K_THREAD_STACK_SIZEOF(stack)</a> if the stack was defined with <a class="el" href="group__thread__stack__api.html#gac5368ce24fdeab3863b5c8dee2ebd955" title="Declare a toplevel thread stack memory region.">K_THREAD_STACK_DEFINE()</a></li>
<li>The return value of <a class="el" href="group__thread__stack__api.html#ga57b3824b117c634dbb6052d47dc4301c">K_KERNEL_STACK_SIZEOF(stack)</a> if the stack was defined with <a class="el" href="threads_2thread__stack_2src_2main_8c.html#a72c0793eec55b1d100382b62b7d3c06d">K_KERNEL_STACK_DEFINE()</a>.</li>
</ul>
<p >Using other values, or sizeof(stack) may produce undefined behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_thread</td><td>Pointer to uninitialized struct <a class="el" href="structk__thread.html">k_thread</a> </td></tr>
    <tr><td class="paramname">stack</td><td>Pointer to the stack space. </td></tr>
    <tr><td class="paramname">stack_size</td><td>Stack size in bytes. </td></tr>
    <tr><td class="paramname">entry</td><td>Thread entry function. </td></tr>
    <tr><td class="paramname">p1</td><td>1st entry point parameter. </td></tr>
    <tr><td class="paramname">p2</td><td>2nd entry point parameter. </td></tr>
    <tr><td class="paramname">p3</td><td>3rd entry point parameter. </td></tr>
    <tr><td class="paramname">prio</td><td>Thread priority. </td></tr>
    <tr><td class="paramname">options</td><td>Thread options. </td></tr>
    <tr><td class="paramname">delay</td><td>Scheduling delay, or K_NO_WAIT (for no delay).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ID of new thread. </dd></dl>

</div>
</div>
<a id="ga19af063cff7b306ba28062996922740d" name="ga19af063cff7b306ba28062996922740d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19af063cff7b306ba28062996922740d">&#9670;&nbsp;</a></span>k_thread_custom_data_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * k_thread_custom_data_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Get current thread's custom data. </p>
<p >This routine returns the custom data for the current thread.</p>
<dl class="section return"><dt>Returns</dt><dd>Current custom data value. </dd></dl>

</div>
</div>
<a id="ga4834d9b81ed60c00eee77b0d4f8ab9e4" name="ga4834d9b81ed60c00eee77b0d4f8ab9e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4834d9b81ed60c00eee77b0d4f8ab9e4">&#9670;&nbsp;</a></span>k_thread_custom_data_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void k_thread_custom_data_set </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Set current thread's custom data. </p>
<p >This routine sets the custom data for the current thread to @ value.</p>
<p >Custom data is not used by the kernel itself, and is freely available for a thread to use as it sees fit. It can be used as a framework upon which to build thread-local storage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>New custom data value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad887f16c1dd6f3247682a83beb22d1ce" name="gad887f16c1dd6f3247682a83beb22d1ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad887f16c1dd6f3247682a83beb22d1ce">&#9670;&nbsp;</a></span>k_thread_deadline_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void k_thread_deadline_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>deadline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Set deadline expiration time for scheduler. </p>
<p >This sets the "deadline" expiration as a time delta from the current time, in the same units used by <a class="el" href="group__clock__apis.html#ga208687de625e0036558343b4e66143d3" title="Read the hardware clock.">k_cycle_get_32()</a>. The scheduler (when deadline scheduling is enabled) will choose the next expiring thread when selecting between threads at the same static priority. Threads at different priorities will be scheduled according to their static priority.</p>
<dl class="section note"><dt>Note</dt><dd>Deadlines are stored internally using 32 bit unsigned integers. The number of cycles between the "first" deadline in the scheduler queue and the "last" deadline must be less than 2^31 (i.e a signed non-negative quantity). Failure to adhere to this rule may result in scheduled threads running in an incorrect deadline order.</dd>
<dd>
Despite the API naming, the scheduler makes no guarantees the the thread WILL be scheduled within that deadline, nor does it take extra metadata (like e.g. the "runtime" and "period" parameters in Linux sched_setattr()) that allows the kernel to validate the scheduling for achievability. Such features could be implemented above this call, which is simply input to the priority selection logic.</dd>
<dd>
You should enable <pre class="fragment">embed:rst:inline :kconfig:option:`CONFIG_SCHED_DEADLINE` </pre> in your project configuration.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>A thread on which to set the deadline </td></tr>
    <tr><td class="paramname">deadline</td><td>A time delta, in cycle units </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae2596d56800769b06fc03c194a126a97" name="gae2596d56800769b06fc03c194a126a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2596d56800769b06fc03c194a126a97">&#9670;&nbsp;</a></span>k_thread_foreach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void k_thread_foreach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__thread__apis.html#gaf9f23a6ff9dae76af56f25b373e74c75">k_thread_user_cb_t</a>&#160;</td>
          <td class="paramname"><em>user_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Iterate over all the threads in the system. </p>
<p >This routine iterates over all the threads in the system and calls the user_cb function for each thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user_cb</td><td>Pointer to the user callback function. </td></tr>
    <tr><td class="paramname">user_data</td><td>Pointer to user data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><pre class="fragment">embed:rst:inline :kconfig:option:`CONFIG_THREAD_MONITOR` </pre> must be set for this function to be effective. </dd>
<dd>
This API uses <a class="el" href="group__spinlock__apis.html#gaac60da4347f5b29ff8c4e5f24c99b3bf">k_spin_lock</a> to protect the _kernel.threads list which means creation of new threads and terminations of existing threads are blocked until this API returns. </dd></dl>

</div>
</div>
<a id="ga30ef8b445a6c1b4a82651674dbb737fc" name="ga30ef8b445a6c1b4a82651674dbb737fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30ef8b445a6c1b4a82651674dbb737fc">&#9670;&nbsp;</a></span>k_thread_foreach_unlocked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void k_thread_foreach_unlocked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__thread__apis.html#gaf9f23a6ff9dae76af56f25b373e74c75">k_thread_user_cb_t</a>&#160;</td>
          <td class="paramname"><em>user_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Iterate over all the threads in the system without locking. </p>
<p >This routine works exactly the same like <a class="el" href="group__thread__apis.html#gae2596d56800769b06fc03c194a126a97">k_thread_foreach</a> but unlocks interrupts when user_cb is executed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user_cb</td><td>Pointer to the user callback function. </td></tr>
    <tr><td class="paramname">user_data</td><td>Pointer to user data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><pre class="fragment">embed:rst:inline :kconfig:option:`CONFIG_THREAD_MONITOR` </pre> must be set for this function to be effective. </dd>
<dd>
This API uses <a class="el" href="group__spinlock__apis.html#gaac60da4347f5b29ff8c4e5f24c99b3bf">k_spin_lock</a> only when accessing the _kernel.threads queue elements. It unlocks it during user callback function processing. If a new task is created when this <code>foreach</code> function is in progress, the added new task would not be included in the enumeration. If a task is aborted during this enumeration, there would be a race here and there is a possibility that this aborted task would be included in the enumeration. </dd>
<dd>
If the task is aborted and the memory occupied by its <code><a class="el" href="structk__thread.html">k_thread</a></code> structure is reused when this <code>k_thread_foreach_unlocked</code> is in progress it might even lead to the system behave unstable. This function may never return, as it would follow some <code>next</code> task pointers treating given pointer as a pointer to the <a class="el" href="structk__thread.html">k_thread</a> structure while it is something different right now. Do not reuse the memory that was occupied by <a class="el" href="structk__thread.html">k_thread</a> structure of aborted task if it was aborted after this function was called in any context. </dd></dl>

</div>
</div>
<a id="ga3f46c06833add2a2e0ddb7242f06702c" name="ga3f46c06833add2a2e0ddb7242f06702c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f46c06833add2a2e0ddb7242f06702c">&#9670;&nbsp;</a></span>k_thread_heap_assign()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void k_thread_heap_assign </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__thread.html">k_thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structk__heap.html">k_heap</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Assign a resource memory pool to a thread. </p>
<p >By default, threads have no resource pool assigned unless their parent thread has a resource pool, in which case it is inherited. Multiple threads may be assigned to the same memory pool.</p>
<p >Changing a thread's resource pool will not migrate allocations from the previous pool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>Target thread to assign a memory pool for resource requests. </td></tr>
    <tr><td class="paramname">heap</td><td>Heap object to use for resources, or NULL if the thread should no longer have a memory pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga40a733561eb1f64dcaae0e01b167d233" name="ga40a733561eb1f64dcaae0e01b167d233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40a733561eb1f64dcaae0e01b167d233">&#9670;&nbsp;</a></span>k_thread_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_thread_join </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__thread.html">k_thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structk__timeout__t.html">k_timeout_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Sleep until a thread exits. </p>
<p >The caller will be put to sleep until the target thread exits, either due to being aborted, self-exiting, or taking a fatal error. This API returns immediately if the thread isn't running.</p>
<p >This API may only be called from ISRs with a K_NO_WAIT timeout, where it can be useful as a predicate to detect when a thread has aborted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>Thread to wait to exit </td></tr>
    <tr><td class="paramname">timeout</td><td>upper bound time to wait for the thread to exit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>success, target thread has exited or wasn't running </td></tr>
    <tr><td class="paramname">-EBUSY</td><td>returned without waiting </td></tr>
    <tr><td class="paramname">-EAGAIN</td><td>waiting period timed out </td></tr>
    <tr><td class="paramname">-EDEADLK</td><td>target thread is joining on the caller, or target thread is the caller </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga07b59ade055c69929ccdc08a14361794" name="ga07b59ade055c69929ccdc08a14361794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07b59ade055c69929ccdc08a14361794">&#9670;&nbsp;</a></span>k_thread_name_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_thread_name_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Copy the thread name into a supplied buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>Thread to obtain name information </td></tr>
    <tr><td class="paramname">buf</td><td>Destination buffer </td></tr>
    <tr><td class="paramname">size</td><td>Destination buffer size </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-ENOSPC</td><td>Destination buffer too small </td></tr>
    <tr><td class="paramname">-EFAULT</td><td>Memory access error </td></tr>
    <tr><td class="paramname">-ENOSYS</td><td>Thread name feature not enabled </td></tr>
    <tr><td class="paramname">0</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadebf45da56dee393164569742459dc0a" name="gadebf45da56dee393164569742459dc0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadebf45da56dee393164569742459dc0a">&#9670;&nbsp;</a></span>k_thread_name_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * k_thread_name_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a>&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Get thread name. </p>
<p >Get the name of a thread</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>Thread ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Thread</td><td>name, or NULL if configuration not enabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga23107333f134b9c9a8b692374211e841" name="ga23107333f134b9c9a8b692374211e841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23107333f134b9c9a8b692374211e841">&#9670;&nbsp;</a></span>k_thread_name_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_thread_name_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Set current thread name. </p>
<p >Set the name of the thread to be used when </p><pre class="fragment">embed:rst:inline :kconfig:option:`CONFIG_THREAD_MONITOR` </pre><p> is enabled for tracing and debugging.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>Thread to set name, or NULL to set the current thread </td></tr>
    <tr><td class="paramname">str</td><td>Name string </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">-EFAULT</td><td>Memory access error with supplied string </td></tr>
    <tr><td class="paramname">-ENOSYS</td><td>Thread name configuration option not enabled </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>Thread name too long </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3a46ed8ad2c3b12416fafe11325f82b3" name="ga3a46ed8ad2c3b12416fafe11325f82b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a46ed8ad2c3b12416fafe11325f82b3">&#9670;&nbsp;</a></span>k_thread_priority_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_thread_priority_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a>&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Get a thread's priority. </p>
<p >This routine gets the priority of <em>thread</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>ID of thread whose priority is needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Priority of <em>thread</em>. </dd></dl>

</div>
</div>
<a id="ga24e50a60c524d1eb22fe21cdf269b6a6" name="ga24e50a60c524d1eb22fe21cdf269b6a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24e50a60c524d1eb22fe21cdf269b6a6">&#9670;&nbsp;</a></span>k_thread_priority_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void k_thread_priority_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Set a thread's priority. </p>
<p >This routine immediately changes the priority of <em>thread</em>.</p>
<p >Rescheduling can occur immediately depending on the priority <em>thread</em> is set to:</p>
<ul>
<li>If its priority is raised above the priority of the caller of this function, and the caller is preemptible, <em>thread</em> will be scheduled in.</li>
<li>If the caller operates on itself, it lowers its priority below that of other threads in the system, and the caller is preemptible, the thread of highest priority will be scheduled in.</li>
</ul>
<p >Priority can be assigned in the range of -CONFIG_NUM_COOP_PRIORITIES to CONFIG_NUM_PREEMPT_PRIORITIES-1, where -CONFIG_NUM_COOP_PRIORITIES is the highest priority.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>ID of thread whose priority is to be set. </td></tr>
    <tr><td class="paramname">prio</td><td>New priority.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Changing the priority of a thread currently involved in mutex priority inheritance may result in undefined behavior. </dd></dl>

</div>
</div>
<a id="ga117b26f8569ec3045ead1fad1851663d" name="ga117b26f8569ec3045ead1fad1851663d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga117b26f8569ec3045ead1fad1851663d">&#9670;&nbsp;</a></span>k_thread_resume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void k_thread_resume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a>&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Resume a suspended thread. </p>
<p >This routine allows the kernel scheduler to make <em>thread</em> the current thread, when it is next eligible for that role.</p>
<p >If <em>thread</em> is not currently suspended, the routine has no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>ID of thread to resume. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga88031bd9fcfcd4305bae4029a4d8416f" name="ga88031bd9fcfcd4305bae4029a4d8416f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88031bd9fcfcd4305bae4029a4d8416f">&#9670;&nbsp;</a></span>k_thread_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void k_thread_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a>&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Start an inactive thread. </p>
<p >If a thread was created with K_FOREVER in the delay parameter, it will not be added to the scheduling queue until this function is called on it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>thread to start </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae36c37d54522fbf8d9a34b93991e51ca" name="gae36c37d54522fbf8d9a34b93991e51ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae36c37d54522fbf8d9a34b93991e51ca">&#9670;&nbsp;</a></span>k_thread_state_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * k_thread_state_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a>&#160;</td>
          <td class="paramname"><em>thread_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Get thread state string. </p>
<p >Get the human friendly thread state string</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_id</td><td>Thread ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Thread</td><td>state string, empty if no state flag is set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga66cf8682fb65870eceb5e57d667a8d4e" name="ga66cf8682fb65870eceb5e57d667a8d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66cf8682fb65870eceb5e57d667a8d4e">&#9670;&nbsp;</a></span>k_thread_suspend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void k_thread_suspend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a>&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Suspend a thread. </p>
<p >This routine prevents the kernel scheduler from making <em>thread</em> the current thread. All other internal operations on <em>thread</em> are still performed; for example, kernel objects it is waiting on are still handed to it. Note that any existing timeouts (e.g. <a class="el" href="group__thread__apis.html#ga48d4b041790454da4d68ac8711f29657" title="Put the current thread to sleep.">k_sleep()</a>, or a timeout argument to <a class="el" href="group__semaphore__apis.html#gac71e2383c1920dddc45a561cacfef090" title="Take a semaphore.">k_sem_take()</a> et. al.) will be canceled. On resume, the thread will begin running immediately and return from the blocked call.</p>
<p >If <em>thread</em> is already suspended, the routine has no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>ID of thread to suspend. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga220d22dc35115fcdc0badb262e7a019d" name="ga220d22dc35115fcdc0badb262e7a019d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga220d22dc35115fcdc0badb262e7a019d">&#9670;&nbsp;</a></span>k_thread_system_pool_assign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void k_thread_system_pool_assign </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__thread.html">k_thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Assign the system heap as a thread's resource pool. </p>
<p >Similar to z_thread_heap_assign(), but the thread will use the kernel heap to draw memory.</p>
<p >Use with caution, as a malicious thread could perform DoS attacks on the kernel heap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>Target thread to assign the system heap for resource requests </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga80013f10d12ccdffbbd88cee048f1c21" name="ga80013f10d12ccdffbbd88cee048f1c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80013f10d12ccdffbbd88cee048f1c21">&#9670;&nbsp;</a></span>k_thread_timeout_expires_ticks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__clock__apis.html#ga9832cb0adc2d1866420e5c370a0863e2">k_ticks_t</a> k_thread_timeout_expires_ticks </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structk__thread.html">k_thread</a> *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Get time when a thread wakes up, in system ticks. </p>
<p >This routine computes the system uptime when a waiting thread next executes, in units of system ticks. If the thread is not waiting, it returns current system time. </p>

</div>
</div>
<a id="ga4cb4126c8e4f62bd44f3dd03f2e4a423" name="ga4cb4126c8e4f62bd44f3dd03f2e4a423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cb4126c8e4f62bd44f3dd03f2e4a423">&#9670;&nbsp;</a></span>k_thread_timeout_remaining_ticks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__clock__apis.html#ga9832cb0adc2d1866420e5c370a0863e2">k_ticks_t</a> k_thread_timeout_remaining_ticks </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structk__thread.html">k_thread</a> *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Get time remaining before a thread wakes up, in system ticks. </p>
<p >This routine computes the time remaining before a waiting thread next executes, in units of system ticks. If the thread is not waiting, it returns zero. </p>

</div>
</div>
<a id="ga3fbe1c8a5f3ef1c25382c7d6fca35764" name="ga3fbe1c8a5f3ef1c25382c7d6fca35764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fbe1c8a5f3ef1c25382c7d6fca35764">&#9670;&nbsp;</a></span>k_thread_user_mode_enter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUNC_NORETURN void k_thread_user_mode_enter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arch__interface_8h.html#af1bd193a26c6e6a8658140185cae42e1">k_thread_entry_t</a>&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Drop a thread's privileges permanently to user mode. </p>
<p >This allows a supervisor thread to be re-used as a user thread. This function does not return, but control will transfer to the provided entry point as if this was a new user thread.</p>
<p >The implementation ensures that the stack buffer contents are erased. Any thread-local storage will be reverted to a pristine state.</p>
<p >Memory domain membership, resource pool assignment, kernel object permissions, priority, and thread options are preserved.</p>
<p >A common use of this function is to re-use the main thread as a user thread once all supervisor mode-only tasks have been completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>Function to start executing from </td></tr>
    <tr><td class="paramname">p1</td><td>1st entry point parameter </td></tr>
    <tr><td class="paramname">p2</td><td>2nd entry point parameter </td></tr>
    <tr><td class="paramname">p3</td><td>3rd entry point parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeac56bb072ce295b9fdc372ab8cee67e" name="gaeac56bb072ce295b9fdc372ab8cee67e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeac56bb072ce295b9fdc372ab8cee67e">&#9670;&nbsp;</a></span>k_usleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a0c18914b3041c2f583aba76f418399c2">int32_t</a> k_usleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a0c18914b3041c2f583aba76f418399c2">int32_t</a>&#160;</td>
          <td class="paramname"><em>us</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Put the current thread to sleep with microsecond resolution. </p>
<p >This function is unlikely to work as expected without kernel tuning. In particular, because the lower bound on the duration of a sleep is the duration of a tick, </p><pre class="fragment">embed:rst:inline :kconfig:option:`CONFIG_SYS_CLOCK_TICKS_PER_SEC` </pre><p> must be adjusted to achieve the resolution desired. The implications of doing this must be understood before attempting to use <a class="el" href="group__thread__apis.html#gaeac56bb072ce295b9fdc372ab8cee67e" title="Put the current thread to sleep with microsecond resolution.">k_usleep()</a>. Use with caution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">us</td><td>Number of microseconds to sleep.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if the requested time has elapsed or the number of microseconds left to sleep, if thread was woken up by <a class="el" href="group__thread__apis.html#ga9275a019c8ff3c7fe49a81f8c078157e">k_wakeup</a> call. </dd></dl>

</div>
</div>
<a id="ga9275a019c8ff3c7fe49a81f8c078157e" name="ga9275a019c8ff3c7fe49a81f8c078157e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9275a019c8ff3c7fe49a81f8c078157e">&#9670;&nbsp;</a></span>k_wakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void k_wakeup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kernel_2thread_8h.html#a6379f5a1f19ffbc262a6877c4f6e3647">k_tid_t</a>&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Wake up a sleeping thread. </p>
<p >This routine prematurely wakes up <em>thread</em> from sleeping.</p>
<p >If <em>thread</em> is not currently sleeping, the routine has no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>ID of thread to wake. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga08a3484c33444ecedc2d71d78495a295" name="ga08a3484c33444ecedc2d71d78495a295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08a3484c33444ecedc2d71d78495a295">&#9670;&nbsp;</a></span>k_yield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void k_yield </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Yield the current thread. </p>
<p >This routine causes the current thread to yield execution to another thread of the same or higher priority. If there are no other ready threads of the same or higher priority, the routine returns immediately. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Mar 5 2022 05:00:47 for Zephyr API Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
<script type="text/javascript">
  $(function() {
    toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
    toggleButton.title = "Toggle Light/Dark Mode"
    $(document).ready(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
    // every resize will remove the button, which is why it has to be added again:
    $(window).resize(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
  })
</script>
</body>
</html>
