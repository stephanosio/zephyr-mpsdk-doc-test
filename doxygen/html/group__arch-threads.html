<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zephyr API Documentation: Architecture thread APIs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-zephyr.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-zephyr.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Zephyr API Documentation
   &#160;<span id="projectnumber">3.0.0-rc3</span>
   </div>
   <div id="projectbrief">A Scalable Open Source RTOS</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__arch-threads.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Architecture thread APIs<div class="ingroups"><a class="el" href="group__arch-interface.html">Architecture Interface</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gade449838e445fa8201266e38215c616c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch-threads.html#gade449838e445fa8201266e38215c616c">arch_new_thread</a> (struct <a class="el" href="structk__thread.html">k_thread</a> *<a class="el" href="timeout__order_8c.html#a2ff5187d48101eb303964e1b8983beb4">thread</a>, <a class="el" href="arch__interface_8h.html#a3e4bde3075edb41069b258d999333b0e">k_thread_stack_t</a> *<a class="el" href="test__stack__fail_8c.html#a6856ea318b5a9498715e4444b13a1de1">stack</a>, char *stack_ptr, <a class="el" href="arch__interface_8h.html#af1bd193a26c6e6a8658140185cae42e1">k_thread_entry_t</a> entry, void *p1, void *p2, void *p3)</td></tr>
<tr class="separator:gade449838e445fa8201266e38215c616c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab411d82ce5b60f062171f5a19e33e025"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch-threads.html#gab411d82ce5b60f062171f5a19e33e025">arch_switch</a> (void *switch_to, void **switched_from)</td></tr>
<tr class="separator:gab411d82ce5b60f062171f5a19e33e025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ddd51635018a2e0235d5599401f5269"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch-threads.html#ga3ddd51635018a2e0235d5599401f5269">arch_switch_to_main_thread</a> (struct <a class="el" href="structk__thread.html">k_thread</a> *<a class="el" href="workq_2work_2src_2main_8c.html#a1a57fef890c6b3defdc54c18c1c47a1c">main_thread</a>, char *stack_ptr, <a class="el" href="arch__interface_8h.html#af1bd193a26c6e6a8658140185cae42e1">k_thread_entry_t</a> _main)</td></tr>
<tr class="separator:ga3ddd51635018a2e0235d5599401f5269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c2f0ee0bee6f9de0bd23a0aa321a46d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch-threads.html#ga7c2f0ee0bee6f9de0bd23a0aa321a46d">arch_float_disable</a> (struct <a class="el" href="structk__thread.html">k_thread</a> *<a class="el" href="timeout__order_8c.html#a2ff5187d48101eb303964e1b8983beb4">thread</a>)</td></tr>
<tr class="memdesc:ga7c2f0ee0bee6f9de0bd23a0aa321a46d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable floating point context preservation.  <a href="group__arch-threads.html#ga7c2f0ee0bee6f9de0bd23a0aa321a46d">More...</a><br /></td></tr>
<tr class="separator:ga7c2f0ee0bee6f9de0bd23a0aa321a46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd40e26783f3dbd8a658fc1af512fb18"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch-threads.html#gacd40e26783f3dbd8a658fc1af512fb18">arch_float_enable</a> (struct <a class="el" href="structk__thread.html">k_thread</a> *<a class="el" href="timeout__order_8c.html#a2ff5187d48101eb303964e1b8983beb4">thread</a>, <a class="el" href="lib_2libc_2minimal_2include_2sys_2types_8h.html#a4089fb16419d359081465355db05f846">unsigned</a> int options)</td></tr>
<tr class="memdesc:gacd40e26783f3dbd8a658fc1af512fb18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable floating point context preservation.  <a href="group__arch-threads.html#gacd40e26783f3dbd8a658fc1af512fb18">More...</a><br /></td></tr>
<tr class="separator:gacd40e26783f3dbd8a658fc1af512fb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga7c2f0ee0bee6f9de0bd23a0aa321a46d" name="ga7c2f0ee0bee6f9de0bd23a0aa321a46d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c2f0ee0bee6f9de0bd23a0aa321a46d">&#9670;&nbsp;</a></span>arch_float_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int arch_float_disable </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__thread.html">k_thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="kernel__arch__interface_8h.html">kernel/include/kernel_arch_interface.h</a>&gt;</code></p>

<p>Disable floating point context preservation. </p>
<p >The function is used to disable the preservation of floating point context information for a particular thread.</p>
<dl class="section note"><dt>Note</dt><dd>For ARM architecture, disabling floating point preservation may only be requested for the current thread and cannot be requested in ISRs.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success. </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>If the floating point disabling could not be performed. </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>If the operation is not supported </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacd40e26783f3dbd8a658fc1af512fb18" name="gacd40e26783f3dbd8a658fc1af512fb18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd40e26783f3dbd8a658fc1af512fb18">&#9670;&nbsp;</a></span>arch_float_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int arch_float_enable </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__thread.html">k_thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lib_2libc_2minimal_2include_2sys_2types_8h.html#a4089fb16419d359081465355db05f846">unsigned</a> int&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="kernel__arch__interface_8h.html">kernel/include/kernel_arch_interface.h</a>&gt;</code></p>

<p>Enable floating point context preservation. </p>
<p >The function is used to enable the preservation of floating point context information for a particular thread. This API depends on each architecture implimentation. If the architecture does not support enabling, this API will always be failed.</p>
<p >The <em>options</em> parameter indicates which floating point register sets will be used by the specified thread. Currently it is used by x86 only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>ID of thread. </td></tr>
    <tr><td class="paramname">options</td><td>architecture dependent options</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success. </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>If the floating point enabling could not be performed. </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>If the operation is not supported </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gade449838e445fa8201266e38215c616c" name="gade449838e445fa8201266e38215c616c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade449838e445fa8201266e38215c616c">&#9670;&nbsp;</a></span>arch_new_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arch_new_thread </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__thread.html">k_thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="arch__interface_8h.html#a3e4bde3075edb41069b258d999333b0e">k_thread_stack_t</a> *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>stack_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="arch__interface_8h.html#af1bd193a26c6e6a8658140185cae42e1">k_thread_entry_t</a>&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="kernel__arch__interface_8h.html">kernel/include/kernel_arch_interface.h</a>&gt;</code></p>
<p >Handle arch-specific logic for setting up new threads</p>
<p >The stack and arch-specific thread state variables must be set up such that a later attempt to switch to this thread will succeed and we will enter z_thread_entry with the requested thread and arguments as its parameters.</p>
<p >At some point in this function's implementation, z_setup_new_thread() must be called with the true bounds of the available stack buffer within the thread's stack object.</p>
<p >The provided stack pointer is guaranteed to be properly aligned with respect to the CPU and ABI requirements. There may be space reserved between the stack pointer and the bounds of the stack buffer for initial stack pointer randomization and thread-local storage.</p>
<p >Fields in thread-&gt;base will be initialized when this is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>Pointer to uninitialized struct <a class="el" href="structk__thread.html">k_thread</a> </td></tr>
    <tr><td class="paramname">stack</td><td>Pointer to the stack object </td></tr>
    <tr><td class="paramname">stack_ptr</td><td>Aligned initial stack pointer </td></tr>
    <tr><td class="paramname">entry</td><td>Thread entry function </td></tr>
    <tr><td class="paramname">p1</td><td>1st entry point parameter </td></tr>
    <tr><td class="paramname">p2</td><td>2nd entry point parameter </td></tr>
    <tr><td class="paramname">p3</td><td>3rd entry point parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab411d82ce5b60f062171f5a19e33e025" name="gab411d82ce5b60f062171f5a19e33e025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab411d82ce5b60f062171f5a19e33e025">&#9670;&nbsp;</a></span>arch_switch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void arch_switch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>switch_to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>switched_from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="kernel__arch__interface_8h.html">kernel/include/kernel_arch_interface.h</a>&gt;</code></p>
<p >Cooperative context switch primitive</p>
<p >The action of <a class="el" href="group__arch-threads.html#gab411d82ce5b60f062171f5a19e33e025">arch_switch()</a> should be to switch to a new context passed in the first argument, and save a pointer to the current context into the address passed in the second argument.</p>
<p >The actual type and interpretation of the switch handle is specified by the architecture. It is the same data structure stored in the "switch_handle" field of a newly-created thread in <a class="el" href="group__arch-threads.html#gade449838e445fa8201266e38215c616c">arch_new_thread()</a>, and passed to the kernel as the "interrupted" argument to z_get_next_switch_handle().</p>
<p >Note that on SMP systems, the kernel uses the store through the second pointer as a synchronization point to detect when a thread context is completely saved (so another CPU can know when it is safe to switch). This store must be done AFTER all relevant state is saved, and must include whatever memory barriers or cache management code is required to be sure another CPU will see the result correctly.</p>
<p >The simplest implementation of <a class="el" href="group__arch-threads.html#gab411d82ce5b60f062171f5a19e33e025">arch_switch()</a> is generally to push state onto the thread stack and use the resulting stack pointer as the switch handle. Some architectures may instead decide to use a pointer into the thread struct as the "switch handle" type. These can legally assume that the second argument to <a class="el" href="group__arch-threads.html#gab411d82ce5b60f062171f5a19e33e025">arch_switch()</a> is the address of the switch_handle field of struct thread_base and can use an offset on this value to find other parts of the thread struct. For example a (C pseudocode) implementation of <a class="el" href="group__arch-threads.html#gab411d82ce5b60f062171f5a19e33e025">arch_switch()</a> might look like:</p>
<p >void <a class="el" href="group__arch-threads.html#gab411d82ce5b60f062171f5a19e33e025">arch_switch(void *switch_to, void **switched_from)</a> { struct <a class="el" href="structk__thread.html">k_thread</a> *new = switch_to; struct <a class="el" href="structk__thread.html">k_thread</a> *old = CONTAINER_OF(switched_from, struct <a class="el" href="structk__thread.html">k_thread</a>, switch_handle);</p>
<p >// save old context... *switched_from = old; // restore new context... }</p>
<p >Note that the kernel manages the switch_handle field for synchronization as described above. So it is not legal for architecture code to assume that it has any particular value at any other time. In particular it is not legal to read the field from the address passed in the second argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">switch_to</td><td>Incoming thread's switch handle </td></tr>
    <tr><td class="paramname">switched_from</td><td>Pointer to outgoing thread's switch handle storage location, which must be updated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3ddd51635018a2e0235d5599401f5269" name="ga3ddd51635018a2e0235d5599401f5269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ddd51635018a2e0235d5599401f5269">&#9670;&nbsp;</a></span>arch_switch_to_main_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arch_switch_to_main_thread </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structk__thread.html">k_thread</a> *&#160;</td>
          <td class="paramname"><em>main_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>stack_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="arch__interface_8h.html#af1bd193a26c6e6a8658140185cae42e1">k_thread_entry_t</a>&#160;</td>
          <td class="paramname"><em>_main</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="kernel__arch__interface_8h.html">kernel/include/kernel_arch_interface.h</a>&gt;</code></p>
<p >Custom logic for entering main thread context at early boot</p>
<p >Used by architectures where the typical trick of setting up a dummy thread in early boot context to "switch out" of isn't workable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">main_thread</td><td>main thread object </td></tr>
    <tr><td class="paramname">stack_ptr</td><td>Initial stack pointer </td></tr>
    <tr><td class="paramname">_main</td><td>Entry point for application main function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Feb 21 2022 04:59:41 for Zephyr API Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
<script type="text/javascript">
  $(function() {
    toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
    toggleButton.title = "Toggle Light/Dark Mode"
    $(document).ready(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
    // every resize will remove the button, which is why it has to be added again:
    $(window).resize(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
  })
</script>
</body>
</html>
