<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zephyr API Documentation: Network Packet Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-zephyr.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-zephyr.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Zephyr API Documentation
   &#160;<span id="projectnumber">3.0.0-rc3</span>
   </div>
   <div id="projectbrief">A Scalable Open Source RTOS</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__net__pkt.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Network Packet Library<div class="ingroups"><a class="el" href="group__networking.html">Networking</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Network packet management library.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnet__pkt__cursor.html">net_pkt_cursor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnet__pkt.html">net_pkt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Network packet.  <a href="structnet__pkt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnet__pkt__data__access.html">net_pkt_data_access</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gafc7e98d5b64d816faabcbaa2ec22a2bb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#gafc7e98d5b64d816faabcbaa2ec22a2bb">NET_PKT_SLAB_DEFINE</a>(name,  <a class="el" href="semaphore_2sys__sem_2src_2main_8c.html#a7624b580dc5672d7564cdc73212de784">count</a>)&#160;&#160;&#160;	<a class="el" href="obj__tracking_2src_2main_8c.html#a28f95631efa7f8ce6a04bc473f52af4e">K_MEM_SLAB_DEFINE</a>(name, sizeof(struct <a class="el" href="structnet__pkt.html">net_pkt</a>), <a class="el" href="semaphore_2sys__sem_2src_2main_8c.html#a7624b580dc5672d7564cdc73212de784">count</a>, 4)</td></tr>
<tr class="memdesc:gafc7e98d5b64d816faabcbaa2ec22a2bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> slab.  <a href="group__net__pkt.html#gafc7e98d5b64d816faabcbaa2ec22a2bb">More...</a><br /></td></tr>
<tr class="separator:gafc7e98d5b64d816faabcbaa2ec22a2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb3bb7347aa5dccb902531a1d6fbd190"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#gacb3bb7347aa5dccb902531a1d6fbd190">NET_PKT_TX_SLAB_DEFINE</a>(name,  <a class="el" href="semaphore_2sys__sem_2src_2main_8c.html#a7624b580dc5672d7564cdc73212de784">count</a>)&#160;&#160;&#160;<a class="el" href="group__net__pkt.html#gafc7e98d5b64d816faabcbaa2ec22a2bb">NET_PKT_SLAB_DEFINE</a>(name, <a class="el" href="semaphore_2sys__sem_2src_2main_8c.html#a7624b580dc5672d7564cdc73212de784">count</a>)</td></tr>
<tr class="separator:gacb3bb7347aa5dccb902531a1d6fbd190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94ab6300b59d739c4e3c5604d3fbe8a5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#ga94ab6300b59d739c4e3c5604d3fbe8a5">NET_PKT_DATA_POOL_DEFINE</a>(name,  <a class="el" href="semaphore_2sys__sem_2src_2main_8c.html#a7624b580dc5672d7564cdc73212de784">count</a>)</td></tr>
<tr class="memdesc:ga94ab6300b59d739c4e3c5604d3fbe8a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a data fragment <a class="el" href="structnet__buf.html" title="Network buffer representation.">net_buf</a> pool.  <a href="group__net__pkt.html#ga94ab6300b59d739c4e3c5604d3fbe8a5">More...</a><br /></td></tr>
<tr class="separator:ga94ab6300b59d739c4e3c5604d3fbe8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b2d0900ae76674d418918ec955bad48"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#ga2b2d0900ae76674d418918ec955bad48">net_pkt_print_frags</a>(pkt)</td></tr>
<tr class="memdesc:ga2b2d0900ae76674d418918ec955bad48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print fragment list and the fragment sizes.  <a href="group__net__pkt.html#ga2b2d0900ae76674d418918ec955bad48">More...</a><br /></td></tr>
<tr class="separator:ga2b2d0900ae76674d418918ec955bad48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd11f2d4f773bf247296eb08b7006c27"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#gafd11f2d4f773bf247296eb08b7006c27">NET_PKT_DATA_ACCESS_DEFINE</a>(_name,  _type)</td></tr>
<tr class="separator:gafd11f2d4f773bf247296eb08b7006c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6a48974656755dcc0979683b8431c37"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#gaa6a48974656755dcc0979683b8431c37">NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE</a>(_name,  _type)</td></tr>
<tr class="separator:gaa6a48974656755dcc0979683b8431c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga30d0b8741abd594f90a7f206f554035f"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structnet__buf.html">net_buf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#ga30d0b8741abd594f90a7f206f554035f">net_pkt_get_reserve_rx_data</a> (<a class="el" href="structk__timeout__t.html">k_timeout_t</a> <a class="el" href="timer_2cycle64_2src_2main_8c.html#a8f4b69a82b00d7baf3f1f7d480bb7fa0">timeout</a>)</td></tr>
<tr class="memdesc:ga30d0b8741abd594f90a7f206f554035f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get RX DATA buffer from pool. Normally you should use <a class="el" href="group__net__pkt.html#gae4d0c53b29d2fbd6e324a274e35f6b9d" title="Get a data fragment that might be from user specific buffer pool or from global DATA pool.">net_pkt_get_frag()</a> instead.  <a href="group__net__pkt.html#ga30d0b8741abd594f90a7f206f554035f">More...</a><br /></td></tr>
<tr class="separator:ga30d0b8741abd594f90a7f206f554035f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca0174ee16d43448a265675b54a57758"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structnet__buf.html">net_buf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#gaca0174ee16d43448a265675b54a57758">net_pkt_get_reserve_tx_data</a> (<a class="el" href="structk__timeout__t.html">k_timeout_t</a> <a class="el" href="timer_2cycle64_2src_2main_8c.html#a8f4b69a82b00d7baf3f1f7d480bb7fa0">timeout</a>)</td></tr>
<tr class="memdesc:gaca0174ee16d43448a265675b54a57758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get TX DATA buffer from pool. Normally you should use <a class="el" href="group__net__pkt.html#gae4d0c53b29d2fbd6e324a274e35f6b9d" title="Get a data fragment that might be from user specific buffer pool or from global DATA pool.">net_pkt_get_frag()</a> instead.  <a href="group__net__pkt.html#gaca0174ee16d43448a265675b54a57758">More...</a><br /></td></tr>
<tr class="separator:gaca0174ee16d43448a265675b54a57758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4d0c53b29d2fbd6e324a274e35f6b9d"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structnet__buf.html">net_buf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#gae4d0c53b29d2fbd6e324a274e35f6b9d">net_pkt_get_frag</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt, <a class="el" href="structk__timeout__t.html">k_timeout_t</a> <a class="el" href="timer_2cycle64_2src_2main_8c.html#a8f4b69a82b00d7baf3f1f7d480bb7fa0">timeout</a>)</td></tr>
<tr class="memdesc:gae4d0c53b29d2fbd6e324a274e35f6b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a data fragment that might be from user specific buffer pool or from global DATA pool.  <a href="group__net__pkt.html#gae4d0c53b29d2fbd6e324a274e35f6b9d">More...</a><br /></td></tr>
<tr class="separator:gae4d0c53b29d2fbd6e324a274e35f6b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga893d1660fd18ad5842224fda78466099"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#ga893d1660fd18ad5842224fda78466099">net_pkt_unref</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt)</td></tr>
<tr class="memdesc:ga893d1660fd18ad5842224fda78466099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place packet back into the available packets slab.  <a href="group__net__pkt.html#ga893d1660fd18ad5842224fda78466099">More...</a><br /></td></tr>
<tr class="separator:ga893d1660fd18ad5842224fda78466099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e83d4f60b46db8f57798c0e96d6cd7a"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#ga4e83d4f60b46db8f57798c0e96d6cd7a">net_pkt_ref</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt)</td></tr>
<tr class="memdesc:ga4e83d4f60b46db8f57798c0e96d6cd7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the packet ref count.  <a href="group__net__pkt.html#ga4e83d4f60b46db8f57798c0e96d6cd7a">More...</a><br /></td></tr>
<tr class="separator:ga4e83d4f60b46db8f57798c0e96d6cd7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea5e1045d188b3abbd85717ff09d563a"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structnet__buf.html">net_buf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#gaea5e1045d188b3abbd85717ff09d563a">net_pkt_frag_ref</a> (struct <a class="el" href="structnet__buf.html">net_buf</a> *frag)</td></tr>
<tr class="memdesc:gaea5e1045d188b3abbd85717ff09d563a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the packet fragment ref count.  <a href="group__net__pkt.html#gaea5e1045d188b3abbd85717ff09d563a">More...</a><br /></td></tr>
<tr class="separator:gaea5e1045d188b3abbd85717ff09d563a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c75ef2149d2ba5ff07525988e0fb7cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#ga5c75ef2149d2ba5ff07525988e0fb7cc">net_pkt_frag_unref</a> (struct <a class="el" href="structnet__buf.html">net_buf</a> *frag)</td></tr>
<tr class="memdesc:ga5c75ef2149d2ba5ff07525988e0fb7cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrease the packet fragment ref count.  <a href="group__net__pkt.html#ga5c75ef2149d2ba5ff07525988e0fb7cc">More...</a><br /></td></tr>
<tr class="separator:ga5c75ef2149d2ba5ff07525988e0fb7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga956c784f5417f0f79976c6e106ad0d76"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structnet__buf.html">net_buf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#ga956c784f5417f0f79976c6e106ad0d76">net_pkt_frag_del</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt, struct <a class="el" href="structnet__buf.html">net_buf</a> *parent, struct <a class="el" href="structnet__buf.html">net_buf</a> *frag)</td></tr>
<tr class="memdesc:ga956c784f5417f0f79976c6e106ad0d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete existing fragment from a packet.  <a href="group__net__pkt.html#ga956c784f5417f0f79976c6e106ad0d76">More...</a><br /></td></tr>
<tr class="separator:ga956c784f5417f0f79976c6e106ad0d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03a53365cfc2b6c3448763d81f56c2c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#ga03a53365cfc2b6c3448763d81f56c2c0">net_pkt_frag_add</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt, struct <a class="el" href="structnet__buf.html">net_buf</a> *frag)</td></tr>
<tr class="memdesc:ga03a53365cfc2b6c3448763d81f56c2c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a fragment to a packet at the end of its fragment list.  <a href="group__net__pkt.html#ga03a53365cfc2b6c3448763d81f56c2c0">More...</a><br /></td></tr>
<tr class="separator:ga03a53365cfc2b6c3448763d81f56c2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcd375d9dbdca21855abe27d7b5a0a7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#gabcd375d9dbdca21855abe27d7b5a0a7e">net_pkt_frag_insert</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt, struct <a class="el" href="structnet__buf.html">net_buf</a> *frag)</td></tr>
<tr class="memdesc:gabcd375d9dbdca21855abe27d7b5a0a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a fragment to a packet at the beginning of its fragment list.  <a href="group__net__pkt.html#gabcd375d9dbdca21855abe27d7b5a0a7e">More...</a><br /></td></tr>
<tr class="separator:gabcd375d9dbdca21855abe27d7b5a0a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d18adc7dc87bf6b54f45f0227c12423"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#ga8d18adc7dc87bf6b54f45f0227c12423">net_pkt_compact</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt)</td></tr>
<tr class="memdesc:ga8d18adc7dc87bf6b54f45f0227c12423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compact the fragment list of a packet.  <a href="group__net__pkt.html#ga8d18adc7dc87bf6b54f45f0227c12423">More...</a><br /></td></tr>
<tr class="separator:ga8d18adc7dc87bf6b54f45f0227c12423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b02b95838b928febfd4970de5e9c9f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#ga7b02b95838b928febfd4970de5e9c9f9">net_pkt_get_info</a> (struct k_mem_slab **rx, struct k_mem_slab **tx, struct <a class="el" href="structnet__buf__pool.html">net_buf_pool</a> **rx_data, struct <a class="el" href="structnet__buf__pool.html">net_buf_pool</a> **tx_data)</td></tr>
<tr class="memdesc:ga7b02b95838b928febfd4970de5e9c9f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information about predefined RX, TX and DATA pools.  <a href="group__net__pkt.html#ga7b02b95838b928febfd4970de5e9c9f9">More...</a><br /></td></tr>
<tr class="separator:ga7b02b95838b928febfd4970de5e9c9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90d97ba913a875b3ee438e0ea8a970fd"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#ga90d97ba913a875b3ee438e0ea8a970fd">net_pkt_alloc</a> (<a class="el" href="structk__timeout__t.html">k_timeout_t</a> <a class="el" href="timer_2cycle64_2src_2main_8c.html#a8f4b69a82b00d7baf3f1f7d480bb7fa0">timeout</a>)</td></tr>
<tr class="memdesc:ga90d97ba913a875b3ee438e0ea8a970fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an initialized <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a>.  <a href="group__net__pkt.html#ga90d97ba913a875b3ee438e0ea8a970fd">More...</a><br /></td></tr>
<tr class="separator:ga90d97ba913a875b3ee438e0ea8a970fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1edbaab59576262647089fa1751d9e3"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#gaf1edbaab59576262647089fa1751d9e3">net_pkt_alloc_from_slab</a> (struct k_mem_slab *slab, <a class="el" href="structk__timeout__t.html">k_timeout_t</a> <a class="el" href="timer_2cycle64_2src_2main_8c.html#a8f4b69a82b00d7baf3f1f7d480bb7fa0">timeout</a>)</td></tr>
<tr class="memdesc:gaf1edbaab59576262647089fa1751d9e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an initialized <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> from a specific slab.  <a href="group__net__pkt.html#gaf1edbaab59576262647089fa1751d9e3">More...</a><br /></td></tr>
<tr class="separator:gaf1edbaab59576262647089fa1751d9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cec027a0de4807879fd3bd3aed4f12a"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#ga4cec027a0de4807879fd3bd3aed4f12a">net_pkt_rx_alloc</a> (<a class="el" href="structk__timeout__t.html">k_timeout_t</a> <a class="el" href="timer_2cycle64_2src_2main_8c.html#a8f4b69a82b00d7baf3f1f7d480bb7fa0">timeout</a>)</td></tr>
<tr class="memdesc:ga4cec027a0de4807879fd3bd3aed4f12a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an initialized <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> for RX.  <a href="group__net__pkt.html#ga4cec027a0de4807879fd3bd3aed4f12a">More...</a><br /></td></tr>
<tr class="separator:ga4cec027a0de4807879fd3bd3aed4f12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga770ffe22fc797691b1fc89954d60b2e6"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#ga770ffe22fc797691b1fc89954d60b2e6">net_pkt_alloc_on_iface</a> (struct <a class="el" href="structnet__if.html">net_if</a> *iface, <a class="el" href="structk__timeout__t.html">k_timeout_t</a> <a class="el" href="timer_2cycle64_2src_2main_8c.html#a8f4b69a82b00d7baf3f1f7d480bb7fa0">timeout</a>)</td></tr>
<tr class="memdesc:ga770ffe22fc797691b1fc89954d60b2e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a network packet for a specific network interface.  <a href="group__net__pkt.html#ga770ffe22fc797691b1fc89954d60b2e6">More...</a><br /></td></tr>
<tr class="separator:ga770ffe22fc797691b1fc89954d60b2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab64f7551b1995c301232ab4cd39b9efc"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#gab64f7551b1995c301232ab4cd39b9efc">net_pkt_rx_alloc_on_iface</a> (struct <a class="el" href="structnet__if.html">net_if</a> *iface, <a class="el" href="structk__timeout__t.html">k_timeout_t</a> <a class="el" href="timer_2cycle64_2src_2main_8c.html#a8f4b69a82b00d7baf3f1f7d480bb7fa0">timeout</a>)</td></tr>
<tr class="separator:gab64f7551b1995c301232ab4cd39b9efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae31b4afd510bce346f7d00a9ec5d190d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#gae31b4afd510bce346f7d00a9ec5d190d">net_pkt_alloc_buffer</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt, size_t size, enum <a class="el" href="group__ip__4__6.html#gaf06819bf427cc58be1229b27b373ca31">net_ip_protocol</a> proto, <a class="el" href="structk__timeout__t.html">k_timeout_t</a> <a class="el" href="timer_2cycle64_2src_2main_8c.html#a8f4b69a82b00d7baf3f1f7d480bb7fa0">timeout</a>)</td></tr>
<tr class="memdesc:gae31b4afd510bce346f7d00a9ec5d190d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate buffer for a <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a>.  <a href="group__net__pkt.html#gae31b4afd510bce346f7d00a9ec5d190d">More...</a><br /></td></tr>
<tr class="separator:gae31b4afd510bce346f7d00a9ec5d190d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57e2f5138acd92ad49864e3d709d9419"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#ga57e2f5138acd92ad49864e3d709d9419">net_pkt_alloc_with_buffer</a> (struct <a class="el" href="structnet__if.html">net_if</a> *iface, size_t size, <a class="el" href="group__ip__4__6.html#ga2d9e094abb99ebd0874373edf1c45eda">sa_family_t</a> family, enum <a class="el" href="group__ip__4__6.html#gaf06819bf427cc58be1229b27b373ca31">net_ip_protocol</a> proto, <a class="el" href="structk__timeout__t.html">k_timeout_t</a> <a class="el" href="timer_2cycle64_2src_2main_8c.html#a8f4b69a82b00d7baf3f1f7d480bb7fa0">timeout</a>)</td></tr>
<tr class="memdesc:ga57e2f5138acd92ad49864e3d709d9419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a network packet and buffer at once.  <a href="group__net__pkt.html#ga57e2f5138acd92ad49864e3d709d9419">More...</a><br /></td></tr>
<tr class="separator:ga57e2f5138acd92ad49864e3d709d9419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga623794964a35e0e24c1f41a75bfba626"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#ga623794964a35e0e24c1f41a75bfba626">net_pkt_rx_alloc_with_buffer</a> (struct <a class="el" href="structnet__if.html">net_if</a> *iface, size_t size, <a class="el" href="group__ip__4__6.html#ga2d9e094abb99ebd0874373edf1c45eda">sa_family_t</a> family, enum <a class="el" href="group__ip__4__6.html#gaf06819bf427cc58be1229b27b373ca31">net_ip_protocol</a> proto, <a class="el" href="structk__timeout__t.html">k_timeout_t</a> <a class="el" href="timer_2cycle64_2src_2main_8c.html#a8f4b69a82b00d7baf3f1f7d480bb7fa0">timeout</a>)</td></tr>
<tr class="separator:ga623794964a35e0e24c1f41a75bfba626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b11492ae3c16368aa6a0ab8f47b67e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#ga2b11492ae3c16368aa6a0ab8f47b67e7">net_pkt_append_buffer</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt, struct <a class="el" href="structnet__buf.html">net_buf</a> *<a class="el" href="group__kernel__mbox__api.html#gab659fc0dee01e6639b8b6108addbd046">buffer</a>)</td></tr>
<tr class="memdesc:ga2b11492ae3c16368aa6a0ab8f47b67e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a buffer in packet.  <a href="group__net__pkt.html#ga2b11492ae3c16368aa6a0ab8f47b67e7">More...</a><br /></td></tr>
<tr class="separator:ga2b11492ae3c16368aa6a0ab8f47b67e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeed119d192e3a14ea3eea6e623334519"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#gaeed119d192e3a14ea3eea6e623334519">net_pkt_available_buffer</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt)</td></tr>
<tr class="memdesc:gaeed119d192e3a14ea3eea6e623334519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get available buffer space from a pkt.  <a href="group__net__pkt.html#gaeed119d192e3a14ea3eea6e623334519">More...</a><br /></td></tr>
<tr class="separator:gaeed119d192e3a14ea3eea6e623334519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9f63047b7945a4a155e5d88eac5203b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#gaa9f63047b7945a4a155e5d88eac5203b">net_pkt_available_payload_buffer</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt, enum <a class="el" href="group__ip__4__6.html#gaf06819bf427cc58be1229b27b373ca31">net_ip_protocol</a> proto)</td></tr>
<tr class="memdesc:gaa9f63047b7945a4a155e5d88eac5203b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get available buffer space for payload from a pkt.  <a href="group__net__pkt.html#gaa9f63047b7945a4a155e5d88eac5203b">More...</a><br /></td></tr>
<tr class="separator:gaa9f63047b7945a4a155e5d88eac5203b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71d1c49f68afab07324cebd835f08a29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#ga71d1c49f68afab07324cebd835f08a29">net_pkt_trim_buffer</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt)</td></tr>
<tr class="memdesc:ga71d1c49f68afab07324cebd835f08a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> buffer.  <a href="group__net__pkt.html#ga71d1c49f68afab07324cebd835f08a29">More...</a><br /></td></tr>
<tr class="separator:ga71d1c49f68afab07324cebd835f08a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab657c80669733a4afefaf1be6310107e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#gab657c80669733a4afefaf1be6310107e">net_pkt_remove_tail</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt, size_t length)</td></tr>
<tr class="memdesc:gab657c80669733a4afefaf1be6310107e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove <em>length</em> bytes from tail of packet.  <a href="group__net__pkt.html#gab657c80669733a4afefaf1be6310107e">More...</a><br /></td></tr>
<tr class="separator:gab657c80669733a4afefaf1be6310107e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b7da39f62dfc8b8948d7689e2dd114a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#ga1b7da39f62dfc8b8948d7689e2dd114a">net_pkt_cursor_init</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt)</td></tr>
<tr class="memdesc:ga1b7da39f62dfc8b8948d7689e2dd114a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> cursor.  <a href="group__net__pkt.html#ga1b7da39f62dfc8b8948d7689e2dd114a">More...</a><br /></td></tr>
<tr class="separator:ga1b7da39f62dfc8b8948d7689e2dd114a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd352b66cdeaff2fb45361a0fae62876"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#gabd352b66cdeaff2fb45361a0fae62876">net_pkt_cursor_backup</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt, struct <a class="el" href="structnet__pkt__cursor.html">net_pkt_cursor</a> *backup)</td></tr>
<tr class="memdesc:gabd352b66cdeaff2fb45361a0fae62876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backup <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> cursor.  <a href="group__net__pkt.html#gabd352b66cdeaff2fb45361a0fae62876">More...</a><br /></td></tr>
<tr class="separator:gabd352b66cdeaff2fb45361a0fae62876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5ab788f01b4bb3640755e8c4a2c612e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#gad5ab788f01b4bb3640755e8c4a2c612e">net_pkt_cursor_restore</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt, struct <a class="el" href="structnet__pkt__cursor.html">net_pkt_cursor</a> *backup)</td></tr>
<tr class="memdesc:gad5ab788f01b4bb3640755e8c4a2c612e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> cursor from a backup.  <a href="group__net__pkt.html#gad5ab788f01b4bb3640755e8c4a2c612e">More...</a><br /></td></tr>
<tr class="separator:gad5ab788f01b4bb3640755e8c4a2c612e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc42ba1bcd0801a116651d965e65b9cd"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#gabc42ba1bcd0801a116651d965e65b9cd">net_pkt_cursor_get_pos</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt)</td></tr>
<tr class="memdesc:gabc42ba1bcd0801a116651d965e65b9cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current position of the cursor.  <a href="group__net__pkt.html#gabc42ba1bcd0801a116651d965e65b9cd">More...</a><br /></td></tr>
<tr class="separator:gabc42ba1bcd0801a116651d965e65b9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga223a79baa1e740a53c4ed0f083d62185"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#ga223a79baa1e740a53c4ed0f083d62185">net_pkt_skip</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt, size_t length)</td></tr>
<tr class="memdesc:ga223a79baa1e740a53c4ed0f083d62185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip some data from a <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a>.  <a href="group__net__pkt.html#ga223a79baa1e740a53c4ed0f083d62185">More...</a><br /></td></tr>
<tr class="separator:ga223a79baa1e740a53c4ed0f083d62185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd241a539bf1290f3d45610fd15b2c1f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#gabd241a539bf1290f3d45610fd15b2c1f">net_pkt_memset</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt, int byte, size_t length)</td></tr>
<tr class="memdesc:gabd241a539bf1290f3d45610fd15b2c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memset some data in a <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a>.  <a href="group__net__pkt.html#gabd241a539bf1290f3d45610fd15b2c1f">More...</a><br /></td></tr>
<tr class="separator:gabd241a539bf1290f3d45610fd15b2c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4648828ca353c8c0ecf00ae2648e963a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#ga4648828ca353c8c0ecf00ae2648e963a">net_pkt_copy</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt_dst, struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt_src, size_t length)</td></tr>
<tr class="memdesc:ga4648828ca353c8c0ecf00ae2648e963a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from a packet into another one.  <a href="group__net__pkt.html#ga4648828ca353c8c0ecf00ae2648e963a">More...</a><br /></td></tr>
<tr class="separator:ga4648828ca353c8c0ecf00ae2648e963a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefefe50d0c68fb4997abc7b309740959"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#gaefefe50d0c68fb4997abc7b309740959">net_pkt_clone</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt, <a class="el" href="structk__timeout__t.html">k_timeout_t</a> <a class="el" href="timer_2cycle64_2src_2main_8c.html#a8f4b69a82b00d7baf3f1f7d480bb7fa0">timeout</a>)</td></tr>
<tr class="memdesc:gaefefe50d0c68fb4997abc7b309740959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone pkt and its buffer.  <a href="group__net__pkt.html#gaefefe50d0c68fb4997abc7b309740959">More...</a><br /></td></tr>
<tr class="separator:gaefefe50d0c68fb4997abc7b309740959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26ae9d1286cb98d255f1bfb65201f1e2"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#ga26ae9d1286cb98d255f1bfb65201f1e2">net_pkt_shallow_clone</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt, <a class="el" href="structk__timeout__t.html">k_timeout_t</a> <a class="el" href="timer_2cycle64_2src_2main_8c.html#a8f4b69a82b00d7baf3f1f7d480bb7fa0">timeout</a>)</td></tr>
<tr class="memdesc:ga26ae9d1286cb98d255f1bfb65201f1e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone pkt and increase the refcount of its buffer.  <a href="group__net__pkt.html#ga26ae9d1286cb98d255f1bfb65201f1e2">More...</a><br /></td></tr>
<tr class="separator:ga26ae9d1286cb98d255f1bfb65201f1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914be010ddd225a4fc2d6ab521ee7b64"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#ga914be010ddd225a4fc2d6ab521ee7b64">net_pkt_read</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt, void *<a class="el" href="test__stack__fail_8c.html#a4bb6fa6c719fd9021449009ab8befc04">data</a>, size_t length)</td></tr>
<tr class="memdesc:ga914be010ddd225a4fc2d6ab521ee7b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read some data from a <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a>.  <a href="group__net__pkt.html#ga914be010ddd225a4fc2d6ab521ee7b64">More...</a><br /></td></tr>
<tr class="separator:ga914be010ddd225a4fc2d6ab521ee7b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b2753cb514804a77d9494c9f070089"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#gaf9b2753cb514804a77d9494c9f070089">net_pkt_read_u8</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt, <a class="el" href="stdint_8h.html#a3cb4a16b0e8d6af0af86d4fd6ba5fd9d">uint8_t</a> *<a class="el" href="test__stack__fail_8c.html#a4bb6fa6c719fd9021449009ab8befc04">data</a>)</td></tr>
<tr class="separator:gaf9b2753cb514804a77d9494c9f070089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga500a318977cfecd4ec7c60cea01db2fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#ga500a318977cfecd4ec7c60cea01db2fc">net_pkt_read_be16</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt, <a class="el" href="stdint_8h.html#a5debae8b2a1ec20a6694c0c443ee399e">uint16_t</a> *<a class="el" href="test__stack__fail_8c.html#a4bb6fa6c719fd9021449009ab8befc04">data</a>)</td></tr>
<tr class="memdesc:ga500a318977cfecd4ec7c60cea01db2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read uint16_t big endian data from a <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a>.  <a href="group__net__pkt.html#ga500a318977cfecd4ec7c60cea01db2fc">More...</a><br /></td></tr>
<tr class="separator:ga500a318977cfecd4ec7c60cea01db2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1735ef4f6a2e538a2692358295dd8d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#gab1735ef4f6a2e538a2692358295dd8d1">net_pkt_read_le16</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt, <a class="el" href="stdint_8h.html#a5debae8b2a1ec20a6694c0c443ee399e">uint16_t</a> *<a class="el" href="test__stack__fail_8c.html#a4bb6fa6c719fd9021449009ab8befc04">data</a>)</td></tr>
<tr class="memdesc:gab1735ef4f6a2e538a2692358295dd8d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read uint16_t little endian data from a <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a>.  <a href="group__net__pkt.html#gab1735ef4f6a2e538a2692358295dd8d1">More...</a><br /></td></tr>
<tr class="separator:gab1735ef4f6a2e538a2692358295dd8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab38c99947d02982073df65c0d5893d2c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#gab38c99947d02982073df65c0d5893d2c">net_pkt_read_be32</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt, <a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> *<a class="el" href="test__stack__fail_8c.html#a4bb6fa6c719fd9021449009ab8befc04">data</a>)</td></tr>
<tr class="memdesc:gab38c99947d02982073df65c0d5893d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read uint32_t big endian data from a <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a>.  <a href="group__net__pkt.html#gab38c99947d02982073df65c0d5893d2c">More...</a><br /></td></tr>
<tr class="separator:gab38c99947d02982073df65c0d5893d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae99eadd977b7f66ecc91d2ccba34c6fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#gae99eadd977b7f66ecc91d2ccba34c6fa">net_pkt_write</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt, const void *<a class="el" href="test__stack__fail_8c.html#a4bb6fa6c719fd9021449009ab8befc04">data</a>, size_t length)</td></tr>
<tr class="memdesc:gae99eadd977b7f66ecc91d2ccba34c6fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data into a <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a>.  <a href="group__net__pkt.html#gae99eadd977b7f66ecc91d2ccba34c6fa">More...</a><br /></td></tr>
<tr class="separator:gae99eadd977b7f66ecc91d2ccba34c6fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5129f661075c13d9b59627ae9110bd1"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#gaa5129f661075c13d9b59627ae9110bd1">net_pkt_write_u8</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt, <a class="el" href="stdint_8h.html#a3cb4a16b0e8d6af0af86d4fd6ba5fd9d">uint8_t</a> <a class="el" href="test__stack__fail_8c.html#a4bb6fa6c719fd9021449009ab8befc04">data</a>)</td></tr>
<tr class="separator:gaa5129f661075c13d9b59627ae9110bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e5083388ccb0333fdcf745bc60ad260"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#ga8e5083388ccb0333fdcf745bc60ad260">net_pkt_write_be16</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt, <a class="el" href="stdint_8h.html#a5debae8b2a1ec20a6694c0c443ee399e">uint16_t</a> <a class="el" href="test__stack__fail_8c.html#a4bb6fa6c719fd9021449009ab8befc04">data</a>)</td></tr>
<tr class="separator:ga8e5083388ccb0333fdcf745bc60ad260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga053aff4ff0a501f336132c35b7fb2022"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#ga053aff4ff0a501f336132c35b7fb2022">net_pkt_write_be32</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt, <a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> <a class="el" href="test__stack__fail_8c.html#a4bb6fa6c719fd9021449009ab8befc04">data</a>)</td></tr>
<tr class="separator:ga053aff4ff0a501f336132c35b7fb2022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2388032e4e0b76fe32e4618ef3ea548"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#gaf2388032e4e0b76fe32e4618ef3ea548">net_pkt_write_le32</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt, <a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> <a class="el" href="test__stack__fail_8c.html#a4bb6fa6c719fd9021449009ab8befc04">data</a>)</td></tr>
<tr class="separator:gaf2388032e4e0b76fe32e4618ef3ea548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8a6ea1b0dc1bcd7b6a3f15869027dd1"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#gac8a6ea1b0dc1bcd7b6a3f15869027dd1">net_pkt_write_le16</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt, <a class="el" href="stdint_8h.html#a5debae8b2a1ec20a6694c0c443ee399e">uint16_t</a> <a class="el" href="test__stack__fail_8c.html#a4bb6fa6c719fd9021449009ab8befc04">data</a>)</td></tr>
<tr class="separator:gac8a6ea1b0dc1bcd7b6a3f15869027dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadee5307216b6b3b725a2fd7584a224c9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#gadee5307216b6b3b725a2fd7584a224c9">net_pkt_remaining_data</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt)</td></tr>
<tr class="memdesc:gadee5307216b6b3b725a2fd7584a224c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the amount of data which can be read from current cursor position.  <a href="group__net__pkt.html#gadee5307216b6b3b725a2fd7584a224c9">More...</a><br /></td></tr>
<tr class="separator:gadee5307216b6b3b725a2fd7584a224c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e7a0f9348a623c5160124da188445ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#ga2e7a0f9348a623c5160124da188445ee">net_pkt_update_length</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt, size_t length)</td></tr>
<tr class="memdesc:ga2e7a0f9348a623c5160124da188445ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the overall length of a packet.  <a href="group__net__pkt.html#ga2e7a0f9348a623c5160124da188445ee">More...</a><br /></td></tr>
<tr class="separator:ga2e7a0f9348a623c5160124da188445ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga434c347a32600ee113c0e1cc13f70cd4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#ga434c347a32600ee113c0e1cc13f70cd4">net_pkt_pull</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt, size_t length)</td></tr>
<tr class="memdesc:ga434c347a32600ee113c0e1cc13f70cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove data from the packet at current location.  <a href="group__net__pkt.html#ga434c347a32600ee113c0e1cc13f70cd4">More...</a><br /></td></tr>
<tr class="separator:ga434c347a32600ee113c0e1cc13f70cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb3b705a0431b3bb98fb2e8193c3b510"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a5debae8b2a1ec20a6694c0c443ee399e">uint16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#gadb3b705a0431b3bb98fb2e8193c3b510">net_pkt_get_current_offset</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt)</td></tr>
<tr class="memdesc:gadb3b705a0431b3bb98fb2e8193c3b510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the actual offset in the packet from its cursor.  <a href="group__net__pkt.html#gadb3b705a0431b3bb98fb2e8193c3b510">More...</a><br /></td></tr>
<tr class="separator:gadb3b705a0431b3bb98fb2e8193c3b510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4ee5a8903b495e000a3a4c8a8493160"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#gaf4ee5a8903b495e000a3a4c8a8493160">net_pkt_is_contiguous</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt, size_t size)</td></tr>
<tr class="memdesc:gaf4ee5a8903b495e000a3a4c8a8493160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a data size could fit contiguously.  <a href="group__net__pkt.html#gaf4ee5a8903b495e000a3a4c8a8493160">More...</a><br /></td></tr>
<tr class="separator:gaf4ee5a8903b495e000a3a4c8a8493160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbd6c0ab33139b134f67a8f8c0096445"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#gafbd6c0ab33139b134f67a8f8c0096445">net_pkt_get_contiguous_len</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt)</td></tr>
<tr class="separator:gafbd6c0ab33139b134f67a8f8c0096445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa00da4276fd4a01faf80a92796f78e70"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#gaa00da4276fd4a01faf80a92796f78e70">net_pkt_get_data</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt, struct <a class="el" href="structnet__pkt__data__access.html">net_pkt_data_access</a> *access)</td></tr>
<tr class="memdesc:gaa00da4276fd4a01faf80a92796f78e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get data from a network packet in a contiguous way.  <a href="group__net__pkt.html#gaa00da4276fd4a01faf80a92796f78e70">More...</a><br /></td></tr>
<tr class="separator:gaa00da4276fd4a01faf80a92796f78e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98df84477b35e203b11029fc4ddec1cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#ga98df84477b35e203b11029fc4ddec1cc">net_pkt_set_data</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt, struct <a class="el" href="structnet__pkt__data__access.html">net_pkt_data_access</a> *access)</td></tr>
<tr class="memdesc:ga98df84477b35e203b11029fc4ddec1cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set contiguous data into a network packet.  <a href="group__net__pkt.html#ga98df84477b35e203b11029fc4ddec1cc">More...</a><br /></td></tr>
<tr class="separator:ga98df84477b35e203b11029fc4ddec1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7226cbfa2da28408f9691d375bc8f9f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__pkt.html#gac7226cbfa2da28408f9691d375bc8f9f">net_pkt_acknowledge_data</a> (struct <a class="el" href="structnet__pkt.html">net_pkt</a> *pkt, struct <a class="el" href="structnet__pkt__data__access.html">net_pkt_data_access</a> *access)</td></tr>
<tr class="separator:gac7226cbfa2da28408f9691d375bc8f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Network packet management library. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaa6a48974656755dcc0979683b8431c37" name="gaa6a48974656755dcc0979683b8431c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6a48974656755dcc0979683b8431c37">&#9670;&nbsp;</a></span>NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">        <span class="keyword">struct </span><a class="code hl_struct" href="structnet__pkt__data__access.html">net_pkt_data_access</a> _name = {                    \</div>
<div class="line">                .<a class="code hl_variable" href="structnet__pkt__data__access.html#ae65969f19c334bc998fafc72ef20e95f">data</a> = NULL,                                   \</div>
<div class="line">                .size = <span class="keyword">sizeof</span>(_type),                          \</div>
<div class="line">        }</div>
<div class="ttc" id="astructnet__pkt__data__access_html"><div class="ttname"><a href="structnet__pkt__data__access.html">net_pkt_data_access</a></div><div class="ttdef"><b>Definition:</b> net_pkt.h:2105</div></div>
<div class="ttc" id="astructnet__pkt__data__access_html_ae65969f19c334bc998fafc72ef20e95f"><div class="ttname"><a href="structnet__pkt__data__access.html#ae65969f19c334bc998fafc72ef20e95f">net_pkt_data_access::data</a></div><div class="ttdeci">void * data</div><div class="ttdef"><b>Definition:</b> net_pkt.h:2107</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gafd11f2d4f773bf247296eb08b7006c27" name="gafd11f2d4f773bf247296eb08b7006c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd11f2d4f773bf247296eb08b7006c27">&#9670;&nbsp;</a></span>NET_PKT_DATA_ACCESS_DEFINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NET_PKT_DATA_ACCESS_DEFINE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">        _type _hdr_##_name;                                     \</div>
<div class="line">        struct <a class="code hl_struct" href="structnet__pkt__data__access.html">net_pkt_data_access</a> _name = {                    \</div>
<div class="line">                .<a class="code hl_variable" href="structnet__pkt__data__access.html#ae65969f19c334bc998fafc72ef20e95f">data</a> = &amp;_hdr_##_name,                          \</div>
<div class="line">                .size = <span class="keyword">sizeof</span>(_type),                          \</div>
<div class="line">        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga94ab6300b59d739c4e3c5604d3fbe8a5" name="ga94ab6300b59d739c4e3c5604d3fbe8a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94ab6300b59d739c4e3c5604d3fbe8a5">&#9670;&nbsp;</a></span>NET_PKT_DATA_POOL_DEFINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NET_PKT_DATA_POOL_DEFINE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="semaphore_2sys__sem_2src_2main_8c.html#a7624b580dc5672d7564cdc73212de784">count</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">        <a class="code hl_define" href="group__net__buf.html#ga810aba8ba321fd012edc238ea9fe19dc">NET_BUF_POOL_DEFINE</a>(name, <a class="code hl_variable" href="condvar_2condvar__api_2src_2main_8c.html#a612635fe60af527de1e4d54f66e27b94">count</a>, CONFIG_NET_BUF_DATA_SIZE,      \</div>
<div class="line">                            0, NULL)</div>
<div class="ttc" id="acondvar_2condvar__api_2src_2main_8c_html_a612635fe60af527de1e4d54f66e27b94"><div class="ttname"><a href="condvar_2condvar__api_2src_2main_8c.html#a612635fe60af527de1e4d54f66e27b94">count</a></div><div class="ttdeci">ZTEST_BMEM int count</div><div class="ttdef"><b>Definition:</b> main.c:33</div></div>
<div class="ttc" id="agroup__net__buf_html_ga810aba8ba321fd012edc238ea9fe19dc"><div class="ttname"><a href="group__net__buf.html#ga810aba8ba321fd012edc238ea9fe19dc">NET_BUF_POOL_DEFINE</a></div><div class="ttdeci">#define NET_BUF_POOL_DEFINE(_name, _count, _size, _ud_size, _destroy)</div><div class="ttdoc">Define a new pool for buffers.</div><div class="ttdef"><b>Definition:</b> buf.h:1212</div></div>
</div><!-- fragment -->
<p>Create a data fragment <a class="el" href="structnet__buf.html" title="Network buffer representation.">net_buf</a> pool. </p>
<p >A <a class="el" href="structnet__buf.html" title="Network buffer representation.">net_buf</a> pool is used to store actual data for network packets. It must be coupled with a <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> slab (:c:macro:<code>NET_PKT_SLAB_DEFINE</code>) used to store the packet meta-information. The macro can be used by an application to define additional custom per-context TX packet pools (see :c:func:<code>net_context_setup_pools</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the pool. </td></tr>
    <tr><td class="paramname">count</td><td>Number of <a class="el" href="structnet__buf.html" title="Network buffer representation.">net_buf</a> in this pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2b2d0900ae76674d418918ec955bad48" name="ga2b2d0900ae76674d418918ec955bad48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b2d0900ae76674d418918ec955bad48">&#9670;&nbsp;</a></span>net_pkt_print_frags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define net_pkt_print_frags</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pkt</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Print fragment list and the fragment sizes. </p>
<p >Only available if debugging is activated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>Network pkt. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafc7e98d5b64d816faabcbaa2ec22a2bb" name="gafc7e98d5b64d816faabcbaa2ec22a2bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc7e98d5b64d816faabcbaa2ec22a2bb">&#9670;&nbsp;</a></span>NET_PKT_SLAB_DEFINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NET_PKT_SLAB_DEFINE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="semaphore_2sys__sem_2src_2main_8c.html#a7624b580dc5672d7564cdc73212de784">count</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;	<a class="el" href="obj__tracking_2src_2main_8c.html#a28f95631efa7f8ce6a04bc473f52af4e">K_MEM_SLAB_DEFINE</a>(name, sizeof(struct <a class="el" href="structnet__pkt.html">net_pkt</a>), <a class="el" href="semaphore_2sys__sem_2src_2main_8c.html#a7624b580dc5672d7564cdc73212de784">count</a>, 4)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Create a <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> slab. </p>
<p >A <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> slab is used to store meta-information about network packets. It must be coupled with a data fragment pool (:c:macro:<code>NET_PKT_DATA_POOL_DEFINE</code>) used to store the actual packet data. The macro can be used by an application to define additional custom per-context TX packet slabs (see :c:func:<code>net_context_setup_pools</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the slab. </td></tr>
    <tr><td class="paramname">count</td><td>Number of <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> in this slab. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacb3bb7347aa5dccb902531a1d6fbd190" name="gacb3bb7347aa5dccb902531a1d6fbd190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb3bb7347aa5dccb902531a1d6fbd190">&#9670;&nbsp;</a></span>NET_PKT_TX_SLAB_DEFINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NET_PKT_TX_SLAB_DEFINE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="semaphore_2sys__sem_2src_2main_8c.html#a7624b580dc5672d7564cdc73212de784">count</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__net__pkt.html#gafc7e98d5b64d816faabcbaa2ec22a2bb">NET_PKT_SLAB_DEFINE</a>(name, <a class="el" href="semaphore_2sys__sem_2src_2main_8c.html#a7624b580dc5672d7564cdc73212de784">count</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gac7226cbfa2da28408f9691d375bc8f9f" name="gac7226cbfa2da28408f9691d375bc8f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7226cbfa2da28408f9691d375bc8f9f">&#9670;&nbsp;</a></span>net_pkt_acknowledge_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int net_pkt_acknowledge_data </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt__data__access.html">net_pkt_data_access</a> *&#160;</td>
          <td class="paramname"><em>access</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>
<p >Acknowledge previously contiguous data taken from a network packet Packet needs to be set to overwrite mode. </p>

</div>
</div>
<a id="ga90d97ba913a875b3ee438e0ea8a970fd" name="ga90d97ba913a875b3ee438e0ea8a970fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90d97ba913a875b3ee438e0ea8a970fd">&#9670;&nbsp;</a></span>net_pkt_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structnet__pkt.html">net_pkt</a> * net_pkt_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structk__timeout__t.html">k_timeout_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Allocate an initialized <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a>. </p>
<p >for the time being, 2 pools are used. One for TX and one for RX. This allocator has to be used for TX.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Maximum time to wait for an allocation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a newly allocated <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> on success, NULL otherwise. </dd></dl>

</div>
</div>
<a id="gae31b4afd510bce346f7d00a9ec5d190d" name="gae31b4afd510bce346f7d00a9ec5d190d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae31b4afd510bce346f7d00a9ec5d190d">&#9670;&nbsp;</a></span>net_pkt_alloc_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int net_pkt_alloc_buffer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__ip__4__6.html#gaf06819bf427cc58be1229b27b373ca31">net_ip_protocol</a>&#160;</td>
          <td class="paramname"><em>proto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structk__timeout__t.html">k_timeout_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Allocate buffer for a <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a>. </p>
<p >: such allocator will take into account space necessary for headers, MTU, and existing buffer (if any). Beware that, due to all these criteria, the allocated size might be smaller/bigger than requested one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>The network packet requiring buffer to be allocated. </td></tr>
    <tr><td class="paramname">size</td><td>The size of buffer being requested. </td></tr>
    <tr><td class="paramname">proto</td><td>The IP protocol type (can be 0 for none). </td></tr>
    <tr><td class="paramname">timeout</td><td>Maximum time to wait for an allocation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno code otherwise. </dd></dl>

</div>
</div>
<a id="gaf1edbaab59576262647089fa1751d9e3" name="gaf1edbaab59576262647089fa1751d9e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1edbaab59576262647089fa1751d9e3">&#9670;&nbsp;</a></span>net_pkt_alloc_from_slab()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structnet__pkt.html">net_pkt</a> * net_pkt_alloc_from_slab </td>
          <td>(</td>
          <td class="paramtype">struct k_mem_slab *&#160;</td>
          <td class="paramname"><em>slab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structk__timeout__t.html">k_timeout_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Allocate an initialized <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> from a specific slab. </p>
<p >unlike <a class="el" href="group__net__pkt.html#ga90d97ba913a875b3ee438e0ea8a970fd" title="Allocate an initialized net_pkt.">net_pkt_alloc()</a> which uses core slabs, this one will use an external slab (see <a class="el" href="group__net__pkt.html#gafc7e98d5b64d816faabcbaa2ec22a2bb" title="Create a net_pkt slab.">NET_PKT_SLAB_DEFINE()</a>). Do <em>not</em> use it unless you know what you are doing. Basically, only <a class="el" href="structnet__context.html">net_context</a> should be using this, in order to allocate packet and then buffer on its local slab/pool (if any).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slab</td><td>The slab to use for allocating the packet </td></tr>
    <tr><td class="paramname">timeout</td><td>Maximum time to wait for an allocation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a newly allocated <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> on success, NULL otherwise. </dd></dl>

</div>
</div>
<a id="ga770ffe22fc797691b1fc89954d60b2e6" name="ga770ffe22fc797691b1fc89954d60b2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga770ffe22fc797691b1fc89954d60b2e6">&#9670;&nbsp;</a></span>net_pkt_alloc_on_iface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structnet__pkt.html">net_pkt</a> * net_pkt_alloc_on_iface </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__if.html">net_if</a> *&#160;</td>
          <td class="paramname"><em>iface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structk__timeout__t.html">k_timeout_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Allocate a network packet for a specific network interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iface</td><td>The network interface the packet is supposed to go through. </td></tr>
    <tr><td class="paramname">timeout</td><td>Maximum time to wait for an allocation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a newly allocated <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> on success, NULL otherwise. </dd></dl>

</div>
</div>
<a id="ga57e2f5138acd92ad49864e3d709d9419" name="ga57e2f5138acd92ad49864e3d709d9419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57e2f5138acd92ad49864e3d709d9419">&#9670;&nbsp;</a></span>net_pkt_alloc_with_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structnet__pkt.html">net_pkt</a> * net_pkt_alloc_with_buffer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__if.html">net_if</a> *&#160;</td>
          <td class="paramname"><em>iface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ip__4__6.html#ga2d9e094abb99ebd0874373edf1c45eda">sa_family_t</a>&#160;</td>
          <td class="paramname"><em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__ip__4__6.html#gaf06819bf427cc58be1229b27b373ca31">net_ip_protocol</a>&#160;</td>
          <td class="paramname"><em>proto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structk__timeout__t.html">k_timeout_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Allocate a network packet and buffer at once. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iface</td><td>The network interface the packet is supposed to go through. </td></tr>
    <tr><td class="paramname">size</td><td>The size of buffer. </td></tr>
    <tr><td class="paramname">family</td><td>The family to which the packet belongs. </td></tr>
    <tr><td class="paramname">proto</td><td>The IP protocol type (can be 0 for none). </td></tr>
    <tr><td class="paramname">timeout</td><td>Maximum time to wait for an allocation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a newly allocated <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> on success, NULL otherwise. </dd></dl>

</div>
</div>
<a id="ga2b11492ae3c16368aa6a0ab8f47b67e7" name="ga2b11492ae3c16368aa6a0ab8f47b67e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b11492ae3c16368aa6a0ab8f47b67e7">&#9670;&nbsp;</a></span>net_pkt_append_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void net_pkt_append_buffer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnet__buf.html">net_buf</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Append a buffer in packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>Network packet where to append the buffer </td></tr>
    <tr><td class="paramname">buffer</td><td>Buffer to append </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeed119d192e3a14ea3eea6e623334519" name="gaeed119d192e3a14ea3eea6e623334519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeed119d192e3a14ea3eea6e623334519">&#9670;&nbsp;</a></span>net_pkt_available_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t net_pkt_available_buffer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Get available buffer space from a pkt. </p>
<dl class="section note"><dt>Note</dt><dd>Reserved bytes (headroom) in any of the fragments are not considered to be available.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>The <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> which buffer availability should be evaluated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the amount of buffer available </dd></dl>

</div>
</div>
<a id="gaa9f63047b7945a4a155e5d88eac5203b" name="gaa9f63047b7945a4a155e5d88eac5203b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9f63047b7945a4a155e5d88eac5203b">&#9670;&nbsp;</a></span>net_pkt_available_payload_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t net_pkt_available_payload_buffer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__ip__4__6.html#gaf06819bf427cc58be1229b27b373ca31">net_ip_protocol</a>&#160;</td>
          <td class="paramname"><em>proto</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Get available buffer space for payload from a pkt. </p>
<dl class="section note"><dt>Note</dt><dd>Reserved bytes (headroom) in any of the fragments are not considered to be available.</dd></dl>
<p>Unlike <a class="el" href="group__net__pkt.html#gaeed119d192e3a14ea3eea6e623334519" title="Get available buffer space from a pkt.">net_pkt_available_buffer()</a>, this will take into account the headers space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>The <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> which payload buffer availability should be evaluated </td></tr>
    <tr><td class="paramname">proto</td><td>The IP protocol type (can be 0 for none).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the amount of buffer available for payload </dd></dl>

</div>
</div>
<a id="gaefefe50d0c68fb4997abc7b309740959" name="gaefefe50d0c68fb4997abc7b309740959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefefe50d0c68fb4997abc7b309740959">&#9670;&nbsp;</a></span>net_pkt_clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structnet__pkt.html">net_pkt</a> * net_pkt_clone </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structk__timeout__t.html">k_timeout_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Clone pkt and its buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>Original pkt to be cloned </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout to wait for free buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if error, cloned packet otherwise. </dd></dl>

</div>
</div>
<a id="ga8d18adc7dc87bf6b54f45f0227c12423" name="ga8d18adc7dc87bf6b54f45f0227c12423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d18adc7dc87bf6b54f45f0227c12423">&#9670;&nbsp;</a></span>net_pkt_compact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> net_pkt_compact </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Compact the fragment list of a packet. </p>
<p >After this there is no more any free space in individual fragments. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>Network packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if compact success, False otherwise. </dd></dl>

</div>
</div>
<a id="ga4648828ca353c8c0ecf00ae2648e963a" name="ga4648828ca353c8c0ecf00ae2648e963a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4648828ca353c8c0ecf00ae2648e963a">&#9670;&nbsp;</a></span>net_pkt_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int net_pkt_copy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Copy data from a packet into another one. </p>
<p >Both <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> cursors should be properly initialized and, if needed, positioned using net_pkt_skip. The cursors will be updated after the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt_dst</td><td>Destination network packet. </td></tr>
    <tr><td class="paramname">pkt_src</td><td>Source network packet. </td></tr>
    <tr><td class="paramname">length</td><td>Length of data to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno code otherwise. </dd></dl>

</div>
</div>
<a id="gabd352b66cdeaff2fb45361a0fae62876" name="gabd352b66cdeaff2fb45361a0fae62876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd352b66cdeaff2fb45361a0fae62876">&#9670;&nbsp;</a></span>net_pkt_cursor_backup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void net_pkt_cursor_backup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt__cursor.html">net_pkt_cursor</a> *&#160;</td>
          <td class="paramname"><em>backup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Backup <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> cursor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>The <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> whose cursor is going to be backed up </td></tr>
    <tr><td class="paramname">backup</td><td>The cursor where to backup <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> cursor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabc42ba1bcd0801a116651d965e65b9cd" name="gabc42ba1bcd0801a116651d965e65b9cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc42ba1bcd0801a116651d965e65b9cd">&#9670;&nbsp;</a></span>net_pkt_cursor_get_pos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void * net_pkt_cursor_get_pos </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Returns current position of the cursor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>The <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> whose cursor position is going to be returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cursor's position </dd></dl>

</div>
</div>
<a id="ga1b7da39f62dfc8b8948d7689e2dd114a" name="ga1b7da39f62dfc8b8948d7689e2dd114a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b7da39f62dfc8b8948d7689e2dd114a">&#9670;&nbsp;</a></span>net_pkt_cursor_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void net_pkt_cursor_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Initialize <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> cursor. </p>
<p >This will initialize the <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> cursor from its buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>The <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> whose cursor is going to be initialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad5ab788f01b4bb3640755e8c4a2c612e" name="gad5ab788f01b4bb3640755e8c4a2c612e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5ab788f01b4bb3640755e8c4a2c612e">&#9670;&nbsp;</a></span>net_pkt_cursor_restore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void net_pkt_cursor_restore </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt__cursor.html">net_pkt_cursor</a> *&#160;</td>
          <td class="paramname"><em>backup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Restore <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> cursor from a backup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>The <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> whose cursor is going to be restored </td></tr>
    <tr><td class="paramname">backup</td><td>The cursor from where to restore <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> cursor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga03a53365cfc2b6c3448763d81f56c2c0" name="ga03a53365cfc2b6c3448763d81f56c2c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03a53365cfc2b6c3448763d81f56c2c0">&#9670;&nbsp;</a></span>net_pkt_frag_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void net_pkt_frag_add </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnet__buf.html">net_buf</a> *&#160;</td>
          <td class="paramname"><em>frag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Add a fragment to a packet at the end of its fragment list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>pkt Network packet where to add the fragment </td></tr>
    <tr><td class="paramname">frag</td><td>Fragment to add </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga956c784f5417f0f79976c6e106ad0d76" name="ga956c784f5417f0f79976c6e106ad0d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga956c784f5417f0f79976c6e106ad0d76">&#9670;&nbsp;</a></span>net_pkt_frag_del()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structnet__buf.html">net_buf</a> * net_pkt_frag_del </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnet__buf.html">net_buf</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnet__buf.html">net_buf</a> *&#160;</td>
          <td class="paramname"><em>frag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Delete existing fragment from a packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>Network packet from which frag belongs to. </td></tr>
    <tr><td class="paramname">parent</td><td>parent fragment of frag, or NULL if none. </td></tr>
    <tr><td class="paramname">frag</td><td>Fragment to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the following fragment, or NULL if it had no further fragments. </dd></dl>

</div>
</div>
<a id="gabcd375d9dbdca21855abe27d7b5a0a7e" name="gabcd375d9dbdca21855abe27d7b5a0a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcd375d9dbdca21855abe27d7b5a0a7e">&#9670;&nbsp;</a></span>net_pkt_frag_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void net_pkt_frag_insert </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnet__buf.html">net_buf</a> *&#160;</td>
          <td class="paramname"><em>frag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Insert a fragment to a packet at the beginning of its fragment list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>pkt Network packet where to insert the fragment </td></tr>
    <tr><td class="paramname">frag</td><td>Fragment to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaea5e1045d188b3abbd85717ff09d563a" name="gaea5e1045d188b3abbd85717ff09d563a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea5e1045d188b3abbd85717ff09d563a">&#9670;&nbsp;</a></span>net_pkt_frag_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structnet__buf.html">net_buf</a> * net_pkt_frag_ref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__buf.html">net_buf</a> *&#160;</td>
          <td class="paramname"><em>frag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Increase the packet fragment ref count. </p>
<p >Mark the fragment to be used still.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frag</td><td>Network fragment to ref.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer on the referenced Network fragment. </dd></dl>

</div>
</div>
<a id="ga5c75ef2149d2ba5ff07525988e0fb7cc" name="ga5c75ef2149d2ba5ff07525988e0fb7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c75ef2149d2ba5ff07525988e0fb7cc">&#9670;&nbsp;</a></span>net_pkt_frag_unref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void net_pkt_frag_unref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__buf.html">net_buf</a> *&#160;</td>
          <td class="paramname"><em>frag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Decrease the packet fragment ref count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frag</td><td>Network fragment to unref. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafbd6c0ab33139b134f67a8f8c0096445" name="gafbd6c0ab33139b134f67a8f8c0096445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbd6c0ab33139b134f67a8f8c0096445">&#9670;&nbsp;</a></span>net_pkt_get_contiguous_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t net_pkt_get_contiguous_len </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>
<p >Get the contiguous buffer space</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>Network packet</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The available contiguous buffer space in bytes starting from the current cursor position. 0 in case of an error. </dd></dl>

</div>
</div>
<a id="gadb3b705a0431b3bb98fb2e8193c3b510" name="gadb3b705a0431b3bb98fb2e8193c3b510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb3b705a0431b3bb98fb2e8193c3b510">&#9670;&nbsp;</a></span>net_pkt_get_current_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a5debae8b2a1ec20a6694c0c443ee399e">uint16_t</a> net_pkt_get_current_offset </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Get the actual offset in the packet from its cursor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>Network packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a valid offset on success, 0 otherwise as there is nothing that can be done to evaluate the offset. </dd></dl>

</div>
</div>
<a id="gaa00da4276fd4a01faf80a92796f78e70" name="gaa00da4276fd4a01faf80a92796f78e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa00da4276fd4a01faf80a92796f78e70">&#9670;&nbsp;</a></span>net_pkt_get_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * net_pkt_get_data </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt__data__access.html">net_pkt_data_access</a> *&#160;</td>
          <td class="paramname"><em>access</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Get data from a network packet in a contiguous way. </p>
<p ><a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a>'s cursor should be properly initialized and, if needed, positioned using net_pkt_skip. Cursor position will be updated after the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>The network packet from where to get the data. </td></tr>
    <tr><td class="paramname">access</td><td>A pointer to a valid <a class="el" href="structnet__pkt__data__access.html">net_pkt_data_access</a> describing the data to get in a contiguous way.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the requested contiguous data, NULL otherwise. </dd></dl>

</div>
</div>
<a id="gae4d0c53b29d2fbd6e324a274e35f6b9d" name="gae4d0c53b29d2fbd6e324a274e35f6b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4d0c53b29d2fbd6e324a274e35f6b9d">&#9670;&nbsp;</a></span>net_pkt_get_frag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structnet__buf.html">net_buf</a> * net_pkt_get_frag </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structk__timeout__t.html">k_timeout_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Get a data fragment that might be from user specific buffer pool or from global DATA pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>Network packet. </td></tr>
    <tr><td class="paramname">timeout</td><td>Affects the action taken should the net buf pool be empty. If K_NO_WAIT, then return immediately. If K_FOREVER, then wait as long as necessary. Otherwise, wait up to the specified time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Network buffer if successful, NULL otherwise. </dd></dl>

</div>
</div>
<a id="ga7b02b95838b928febfd4970de5e9c9f9" name="ga7b02b95838b928febfd4970de5e9c9f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b02b95838b928febfd4970de5e9c9f9">&#9670;&nbsp;</a></span>net_pkt_get_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void net_pkt_get_info </td>
          <td>(</td>
          <td class="paramtype">struct k_mem_slab **&#160;</td>
          <td class="paramname"><em>rx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct k_mem_slab **&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnet__buf__pool.html">net_buf_pool</a> **&#160;</td>
          <td class="paramname"><em>rx_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnet__buf__pool.html">net_buf_pool</a> **&#160;</td>
          <td class="paramname"><em>tx_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Get information about predefined RX, TX and DATA pools. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rx</td><td>Pointer to RX pool is returned. </td></tr>
    <tr><td class="paramname">tx</td><td>Pointer to TX pool is returned. </td></tr>
    <tr><td class="paramname">rx_data</td><td>Pointer to RX DATA pool is returned. </td></tr>
    <tr><td class="paramname">tx_data</td><td>Pointer to TX DATA pool is returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga30d0b8741abd594f90a7f206f554035f" name="ga30d0b8741abd594f90a7f206f554035f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30d0b8741abd594f90a7f206f554035f">&#9670;&nbsp;</a></span>net_pkt_get_reserve_rx_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structnet__buf.html">net_buf</a> * net_pkt_get_reserve_rx_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structk__timeout__t.html">k_timeout_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Get RX DATA buffer from pool. Normally you should use <a class="el" href="group__net__pkt.html#gae4d0c53b29d2fbd6e324a274e35f6b9d" title="Get a data fragment that might be from user specific buffer pool or from global DATA pool.">net_pkt_get_frag()</a> instead. </p>
<p >Normally this version is not useful for applications but is mainly used by network fragmentation code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Affects the action taken should the net buf pool be empty. If K_NO_WAIT, then return immediately. If K_FOREVER, then wait as long as necessary. Otherwise, wait up to the specified time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Network buffer if successful, NULL otherwise. </dd></dl>

</div>
</div>
<a id="gaca0174ee16d43448a265675b54a57758" name="gaca0174ee16d43448a265675b54a57758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca0174ee16d43448a265675b54a57758">&#9670;&nbsp;</a></span>net_pkt_get_reserve_tx_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structnet__buf.html">net_buf</a> * net_pkt_get_reserve_tx_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structk__timeout__t.html">k_timeout_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Get TX DATA buffer from pool. Normally you should use <a class="el" href="group__net__pkt.html#gae4d0c53b29d2fbd6e324a274e35f6b9d" title="Get a data fragment that might be from user specific buffer pool or from global DATA pool.">net_pkt_get_frag()</a> instead. </p>
<p >Normally this version is not useful for applications but is mainly used by network fragmentation code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Affects the action taken should the net buf pool be empty. If K_NO_WAIT, then return immediately. If K_FOREVER, then wait as long as necessary. Otherwise, wait up to the specified time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Network buffer if successful, NULL otherwise. </dd></dl>

</div>
</div>
<a id="gaf4ee5a8903b495e000a3a4c8a8493160" name="gaf4ee5a8903b495e000a3a4c8a8493160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4ee5a8903b495e000a3a4c8a8493160">&#9670;&nbsp;</a></span>net_pkt_is_contiguous()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> net_pkt_is_contiguous </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Check if a data size could fit contiguously. </p>
<p ><a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a>'s cursor should be properly initialized and, if needed, positioned using net_pkt_skip.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>Network packet. </td></tr>
    <tr><td class="paramname">size</td><td>The size to check for contiguity</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if that is the case, false otherwise. </dd></dl>

</div>
</div>
<a id="gabd241a539bf1290f3d45610fd15b2c1f" name="gabd241a539bf1290f3d45610fd15b2c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd241a539bf1290f3d45610fd15b2c1f">&#9670;&nbsp;</a></span>net_pkt_memset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int net_pkt_memset </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Memset some data in a <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a>. </p>
<p ><a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a>'s cursor should be properly initialized and, if needed, positioned using net_pkt_skip. Cursor position will be updated after the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>The <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> whose buffer to fill starting at the current cursor position. </td></tr>
    <tr><td class="paramname">byte</td><td>The byte to write in memory </td></tr>
    <tr><td class="paramname">length</td><td>Amount of data to memset with given byte</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 in success, negative errno code otherwise. </dd></dl>

</div>
</div>
<a id="ga434c347a32600ee113c0e1cc13f70cd4" name="ga434c347a32600ee113c0e1cc13f70cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga434c347a32600ee113c0e1cc13f70cd4">&#9670;&nbsp;</a></span>net_pkt_pull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int net_pkt_pull </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Remove data from the packet at current location. </p>
<p ><a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a>'s cursor should be properly initialized and, eventually, properly positioned using net_pkt_skip/read/write. Note that <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a>'s cursor is reset by this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>Network packet </td></tr>
    <tr><td class="paramname">length</td><td>Number of bytes to be removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno code otherwise. </dd></dl>

</div>
</div>
<a id="ga914be010ddd225a4fc2d6ab521ee7b64" name="ga914be010ddd225a4fc2d6ab521ee7b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga914be010ddd225a4fc2d6ab521ee7b64">&#9670;&nbsp;</a></span>net_pkt_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int net_pkt_read </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Read some data from a <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a>. </p>
<p ><a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a>'s cursor should be properly initialized and, if needed, positioned using net_pkt_skip. Cursor position will be updated after the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>The network packet from where to read some data </td></tr>
    <tr><td class="paramname">data</td><td>The destination buffer where to copy the data </td></tr>
    <tr><td class="paramname">length</td><td>The amount of data to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno code otherwise. </dd></dl>

</div>
</div>
<a id="ga500a318977cfecd4ec7c60cea01db2fc" name="ga500a318977cfecd4ec7c60cea01db2fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga500a318977cfecd4ec7c60cea01db2fc">&#9670;&nbsp;</a></span>net_pkt_read_be16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int net_pkt_read_be16 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a5debae8b2a1ec20a6694c0c443ee399e">uint16_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Read uint16_t big endian data from a <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a>. </p>
<p ><a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a>'s cursor should be properly initialized and, if needed, positioned using net_pkt_skip. Cursor position will be updated after the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>The network packet from where to read </td></tr>
    <tr><td class="paramname">data</td><td>The destination uint16_t where to copy the data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno code otherwise. </dd></dl>

</div>
</div>
<a id="gab38c99947d02982073df65c0d5893d2c" name="gab38c99947d02982073df65c0d5893d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab38c99947d02982073df65c0d5893d2c">&#9670;&nbsp;</a></span>net_pkt_read_be32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int net_pkt_read_be32 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Read uint32_t big endian data from a <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a>. </p>
<p ><a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a>'s cursor should be properly initialized and, if needed, positioned using net_pkt_skip. Cursor position will be updated after the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>The network packet from where to read </td></tr>
    <tr><td class="paramname">data</td><td>The destination uint32_t where to copy the data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno code otherwise. </dd></dl>

</div>
</div>
<a id="gab1735ef4f6a2e538a2692358295dd8d1" name="gab1735ef4f6a2e538a2692358295dd8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1735ef4f6a2e538a2692358295dd8d1">&#9670;&nbsp;</a></span>net_pkt_read_le16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int net_pkt_read_le16 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a5debae8b2a1ec20a6694c0c443ee399e">uint16_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Read uint16_t little endian data from a <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a>. </p>
<p ><a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a>'s cursor should be properly initialized and, if needed, positioned using net_pkt_skip. Cursor position will be updated after the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>The network packet from where to read </td></tr>
    <tr><td class="paramname">data</td><td>The destination uint16_t where to copy the data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno code otherwise. </dd></dl>

</div>
</div>
<a id="gaf9b2753cb514804a77d9494c9f070089" name="gaf9b2753cb514804a77d9494c9f070089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9b2753cb514804a77d9494c9f070089">&#9670;&nbsp;</a></span>net_pkt_read_u8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int net_pkt_read_u8 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a3cb4a16b0e8d6af0af86d4fd6ba5fd9d">uint8_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

</div>
</div>
<a id="ga4e83d4f60b46db8f57798c0e96d6cd7a" name="ga4e83d4f60b46db8f57798c0e96d6cd7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e83d4f60b46db8f57798c0e96d6cd7a">&#9670;&nbsp;</a></span>net_pkt_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structnet__pkt.html">net_pkt</a> * net_pkt_ref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Increase the packet ref count. </p>
<p >Mark the packet to be used still.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>Network packet to ref.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Network packet if successful, NULL otherwise. </dd></dl>

</div>
</div>
<a id="gadee5307216b6b3b725a2fd7584a224c9" name="gadee5307216b6b3b725a2fd7584a224c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadee5307216b6b3b725a2fd7584a224c9">&#9670;&nbsp;</a></span>net_pkt_remaining_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t net_pkt_remaining_data </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Get the amount of data which can be read from current cursor position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>Network packet</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Amount of data which can be read from current pkt cursor </dd></dl>

</div>
</div>
<a id="gab657c80669733a4afefaf1be6310107e" name="gab657c80669733a4afefaf1be6310107e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab657c80669733a4afefaf1be6310107e">&#9670;&nbsp;</a></span>net_pkt_remove_tail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int net_pkt_remove_tail </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Remove <em>length</em> bytes from tail of packet. </p>
<p >This function does not take packet cursor into account. It is a helper to remove unneeded bytes from tail of packet (like appended CRC). It takes care of buffer deallocation if removed bytes span whole buffer(s).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>Network packet </td></tr>
    <tr><td class="paramname">length</td><td>Number of bytes to be removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success. </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>If packet length is shorter than <em>length</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4cec027a0de4807879fd3bd3aed4f12a" name="ga4cec027a0de4807879fd3bd3aed4f12a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cec027a0de4807879fd3bd3aed4f12a">&#9670;&nbsp;</a></span>net_pkt_rx_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structnet__pkt.html">net_pkt</a> * net_pkt_rx_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structk__timeout__t.html">k_timeout_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Allocate an initialized <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> for RX. </p>
<p >for the time being, 2 pools are used. One for TX and one for RX. This allocator has to be used for RX.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Maximum time to wait for an allocation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a newly allocated <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> on success, NULL otherwise. </dd></dl>

</div>
</div>
<a id="gab64f7551b1995c301232ab4cd39b9efc" name="gab64f7551b1995c301232ab4cd39b9efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab64f7551b1995c301232ab4cd39b9efc">&#9670;&nbsp;</a></span>net_pkt_rx_alloc_on_iface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structnet__pkt.html">net_pkt</a> * net_pkt_rx_alloc_on_iface </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__if.html">net_if</a> *&#160;</td>
          <td class="paramname"><em>iface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structk__timeout__t.html">k_timeout_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

</div>
</div>
<a id="ga623794964a35e0e24c1f41a75bfba626" name="ga623794964a35e0e24c1f41a75bfba626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga623794964a35e0e24c1f41a75bfba626">&#9670;&nbsp;</a></span>net_pkt_rx_alloc_with_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structnet__pkt.html">net_pkt</a> * net_pkt_rx_alloc_with_buffer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__if.html">net_if</a> *&#160;</td>
          <td class="paramname"><em>iface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ip__4__6.html#ga2d9e094abb99ebd0874373edf1c45eda">sa_family_t</a>&#160;</td>
          <td class="paramname"><em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__ip__4__6.html#gaf06819bf427cc58be1229b27b373ca31">net_ip_protocol</a>&#160;</td>
          <td class="paramname"><em>proto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structk__timeout__t.html">k_timeout_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

</div>
</div>
<a id="ga98df84477b35e203b11029fc4ddec1cc" name="ga98df84477b35e203b11029fc4ddec1cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98df84477b35e203b11029fc4ddec1cc">&#9670;&nbsp;</a></span>net_pkt_set_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int net_pkt_set_data </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt__data__access.html">net_pkt_data_access</a> *&#160;</td>
          <td class="paramname"><em>access</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Set contiguous data into a network packet. </p>
<p ><a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a>'s cursor should be properly initialized and, if needed, positioned using net_pkt_skip. Cursor position will be updated after the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>The network packet to where the data should be set. </td></tr>
    <tr><td class="paramname">access</td><td>A pointer to a valid <a class="el" href="structnet__pkt__data__access.html">net_pkt_data_access</a> describing the data to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative errno otherwise. </dd></dl>

</div>
</div>
<a id="ga26ae9d1286cb98d255f1bfb65201f1e2" name="ga26ae9d1286cb98d255f1bfb65201f1e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26ae9d1286cb98d255f1bfb65201f1e2">&#9670;&nbsp;</a></span>net_pkt_shallow_clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structnet__pkt.html">net_pkt</a> * net_pkt_shallow_clone </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structk__timeout__t.html">k_timeout_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Clone pkt and increase the refcount of its buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>Original pkt to be shallow cloned </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout to wait for free packet</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if error, cloned packet otherwise. </dd></dl>

</div>
</div>
<a id="ga223a79baa1e740a53c4ed0f083d62185" name="ga223a79baa1e740a53c4ed0f083d62185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga223a79baa1e740a53c4ed0f083d62185">&#9670;&nbsp;</a></span>net_pkt_skip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int net_pkt_skip </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Skip some data from a <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a>. </p>
<p ><a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a>'s cursor should be properly initialized Cursor position will be updated after the operation. Depending on the value of pkt-&gt;overwrite bit, this function will affect the buffer length or not. If it's true, it will advance the cursor to the requested length. If it's false, it will do the same but if the cursor was already also at the end of existing data, it will increment the buffer length. So in this case, its behavior is just like net_pkt_write or net_pkt_memset, difference being that it will not affect the buffer content itself (which may be just garbage then).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>The <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> whose cursor will be updated to skip given amount of data from the buffer. </td></tr>
    <tr><td class="paramname">length</td><td>Amount of data to skip in the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 in success, negative errno code otherwise. </dd></dl>

</div>
</div>
<a id="ga71d1c49f68afab07324cebd835f08a29" name="ga71d1c49f68afab07324cebd835f08a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71d1c49f68afab07324cebd835f08a29">&#9670;&nbsp;</a></span>net_pkt_trim_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void net_pkt_trim_buffer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Trim <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> buffer. </p>
<p >This will basically check for unused buffers and deallocates them relevantly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>The <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a> which buffer will be trimmed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga893d1660fd18ad5842224fda78466099" name="ga893d1660fd18ad5842224fda78466099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga893d1660fd18ad5842224fda78466099">&#9670;&nbsp;</a></span>net_pkt_unref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void net_pkt_unref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Place packet back into the available packets slab. </p>
<p >Releases the packet to other use. This needs to be called by application after it has finished with the packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>Network packet to release. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2e7a0f9348a623c5160124da188445ee" name="ga2e7a0f9348a623c5160124da188445ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e7a0f9348a623c5160124da188445ee">&#9670;&nbsp;</a></span>net_pkt_update_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int net_pkt_update_length </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Update the overall length of a packet. </p>
<p >Unlike <a class="el" href="group__net__pkt.html#ga434c347a32600ee113c0e1cc13f70cd4" title="Remove data from the packet at current location.">net_pkt_pull()</a> below, this does not take packet cursor into account. It's mainly a helper dedicated for ipv4 and ipv6 input functions. It shrinks the overall length by given parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>Network packet </td></tr>
    <tr><td class="paramname">length</td><td>The new length of the packet</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno code otherwise. </dd></dl>

</div>
</div>
<a id="gae99eadd977b7f66ecc91d2ccba34c6fa" name="gae99eadd977b7f66ecc91d2ccba34c6fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae99eadd977b7f66ecc91d2ccba34c6fa">&#9670;&nbsp;</a></span>net_pkt_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int net_pkt_write </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

<p>Write data into a <a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a>. </p>
<p ><a class="el" href="structnet__pkt.html" title="Network packet.">net_pkt</a>'s cursor should be properly initialized and, if needed, positioned using net_pkt_skip. Cursor position will be updated after the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>The network packet where to write </td></tr>
    <tr><td class="paramname">data</td><td>Data to be written </td></tr>
    <tr><td class="paramname">length</td><td>Length of the data to be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno code otherwise. </dd></dl>

</div>
</div>
<a id="ga8e5083388ccb0333fdcf745bc60ad260" name="ga8e5083388ccb0333fdcf745bc60ad260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e5083388ccb0333fdcf745bc60ad260">&#9670;&nbsp;</a></span>net_pkt_write_be16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int net_pkt_write_be16 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a5debae8b2a1ec20a6694c0c443ee399e">uint16_t</a>&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

</div>
</div>
<a id="ga053aff4ff0a501f336132c35b7fb2022" name="ga053aff4ff0a501f336132c35b7fb2022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga053aff4ff0a501f336132c35b7fb2022">&#9670;&nbsp;</a></span>net_pkt_write_be32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int net_pkt_write_be32 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a>&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

</div>
</div>
<a id="gac8a6ea1b0dc1bcd7b6a3f15869027dd1" name="gac8a6ea1b0dc1bcd7b6a3f15869027dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8a6ea1b0dc1bcd7b6a3f15869027dd1">&#9670;&nbsp;</a></span>net_pkt_write_le16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int net_pkt_write_le16 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a5debae8b2a1ec20a6694c0c443ee399e">uint16_t</a>&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

</div>
</div>
<a id="gaf2388032e4e0b76fe32e4618ef3ea548" name="gaf2388032e4e0b76fe32e4618ef3ea548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2388032e4e0b76fe32e4618ef3ea548">&#9670;&nbsp;</a></span>net_pkt_write_le32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int net_pkt_write_le32 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a>&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

</div>
</div>
<a id="gaa5129f661075c13d9b59627ae9110bd1" name="gaa5129f661075c13d9b59627ae9110bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5129f661075c13d9b59627ae9110bd1">&#9670;&nbsp;</a></span>net_pkt_write_u8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int net_pkt_write_u8 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnet__pkt.html">net_pkt</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a3cb4a16b0e8d6af0af86d4fd6ba5fd9d">uint8_t</a>&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__pkt_8h.html">include/net/net_pkt.h</a>&gt;</code></p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Feb 21 2022 04:59:41 for Zephyr API Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
<script type="text/javascript">
  $(function() {
    toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
    toggleButton.title = "Toggle Light/Dark Mode"
    $(document).ready(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
    // every resize will remove the button, which is why it has to be added again:
    $(window).resize(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
  })
</script>
</body>
</html>
