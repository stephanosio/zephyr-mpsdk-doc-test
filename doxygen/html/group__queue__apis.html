<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zephyr API Documentation: Queue APIs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-zephyr.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-zephyr.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Zephyr API Documentation
   &#160;<span id="projectnumber">3.0.99</span>
   </div>
   <div id="projectbrief">A Scalable Open Source RTOS</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__queue__apis.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Queue APIs<div class="ingroups"><a class="el" href="group__kernel__apis.html">Kernel APIs</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gacd0bc309f0147d4669f65fafa87e0e70"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__queue__apis.html#gacd0bc309f0147d4669f65fafa87e0e70">K_QUEUE_DEFINE</a>(name)</td></tr>
<tr class="memdesc:gacd0bc309f0147d4669f65fafa87e0e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically define and initialize a queue.  <a href="group__queue__apis.html#gacd0bc309f0147d4669f65fafa87e0e70">More...</a><br /></td></tr>
<tr class="separator:gacd0bc309f0147d4669f65fafa87e0e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0236222d42768c2bf00942f328146c21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__queue__apis.html#ga0236222d42768c2bf00942f328146c21">k_queue_init</a> (struct k_queue *<a class="el" href="test__queue__loop_8c.html#a643b6f9660035f1e1098c9484d214bbd">queue</a>)</td></tr>
<tr class="memdesc:ga0236222d42768c2bf00942f328146c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a queue.  <a href="group__queue__apis.html#ga0236222d42768c2bf00942f328146c21">More...</a><br /></td></tr>
<tr class="separator:ga0236222d42768c2bf00942f328146c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c39d86cc6509f59ff9223cac3ea5071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__queue__apis.html#ga7c39d86cc6509f59ff9223cac3ea5071">k_queue_cancel_wait</a> (struct k_queue *<a class="el" href="test__queue__loop_8c.html#a643b6f9660035f1e1098c9484d214bbd">queue</a>)</td></tr>
<tr class="memdesc:ga7c39d86cc6509f59ff9223cac3ea5071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel waiting on a queue.  <a href="group__queue__apis.html#ga7c39d86cc6509f59ff9223cac3ea5071">More...</a><br /></td></tr>
<tr class="separator:ga7c39d86cc6509f59ff9223cac3ea5071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa84522a5ace6e7f8ba61033baca6972f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__queue__apis.html#gaa84522a5ace6e7f8ba61033baca6972f">k_queue_append</a> (struct k_queue *<a class="el" href="test__queue__loop_8c.html#a643b6f9660035f1e1098c9484d214bbd">queue</a>, void *<a class="el" href="test__stack__fail_8c.html#a4bb6fa6c719fd9021449009ab8befc04">data</a>)</td></tr>
<tr class="memdesc:gaa84522a5ace6e7f8ba61033baca6972f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an element to the end of a queue.  <a href="group__queue__apis.html#gaa84522a5ace6e7f8ba61033baca6972f">More...</a><br /></td></tr>
<tr class="separator:gaa84522a5ace6e7f8ba61033baca6972f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga690f3a1450e946d75f31b3e499d1d06a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a0c18914b3041c2f583aba76f418399c2">int32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__queue__apis.html#ga690f3a1450e946d75f31b3e499d1d06a">k_queue_alloc_append</a> (struct k_queue *<a class="el" href="test__queue__loop_8c.html#a643b6f9660035f1e1098c9484d214bbd">queue</a>, void *<a class="el" href="test__stack__fail_8c.html#a4bb6fa6c719fd9021449009ab8befc04">data</a>)</td></tr>
<tr class="memdesc:ga690f3a1450e946d75f31b3e499d1d06a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an element to a queue.  <a href="group__queue__apis.html#ga690f3a1450e946d75f31b3e499d1d06a">More...</a><br /></td></tr>
<tr class="separator:ga690f3a1450e946d75f31b3e499d1d06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ce013d8a037d4be5078797e0050e9c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__queue__apis.html#ga8ce013d8a037d4be5078797e0050e9c6">k_queue_prepend</a> (struct k_queue *<a class="el" href="test__queue__loop_8c.html#a643b6f9660035f1e1098c9484d214bbd">queue</a>, void *<a class="el" href="test__stack__fail_8c.html#a4bb6fa6c719fd9021449009ab8befc04">data</a>)</td></tr>
<tr class="memdesc:ga8ce013d8a037d4be5078797e0050e9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepend an element to a queue.  <a href="group__queue__apis.html#ga8ce013d8a037d4be5078797e0050e9c6">More...</a><br /></td></tr>
<tr class="separator:ga8ce013d8a037d4be5078797e0050e9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf3dba40125073c11075e5a134919f88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a0c18914b3041c2f583aba76f418399c2">int32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__queue__apis.html#gacf3dba40125073c11075e5a134919f88">k_queue_alloc_prepend</a> (struct k_queue *<a class="el" href="test__queue__loop_8c.html#a643b6f9660035f1e1098c9484d214bbd">queue</a>, void *<a class="el" href="test__stack__fail_8c.html#a4bb6fa6c719fd9021449009ab8befc04">data</a>)</td></tr>
<tr class="memdesc:gacf3dba40125073c11075e5a134919f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepend an element to a queue.  <a href="group__queue__apis.html#gacf3dba40125073c11075e5a134919f88">More...</a><br /></td></tr>
<tr class="separator:gacf3dba40125073c11075e5a134919f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad47336f27e433a52600a3b67ab89556a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__queue__apis.html#gad47336f27e433a52600a3b67ab89556a">k_queue_insert</a> (struct k_queue *<a class="el" href="test__queue__loop_8c.html#a643b6f9660035f1e1098c9484d214bbd">queue</a>, void *prev, void *<a class="el" href="test__stack__fail_8c.html#a4bb6fa6c719fd9021449009ab8befc04">data</a>)</td></tr>
<tr class="memdesc:gad47336f27e433a52600a3b67ab89556a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element to a queue.  <a href="group__queue__apis.html#gad47336f27e433a52600a3b67ab89556a">More...</a><br /></td></tr>
<tr class="separator:gad47336f27e433a52600a3b67ab89556a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91d1a144fc2aeb3dd655accc94ca43aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__queue__apis.html#ga91d1a144fc2aeb3dd655accc94ca43aa">k_queue_append_list</a> (struct k_queue *<a class="el" href="test__queue__loop_8c.html#a643b6f9660035f1e1098c9484d214bbd">queue</a>, void *head, void *tail)</td></tr>
<tr class="memdesc:ga91d1a144fc2aeb3dd655accc94ca43aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically append a list of elements to a queue.  <a href="group__queue__apis.html#ga91d1a144fc2aeb3dd655accc94ca43aa">More...</a><br /></td></tr>
<tr class="separator:ga91d1a144fc2aeb3dd655accc94ca43aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4eee0da7442d60572b05d60a9996e69d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__queue__apis.html#ga4eee0da7442d60572b05d60a9996e69d">k_queue_merge_slist</a> (struct k_queue *<a class="el" href="test__queue__loop_8c.html#a643b6f9660035f1e1098c9484d214bbd">queue</a>, <a class="el" href="slist_8h.html#a44658c336b634c03938a251cdc8134f8">sys_slist_t</a> *list)</td></tr>
<tr class="memdesc:ga4eee0da7442d60572b05d60a9996e69d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically add a list of elements to a queue.  <a href="group__queue__apis.html#ga4eee0da7442d60572b05d60a9996e69d">More...</a><br /></td></tr>
<tr class="separator:ga4eee0da7442d60572b05d60a9996e69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a77d8556e7d253319275de034f01619"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__queue__apis.html#ga0a77d8556e7d253319275de034f01619">k_queue_get</a> (struct k_queue *<a class="el" href="test__queue__loop_8c.html#a643b6f9660035f1e1098c9484d214bbd">queue</a>, <a class="el" href="structk__timeout__t.html">k_timeout_t</a> <a class="el" href="timer_2cycle64_2src_2main_8c.html#a8f4b69a82b00d7baf3f1f7d480bb7fa0">timeout</a>)</td></tr>
<tr class="memdesc:ga0a77d8556e7d253319275de034f01619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an element from a queue.  <a href="group__queue__apis.html#ga0a77d8556e7d253319275de034f01619">More...</a><br /></td></tr>
<tr class="separator:ga0a77d8556e7d253319275de034f01619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bff929ed1d366a06e00865a5bbe2544"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__queue__apis.html#ga4bff929ed1d366a06e00865a5bbe2544">k_queue_remove</a> (struct k_queue *<a class="el" href="test__queue__loop_8c.html#a643b6f9660035f1e1098c9484d214bbd">queue</a>, void *<a class="el" href="test__stack__fail_8c.html#a4bb6fa6c719fd9021449009ab8befc04">data</a>)</td></tr>
<tr class="memdesc:ga4bff929ed1d366a06e00865a5bbe2544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an element from a queue.  <a href="group__queue__apis.html#ga4bff929ed1d366a06e00865a5bbe2544">More...</a><br /></td></tr>
<tr class="separator:ga4bff929ed1d366a06e00865a5bbe2544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga287a2d81e2e3041be1cd45164e72f127"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__queue__apis.html#ga287a2d81e2e3041be1cd45164e72f127">k_queue_unique_append</a> (struct k_queue *<a class="el" href="test__queue__loop_8c.html#a643b6f9660035f1e1098c9484d214bbd">queue</a>, void *<a class="el" href="test__stack__fail_8c.html#a4bb6fa6c719fd9021449009ab8befc04">data</a>)</td></tr>
<tr class="memdesc:ga287a2d81e2e3041be1cd45164e72f127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an element to a queue only if it's not present already.  <a href="group__queue__apis.html#ga287a2d81e2e3041be1cd45164e72f127">More...</a><br /></td></tr>
<tr class="separator:ga287a2d81e2e3041be1cd45164e72f127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb2bb8088868b3c5801c72b320389ca9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__queue__apis.html#gadb2bb8088868b3c5801c72b320389ca9">k_queue_is_empty</a> (struct k_queue *<a class="el" href="test__queue__loop_8c.html#a643b6f9660035f1e1098c9484d214bbd">queue</a>)</td></tr>
<tr class="memdesc:gadb2bb8088868b3c5801c72b320389ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query a queue to see if it has data available.  <a href="group__queue__apis.html#gadb2bb8088868b3c5801c72b320389ca9">More...</a><br /></td></tr>
<tr class="separator:gadb2bb8088868b3c5801c72b320389ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ccd5137690c127a0f7d67619b88a52b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__queue__apis.html#ga8ccd5137690c127a0f7d67619b88a52b">k_queue_peek_head</a> (struct k_queue *<a class="el" href="test__queue__loop_8c.html#a643b6f9660035f1e1098c9484d214bbd">queue</a>)</td></tr>
<tr class="memdesc:ga8ccd5137690c127a0f7d67619b88a52b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek element at the head of queue.  <a href="group__queue__apis.html#ga8ccd5137690c127a0f7d67619b88a52b">More...</a><br /></td></tr>
<tr class="separator:ga8ccd5137690c127a0f7d67619b88a52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27a460c42836d8b093ad9274c14bb176"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__queue__apis.html#ga27a460c42836d8b093ad9274c14bb176">k_queue_peek_tail</a> (struct k_queue *<a class="el" href="test__queue__loop_8c.html#a643b6f9660035f1e1098c9484d214bbd">queue</a>)</td></tr>
<tr class="memdesc:ga27a460c42836d8b093ad9274c14bb176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek element at the tail of queue.  <a href="group__queue__apis.html#ga27a460c42836d8b093ad9274c14bb176">More...</a><br /></td></tr>
<tr class="separator:ga27a460c42836d8b093ad9274c14bb176"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gacd0bc309f0147d4669f65fafa87e0e70" name="gacd0bc309f0147d4669f65fafa87e0e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd0bc309f0147d4669f65fafa87e0e70">&#9670;&nbsp;</a></span>K_QUEUE_DEFINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define K_QUEUE_DEFINE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">        <a class="code hl_define" href="group__iterable__section__apis.html#gabed6642b8cc06863ce97dd536698004d">STRUCT_SECTION_ITERABLE</a>(k_queue, name) = \</div>
<div class="line">                Z_QUEUE_INITIALIZER(name)</div>
<div class="ttc" id="agroup__iterable__section__apis_html_gabed6642b8cc06863ce97dd536698004d"><div class="ttname"><a href="group__iterable__section__apis.html#gabed6642b8cc06863ce97dd536698004d">STRUCT_SECTION_ITERABLE</a></div><div class="ttdeci">#define STRUCT_SECTION_ITERABLE(struct_type, name)</div><div class="ttdoc">Defines a new iterable section.</div><div class="ttdef"><b>Definition:</b> common.h:210</div></div>
</div><!-- fragment -->
<p>Statically define and initialize a queue. </p>
<p >The queue can be accessed outside the module where it is defined using:</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="keyword">struct </span>k_queue &lt;name&gt;; </div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga690f3a1450e946d75f31b3e499d1d06a" name="ga690f3a1450e946d75f31b3e499d1d06a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga690f3a1450e946d75f31b3e499d1d06a">&#9670;&nbsp;</a></span>k_queue_alloc_append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a0c18914b3041c2f583aba76f418399c2">int32_t</a> k_queue_alloc_append </td>
          <td>(</td>
          <td class="paramtype">struct k_queue *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Append an element to a queue. </p>
<p >This routine appends a data item to <em>queue</em>. There is an implicit memory allocation to create an additional temporary bookkeeping data structure from the calling thread's resource pool, which is automatically freed when the item is removed. The data itself is not copied.</p>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Address of the queue. </td></tr>
    <tr><td class="paramname">data</td><td>Address of the data item.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">-ENOMEM</td><td>if there isn't sufficient RAM in the caller's resource pool </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacf3dba40125073c11075e5a134919f88" name="gacf3dba40125073c11075e5a134919f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf3dba40125073c11075e5a134919f88">&#9670;&nbsp;</a></span>k_queue_alloc_prepend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a0c18914b3041c2f583aba76f418399c2">int32_t</a> k_queue_alloc_prepend </td>
          <td>(</td>
          <td class="paramtype">struct k_queue *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Prepend an element to a queue. </p>
<p >This routine prepends a data item to <em>queue</em>. There is an implicit memory allocation to create an additional temporary bookkeeping data structure from the calling thread's resource pool, which is automatically freed when the item is removed. The data itself is not copied.</p>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Address of the queue. </td></tr>
    <tr><td class="paramname">data</td><td>Address of the data item.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">-ENOMEM</td><td>if there isn't sufficient RAM in the caller's resource pool </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa84522a5ace6e7f8ba61033baca6972f" name="gaa84522a5ace6e7f8ba61033baca6972f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa84522a5ace6e7f8ba61033baca6972f">&#9670;&nbsp;</a></span>k_queue_append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void k_queue_append </td>
          <td>(</td>
          <td class="paramtype">struct k_queue *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Append an element to the end of a queue. </p>
<p >This routine appends a data item to <em>queue</em>. A queue data item must be aligned on a word boundary, and the first word of the item is reserved for the kernel's use.</p>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Address of the queue. </td></tr>
    <tr><td class="paramname">data</td><td>Address of the data item. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga91d1a144fc2aeb3dd655accc94ca43aa" name="ga91d1a144fc2aeb3dd655accc94ca43aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91d1a144fc2aeb3dd655accc94ca43aa">&#9670;&nbsp;</a></span>k_queue_append_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_queue_append_list </td>
          <td>(</td>
          <td class="paramtype">struct k_queue *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Atomically append a list of elements to a queue. </p>
<p >This routine adds a list of data items to <em>queue</em> in one operation. The data items must be in a singly-linked list, with the first word in each data item pointing to the next data item; the list must be NULL-terminated.</p>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Address of the queue. </td></tr>
    <tr><td class="paramname">head</td><td>Pointer to first node in singly-linked list. </td></tr>
    <tr><td class="paramname">tail</td><td>Pointer to last node in singly-linked list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>on invalid supplied data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7c39d86cc6509f59ff9223cac3ea5071" name="ga7c39d86cc6509f59ff9223cac3ea5071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c39d86cc6509f59ff9223cac3ea5071">&#9670;&nbsp;</a></span>k_queue_cancel_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void k_queue_cancel_wait </td>
          <td>(</td>
          <td class="paramtype">struct k_queue *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Cancel waiting on a queue. </p>
<p >This routine causes first thread pending on <em>queue</em>, if any, to return from <a class="el" href="group__queue__apis.html#ga0a77d8556e7d253319275de034f01619" title="Get an element from a queue.">k_queue_get()</a> call with NULL value (as if timeout expired). If the queue is being waited on by <a class="el" href="group__poll__apis.html#gac550dc93662ce164fb22a5a91d6830db" title="Wait for one or many of multiple poll events to occur.">k_poll()</a>, it will return with -EINTR and K_POLL_STATE_CANCELLED state (and per above, subsequent <a class="el" href="group__queue__apis.html#ga0a77d8556e7d253319275de034f01619" title="Get an element from a queue.">k_queue_get()</a> will return NULL).</p>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Address of the queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0a77d8556e7d253319275de034f01619" name="ga0a77d8556e7d253319275de034f01619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a77d8556e7d253319275de034f01619">&#9670;&nbsp;</a></span>k_queue_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * k_queue_get </td>
          <td>(</td>
          <td class="paramtype">struct k_queue *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structk__timeout__t.html">k_timeout_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Get an element from a queue. </p>
<p >This routine removes first data item from <em>queue</em>. The first word of the data item is reserved for the kernel's use.</p>
<dl class="section note"><dt>Note</dt><dd><em>timeout</em> must be set to K_NO_WAIT if called from ISR.</dd></dl>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Address of the queue. </td></tr>
    <tr><td class="paramname">timeout</td><td>Non-negative waiting period to obtain a data item or one of the special values K_NO_WAIT and K_FOREVER.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address of the data item if successful; NULL if returned without waiting, or waiting period timed out. </dd></dl>

</div>
</div>
<a id="ga0236222d42768c2bf00942f328146c21" name="ga0236222d42768c2bf00942f328146c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0236222d42768c2bf00942f328146c21">&#9670;&nbsp;</a></span>k_queue_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void k_queue_init </td>
          <td>(</td>
          <td class="paramtype">struct k_queue *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Initialize a queue. </p>
<p >This routine initializes a queue object, prior to its first use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Address of the queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad47336f27e433a52600a3b67ab89556a" name="gad47336f27e433a52600a3b67ab89556a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad47336f27e433a52600a3b67ab89556a">&#9670;&nbsp;</a></span>k_queue_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void k_queue_insert </td>
          <td>(</td>
          <td class="paramtype">struct k_queue *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>prev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Inserts an element to a queue. </p>
<p >This routine inserts a data item to <em>queue</em> after previous item. A queue data item must be aligned on a word boundary, and the first word of the item is reserved for the kernel's use.</p>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Address of the queue. </td></tr>
    <tr><td class="paramname">prev</td><td>Address of the previous data item. </td></tr>
    <tr><td class="paramname">data</td><td>Address of the data item. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadb2bb8088868b3c5801c72b320389ca9" name="gadb2bb8088868b3c5801c72b320389ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb2bb8088868b3c5801c72b320389ca9">&#9670;&nbsp;</a></span>k_queue_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_queue_is_empty </td>
          <td>(</td>
          <td class="paramtype">struct k_queue *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Query a queue to see if it has data available. </p>
<p >Note that the data might be already gone by the time this function returns if other threads are also trying to read from the queue.</p>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Address of the queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the queue is empty. </dd>
<dd>
0 if data is available. </dd></dl>

</div>
</div>
<a id="ga4eee0da7442d60572b05d60a9996e69d" name="ga4eee0da7442d60572b05d60a9996e69d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4eee0da7442d60572b05d60a9996e69d">&#9670;&nbsp;</a></span>k_queue_merge_slist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_queue_merge_slist </td>
          <td>(</td>
          <td class="paramtype">struct k_queue *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="slist_8h.html#a44658c336b634c03938a251cdc8134f8">sys_slist_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Atomically add a list of elements to a queue. </p>
<p >This routine adds a list of data items to <em>queue</em> in one operation. The data items must be in a singly-linked list implemented using a sys_slist_t object. Upon completion, the original list is empty.</p>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Address of the queue. </td></tr>
    <tr><td class="paramname">list</td><td>Pointer to sys_slist_t object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>on invalid data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8ccd5137690c127a0f7d67619b88a52b" name="ga8ccd5137690c127a0f7d67619b88a52b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ccd5137690c127a0f7d67619b88a52b">&#9670;&nbsp;</a></span>k_queue_peek_head()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * k_queue_peek_head </td>
          <td>(</td>
          <td class="paramtype">struct k_queue *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Peek element at the head of queue. </p>
<p >Return element from the head of queue without removing it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Address of the queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Head element, or NULL if queue is empty. </dd></dl>

</div>
</div>
<a id="ga27a460c42836d8b093ad9274c14bb176" name="ga27a460c42836d8b093ad9274c14bb176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27a460c42836d8b093ad9274c14bb176">&#9670;&nbsp;</a></span>k_queue_peek_tail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * k_queue_peek_tail </td>
          <td>(</td>
          <td class="paramtype">struct k_queue *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Peek element at the tail of queue. </p>
<p >Return element from the tail of queue without removing it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Address of the queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tail element, or NULL if queue is empty. </dd></dl>

</div>
</div>
<a id="ga8ce013d8a037d4be5078797e0050e9c6" name="ga8ce013d8a037d4be5078797e0050e9c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ce013d8a037d4be5078797e0050e9c6">&#9670;&nbsp;</a></span>k_queue_prepend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void k_queue_prepend </td>
          <td>(</td>
          <td class="paramtype">struct k_queue *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Prepend an element to a queue. </p>
<p >This routine prepends a data item to <em>queue</em>. A queue data item must be aligned on a word boundary, and the first word of the item is reserved for the kernel's use.</p>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Address of the queue. </td></tr>
    <tr><td class="paramname">data</td><td>Address of the data item. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4bff929ed1d366a06e00865a5bbe2544" name="ga4bff929ed1d366a06e00865a5bbe2544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bff929ed1d366a06e00865a5bbe2544">&#9670;&nbsp;</a></span>k_queue_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> k_queue_remove </td>
          <td>(</td>
          <td class="paramtype">struct k_queue *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Remove an element from a queue. </p>
<p >This routine removes data item from <em>queue</em>. The first word of the data item is reserved for the kernel's use. Removing elements from k_queue rely on sys_slist_find_and_remove which is not a constant time operation.</p>
<dl class="section note"><dt>Note</dt><dd><em>timeout</em> must be set to K_NO_WAIT if called from ISR.</dd></dl>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Address of the queue. </td></tr>
    <tr><td class="paramname">data</td><td>Address of the data item.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if data item was removed </dd></dl>

</div>
</div>
<a id="ga287a2d81e2e3041be1cd45164e72f127" name="ga287a2d81e2e3041be1cd45164e72f127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga287a2d81e2e3041be1cd45164e72f127">&#9670;&nbsp;</a></span>k_queue_unique_append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> k_queue_unique_append </td>
          <td>(</td>
          <td class="paramtype">struct k_queue *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Append an element to a queue only if it's not present already. </p>
<p >This routine appends data item to <em>queue</em>. The first word of the data item is reserved for the kernel's use. Appending elements to k_queue relies on sys_slist_is_node_in_list which is not a constant time operation.</p>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Address of the queue. </td></tr>
    <tr><td class="paramname">data</td><td>Address of the data item.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if data item was added, false if not </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Mar 5 2022 05:00:47 for Zephyr API Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
<script type="text/javascript">
  $(function() {
    toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
    toggleButton.title = "Toggle Light/Dark Mode"
    $(document).ready(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
    // every resize will remove the button, which is why it has to be added again:
    $(window).resize(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
  })
</script>
</body>
</html>
