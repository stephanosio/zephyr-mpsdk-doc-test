<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zephyr API Documentation: Architecture-specific memory-mapping APIs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-zephyr.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-zephyr.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Zephyr API Documentation
   &#160;<span id="projectnumber">3.0.99</span>
   </div>
   <div id="projectbrief">A Scalable Open Source RTOS</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__arch-mmu.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Architecture-specific memory-mapping APIs<div class="ingroups"><a class="el" href="group__arch-interface.html">Architecture Interface</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga38cfc7602d259972cdd0b557ab26c2b4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch-mmu.html#ga38cfc7602d259972cdd0b557ab26c2b4">ARCH_DATA_PAGE_ACCESSED</a>&#160;&#160;&#160;((<a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a>)<a class="el" href="group__sys-util.html#ga3a8ea58898cb58fc96013383d39f482c">BIT</a>(5))</td></tr>
<tr class="separator:ga38cfc7602d259972cdd0b557ab26c2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a60b63f47f88db455d67c33ef7bb85d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch-mmu.html#ga4a60b63f47f88db455d67c33ef7bb85d">ARCH_DATA_PAGE_DIRTY</a>&#160;&#160;&#160;((<a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a>)<a class="el" href="group__sys-util.html#ga3a8ea58898cb58fc96013383d39f482c">BIT</a>(6))</td></tr>
<tr class="separator:ga4a60b63f47f88db455d67c33ef7bb85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae76ce742aca8b4ac12907a2bfce98b0e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch-mmu.html#gae76ce742aca8b4ac12907a2bfce98b0e">ARCH_DATA_PAGE_LOADED</a>&#160;&#160;&#160;((<a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a>)<a class="el" href="group__sys-util.html#ga3a8ea58898cb58fc96013383d39f482c">BIT</a>(0))</td></tr>
<tr class="separator:gae76ce742aca8b4ac12907a2bfce98b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga843c53394b00d80b1649a6224557a56a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch-mmu.html#ga843c53394b00d80b1649a6224557a56a">ARCH_DATA_PAGE_NOT_MAPPED</a>&#160;&#160;&#160;((<a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a>)<a class="el" href="group__sys-util.html#ga3a8ea58898cb58fc96013383d39f482c">BIT</a>(7))</td></tr>
<tr class="separator:ga843c53394b00d80b1649a6224557a56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga65e10c80055d7e695add000f2ccfbb0b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch-mmu.html#ga65e10c80055d7e695add000f2ccfbb0b">arch_page_location</a> { <a class="el" href="group__arch-mmu.html#gga65e10c80055d7e695add000f2ccfbb0bacf9e624eac380ea2bfa37632c4d17a3a">ARCH_PAGE_LOCATION_PAGED_OUT</a>
, <a class="el" href="group__arch-mmu.html#gga65e10c80055d7e695add000f2ccfbb0bae378a008f497ae10ab50cab06f8c36db">ARCH_PAGE_LOCATION_PAGED_IN</a>
, <a class="el" href="group__arch-mmu.html#gga65e10c80055d7e695add000f2ccfbb0ba7ff70acdf02345b5fa4c42ed2b2adde9">ARCH_PAGE_LOCATION_BAD</a>
 }</td></tr>
<tr class="separator:ga65e10c80055d7e695add000f2ccfbb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga627bee468e54bb2d5ebe6ac53bb7fc94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch-mmu.html#ga627bee468e54bb2d5ebe6ac53bb7fc94">arch_mem_map</a> (void *virt, <a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a> phys, size_t size, <a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> <a class="el" href="http__parser_8h.html#ab6b306ef981f5e21bb41ea2c2dbe8cd9">flags</a>)</td></tr>
<tr class="separator:ga627bee468e54bb2d5ebe6ac53bb7fc94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8783e1d292510477b3816b6686d7d8cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch-mmu.html#ga8783e1d292510477b3816b6686d7d8cd">arch_mem_unmap</a> (void *addr, size_t size)</td></tr>
<tr class="separator:ga8783e1d292510477b3816b6686d7d8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa31a233dab4ad575a9a969de10965200"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch-mmu.html#gaa31a233dab4ad575a9a969de10965200">arch_page_phys_get</a> (void *virt, <a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a> *phys)</td></tr>
<tr class="separator:gaa31a233dab4ad575a9a969de10965200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga229fa5699ad47951235af494f3d2a06a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch-mmu.html#ga229fa5699ad47951235af494f3d2a06a">arch_reserved_pages_update</a> (void)</td></tr>
<tr class="separator:ga229fa5699ad47951235af494f3d2a06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c13ffab5b5a5f8c93971c4d3b51bd8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch-mmu.html#ga4c13ffab5b5a5f8c93971c4d3b51bd8f">arch_mem_page_out</a> (void *addr, <a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a> location)</td></tr>
<tr class="separator:ga4c13ffab5b5a5f8c93971c4d3b51bd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c446aea862e37d479a809582322b3ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch-mmu.html#ga3c446aea862e37d479a809582322b3ae">arch_mem_page_in</a> (void *addr, <a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a> phys)</td></tr>
<tr class="separator:ga3c446aea862e37d479a809582322b3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4e82c3100b08bdfdcd9361d316735a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch-mmu.html#gae4e82c3100b08bdfdcd9361d316735a1">arch_mem_scratch</a> (<a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a> phys)</td></tr>
<tr class="separator:gae4e82c3100b08bdfdcd9361d316735a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74b3ce1173b91a8f82c25ef89f9fbbc0"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__arch-mmu.html#ga65e10c80055d7e695add000f2ccfbb0b">arch_page_location</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch-mmu.html#ga74b3ce1173b91a8f82c25ef89f9fbbc0">arch_page_location_get</a> (void *addr, <a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a> *location)</td></tr>
<tr class="separator:ga74b3ce1173b91a8f82c25ef89f9fbbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab32a4bb6b3d44c126d63a473caf28b70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch-mmu.html#gab32a4bb6b3d44c126d63a473caf28b70">arch_page_info_get</a> (void *addr, <a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a> *location, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clear_accessed)</td></tr>
<tr class="separator:gab32a4bb6b3d44c126d63a473caf28b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga38cfc7602d259972cdd0b557ab26c2b4" name="ga38cfc7602d259972cdd0b557ab26c2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38cfc7602d259972cdd0b557ab26c2b4">&#9670;&nbsp;</a></span>ARCH_DATA_PAGE_ACCESSED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ARCH_DATA_PAGE_ACCESSED&#160;&#160;&#160;((<a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a>)<a class="el" href="group__sys-util.html#ga3a8ea58898cb58fc96013383d39f482c">BIT</a>(5))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="mmustructs_8h.html">include/arch/x86/mmustructs.h</a>&gt;</code></p>
<p >Bit indicating the data page was accessed since the value was last cleared.</p>
<p >Used by marking eviction algorithms. Safe to set this if uncertain.</p>
<p >This bit is undefined if ARCH_DATA_PAGE_LOADED is not set. </p>

</div>
</div>
<a id="ga4a60b63f47f88db455d67c33ef7bb85d" name="ga4a60b63f47f88db455d67c33ef7bb85d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a60b63f47f88db455d67c33ef7bb85d">&#9670;&nbsp;</a></span>ARCH_DATA_PAGE_DIRTY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ARCH_DATA_PAGE_DIRTY&#160;&#160;&#160;((<a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a>)<a class="el" href="group__sys-util.html#ga3a8ea58898cb58fc96013383d39f482c">BIT</a>(6))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="mmustructs_8h.html">include/arch/x86/mmustructs.h</a>&gt;</code></p>
<p >Bit indicating the data page, if evicted, will need to be paged out.</p>
<p >Set if the data page was modified since it was last paged out, or if it has never been paged out before. Safe to set this if uncertain.</p>
<p >This bit is undefined if ARCH_DATA_PAGE_LOADED is not set. </p>

</div>
</div>
<a id="gae76ce742aca8b4ac12907a2bfce98b0e" name="gae76ce742aca8b4ac12907a2bfce98b0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae76ce742aca8b4ac12907a2bfce98b0e">&#9670;&nbsp;</a></span>ARCH_DATA_PAGE_LOADED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ARCH_DATA_PAGE_LOADED&#160;&#160;&#160;((<a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a>)<a class="el" href="group__sys-util.html#ga3a8ea58898cb58fc96013383d39f482c">BIT</a>(0))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="mmustructs_8h.html">include/arch/x86/mmustructs.h</a>&gt;</code></p>
<p >Bit indicating that the data page is loaded into a physical page frame.</p>
<p >If un-set, the data page is paged out or not mapped. </p>

</div>
</div>
<a id="ga843c53394b00d80b1649a6224557a56a" name="ga843c53394b00d80b1649a6224557a56a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga843c53394b00d80b1649a6224557a56a">&#9670;&nbsp;</a></span>ARCH_DATA_PAGE_NOT_MAPPED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ARCH_DATA_PAGE_NOT_MAPPED&#160;&#160;&#160;((<a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a>)<a class="el" href="group__sys-util.html#ga3a8ea58898cb58fc96013383d39f482c">BIT</a>(7))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="mmustructs_8h.html">include/arch/x86/mmustructs.h</a>&gt;</code></p>
<p >If ARCH_DATA_PAGE_LOADED is un-set, this will indicate that the page is not mapped at all. This bit is undefined if ARCH_DATA_PAGE_LOADED is set. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga65e10c80055d7e695add000f2ccfbb0b" name="ga65e10c80055d7e695add000f2ccfbb0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65e10c80055d7e695add000f2ccfbb0b">&#9670;&nbsp;</a></span>arch_page_location</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__arch-mmu.html#ga65e10c80055d7e695add000f2ccfbb0b">arch_page_location</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="kernel__arch__interface_8h.html">kernel/include/kernel_arch_interface.h</a>&gt;</code></p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga65e10c80055d7e695add000f2ccfbb0bacf9e624eac380ea2bfa37632c4d17a3a" name="gga65e10c80055d7e695add000f2ccfbb0bacf9e624eac380ea2bfa37632c4d17a3a"></a>ARCH_PAGE_LOCATION_PAGED_OUT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga65e10c80055d7e695add000f2ccfbb0bae378a008f497ae10ab50cab06f8c36db" name="gga65e10c80055d7e695add000f2ccfbb0bae378a008f497ae10ab50cab06f8c36db"></a>ARCH_PAGE_LOCATION_PAGED_IN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga65e10c80055d7e695add000f2ccfbb0ba7ff70acdf02345b5fa4c42ed2b2adde9" name="gga65e10c80055d7e695add000f2ccfbb0ba7ff70acdf02345b5fa4c42ed2b2adde9"></a>ARCH_PAGE_LOCATION_BAD&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga627bee468e54bb2d5ebe6ac53bb7fc94" name="ga627bee468e54bb2d5ebe6ac53bb7fc94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga627bee468e54bb2d5ebe6ac53bb7fc94">&#9670;&nbsp;</a></span>arch_mem_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arch_mem_map </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>virt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a>&#160;</td>
          <td class="paramname"><em>phys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="kernel__arch__interface_8h.html">kernel/include/kernel_arch_interface.h</a>&gt;</code></p>
<p >Map physical memory into the virtual address space</p>
<p >This is a low-level interface to mapping pages into the address space. Behavior when providing unaligned addresses/sizes is undefined, these are assumed to be aligned to CONFIG_MMU_PAGE_SIZE.</p>
<p >The core kernel handles all management of the virtual address space; by the time we invoke this function, we know exactly where this mapping will be established. If the page tables already had mappings installed for the virtual memory region, these will be overwritten.</p>
<p >If the target architecture supports multiple page sizes, currently only the smallest page size will be used.</p>
<p >The memory range itself is never accessed by this operation.</p>
<p >This API must be safe to call in ISRs or exception handlers. Calls to this API are assumed to be serialized, and indeed all usage will originate from kernel/mm.c which handles virtual memory management.</p>
<p >Architectures are expected to pre-allocate page tables for the entire address space, as defined by CONFIG_KERNEL_VM_BASE and CONFIG_KERNEL_VM_SIZE. This operation should never require any kind of allocation for paging structures.</p>
<p >Validation of arguments should be done via assertions.</p>
<p >This API is part of infrastructure still under development and may change.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">virt</td><td>Page-aligned Destination virtual address to map </td></tr>
    <tr><td class="paramname">phys</td><td>Page-aligned Source physical address to map </td></tr>
    <tr><td class="paramname">size</td><td>Page-aligned size of the mapped memory region in bytes </td></tr>
    <tr><td class="paramname">flags</td><td>Caching, access and control flags, see K_MAP_* macros </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3c446aea862e37d479a809582322b3ae" name="ga3c446aea862e37d479a809582322b3ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c446aea862e37d479a809582322b3ae">&#9670;&nbsp;</a></span>arch_mem_page_in()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arch_mem_page_in </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a>&#160;</td>
          <td class="paramname"><em>phys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="kernel__arch__interface_8h.html">kernel/include/kernel_arch_interface.h</a>&gt;</code></p>
<p >Update all page tables for a paged-in data page</p>
<p >This function:</p><ul>
<li>Maps the specified virtual data page address to the provided physical page frame address, such that future memory accesses will function as expected. Access and caching attributes are undisturbed.</li>
<li>Clears any accounting for "accessed" and "dirty" states.</li>
</ul>
<p >If multiple page tables are in use, this must update all page tables. This function is called with interrupts locked.</p>
<p >Calling this function on data pages which are already paged in is undefined behavior.</p>
<p >This API is part of infrastructure still under development and may change. </p>

</div>
</div>
<a id="ga4c13ffab5b5a5f8c93971c4d3b51bd8f" name="ga4c13ffab5b5a5f8c93971c4d3b51bd8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c13ffab5b5a5f8c93971c4d3b51bd8f">&#9670;&nbsp;</a></span>arch_mem_page_out()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arch_mem_page_out </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a>&#160;</td>
          <td class="paramname"><em>location</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="kernel__arch__interface_8h.html">kernel/include/kernel_arch_interface.h</a>&gt;</code></p>
<p >Update all page tables for a paged-out data page</p>
<p >This function:</p><ul>
<li>Sets the data page virtual address to trigger a fault if accessed that can be distinguished from access violations or un-mapped pages.</li>
<li>Saves the provided location value so that it can retrieved for that data page in the page fault handler.</li>
<li>The location value semantics are undefined here but the value will be always be page-aligned. It could be 0.</li>
</ul>
<p >If multiple page tables are in use, this must update all page tables. This function is called with interrupts locked.</p>
<p >Calling this function on data pages which are already paged out is undefined behavior.</p>
<p >This API is part of infrastructure still under development and may change. </p>

</div>
</div>
<a id="gae4e82c3100b08bdfdcd9361d316735a1" name="gae4e82c3100b08bdfdcd9361d316735a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4e82c3100b08bdfdcd9361d316735a1">&#9670;&nbsp;</a></span>arch_mem_scratch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arch_mem_scratch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a>&#160;</td>
          <td class="paramname"><em>phys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="kernel__arch__interface_8h.html">kernel/include/kernel_arch_interface.h</a>&gt;</code></p>
<p >Update current page tables for a temporary mapping</p>
<p >Map a physical page frame address to a special virtual address Z_SCRATCH_PAGE, with read/write access to supervisor mode, such that when this function returns, the calling context can read/write the page frame's contents from the Z_SCRATCH_PAGE address.</p>
<p >This mapping only needs to be done on the current set of page tables, as it is only used for a short period of time exclusively by the caller. This function is called with interrupts locked.</p>
<p >This API is part of infrastructure still under development and may change. </p>

</div>
</div>
<a id="ga8783e1d292510477b3816b6686d7d8cd" name="ga8783e1d292510477b3816b6686d7d8cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8783e1d292510477b3816b6686d7d8cd">&#9670;&nbsp;</a></span>arch_mem_unmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arch_mem_unmap </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="kernel__arch__interface_8h.html">kernel/include/kernel_arch_interface.h</a>&gt;</code></p>
<p >Remove mappings for a provided virtual address range</p>
<p >This is a low-level interface for un-mapping pages from the address space. When this completes, the relevant page table entries will be updated as if no mapping was ever made for that memory range. No previous context needs to be preserved. This function must update mappings in all active page tables.</p>
<p >Behavior when providing unaligned addresses/sizes is undefined, these are assumed to be aligned to CONFIG_MMU_PAGE_SIZE.</p>
<p >Behavior when providing an address range that is not already mapped is undefined.</p>
<p >This function should never require memory allocations for paging structures, and it is not necessary to free any paging structures. Empty page tables due to all contained entries being un-mapped may remain in place.</p>
<p >Implementations must invalidate TLBs as necessary.</p>
<p >This API is part of infrastructure still under development and may change.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Page-aligned base virtual address to un-map </td></tr>
    <tr><td class="paramname">size</td><td>Page-aligned region size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab32a4bb6b3d44c126d63a473caf28b70" name="gab32a4bb6b3d44c126d63a473caf28b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab32a4bb6b3d44c126d63a473caf28b70">&#9670;&nbsp;</a></span>arch_page_info_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a> arch_page_info_get </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a> *&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>clear_accessed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="kernel__arch__interface_8h.html">kernel/include/kernel_arch_interface.h</a>&gt;</code></p>
<p >Retrieve page characteristics from the page table(s)</p>
<p >The architecture is responsible for maintaining "accessed" and "dirty" states of data pages to support marking eviction algorithms. This can either be directly supported by hardware or emulated by modifying protection policy to generate faults on reads or writes. In all cases the architecture must maintain this information in some way.</p>
<p >For the provided virtual address, report the logical OR of the accessed and dirty states for the relevant entries in all active page tables in the system if the page is mapped and not paged out.</p>
<p >If clear_accessed is true, the ARCH_DATA_PAGE_ACCESSED flag will be reset. This function will report its prior state. If multiple page tables are in use, this function clears accessed state in all of them.</p>
<p >This function is called with interrupts locked, so that the reported information can't become stale while decisions are being made based on it.</p>
<p >The return value may have other bits set which the caller must ignore.</p>
<p >Clearing accessed state for data pages that are not ARCH_DATA_PAGE_LOADED is undefined behavior.</p>
<p >ARCH_DATA_PAGE_DIRTY and ARCH_DATA_PAGE_ACCESSED bits in the return value are only significant if ARCH_DATA_PAGE_LOADED is set, otherwise ignore them.</p>
<p >ARCH_DATA_PAGE_NOT_MAPPED bit in the return value is only significant if ARCH_DATA_PAGE_LOADED is un-set, otherwise ignore it.</p>
<p >Unless otherwise specified, virtual data pages have the same mappings across all page tables. Calling this function on data pages that are exceptions to this rule (such as the scratch page) is undefined behavior.</p>
<p >This API is part of infrastructure still under development and may change.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">addr</td><td>Virtual address to look up in page tables </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">location</td><td>If non-NULL, updated with either physical page frame address or backing store location depending on ARCH_DATA_PAGE_LOADED state. This is not touched if ARCH_DATA_PAGE_NOT_MAPPED. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">clear_accessed</td><td>Whether to clear ARCH_DATA_PAGE_ACCESSED state </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>with ARCH_DATA_PAGE_* bits set reflecting the data page configuration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga74b3ce1173b91a8f82c25ef89f9fbbc0" name="ga74b3ce1173b91a8f82c25ef89f9fbbc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74b3ce1173b91a8f82c25ef89f9fbbc0">&#9670;&nbsp;</a></span>arch_page_location_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__arch-mmu.html#ga65e10c80055d7e695add000f2ccfbb0b">arch_page_location</a> arch_page_location_get </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a> *&#160;</td>
          <td class="paramname"><em>location</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="kernel__arch__interface_8h.html">kernel/include/kernel_arch_interface.h</a>&gt;</code></p>
<p >Fetch location information about a page at a particular address</p>
<p >The function only needs to query the current set of page tables as the information it reports must be common to all of them if multiple page tables are in use. If multiple page tables are active it is unnecessary to iterate over all of them. This may allow certain types of optimizations (such as reverse page table mapping on x86).</p>
<p >This function is called with interrupts locked, so that the reported information can't become stale while decisions are being made based on it.</p>
<p >Unless otherwise specified, virtual data pages have the same mappings across all page tables. Calling this function on data pages that are exceptions to this rule (such as the scratch page) is undefined behavior. Just check the currently installed page tables and return the information in that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">addr</td><td>Virtual data page address that took the page fault </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">location</td><td>In the case of ARCH_PAGE_FAULT_PAGED_OUT, the backing store location value used to retrieve the data page. In the case of ARCH_PAGE_FAULT_PAGED_IN, the physical address the page is mapped to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ARCH_PAGE_FAULT_PAGED_OUT</td><td>The page was evicted to the backing store. </td></tr>
    <tr><td class="paramname">ARCH_PAGE_FAULT_PAGED_IN</td><td>The data page is resident in memory. </td></tr>
    <tr><td class="paramname">ARCH_PAGE_FAULT_BAD</td><td>The page is un-mapped or otherwise has had invalid access </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa31a233dab4ad575a9a969de10965200" name="gaa31a233dab4ad575a9a969de10965200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa31a233dab4ad575a9a969de10965200">&#9670;&nbsp;</a></span>arch_page_phys_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int arch_page_phys_get </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>virt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a4788399d1d0b37ccf098a7da82254808">uintptr_t</a> *&#160;</td>
          <td class="paramname"><em>phys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="kernel__arch__interface_8h.html">kernel/include/kernel_arch_interface.h</a>&gt;</code></p>
<p >Get the mapped physical memory address from virtual address.</p>
<p >The function only needs to query the current set of page tables as the information it reports must be common to all of them if multiple page tables are in use. If multiple page tables are active it is unnecessary to iterate over all of them.</p>
<p >Unless otherwise specified, virtual pages have the same mappings across all page tables. Calling this function on data pages that are exceptions to this rule (such as the scratch page) is undefined behavior. Just check the currently installed page tables and return the information in that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">virt</td><td>Page-aligned virtual address </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">phys</td><td>Mapped physical address (can be NULL if only checking if virtual address is mapped)</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if mapping is found and valid </td></tr>
    <tr><td class="paramname">-EFAULT</td><td>if virtual address is not mapped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga229fa5699ad47951235af494f3d2a06a" name="ga229fa5699ad47951235af494f3d2a06a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga229fa5699ad47951235af494f3d2a06a">&#9670;&nbsp;</a></span>arch_reserved_pages_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arch_reserved_pages_update </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="kernel__arch__interface_8h.html">kernel/include/kernel_arch_interface.h</a>&gt;</code></p>
<p >Update page frame database with reserved pages</p>
<p >Some page frames within system RAM may not be available for use. A good example of this is reserved regions in the first megabyte on PC-like systems.</p>
<p >Implementations of this function should mark all relavent entries in z_page_frames with K_PAGE_FRAME_RESERVED. This function is called at early system initialization with mm_lock held. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Mar 5 2022 05:00:46 for Zephyr API Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
<script type="text/javascript">
  $(function() {
    toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
    toggleButton.title = "Toggle Light/Dark Mode"
    $(document).ready(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
    // every resize will remove the button, which is why it has to be added again:
    $(window).resize(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
  })
</script>
</body>
</html>
