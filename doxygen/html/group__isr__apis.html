<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zephyr API Documentation: Interrupt Service Routine APIs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-zephyr.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-zephyr.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Zephyr API Documentation
   &#160;<span id="projectnumber">3.0.99</span>
   </div>
   <div id="projectbrief">A Scalable Open Source RTOS</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__isr__apis.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Interrupt Service Routine APIs<div class="ingroups"><a class="el" href="group__kernel__apis.html">Kernel APIs</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga131739d1faf501a15590053817aba984"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__isr__apis.html#ga131739d1faf501a15590053817aba984">IRQ_CONNECT</a>(irq_p,  priority_p,  isr_p,  isr_param_p,  flags_p)&#160;&#160;&#160;	<a class="el" href="xtensa_2arch_8h.html#accdf8a59e00ac1c1fcedc18b78be4b8a">ARCH_IRQ_CONNECT</a>(irq_p, priority_p, isr_p, isr_param_p, flags_p)</td></tr>
<tr class="memdesc:ga131739d1faf501a15590053817aba984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an interrupt handler.  <a href="group__isr__apis.html#ga131739d1faf501a15590053817aba984">More...</a><br /></td></tr>
<tr class="separator:ga131739d1faf501a15590053817aba984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6c8746ac28da6ce02b24714f4144ff3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__isr__apis.html#gac6c8746ac28da6ce02b24714f4144ff3">IRQ_DIRECT_CONNECT</a>(irq_p,  priority_p,  isr_p,  flags_p)&#160;&#160;&#160;	<a class="el" href="x86_2ia32_2arch_8h.html#a875f2b1ca924721fe3854796bd96c2db">ARCH_IRQ_DIRECT_CONNECT</a>(irq_p, priority_p, isr_p, flags_p)</td></tr>
<tr class="memdesc:gac6c8746ac28da6ce02b24714f4144ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a 'direct' interrupt handler.  <a href="group__isr__apis.html#gac6c8746ac28da6ce02b24714f4144ff3">More...</a><br /></td></tr>
<tr class="separator:gac6c8746ac28da6ce02b24714f4144ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ab99dbeb50b228001e1fca808cbaeea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__isr__apis.html#ga1ab99dbeb50b228001e1fca808cbaeea">ISR_DIRECT_HEADER</a>()&#160;&#160;&#160;<a class="el" href="x86_2ia32_2arch_8h.html#a6c6d57983c066fe8ab21a78f86f7adb3">ARCH_ISR_DIRECT_HEADER</a>()</td></tr>
<tr class="memdesc:ga1ab99dbeb50b228001e1fca808cbaeea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common tasks before executing the body of an ISR.  <a href="group__isr__apis.html#ga1ab99dbeb50b228001e1fca808cbaeea">More...</a><br /></td></tr>
<tr class="separator:ga1ab99dbeb50b228001e1fca808cbaeea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31581157c9dbacf935f0e6a8dd456335"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__isr__apis.html#ga31581157c9dbacf935f0e6a8dd456335">ISR_DIRECT_FOOTER</a>(check_reschedule)&#160;&#160;&#160;	<a class="el" href="x86_2ia32_2arch_8h.html#aa7c471213fa28b3685f153ea2a72cf9d">ARCH_ISR_DIRECT_FOOTER</a>(check_reschedule)</td></tr>
<tr class="memdesc:ga31581157c9dbacf935f0e6a8dd456335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common tasks before exiting the body of an ISR.  <a href="group__isr__apis.html#ga31581157c9dbacf935f0e6a8dd456335">More...</a><br /></td></tr>
<tr class="separator:ga31581157c9dbacf935f0e6a8dd456335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c1327551dfca7818975e3fbf1470227"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__isr__apis.html#ga3c1327551dfca7818975e3fbf1470227">ISR_DIRECT_PM</a>()&#160;&#160;&#160;<a class="el" href="x86_2ia32_2arch_8h.html#a491cb79acec18c83b9a61b0b45dfab69">ARCH_ISR_DIRECT_PM</a>()</td></tr>
<tr class="memdesc:ga3c1327551dfca7818975e3fbf1470227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform power management idle exit logic.  <a href="group__isr__apis.html#ga3c1327551dfca7818975e3fbf1470227">More...</a><br /></td></tr>
<tr class="separator:ga3c1327551dfca7818975e3fbf1470227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf86866cd07fd37f381d98866f8874ebf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__isr__apis.html#gaf86866cd07fd37f381d98866f8874ebf">ISR_DIRECT_DECLARE</a>(name)&#160;&#160;&#160;<a class="el" href="x86_2ia32_2arch_8h.html#a5279598e93dd914614a2ae52557be1a5">ARCH_ISR_DIRECT_DECLARE</a>(name)</td></tr>
<tr class="memdesc:gaf86866cd07fd37f381d98866f8874ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro to declare a direct interrupt service routine.  <a href="group__isr__apis.html#gaf86866cd07fd37f381d98866f8874ebf">More...</a><br /></td></tr>
<tr class="separator:gaf86866cd07fd37f381d98866f8874ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19fdde73c3b02fcca6cf1d1e67631228"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__isr__apis.html#ga19fdde73c3b02fcca6cf1d1e67631228">irq_lock</a>()&#160;&#160;&#160;z_smp_global_lock()</td></tr>
<tr class="memdesc:ga19fdde73c3b02fcca6cf1d1e67631228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock interrupts.  <a href="group__isr__apis.html#ga19fdde73c3b02fcca6cf1d1e67631228">More...</a><br /></td></tr>
<tr class="separator:ga19fdde73c3b02fcca6cf1d1e67631228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga646045943b3b2a130738bcc48867bf57"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__isr__apis.html#ga646045943b3b2a130738bcc48867bf57">irq_unlock</a>(<a class="el" href="spinlock__error__case_8c.html#ac67cfa528fbe6d605bc5a011b74611cc">key</a>)&#160;&#160;&#160;z_smp_global_unlock(<a class="el" href="spinlock__error__case_8c.html#ac67cfa528fbe6d605bc5a011b74611cc">key</a>)</td></tr>
<tr class="memdesc:ga646045943b3b2a130738bcc48867bf57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock interrupts.  <a href="group__isr__apis.html#ga646045943b3b2a130738bcc48867bf57">More...</a><br /></td></tr>
<tr class="separator:ga646045943b3b2a130738bcc48867bf57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ea700ee31e4ff036c997a554dbedfeb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__isr__apis.html#ga7ea700ee31e4ff036c997a554dbedfeb">irq_enable</a>(irq)&#160;&#160;&#160;<a class="el" href="group__arch-irq.html#gaa278d630653b33cb339621d725ed295a">arch_irq_enable</a>(irq)</td></tr>
<tr class="memdesc:ga7ea700ee31e4ff036c997a554dbedfeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable an IRQ.  <a href="group__isr__apis.html#ga7ea700ee31e4ff036c997a554dbedfeb">More...</a><br /></td></tr>
<tr class="separator:ga7ea700ee31e4ff036c997a554dbedfeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82c3a15d812f58e0f6525f358d031e6d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__isr__apis.html#ga82c3a15d812f58e0f6525f358d031e6d">irq_disable</a>(irq)&#160;&#160;&#160;<a class="el" href="group__arch-irq.html#ga216d692e87bfba955a60f8e570e127df">arch_irq_disable</a>(irq)</td></tr>
<tr class="memdesc:ga82c3a15d812f58e0f6525f358d031e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable an IRQ.  <a href="group__isr__apis.html#ga82c3a15d812f58e0f6525f358d031e6d">More...</a><br /></td></tr>
<tr class="separator:ga82c3a15d812f58e0f6525f358d031e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71fef3867ba9818cf0a5baf8410a6354"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__isr__apis.html#ga71fef3867ba9818cf0a5baf8410a6354">irq_is_enabled</a>(irq)&#160;&#160;&#160;<a class="el" href="group__arch-irq.html#ga3bd8e963a124421bb372dab4bdc6cd83">arch_irq_is_enabled</a>(irq)</td></tr>
<tr class="memdesc:ga71fef3867ba9818cf0a5baf8410a6354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get IRQ enable state.  <a href="group__isr__apis.html#ga71fef3867ba9818cf0a5baf8410a6354">More...</a><br /></td></tr>
<tr class="separator:ga71fef3867ba9818cf0a5baf8410a6354"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4e9915b92b09df49b99bc449f0cc31a1"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__isr__apis.html#ga4e9915b92b09df49b99bc449f0cc31a1">irq_connect_dynamic</a> (<a class="el" href="lib_2libc_2minimal_2include_2sys_2types_8h.html#a4089fb16419d359081465355db05f846">unsigned</a> int irq, <a class="el" href="lib_2libc_2minimal_2include_2sys_2types_8h.html#a4089fb16419d359081465355db05f846">unsigned</a> int priority, void(*routine)(const void *parameter), const void *parameter, <a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a> <a class="el" href="http__parser_8h.html#ab6b306ef981f5e21bb41ea2c2dbe8cd9">flags</a>)</td></tr>
<tr class="separator:ga4e9915b92b09df49b99bc449f0cc31a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45afd68784e71521606e489d965b1c13"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="lib_2libc_2minimal_2include_2sys_2types_8h.html#a4089fb16419d359081465355db05f846">unsigned</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__isr__apis.html#ga45afd68784e71521606e489d965b1c13">irq_get_level</a> (<a class="el" href="lib_2libc_2minimal_2include_2sys_2types_8h.html#a4089fb16419d359081465355db05f846">unsigned</a> int irq)</td></tr>
<tr class="separator:ga45afd68784e71521606e489d965b1c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8482b0dd2283d12677a9ebe321667d16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__isr__apis.html#ga8482b0dd2283d12677a9ebe321667d16">k_is_in_isr</a> (void)</td></tr>
<tr class="memdesc:ga8482b0dd2283d12677a9ebe321667d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if code is running at interrupt level.  <a href="group__isr__apis.html#ga8482b0dd2283d12677a9ebe321667d16">More...</a><br /></td></tr>
<tr class="separator:ga8482b0dd2283d12677a9ebe321667d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91e1cf0dc7fc93a3214cadb74ed86666"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__isr__apis.html#ga91e1cf0dc7fc93a3214cadb74ed86666">k_is_preempt_thread</a> (void)</td></tr>
<tr class="memdesc:ga91e1cf0dc7fc93a3214cadb74ed86666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if code is running in a preemptible thread.  <a href="group__isr__apis.html#ga91e1cf0dc7fc93a3214cadb74ed86666">More...</a><br /></td></tr>
<tr class="separator:ga91e1cf0dc7fc93a3214cadb74ed86666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae74e5de996276df767b96d4b50fa47ea"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__isr__apis.html#gae74e5de996276df767b96d4b50fa47ea">k_is_pre_kernel</a> (void)</td></tr>
<tr class="memdesc:gae74e5de996276df767b96d4b50fa47ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether startup is in the before-main-task phase.  <a href="group__isr__apis.html#gae74e5de996276df767b96d4b50fa47ea">More...</a><br /></td></tr>
<tr class="separator:gae74e5de996276df767b96d4b50fa47ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga131739d1faf501a15590053817aba984" name="ga131739d1faf501a15590053817aba984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga131739d1faf501a15590053817aba984">&#9670;&nbsp;</a></span>IRQ_CONNECT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IRQ_CONNECT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">irq_p, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">priority_p, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">isr_p, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">isr_param_p, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">flags_p&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;	<a class="el" href="xtensa_2arch_8h.html#accdf8a59e00ac1c1fcedc18b78be4b8a">ARCH_IRQ_CONNECT</a>(irq_p, priority_p, isr_p, isr_param_p, flags_p)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="irq_8h.html">include/irq.h</a>&gt;</code></p>

<p>Initialize an interrupt handler. </p>
<p >This routine initializes an interrupt handler for an IRQ. The IRQ must be subsequently enabled before the interrupt handler begins servicing interrupts.</p>
<dl class="section warning"><dt>Warning</dt><dd>Although this routine is invoked at run-time, all of its arguments must be computable by the compiler at build time.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">irq_p</td><td>IRQ line number. </td></tr>
    <tr><td class="paramname">priority_p</td><td>Interrupt priority. </td></tr>
    <tr><td class="paramname">isr_p</td><td>Address of interrupt service routine. </td></tr>
    <tr><td class="paramname">isr_param_p</td><td>Parameter passed to interrupt service routine. </td></tr>
    <tr><td class="paramname">flags_p</td><td>Architecture-specific IRQ configuration flags.. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac6c8746ac28da6ce02b24714f4144ff3" name="gac6c8746ac28da6ce02b24714f4144ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6c8746ac28da6ce02b24714f4144ff3">&#9670;&nbsp;</a></span>IRQ_DIRECT_CONNECT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IRQ_DIRECT_CONNECT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">irq_p, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">priority_p, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">isr_p, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">flags_p&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;	<a class="el" href="x86_2ia32_2arch_8h.html#a875f2b1ca924721fe3854796bd96c2db">ARCH_IRQ_DIRECT_CONNECT</a>(irq_p, priority_p, isr_p, flags_p)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="irq_8h.html">include/irq.h</a>&gt;</code></p>

<p>Initialize a 'direct' interrupt handler. </p>
<p >This routine initializes an interrupt handler for an IRQ. The IRQ must be subsequently enabled via <a class="el" href="group__isr__apis.html#ga7ea700ee31e4ff036c997a554dbedfeb" title="Enable an IRQ.">irq_enable()</a> before the interrupt handler begins servicing interrupts.</p>
<p >These ISRs are designed for performance-critical interrupt handling and do not go through common interrupt handling code. They must be implemented in such a way that it is safe to put them directly in the vector table. For ISRs written in C, The <a class="el" href="group__isr__apis.html#gaf86866cd07fd37f381d98866f8874ebf" title="Helper macro to declare a direct interrupt service routine.">ISR_DIRECT_DECLARE()</a> macro will do this automatically. For ISRs written in assembly it is entirely up to the developer to ensure that the right steps are taken.</p>
<p >This type of interrupt currently has a few limitations compared to normal Zephyr interrupts:</p><ul>
<li>No parameters are passed to the ISR.</li>
<li>No stack switch is done, the ISR will run on the interrupted context's stack, unless the architecture automatically does the stack switch in HW.</li>
<li>Interrupt locking state is unchanged from how the HW sets it when the ISR runs. On arches that enter ISRs with interrupts locked, they will remain locked.</li>
<li>Scheduling decisions are now optional, controlled by the return value of ISRs implemented with the <a class="el" href="group__isr__apis.html#gaf86866cd07fd37f381d98866f8874ebf" title="Helper macro to declare a direct interrupt service routine.">ISR_DIRECT_DECLARE()</a> macro</li>
<li>The call into the OS to exit power management idle state is now optional. Normal interrupts always do this before the ISR is run, but when it runs is now controlled by the placement of a <a class="el" href="group__isr__apis.html#ga3c1327551dfca7818975e3fbf1470227" title="Perform power management idle exit logic.">ISR_DIRECT_PM()</a> macro, or omitted entirely.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>Although this routine is invoked at run-time, all of its arguments must be computable by the compiler at build time.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">irq_p</td><td>IRQ line number. </td></tr>
    <tr><td class="paramname">priority_p</td><td>Interrupt priority. </td></tr>
    <tr><td class="paramname">isr_p</td><td>Address of interrupt service routine. </td></tr>
    <tr><td class="paramname">flags_p</td><td>Architecture-specific IRQ configuration flags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga82c3a15d812f58e0f6525f358d031e6d" name="ga82c3a15d812f58e0f6525f358d031e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82c3a15d812f58e0f6525f358d031e6d">&#9670;&nbsp;</a></span>irq_disable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define irq_disable</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">irq</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__arch-irq.html#ga216d692e87bfba955a60f8e570e127df">arch_irq_disable</a>(irq)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="irq_8h.html">include/irq.h</a>&gt;</code></p>

<p>Disable an IRQ. </p>
<p >This routine disables interrupts from source <em>irq</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">irq</td><td>IRQ line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7ea700ee31e4ff036c997a554dbedfeb" name="ga7ea700ee31e4ff036c997a554dbedfeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ea700ee31e4ff036c997a554dbedfeb">&#9670;&nbsp;</a></span>irq_enable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define irq_enable</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">irq</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__arch-irq.html#gaa278d630653b33cb339621d725ed295a">arch_irq_enable</a>(irq)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="irq_8h.html">include/irq.h</a>&gt;</code></p>

<p>Enable an IRQ. </p>
<p >This routine enables interrupts from source <em>irq</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">irq</td><td>IRQ line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga71fef3867ba9818cf0a5baf8410a6354" name="ga71fef3867ba9818cf0a5baf8410a6354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71fef3867ba9818cf0a5baf8410a6354">&#9670;&nbsp;</a></span>irq_is_enabled</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define irq_is_enabled</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">irq</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__arch-irq.html#ga3bd8e963a124421bb372dab4bdc6cd83">arch_irq_is_enabled</a>(irq)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="irq_8h.html">include/irq.h</a>&gt;</code></p>

<p>Get IRQ enable state. </p>
<p >This routine indicates if interrupts from source <em>irq</em> are enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">irq</td><td>IRQ line.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interrupt enable state, true or false </dd></dl>

</div>
</div>
<a id="ga19fdde73c3b02fcca6cf1d1e67631228" name="ga19fdde73c3b02fcca6cf1d1e67631228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19fdde73c3b02fcca6cf1d1e67631228">&#9670;&nbsp;</a></span>irq_lock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define irq_lock</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;z_smp_global_lock()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="irq_8h.html">include/irq.h</a>&gt;</code></p>

<p>Lock interrupts. </p>
<p >This routine disables all interrupts on the CPU. It returns an unsigned integer "lock-out key", which is an architecture-dependent indicator of whether interrupts were locked prior to the call. The lock-out key must be passed to <a class="el" href="group__isr__apis.html#ga646045943b3b2a130738bcc48867bf57" title="Unlock interrupts.">irq_unlock()</a> to re-enable interrupts.</p>
<dl class="section note"><dt>Note</dt><dd>This routine must also serve as a memory barrier to ensure the uniprocessor implementation of <code>k_spinlock_t</code> is correct.</dd></dl>
<p>This routine can be called recursively, as long as the caller keeps track of each lock-out key that is generated. Interrupts are re-enabled by passing each of the keys to <a class="el" href="group__isr__apis.html#ga646045943b3b2a130738bcc48867bf57" title="Unlock interrupts.">irq_unlock()</a> in the reverse order they were acquired. (That is, each call to <a class="el" href="group__isr__apis.html#ga19fdde73c3b02fcca6cf1d1e67631228" title="Lock interrupts.">irq_lock()</a> must be balanced by a corresponding call to <a class="el" href="group__isr__apis.html#ga646045943b3b2a130738bcc48867bf57" title="Unlock interrupts.">irq_unlock()</a>.)</p>
<p >This routine can only be invoked from supervisor mode. Some architectures (for example, ARM) will fail silently if invoked from user mode instead of generating an exception.</p>
<dl class="section note"><dt>Note</dt><dd>This routine can be called by ISRs or by threads. If it is called by a thread, the interrupt lock is thread-specific; this means that interrupts remain disabled only while the thread is running. If the thread performs an operation that allows another thread to run (for example, giving a semaphore or sleeping for N milliseconds), the interrupt lock no longer applies and interrupts may be re-enabled while other processing occurs. When the thread once again becomes the current thread, the kernel re-establishes its interrupt lock; this ensures the thread won't be interrupted until it has explicitly released the interrupt lock it established.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The lock-out key should never be used to manually re-enable interrupts or to inspect or manipulate the contents of the CPU's interrupt bits.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An architecture-dependent lock-out key representing the "interrupt disable state" prior to the call. </dd></dl>

</div>
</div>
<a id="ga646045943b3b2a130738bcc48867bf57" name="ga646045943b3b2a130738bcc48867bf57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga646045943b3b2a130738bcc48867bf57">&#9670;&nbsp;</a></span>irq_unlock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define irq_unlock</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="spinlock__error__case_8c.html#ac67cfa528fbe6d605bc5a011b74611cc">key</a></td><td>)</td>
          <td>&#160;&#160;&#160;z_smp_global_unlock(<a class="el" href="spinlock__error__case_8c.html#ac67cfa528fbe6d605bc5a011b74611cc">key</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="irq_8h.html">include/irq.h</a>&gt;</code></p>

<p>Unlock interrupts. </p>
<p >This routine reverses the effect of a previous call to <a class="el" href="group__isr__apis.html#ga19fdde73c3b02fcca6cf1d1e67631228" title="Lock interrupts.">irq_lock()</a> using the associated lock-out key. The caller must call the routine once for each time it called <a class="el" href="group__isr__apis.html#ga19fdde73c3b02fcca6cf1d1e67631228" title="Lock interrupts.">irq_lock()</a>, supplying the keys in the reverse order they were acquired, before interrupts are enabled.</p>
<dl class="section note"><dt>Note</dt><dd>This routine must also serve as a memory barrier to ensure the uniprocessor implementation of <code>k_spinlock_t</code> is correct.</dd></dl>
<p>This routine can only be invoked from supervisor mode. Some architectures (for example, ARM) will fail silently if invoked from user mode instead of generating an exception.</p>
<dl class="section note"><dt>Note</dt><dd>Can be called by ISRs.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Lock-out key generated by <a class="el" href="group__isr__apis.html#ga19fdde73c3b02fcca6cf1d1e67631228" title="Lock interrupts.">irq_lock()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf86866cd07fd37f381d98866f8874ebf" name="gaf86866cd07fd37f381d98866f8874ebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf86866cd07fd37f381d98866f8874ebf">&#9670;&nbsp;</a></span>ISR_DIRECT_DECLARE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ISR_DIRECT_DECLARE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="x86_2ia32_2arch_8h.html#a5279598e93dd914614a2ae52557be1a5">ARCH_ISR_DIRECT_DECLARE</a>(name)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="irq_8h.html">include/irq.h</a>&gt;</code></p>

<p>Helper macro to declare a direct interrupt service routine. </p>
<p >This will declare the function in a proper way and automatically include the <a class="el" href="group__isr__apis.html#ga31581157c9dbacf935f0e6a8dd456335" title="Common tasks before exiting the body of an ISR.">ISR_DIRECT_FOOTER()</a> and <a class="el" href="group__isr__apis.html#ga1ab99dbeb50b228001e1fca808cbaeea" title="Common tasks before executing the body of an ISR.">ISR_DIRECT_HEADER()</a> macros. The function should return nonzero status if a scheduling decision should potentially be made. See <a class="el" href="group__isr__apis.html#ga31581157c9dbacf935f0e6a8dd456335" title="Common tasks before exiting the body of an ISR.">ISR_DIRECT_FOOTER()</a> for more details on the scheduling decision.</p>
<p >For architectures that support 'regular' and 'fast' interrupt types, where these interrupt types require different assembly language handling of registers by the ISR, this will always generate code for the 'fast' interrupt type.</p>
<p >Example usage: </p><pre class="fragment">ISR_DIRECT_DECLARE(my_isr)
{
        bool done = do_stuff();
        ISR_DIRECT_PM(); // done after do_stuff() due to latency concerns
        if (!done) {
            return 0; // don't bother checking if we have to z_swap()
        }

        k_sem_give(some_sem);
        return 1;
 }
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>symbol name of the ISR </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga31581157c9dbacf935f0e6a8dd456335" name="ga31581157c9dbacf935f0e6a8dd456335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31581157c9dbacf935f0e6a8dd456335">&#9670;&nbsp;</a></span>ISR_DIRECT_FOOTER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ISR_DIRECT_FOOTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">check_reschedule</td><td>)</td>
          <td>&#160;&#160;&#160;	<a class="el" href="x86_2ia32_2arch_8h.html#aa7c471213fa28b3685f153ea2a72cf9d">ARCH_ISR_DIRECT_FOOTER</a>(check_reschedule)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="irq_8h.html">include/irq.h</a>&gt;</code></p>

<p>Common tasks before exiting the body of an ISR. </p>
<p >This macro must be at the end of all direct interrupts and performs minimal architecture-specific tasks like EOI. It has no return value.</p>
<p >In a normal interrupt, a check is done at end of interrupt to invoke z_swap() logic if the current thread is preemptible and there is another thread ready to run in the kernel's ready queue cache. This is now optional and controlled by the check_reschedule argument. If unsure, set to nonzero. On systems that do stack switching and nested interrupt tracking in software, z_swap() should only be called if this was a non-nested interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">check_reschedule</td><td>If nonzero, additionally invoke scheduling logic </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1ab99dbeb50b228001e1fca808cbaeea" name="ga1ab99dbeb50b228001e1fca808cbaeea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ab99dbeb50b228001e1fca808cbaeea">&#9670;&nbsp;</a></span>ISR_DIRECT_HEADER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ISR_DIRECT_HEADER</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="x86_2ia32_2arch_8h.html#a6c6d57983c066fe8ab21a78f86f7adb3">ARCH_ISR_DIRECT_HEADER</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="irq_8h.html">include/irq.h</a>&gt;</code></p>

<p>Common tasks before executing the body of an ISR. </p>
<p >This macro must be at the beginning of all direct interrupts and performs minimal architecture-specific tasks before the ISR itself can run. It takes no arguments and has no return value. </p>

</div>
</div>
<a id="ga3c1327551dfca7818975e3fbf1470227" name="ga3c1327551dfca7818975e3fbf1470227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c1327551dfca7818975e3fbf1470227">&#9670;&nbsp;</a></span>ISR_DIRECT_PM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ISR_DIRECT_PM</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="x86_2ia32_2arch_8h.html#a491cb79acec18c83b9a61b0b45dfab69">ARCH_ISR_DIRECT_PM</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="irq_8h.html">include/irq.h</a>&gt;</code></p>

<p>Perform power management idle exit logic. </p>
<p >This macro may optionally be invoked somewhere in between IRQ_DIRECT_HEADER() and IRQ_DIRECT_FOOTER() invocations. It performs tasks necessary to exit power management idle state. It takes no parameters and returns no arguments. It may be omitted, but be careful! </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga4e9915b92b09df49b99bc449f0cc31a1" name="ga4e9915b92b09df49b99bc449f0cc31a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e9915b92b09df49b99bc449f0cc31a1">&#9670;&nbsp;</a></span>irq_connect_dynamic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int irq_connect_dynamic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lib_2libc_2minimal_2include_2sys_2types_8h.html#a4089fb16419d359081465355db05f846">unsigned</a> int&#160;</td>
          <td class="paramname"><em>irq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lib_2libc_2minimal_2include_2sys_2types_8h.html#a4089fb16419d359081465355db05f846">unsigned</a> int&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(const void *parameter)&#160;</td>
          <td class="paramname"><em>routine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a0a8582351ac627ee8bde2973c825e47f">uint32_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="irq_8h.html">include/irq.h</a>&gt;</code></p>
<p >Configure a dynamic interrupt.</p>
<p >Use this instead of <a class="el" href="group__isr__apis.html#ga131739d1faf501a15590053817aba984" title="Initialize an interrupt handler.">IRQ_CONNECT()</a> if arguments cannot be known at build time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">irq</td><td>IRQ line number </td></tr>
    <tr><td class="paramname">priority</td><td>Interrupt priority </td></tr>
    <tr><td class="paramname">routine</td><td>Interrupt service routine </td></tr>
    <tr><td class="paramname">parameter</td><td>ISR parameter </td></tr>
    <tr><td class="paramname">flags</td><td>Arch-specific IRQ configuration flags</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector assigned to this interrupt </dd></dl>

</div>
</div>
<a id="ga45afd68784e71521606e489d965b1c13" name="ga45afd68784e71521606e489d965b1c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45afd68784e71521606e489d965b1c13">&#9670;&nbsp;</a></span>irq_get_level()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="lib_2libc_2minimal_2include_2sys_2types_8h.html#a4089fb16419d359081465355db05f846">unsigned</a> int irq_get_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lib_2libc_2minimal_2include_2sys_2types_8h.html#a4089fb16419d359081465355db05f846">unsigned</a> int&#160;</td>
          <td class="paramname"><em>irq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="irq_8h.html">include/irq.h</a>&gt;</code></p>

</div>
</div>
<a id="ga8482b0dd2283d12677a9ebe321667d16" name="ga8482b0dd2283d12677a9ebe321667d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8482b0dd2283d12677a9ebe321667d16">&#9670;&nbsp;</a></span>k_is_in_isr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> k_is_in_isr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Determine if code is running at interrupt level. </p>
<p >This routine allows the caller to customize its actions, depending on whether it is a thread or an ISR.</p>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>false if invoked by a thread. </dd>
<dd>
true if invoked by an ISR. </dd></dl>

</div>
</div>
<a id="gae74e5de996276df767b96d4b50fa47ea" name="gae74e5de996276df767b96d4b50fa47ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae74e5de996276df767b96d4b50fa47ea">&#9670;&nbsp;</a></span>k_is_pre_kernel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> k_is_pre_kernel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Test whether startup is in the before-main-task phase. </p>
<p >This routine allows the caller to customize its actions, depending on whether it being invoked before the kernel is fully active.</p>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if invoked before post-kernel initialization </dd>
<dd>
false if invoked during/after post-kernel initialization </dd></dl>

</div>
</div>
<a id="ga91e1cf0dc7fc93a3214cadb74ed86666" name="ga91e1cf0dc7fc93a3214cadb74ed86666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91e1cf0dc7fc93a3214cadb74ed86666">&#9670;&nbsp;</a></span>k_is_preempt_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_is_preempt_thread </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="include_2kernel_8h.html">include/kernel.h</a>&gt;</code></p>

<p>Determine if code is running in a preemptible thread. </p>
<p >This routine allows the caller to customize its actions, depending on whether it can be preempted by another thread. The routine returns a 'true' value if all of the following conditions are met:</p>
<ul>
<li>The code is running in a thread, not at ISR.</li>
<li>The thread's priority is in the preemptible range.</li>
<li>The thread has not locked the scheduler.</li>
</ul>
<dl class="section user"><dt>Function properties (list may not be complete)</dt><dd> isr-ok  </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 if invoked by an ISR or by a cooperative thread. </dd>
<dd>
Non-zero if invoked by a preemptible thread. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Mar 5 2022 05:00:47 for Zephyr API Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
<script type="text/javascript">
  $(function() {
    toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
    toggleButton.title = "Toggle Light/Dark Mode"
    $(document).ready(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
    // every resize will remove the button, which is why it has to be added again:
    $(window).resize(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
  })
</script>
</body>
</html>
