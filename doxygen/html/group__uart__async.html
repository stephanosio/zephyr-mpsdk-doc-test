<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zephyr API Documentation: Async UART API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-zephyr.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-zephyr.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Zephyr API Documentation
   &#160;<span id="projectnumber">3.0.99</span>
   </div>
   <div id="projectbrief">A Scalable Open Source RTOS</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__uart__async.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Async UART API<div class="ingroups"><a class="el" href="group__io__interfaces.html">Device Driver APIs</a> &raquo; <a class="el" href="group__uart__interface.html">UART Interface</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuart__event__tx.html">uart_event_tx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART TX event data.  <a href="structuart__event__tx.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuart__event__rx.html">uart_event_rx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART RX event data.  <a href="structuart__event__rx.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuart__event__rx__buf.html">uart_event_rx_buf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART RX buffer released event data.  <a href="structuart__event__rx__buf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuart__event__rx__stop.html">uart_event_rx_stop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART RX stopped data.  <a href="structuart__event__rx__stop.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuart__event.html">uart_event</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure containing information about current event.  <a href="structuart__event.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga7b90c86ad81b06e3e16dd466e29b1151"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__async.html#ga7b90c86ad81b06e3e16dd466e29b1151">uart_callback_t</a>) (const struct <a class="el" href="structdevice.html">device</a> *dev, struct <a class="el" href="structuart__event.html">uart_event</a> *evt, void *<a class="el" href="timer_2timer__api_2src_2main_8c.html#a862de962130decf51321624c10294338">user_data</a>)</td></tr>
<tr class="memdesc:ga7b90c86ad81b06e3e16dd466e29b1151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the application callback function signature for <a class="el" href="group__uart__async.html#gad33e627ed8729409b14e92453e53459c" title="Set event handler function.">uart_callback_set()</a> function.  <a href="group__uart__async.html#ga7b90c86ad81b06e3e16dd466e29b1151">More...</a><br /></td></tr>
<tr class="separator:ga7b90c86ad81b06e3e16dd466e29b1151"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaf0c9513cbafa36d86b4c83f2b6a03dcd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__async.html#gaf0c9513cbafa36d86b4c83f2b6a03dcd">uart_event_type</a> { <br />
&#160;&#160;<a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcda4b5cdf863d8b6e5cd7b58f611808a6e4">UART_TX_DONE</a>
, <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcda0abcf565ba1011815285bb3845f8d5a1">UART_TX_ABORTED</a>
, <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcda7c70c3a56f64602f3d808b46e7b047f7">UART_RX_RDY</a>
, <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcda0d250f372702526f1bce6d4dfe166abe">UART_RX_BUF_REQUEST</a>
, <br />
&#160;&#160;<a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcdab2d152bd84f659d4fc4060df29811b48">UART_RX_BUF_RELEASED</a>
, <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcdaa8ff5629c002a61bc3bdf5baa2ebc203">UART_RX_DISABLED</a>
, <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcda05b81ddf74d208aeabace6ac90ae52dd">UART_RX_STOPPED</a>
<br />
 }</td></tr>
<tr class="memdesc:gaf0c9513cbafa36d86b4c83f2b6a03dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of events passed to callback in UART_ASYNC_API.  <a href="group__uart__async.html#gaf0c9513cbafa36d86b4c83f2b6a03dcd">More...</a><br /></td></tr>
<tr class="separator:gaf0c9513cbafa36d86b4c83f2b6a03dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad33e627ed8729409b14e92453e53459c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__async.html#gad33e627ed8729409b14e92453e53459c">uart_callback_set</a> (const struct <a class="el" href="structdevice.html">device</a> *dev, <a class="el" href="group__uart__async.html#ga7b90c86ad81b06e3e16dd466e29b1151">uart_callback_t</a> callback, void *<a class="el" href="timer_2timer__api_2src_2main_8c.html#a862de962130decf51321624c10294338">user_data</a>)</td></tr>
<tr class="memdesc:gad33e627ed8729409b14e92453e53459c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set event handler function.  <a href="group__uart__async.html#gad33e627ed8729409b14e92453e53459c">More...</a><br /></td></tr>
<tr class="separator:gad33e627ed8729409b14e92453e53459c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf99f32ce2e2d9beb32a2f2e5a26320dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__async.html#gaf99f32ce2e2d9beb32a2f2e5a26320dc">uart_tx</a> (const struct <a class="el" href="structdevice.html">device</a> *dev, const <a class="el" href="stdint_8h.html#a3cb4a16b0e8d6af0af86d4fd6ba5fd9d">uint8_t</a> *buf, size_t len, <a class="el" href="stdint_8h.html#a0c18914b3041c2f583aba76f418399c2">int32_t</a> <a class="el" href="timer_2cycle64_2src_2main_8c.html#a8f4b69a82b00d7baf3f1f7d480bb7fa0">timeout</a>)</td></tr>
<tr class="memdesc:gaf99f32ce2e2d9beb32a2f2e5a26320dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send given number of bytes from buffer through UART.  <a href="group__uart__async.html#gaf99f32ce2e2d9beb32a2f2e5a26320dc">More...</a><br /></td></tr>
<tr class="separator:gaf99f32ce2e2d9beb32a2f2e5a26320dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0ea611cd072fa459a6f1780ce62c9e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__async.html#gab0ea611cd072fa459a6f1780ce62c9e3">uart_tx_u16</a> (const struct <a class="el" href="structdevice.html">device</a> *dev, const <a class="el" href="stdint_8h.html#a5debae8b2a1ec20a6694c0c443ee399e">uint16_t</a> *buf, size_t len, <a class="el" href="stdint_8h.html#a0c18914b3041c2f583aba76f418399c2">int32_t</a> <a class="el" href="timer_2cycle64_2src_2main_8c.html#a8f4b69a82b00d7baf3f1f7d480bb7fa0">timeout</a>)</td></tr>
<tr class="memdesc:gab0ea611cd072fa459a6f1780ce62c9e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send given number of datum from buffer through UART.  <a href="group__uart__async.html#gab0ea611cd072fa459a6f1780ce62c9e3">More...</a><br /></td></tr>
<tr class="separator:gab0ea611cd072fa459a6f1780ce62c9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8a26d3ea685fb98030ea03613be6280"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__async.html#gaa8a26d3ea685fb98030ea03613be6280">uart_tx_abort</a> (const struct <a class="el" href="structdevice.html">device</a> *dev)</td></tr>
<tr class="memdesc:gaa8a26d3ea685fb98030ea03613be6280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort current TX transmission.  <a href="group__uart__async.html#gaa8a26d3ea685fb98030ea03613be6280">More...</a><br /></td></tr>
<tr class="separator:gaa8a26d3ea685fb98030ea03613be6280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga902e18c2a727ed2988e1b6caa6a444b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__async.html#ga902e18c2a727ed2988e1b6caa6a444b8">uart_rx_enable</a> (const struct <a class="el" href="structdevice.html">device</a> *dev, <a class="el" href="stdint_8h.html#a3cb4a16b0e8d6af0af86d4fd6ba5fd9d">uint8_t</a> *buf, size_t len, <a class="el" href="stdint_8h.html#a0c18914b3041c2f583aba76f418399c2">int32_t</a> <a class="el" href="timer_2cycle64_2src_2main_8c.html#a8f4b69a82b00d7baf3f1f7d480bb7fa0">timeout</a>)</td></tr>
<tr class="memdesc:ga902e18c2a727ed2988e1b6caa6a444b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start receiving data through UART.  <a href="group__uart__async.html#ga902e18c2a727ed2988e1b6caa6a444b8">More...</a><br /></td></tr>
<tr class="separator:ga902e18c2a727ed2988e1b6caa6a444b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12d91846133351a85fa471fa90f2a0fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__async.html#ga12d91846133351a85fa471fa90f2a0fd">uart_rx_enable_u16</a> (const struct <a class="el" href="structdevice.html">device</a> *dev, <a class="el" href="stdint_8h.html#a5debae8b2a1ec20a6694c0c443ee399e">uint16_t</a> *buf, size_t len, <a class="el" href="stdint_8h.html#a0c18914b3041c2f583aba76f418399c2">int32_t</a> <a class="el" href="timer_2cycle64_2src_2main_8c.html#a8f4b69a82b00d7baf3f1f7d480bb7fa0">timeout</a>)</td></tr>
<tr class="memdesc:ga12d91846133351a85fa471fa90f2a0fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start receiving wide data through UART.  <a href="group__uart__async.html#ga12d91846133351a85fa471fa90f2a0fd">More...</a><br /></td></tr>
<tr class="separator:ga12d91846133351a85fa471fa90f2a0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3970fe2818e214b0814ea8b73a816a6a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__async.html#ga3970fe2818e214b0814ea8b73a816a6a">uart_rx_buf_rsp</a> (const struct <a class="el" href="structdevice.html">device</a> *dev, <a class="el" href="stdint_8h.html#a3cb4a16b0e8d6af0af86d4fd6ba5fd9d">uint8_t</a> *buf, size_t len)</td></tr>
<tr class="memdesc:ga3970fe2818e214b0814ea8b73a816a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide receive buffer in response to <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcda0d250f372702526f1bce6d4dfe166abe">uart_event_type::UART_RX_BUF_REQUEST</a> event.  <a href="group__uart__async.html#ga3970fe2818e214b0814ea8b73a816a6a">More...</a><br /></td></tr>
<tr class="separator:ga3970fe2818e214b0814ea8b73a816a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga778bcfc30be853c8d320f295b34c17c0"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__async.html#ga778bcfc30be853c8d320f295b34c17c0">uart_rx_buf_rsp_u16</a> (const struct <a class="el" href="structdevice.html">device</a> *dev, <a class="el" href="stdint_8h.html#a5debae8b2a1ec20a6694c0c443ee399e">uint16_t</a> *buf, size_t len)</td></tr>
<tr class="memdesc:ga778bcfc30be853c8d320f295b34c17c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wide data receive buffer in response to <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcda0d250f372702526f1bce6d4dfe166abe">uart_event_type::UART_RX_BUF_REQUEST</a> event.  <a href="group__uart__async.html#ga778bcfc30be853c8d320f295b34c17c0">More...</a><br /></td></tr>
<tr class="separator:ga778bcfc30be853c8d320f295b34c17c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd4753bee51b230091a3c6ddb26ea734"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__async.html#gafd4753bee51b230091a3c6ddb26ea734">uart_rx_disable</a> (const struct <a class="el" href="structdevice.html">device</a> *dev)</td></tr>
<tr class="memdesc:gafd4753bee51b230091a3c6ddb26ea734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable RX.  <a href="group__uart__async.html#gafd4753bee51b230091a3c6ddb26ea734">More...</a><br /></td></tr>
<tr class="separator:gafd4753bee51b230091a3c6ddb26ea734"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga7b90c86ad81b06e3e16dd466e29b1151" name="ga7b90c86ad81b06e3e16dd466e29b1151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b90c86ad81b06e3e16dd466e29b1151">&#9670;&nbsp;</a></span>uart_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uart_callback_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="uart_8h.html">include/drivers/uart.h</a>&gt;</code></p>

<p>Define the application callback function signature for <a class="el" href="group__uart__async.html#gad33e627ed8729409b14e92453e53459c" title="Set event handler function.">uart_callback_set()</a> function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>UART device instance. </td></tr>
    <tr><td class="paramname">evt</td><td>Pointer to <a class="el" href="structuart__event.html" title="Structure containing information about current event.">uart_event</a> instance. </td></tr>
    <tr><td class="paramname">user_data</td><td>Pointer to data specified by user. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaf0c9513cbafa36d86b4c83f2b6a03dcd" name="gaf0c9513cbafa36d86b4c83f2b6a03dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0c9513cbafa36d86b4c83f2b6a03dcd">&#9670;&nbsp;</a></span>uart_event_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__uart__async.html#gaf0c9513cbafa36d86b4c83f2b6a03dcd">uart_event_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="uart_8h.html">include/drivers/uart.h</a>&gt;</code></p>

<p>Types of events passed to callback in UART_ASYNC_API. </p>
<p >Receiving:</p><ol type="1">
<li>To start receiving, uart_rx_enable has to be called with first buffer</li>
<li>When receiving starts to current buffer, <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcda0d250f372702526f1bce6d4dfe166abe">uart_event_type::UART_RX_BUF_REQUEST</a> will be generated, in response to that user can either:<ul>
<li>Provide second buffer using uart_rx_buf_rsp, when first buffer is filled, receiving will automatically start to second buffer.</li>
<li>Ignore the event, this way when current buffer is filled <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcda7c70c3a56f64602f3d808b46e7b047f7">uart_event_type::UART_RX_RDY</a> event will be generated and receiving will be stopped.</li>
</ul>
</li>
<li>If some data was received and timeout occurred <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcda7c70c3a56f64602f3d808b46e7b047f7">uart_event_type::UART_RX_RDY</a> event will be generated. It can happen multiples times for the same buffer. RX timeout is counted from last byte received i.e. if no data was received, there won't be any timeout event.</li>
<li>After buffer is filled <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcda7c70c3a56f64602f3d808b46e7b047f7">uart_event_type::UART_RX_RDY</a> will be generated, immediately followed by <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcdab2d152bd84f659d4fc4060df29811b48">uart_event_type::UART_RX_BUF_RELEASED</a> indicating that current buffer is no longer used.</li>
<li>If there was second buffer provided, it will become current buffer and we start again at point 2. If no second buffer was specified receiving is stopped and <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcdaa8ff5629c002a61bc3bdf5baa2ebc203">uart_event_type::UART_RX_DISABLED</a> event is generated. After that whole process can be repeated.</li>
</ol>
<p >Any time during reception <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcda05b81ddf74d208aeabace6ac90ae52dd">uart_event_type::UART_RX_STOPPED</a> event can occur. if there is any data received, <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcda7c70c3a56f64602f3d808b46e7b047f7">uart_event_type::UART_RX_RDY</a> event will be generated. It will be followed by <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcdab2d152bd84f659d4fc4060df29811b48">uart_event_type::UART_RX_BUF_RELEASED</a> event for every buffer currently passed to driver and finally by <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcdaa8ff5629c002a61bc3bdf5baa2ebc203">uart_event_type::UART_RX_DISABLED</a> event.</p>
<p >Receiving can be disabled using uart_rx_disable, after calling that function, if there is any data received, <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcda7c70c3a56f64602f3d808b46e7b047f7">uart_event_type::UART_RX_RDY</a> event will be generated. <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcdab2d152bd84f659d4fc4060df29811b48">uart_event_type::UART_RX_BUF_RELEASED</a> event will be generated for every buffer currently passed to driver and finally <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcdaa8ff5629c002a61bc3bdf5baa2ebc203">uart_event_type::UART_RX_DISABLED</a> event will occur.</p>
<p >Transmitting:</p><ol type="1">
<li>Transmitting starts by uart_tx function.</li>
<li>If whole buffer was transmitted <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcda4b5cdf863d8b6e5cd7b58f611808a6e4">uart_event_type::UART_TX_DONE</a> is generated. If timeout occurred <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcda0abcf565ba1011815285bb3845f8d5a1">uart_event_type::UART_TX_ABORTED</a> will be generated.</li>
</ol>
<p >Transmitting can be aborted using <a class="el" href="group__uart__async.html#gaa8a26d3ea685fb98030ea03613be6280">uart_tx_abort</a>, after calling that function <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcda0abcf565ba1011815285bb3845f8d5a1">uart_event_type::UART_TX_ABORTED</a> event will be generated. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf0c9513cbafa36d86b4c83f2b6a03dcda4b5cdf863d8b6e5cd7b58f611808a6e4" name="ggaf0c9513cbafa36d86b4c83f2b6a03dcda4b5cdf863d8b6e5cd7b58f611808a6e4"></a>UART_TX_DONE&#160;</td><td class="fielddoc"><p >Whole TX buffer was transmitted. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf0c9513cbafa36d86b4c83f2b6a03dcda0abcf565ba1011815285bb3845f8d5a1" name="ggaf0c9513cbafa36d86b4c83f2b6a03dcda0abcf565ba1011815285bb3845f8d5a1"></a>UART_TX_ABORTED&#160;</td><td class="fielddoc"><p >Transmitting aborted due to timeout or uart_tx_abort call. </p>
<p >When flow control is enabled, there is a possibility that TX transfer won't finish in the allotted time. Some data may have been transferred, information about it can be found in event data. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf0c9513cbafa36d86b4c83f2b6a03dcda7c70c3a56f64602f3d808b46e7b047f7" name="ggaf0c9513cbafa36d86b4c83f2b6a03dcda7c70c3a56f64602f3d808b46e7b047f7"></a>UART_RX_RDY&#160;</td><td class="fielddoc"><p >Received data is ready for processing. </p>
<p >This event is generated in the following cases:</p><ul>
<li>When RX timeout occurred, and data was stored in provided buffer. This can happen multiple times in the same buffer.</li>
<li>When provided buffer is full.</li>
<li>After <a class="el" href="group__uart__async.html#gafd4753bee51b230091a3c6ddb26ea734" title="Disable RX.">uart_rx_disable()</a>.</li>
<li>After stopping due to external event (<a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcda05b81ddf74d208aeabace6ac90ae52dd">uart_event_type::UART_RX_STOPPED</a>). </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="ggaf0c9513cbafa36d86b4c83f2b6a03dcda0d250f372702526f1bce6d4dfe166abe" name="ggaf0c9513cbafa36d86b4c83f2b6a03dcda0d250f372702526f1bce6d4dfe166abe"></a>UART_RX_BUF_REQUEST&#160;</td><td class="fielddoc"><p >Driver requests next buffer for continuous reception. </p>
<p >This event is triggered when receiving has started for a new buffer, i.e. it's time to provide a next buffer for a seamless switchover to it. For continuous reliable receiving, user should provide another RX buffer in response to this event, using uart_rx_buf_rsp function</p>
<p >If uart_rx_buf_rsp is not called before current buffer is filled up, receiving will stop. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf0c9513cbafa36d86b4c83f2b6a03dcdab2d152bd84f659d4fc4060df29811b48" name="ggaf0c9513cbafa36d86b4c83f2b6a03dcdab2d152bd84f659d4fc4060df29811b48"></a>UART_RX_BUF_RELEASED&#160;</td><td class="fielddoc"><p >Buffer is no longer used by UART driver. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf0c9513cbafa36d86b4c83f2b6a03dcdaa8ff5629c002a61bc3bdf5baa2ebc203" name="ggaf0c9513cbafa36d86b4c83f2b6a03dcdaa8ff5629c002a61bc3bdf5baa2ebc203"></a>UART_RX_DISABLED&#160;</td><td class="fielddoc"><p >RX has been disabled and can be reenabled. </p>
<p >This event is generated whenever receiver has been stopped, disabled or finished its operation and can be enabled again using uart_rx_enable </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf0c9513cbafa36d86b4c83f2b6a03dcda05b81ddf74d208aeabace6ac90ae52dd" name="ggaf0c9513cbafa36d86b4c83f2b6a03dcda05b81ddf74d208aeabace6ac90ae52dd"></a>UART_RX_STOPPED&#160;</td><td class="fielddoc"><p >RX has stopped due to external event. </p>
<p >Reason is one of uart_rx_stop_reason. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad33e627ed8729409b14e92453e53459c" name="gad33e627ed8729409b14e92453e53459c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad33e627ed8729409b14e92453e53459c">&#9670;&nbsp;</a></span>uart_callback_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int uart_callback_set </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__uart__async.html#ga7b90c86ad81b06e3e16dd466e29b1151">uart_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="uart_8h.html">include/drivers/uart.h</a>&gt;</code></p>

<p>Set event handler function. </p>
<p >Since it is mandatory to set callback to use other asynchronous functions, it can be used to detect if the device supports asynchronous API. Remaining API does not have that detection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>UART device instance. </td></tr>
    <tr><td class="paramname">callback</td><td>Event handler. </td></tr>
    <tr><td class="paramname">user_data</td><td>Data to pass to event handler function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If successful. </td></tr>
    <tr><td class="paramname">-ENOSYS</td><td>If not supported by the device. </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>If API not enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3970fe2818e214b0814ea8b73a816a6a" name="ga3970fe2818e214b0814ea8b73a816a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3970fe2818e214b0814ea8b73a816a6a">&#9670;&nbsp;</a></span>uart_rx_buf_rsp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int uart_rx_buf_rsp </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a3cb4a16b0e8d6af0af86d4fd6ba5fd9d">uint8_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="uart_8h.html">include/drivers/uart.h</a>&gt;</code></p>

<p>Provide receive buffer in response to <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcda0d250f372702526f1bce6d4dfe166abe">uart_event_type::UART_RX_BUF_REQUEST</a> event. </p>
<p >Provide pointer to RX buffer, which will be used when current buffer is filled.</p>
<dl class="section note"><dt>Note</dt><dd>Providing buffer that is already in usage by driver leads to undefined behavior. Buffer can be reused when it has been released by driver.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>UART device instance. </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to receive buffer. </td></tr>
    <tr><td class="paramname">len</td><td>Buffer length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If successful. </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>If API is not enabled. </td></tr>
    <tr><td class="paramname">-EBUSY</td><td>Next buffer already set. </td></tr>
    <tr><td class="paramname">-EACCES</td><td>Receiver is already disabled (function called too late?). </td></tr>
    <tr><td class="paramname">-errno</td><td>Other negative errno value in case of failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga778bcfc30be853c8d320f295b34c17c0" name="ga778bcfc30be853c8d320f295b34c17c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga778bcfc30be853c8d320f295b34c17c0">&#9670;&nbsp;</a></span>uart_rx_buf_rsp_u16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int uart_rx_buf_rsp_u16 </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a5debae8b2a1ec20a6694c0c443ee399e">uint16_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="uart_8h.html">include/drivers/uart.h</a>&gt;</code></p>

<p>Provide wide data receive buffer in response to <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcda0d250f372702526f1bce6d4dfe166abe">uart_event_type::UART_RX_BUF_REQUEST</a> event. </p>
<p >Provide pointer to RX buffer, which will be used when current buffer is filled.</p>
<dl class="section note"><dt>Note</dt><dd>Providing buffer that is already in usage by driver leads to undefined behavior. Buffer can be reused when it has been released by driver.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>UART device instance. </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to wide data receive buffer. </td></tr>
    <tr><td class="paramname">len</td><td>Buffer length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If successful. </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>If API is not enabled </td></tr>
    <tr><td class="paramname">-EBUSY</td><td>Next buffer already set. </td></tr>
    <tr><td class="paramname">-EACCES</td><td>Receiver is already disabled (function called too late?). </td></tr>
    <tr><td class="paramname">-errno</td><td>Other negative errno value in case of failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafd4753bee51b230091a3c6ddb26ea734" name="gafd4753bee51b230091a3c6ddb26ea734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd4753bee51b230091a3c6ddb26ea734">&#9670;&nbsp;</a></span>uart_rx_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int uart_rx_disable </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="uart_8h.html">include/drivers/uart.h</a>&gt;</code></p>

<p>Disable RX. </p>
<p ><a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcdab2d152bd84f659d4fc4060df29811b48">uart_event_type::UART_RX_BUF_RELEASED</a> event will be generated for every buffer scheduled, after that <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcdaa8ff5629c002a61bc3bdf5baa2ebc203">uart_event_type::UART_RX_DISABLED</a> event will be generated. Additionally, if there is any pending received data, the <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcda7c70c3a56f64602f3d808b46e7b047f7">uart_event_type::UART_RX_RDY</a> event for that data will be generated before the <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcdab2d152bd84f659d4fc4060df29811b48">uart_event_type::UART_RX_BUF_RELEASED</a> events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>UART device instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If successful. </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>If API is not enabled. </td></tr>
    <tr><td class="paramname">-EFAULT</td><td>There is no active reception. </td></tr>
    <tr><td class="paramname">-errno</td><td>Other negative errno value in case of failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga902e18c2a727ed2988e1b6caa6a444b8" name="ga902e18c2a727ed2988e1b6caa6a444b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga902e18c2a727ed2988e1b6caa6a444b8">&#9670;&nbsp;</a></span>uart_rx_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int uart_rx_enable </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a3cb4a16b0e8d6af0af86d4fd6ba5fd9d">uint8_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a0c18914b3041c2f583aba76f418399c2">int32_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="uart_8h.html">include/drivers/uart.h</a>&gt;</code></p>

<p>Start receiving data through UART. </p>
<p >Function sets given buffer as first buffer for receiving and returns immediately. After that event handler, set using <a class="el" href="group__uart__async.html#gad33e627ed8729409b14e92453e53459c">uart_callback_set</a>, is called with <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcda7c70c3a56f64602f3d808b46e7b047f7">uart_event_type::UART_RX_RDY</a> or <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcda0d250f372702526f1bce6d4dfe166abe">uart_event_type::UART_RX_BUF_REQUEST</a> events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>UART device instance. </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to receive buffer. </td></tr>
    <tr><td class="paramname">len</td><td>Buffer length. </td></tr>
    <tr><td class="paramname">timeout</td><td>Inactivity period after receiving at least a byte which triggers <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcda7c70c3a56f64602f3d808b46e7b047f7">uart_event_type::UART_RX_RDY</a> event. Given in microseconds. <a class="el" href="time__units_8h.html#ad8743aaa97d3b2650908020ffb76ef0e">SYS_FOREVER_US</a> disables timeout. See <a class="el" href="group__uart__async.html#gaf0c9513cbafa36d86b4c83f2b6a03dcd">uart_event_type</a> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If successful. </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>If API is not enabled. </td></tr>
    <tr><td class="paramname">-EBUSY</td><td>RX already in progress. </td></tr>
    <tr><td class="paramname">-errno</td><td>Other negative errno value in case of failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga12d91846133351a85fa471fa90f2a0fd" name="ga12d91846133351a85fa471fa90f2a0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12d91846133351a85fa471fa90f2a0fd">&#9670;&nbsp;</a></span>uart_rx_enable_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int uart_rx_enable_u16 </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a5debae8b2a1ec20a6694c0c443ee399e">uint16_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a0c18914b3041c2f583aba76f418399c2">int32_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="uart_8h.html">include/drivers/uart.h</a>&gt;</code></p>

<p>Start receiving wide data through UART. </p>
<p >Function sets given buffer as first buffer for receiving and returns immediately. After that event handler, set using <a class="el" href="group__uart__async.html#gad33e627ed8729409b14e92453e53459c">uart_callback_set</a>, is called with <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcda7c70c3a56f64602f3d808b46e7b047f7">uart_event_type::UART_RX_RDY</a> or <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcda0d250f372702526f1bce6d4dfe166abe">uart_event_type::UART_RX_BUF_REQUEST</a> events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>UART device instance. </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to wide data receive buffer. </td></tr>
    <tr><td class="paramname">len</td><td>Buffer length. </td></tr>
    <tr><td class="paramname">timeout</td><td>Inactivity period after receiving at least a byte which triggers <a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcda7c70c3a56f64602f3d808b46e7b047f7">uart_event_type::UART_RX_RDY</a> event. Given in milliseconds. <a class="el" href="time__units_8h.html#a9f9c4c41f62c7578a30209475201efed">SYS_FOREVER_MS</a> disables timeout. See <a class="el" href="group__uart__async.html#gaf0c9513cbafa36d86b4c83f2b6a03dcd">uart_event_type</a> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If successful. </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>If API is not enabled. </td></tr>
    <tr><td class="paramname">-EBUSY</td><td>RX already in progress. </td></tr>
    <tr><td class="paramname">-errno</td><td>Other negative errno value in case of failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf99f32ce2e2d9beb32a2f2e5a26320dc" name="gaf99f32ce2e2d9beb32a2f2e5a26320dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf99f32ce2e2d9beb32a2f2e5a26320dc">&#9670;&nbsp;</a></span>uart_tx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int uart_tx </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="stdint_8h.html#a3cb4a16b0e8d6af0af86d4fd6ba5fd9d">uint8_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a0c18914b3041c2f583aba76f418399c2">int32_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="uart_8h.html">include/drivers/uart.h</a>&gt;</code></p>

<p>Send given number of bytes from buffer through UART. </p>
<p >Function returns immediately and event handler, set using <a class="el" href="group__uart__async.html#gad33e627ed8729409b14e92453e53459c">uart_callback_set</a>, is called after transfer is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>UART device instance. </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to transmit buffer. </td></tr>
    <tr><td class="paramname">len</td><td>Length of transmit buffer. </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in microseconds. Valid only if flow control is enabled. <a class="el" href="time__units_8h.html#ad8743aaa97d3b2650908020ffb76ef0e">SYS_FOREVER_US</a> disables timeout.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If successful. </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>If API is not enabled. </td></tr>
    <tr><td class="paramname">-EBUSY</td><td>If There is already an ongoing transfer. </td></tr>
    <tr><td class="paramname">-errno</td><td>Other negative errno value in case of failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa8a26d3ea685fb98030ea03613be6280" name="gaa8a26d3ea685fb98030ea03613be6280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8a26d3ea685fb98030ea03613be6280">&#9670;&nbsp;</a></span>uart_tx_abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int uart_tx_abort </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="uart_8h.html">include/drivers/uart.h</a>&gt;</code></p>

<p>Abort current TX transmission. </p>
<p ><a class="el" href="group__uart__async.html#ggaf0c9513cbafa36d86b4c83f2b6a03dcda4b5cdf863d8b6e5cd7b58f611808a6e4">uart_event_type::UART_TX_DONE</a> event will be generated with amount of data sent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>UART device instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If successful. </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>If API is not enabled. </td></tr>
    <tr><td class="paramname">-EFAULT</td><td>There is no active transmission. </td></tr>
    <tr><td class="paramname">-errno</td><td>Other negative errno value in case of failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab0ea611cd072fa459a6f1780ce62c9e3" name="gab0ea611cd072fa459a6f1780ce62c9e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0ea611cd072fa459a6f1780ce62c9e3">&#9670;&nbsp;</a></span>uart_tx_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int uart_tx_u16 </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="stdint_8h.html#a5debae8b2a1ec20a6694c0c443ee399e">uint16_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a0c18914b3041c2f583aba76f418399c2">int32_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="uart_8h.html">include/drivers/uart.h</a>&gt;</code></p>

<p>Send given number of datum from buffer through UART. </p>
<p >Function returns immediately and event handler, set using <a class="el" href="group__uart__async.html#gad33e627ed8729409b14e92453e53459c">uart_callback_set</a>, is called after transfer is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>UART device instance. </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to wide data transmit buffer. </td></tr>
    <tr><td class="paramname">len</td><td>Length of wide data transmit buffer. </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in milliseconds. Valid only if flow control is enabled. <a class="el" href="time__units_8h.html#a9f9c4c41f62c7578a30209475201efed">SYS_FOREVER_MS</a> disables timeout.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If successful. </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>If API is not enabled. </td></tr>
    <tr><td class="paramname">-EBUSY</td><td>If there is already an ongoing transfer. </td></tr>
    <tr><td class="paramname">-errno</td><td>Other negative errno value in case of failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Mar 5 2022 05:00:46 for Zephyr API Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
<script type="text/javascript">
  $(function() {
    toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
    toggleButton.title = "Toggle Light/Dark Mode"
    $(document).ready(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
    // every resize will remove the button, which is why it has to be added again:
    $(window).resize(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
  })
</script>
</body>
</html>
