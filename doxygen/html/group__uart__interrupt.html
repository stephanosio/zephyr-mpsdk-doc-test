<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zephyr API Documentation: Interrupt-driven UART API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-zephyr.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-zephyr.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Zephyr API Documentation
   &#160;<span id="projectnumber">3.0.99</span>
   </div>
   <div id="projectbrief">A Scalable Open Source RTOS</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__uart__interrupt.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Interrupt-driven UART API<div class="ingroups"><a class="el" href="group__io__interfaces.html">Device Driver APIs</a> &raquo; <a class="el" href="group__uart__interface.html">UART Interface</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad7a26b1a1d6212d7d39c05c8ad4ec926"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__interrupt.html#gad7a26b1a1d6212d7d39c05c8ad4ec926">uart_irq_callback_user_data_t</a>) (const struct <a class="el" href="structdevice.html">device</a> *dev, void *<a class="el" href="timer_2timer__api_2src_2main_8c.html#a862de962130decf51321624c10294338">user_data</a>)</td></tr>
<tr class="memdesc:gad7a26b1a1d6212d7d39c05c8ad4ec926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the application callback function signature for <a class="el" href="group__uart__interrupt.html#gaef0210c791ac400d149dc0b67420eec5" title="Set the IRQ callback function pointer.">uart_irq_callback_user_data_set()</a> function.  <a href="group__uart__interrupt.html#gad7a26b1a1d6212d7d39c05c8ad4ec926">More...</a><br /></td></tr>
<tr class="separator:gad7a26b1a1d6212d7d39c05c8ad4ec926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6750414923953c84fb1e19177ec74ae0"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__interrupt.html#ga6750414923953c84fb1e19177ec74ae0">uart_irq_config_func_t</a>) (const struct <a class="el" href="structdevice.html">device</a> *dev)</td></tr>
<tr class="memdesc:ga6750414923953c84fb1e19177ec74ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">For configuring IRQ on each individual UART device.  <a href="group__uart__interrupt.html#ga6750414923953c84fb1e19177ec74ae0">More...</a><br /></td></tr>
<tr class="separator:ga6750414923953c84fb1e19177ec74ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gafe42e4719eada7e25904bc9ebfe87791"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__interrupt.html#gafe42e4719eada7e25904bc9ebfe87791">uart_fifo_fill</a> (const struct <a class="el" href="structdevice.html">device</a> *dev, const <a class="el" href="stdint_8h.html#a3cb4a16b0e8d6af0af86d4fd6ba5fd9d">uint8_t</a> *tx_data, int size)</td></tr>
<tr class="memdesc:gafe42e4719eada7e25904bc9ebfe87791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill FIFO with data.  <a href="group__uart__interrupt.html#gafe42e4719eada7e25904bc9ebfe87791">More...</a><br /></td></tr>
<tr class="separator:gafe42e4719eada7e25904bc9ebfe87791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa89f58818d8428ad6a11abf692c54c0d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__interrupt.html#gaa89f58818d8428ad6a11abf692c54c0d">uart_fifo_fill_u16</a> (const struct <a class="el" href="structdevice.html">device</a> *dev, const <a class="el" href="stdint_8h.html#a5debae8b2a1ec20a6694c0c443ee399e">uint16_t</a> *tx_data, int size)</td></tr>
<tr class="memdesc:gaa89f58818d8428ad6a11abf692c54c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill FIFO with wide data.  <a href="group__uart__interrupt.html#gaa89f58818d8428ad6a11abf692c54c0d">More...</a><br /></td></tr>
<tr class="separator:gaa89f58818d8428ad6a11abf692c54c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab10942076ac47ecff29e924098049398"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__interrupt.html#gab10942076ac47ecff29e924098049398">uart_fifo_read</a> (const struct <a class="el" href="structdevice.html">device</a> *dev, <a class="el" href="stdint_8h.html#a3cb4a16b0e8d6af0af86d4fd6ba5fd9d">uint8_t</a> *rx_data, const int size)</td></tr>
<tr class="memdesc:gab10942076ac47ecff29e924098049398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from FIFO.  <a href="group__uart__interrupt.html#gab10942076ac47ecff29e924098049398">More...</a><br /></td></tr>
<tr class="separator:gab10942076ac47ecff29e924098049398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a3c25dad2290f1f40e4b847e3b83f64"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__interrupt.html#ga4a3c25dad2290f1f40e4b847e3b83f64">uart_fifo_read_u16</a> (const struct <a class="el" href="structdevice.html">device</a> *dev, <a class="el" href="stdint_8h.html#a5debae8b2a1ec20a6694c0c443ee399e">uint16_t</a> *rx_data, const int size)</td></tr>
<tr class="memdesc:ga4a3c25dad2290f1f40e4b847e3b83f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read wide data from FIFO.  <a href="group__uart__interrupt.html#ga4a3c25dad2290f1f40e4b847e3b83f64">More...</a><br /></td></tr>
<tr class="separator:ga4a3c25dad2290f1f40e4b847e3b83f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cbd6e33dce6a5b06233cf10077e19cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__interrupt.html#ga9cbd6e33dce6a5b06233cf10077e19cc">uart_irq_tx_enable</a> (const struct <a class="el" href="structdevice.html">device</a> *dev)</td></tr>
<tr class="memdesc:ga9cbd6e33dce6a5b06233cf10077e19cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable TX interrupt in IER.  <a href="group__uart__interrupt.html#ga9cbd6e33dce6a5b06233cf10077e19cc">More...</a><br /></td></tr>
<tr class="separator:ga9cbd6e33dce6a5b06233cf10077e19cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8a5bc26cd7c32e7bc6516c6f873c45a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__interrupt.html#gaf8a5bc26cd7c32e7bc6516c6f873c45a">uart_irq_tx_disable</a> (const struct <a class="el" href="structdevice.html">device</a> *dev)</td></tr>
<tr class="memdesc:gaf8a5bc26cd7c32e7bc6516c6f873c45a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable TX interrupt in IER.  <a href="group__uart__interrupt.html#gaf8a5bc26cd7c32e7bc6516c6f873c45a">More...</a><br /></td></tr>
<tr class="separator:gaf8a5bc26cd7c32e7bc6516c6f873c45a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e126b5f19549eb7f5b785b98ebe7638"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__interrupt.html#ga5e126b5f19549eb7f5b785b98ebe7638">uart_irq_tx_ready</a> (const struct <a class="el" href="structdevice.html">device</a> *dev)</td></tr>
<tr class="memdesc:ga5e126b5f19549eb7f5b785b98ebe7638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if UART TX buffer can accept a new char.  <a href="group__uart__interrupt.html#ga5e126b5f19549eb7f5b785b98ebe7638">More...</a><br /></td></tr>
<tr class="separator:ga5e126b5f19549eb7f5b785b98ebe7638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ec3ae3974da2b3ab94ae7b835d17bad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__interrupt.html#ga4ec3ae3974da2b3ab94ae7b835d17bad">uart_irq_rx_enable</a> (const struct <a class="el" href="structdevice.html">device</a> *dev)</td></tr>
<tr class="memdesc:ga4ec3ae3974da2b3ab94ae7b835d17bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable RX interrupt.  <a href="group__uart__interrupt.html#ga4ec3ae3974da2b3ab94ae7b835d17bad">More...</a><br /></td></tr>
<tr class="separator:ga4ec3ae3974da2b3ab94ae7b835d17bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa759d7935fdd9ab6ca0761f161389a29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__interrupt.html#gaa759d7935fdd9ab6ca0761f161389a29">uart_irq_rx_disable</a> (const struct <a class="el" href="structdevice.html">device</a> *dev)</td></tr>
<tr class="memdesc:gaa759d7935fdd9ab6ca0761f161389a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable RX interrupt.  <a href="group__uart__interrupt.html#gaa759d7935fdd9ab6ca0761f161389a29">More...</a><br /></td></tr>
<tr class="separator:gaa759d7935fdd9ab6ca0761f161389a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga917935a13bf6a5d1e32ef34339e96455"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__interrupt.html#ga917935a13bf6a5d1e32ef34339e96455">uart_irq_tx_complete</a> (const struct <a class="el" href="structdevice.html">device</a> *dev)</td></tr>
<tr class="memdesc:ga917935a13bf6a5d1e32ef34339e96455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if UART TX block finished transmission.  <a href="group__uart__interrupt.html#ga917935a13bf6a5d1e32ef34339e96455">More...</a><br /></td></tr>
<tr class="separator:ga917935a13bf6a5d1e32ef34339e96455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad04073b1b8e3de13b43ae1194561377b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__interrupt.html#gad04073b1b8e3de13b43ae1194561377b">uart_irq_rx_ready</a> (const struct <a class="el" href="structdevice.html">device</a> *dev)</td></tr>
<tr class="memdesc:gad04073b1b8e3de13b43ae1194561377b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if UART RX buffer has a received char.  <a href="group__uart__interrupt.html#gad04073b1b8e3de13b43ae1194561377b">More...</a><br /></td></tr>
<tr class="separator:gad04073b1b8e3de13b43ae1194561377b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c24daae3326bc2959ea13a2be79969f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__interrupt.html#ga7c24daae3326bc2959ea13a2be79969f">uart_irq_err_enable</a> (const struct <a class="el" href="structdevice.html">device</a> *dev)</td></tr>
<tr class="memdesc:ga7c24daae3326bc2959ea13a2be79969f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable error interrupt.  <a href="group__uart__interrupt.html#ga7c24daae3326bc2959ea13a2be79969f">More...</a><br /></td></tr>
<tr class="separator:ga7c24daae3326bc2959ea13a2be79969f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf8a88361807e204f7227fbd1d0e75b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__interrupt.html#gaaf8a88361807e204f7227fbd1d0e75b2">uart_irq_err_disable</a> (const struct <a class="el" href="structdevice.html">device</a> *dev)</td></tr>
<tr class="memdesc:gaaf8a88361807e204f7227fbd1d0e75b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable error interrupt.  <a href="group__uart__interrupt.html#gaaf8a88361807e204f7227fbd1d0e75b2">More...</a><br /></td></tr>
<tr class="separator:gaaf8a88361807e204f7227fbd1d0e75b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11ccae917c8b5fd76aaabdb047125f6a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__interrupt.html#ga11ccae917c8b5fd76aaabdb047125f6a">uart_irq_is_pending</a> (const struct <a class="el" href="structdevice.html">device</a> *dev)</td></tr>
<tr class="memdesc:ga11ccae917c8b5fd76aaabdb047125f6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if any IRQs is pending.  <a href="group__uart__interrupt.html#ga11ccae917c8b5fd76aaabdb047125f6a">More...</a><br /></td></tr>
<tr class="separator:ga11ccae917c8b5fd76aaabdb047125f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5241e000d482c40b2a4856c58c106a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__interrupt.html#gac5241e000d482c40b2a4856c58c106a6">uart_irq_update</a> (const struct <a class="el" href="structdevice.html">device</a> *dev)</td></tr>
<tr class="memdesc:gac5241e000d482c40b2a4856c58c106a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start processing interrupts in ISR.  <a href="group__uart__interrupt.html#gac5241e000d482c40b2a4856c58c106a6">More...</a><br /></td></tr>
<tr class="separator:gac5241e000d482c40b2a4856c58c106a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef0210c791ac400d149dc0b67420eec5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__interrupt.html#gaef0210c791ac400d149dc0b67420eec5">uart_irq_callback_user_data_set</a> (const struct <a class="el" href="structdevice.html">device</a> *dev, <a class="el" href="group__uart__interrupt.html#gad7a26b1a1d6212d7d39c05c8ad4ec926">uart_irq_callback_user_data_t</a> cb, void *<a class="el" href="timer_2timer__api_2src_2main_8c.html#a862de962130decf51321624c10294338">user_data</a>)</td></tr>
<tr class="memdesc:gaef0210c791ac400d149dc0b67420eec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the IRQ callback function pointer.  <a href="group__uart__interrupt.html#gaef0210c791ac400d149dc0b67420eec5">More...</a><br /></td></tr>
<tr class="separator:gaef0210c791ac400d149dc0b67420eec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac896825681a3febf24bb3cba5178f39f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__interrupt.html#gac896825681a3febf24bb3cba5178f39f">uart_irq_callback_set</a> (const struct <a class="el" href="structdevice.html">device</a> *dev, <a class="el" href="group__uart__interrupt.html#gad7a26b1a1d6212d7d39c05c8ad4ec926">uart_irq_callback_user_data_t</a> cb)</td></tr>
<tr class="memdesc:gac896825681a3febf24bb3cba5178f39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the IRQ callback function pointer (legacy).  <a href="group__uart__interrupt.html#gac896825681a3febf24bb3cba5178f39f">More...</a><br /></td></tr>
<tr class="separator:gac896825681a3febf24bb3cba5178f39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gad7a26b1a1d6212d7d39c05c8ad4ec926" name="gad7a26b1a1d6212d7d39c05c8ad4ec926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7a26b1a1d6212d7d39c05c8ad4ec926">&#9670;&nbsp;</a></span>uart_irq_callback_user_data_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* uart_irq_callback_user_data_t) (const struct <a class="el" href="structdevice.html">device</a> *dev, void *<a class="el" href="timer_2timer__api_2src_2main_8c.html#a862de962130decf51321624c10294338">user_data</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="uart_8h.html">include/drivers/uart.h</a>&gt;</code></p>

<p>Define the application callback function signature for <a class="el" href="group__uart__interrupt.html#gaef0210c791ac400d149dc0b67420eec5" title="Set the IRQ callback function pointer.">uart_irq_callback_user_data_set()</a> function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>UART device instance. </td></tr>
    <tr><td class="paramname">user_data</td><td>Arbitrary user data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6750414923953c84fb1e19177ec74ae0" name="ga6750414923953c84fb1e19177ec74ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6750414923953c84fb1e19177ec74ae0">&#9670;&nbsp;</a></span>uart_irq_config_func_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* uart_irq_config_func_t) (const struct <a class="el" href="structdevice.html">device</a> *dev)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="uart_8h.html">include/drivers/uart.h</a>&gt;</code></p>

<p>For configuring IRQ on each individual UART device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>UART device instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gafe42e4719eada7e25904bc9ebfe87791" name="gafe42e4719eada7e25904bc9ebfe87791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe42e4719eada7e25904bc9ebfe87791">&#9670;&nbsp;</a></span>uart_fifo_fill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int uart_fifo_fill </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="stdint_8h.html#a3cb4a16b0e8d6af0af86d4fd6ba5fd9d">uint8_t</a> *&#160;</td>
          <td class="paramname"><em>tx_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="uart_8h.html">include/drivers/uart.h</a>&gt;</code></p>

<p>Fill FIFO with data. </p>
<p >This function is expected to be called from UART interrupt handler (ISR), if <a class="el" href="group__uart__interrupt.html#ga5e126b5f19549eb7f5b785b98ebe7638" title="Check if UART TX buffer can accept a new char.">uart_irq_tx_ready()</a> returns true. Result of calling this function not from an ISR is undefined (hardware-dependent). Likewise, <em>not</em> calling this function from an ISR if <a class="el" href="group__uart__interrupt.html#ga5e126b5f19549eb7f5b785b98ebe7638" title="Check if UART TX buffer can accept a new char.">uart_irq_tx_ready()</a> returns true may lead to undefined behavior, e.g. infinite interrupt loops. It's mandatory to test return value of this function, as different hardware has different FIFO depth (oftentimes just 1).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>UART device instance. </td></tr>
    <tr><td class="paramname">tx_data</td><td>Data to transmit. </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to send.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes sent. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-ENOSYS</td><td>if this function is not supported </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>If API is not enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa89f58818d8428ad6a11abf692c54c0d" name="gaa89f58818d8428ad6a11abf692c54c0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa89f58818d8428ad6a11abf692c54c0d">&#9670;&nbsp;</a></span>uart_fifo_fill_u16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int uart_fifo_fill_u16 </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="stdint_8h.html#a5debae8b2a1ec20a6694c0c443ee399e">uint16_t</a> *&#160;</td>
          <td class="paramname"><em>tx_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="uart_8h.html">include/drivers/uart.h</a>&gt;</code></p>

<p>Fill FIFO with wide data. </p>
<p >This function is expected to be called from UART interrupt handler (ISR), if <a class="el" href="group__uart__interrupt.html#ga5e126b5f19549eb7f5b785b98ebe7638" title="Check if UART TX buffer can accept a new char.">uart_irq_tx_ready()</a> returns true. Result of calling this function not from an ISR is undefined (hardware-dependent). Likewise, <em>not</em> calling this function from an ISR if <a class="el" href="group__uart__interrupt.html#ga5e126b5f19549eb7f5b785b98ebe7638" title="Check if UART TX buffer can accept a new char.">uart_irq_tx_ready()</a> returns true may lead to undefined behavior, e.g. infinite interrupt loops. It's mandatory to test return value of this function, as different hardware has different FIFO depth (oftentimes just 1).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>UART device instance. </td></tr>
    <tr><td class="paramname">tx_data</td><td>Wide data to transmit. </td></tr>
    <tr><td class="paramname">size</td><td>Number of datum to send.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of datum sent. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-ENOSYS</td><td>If this function is not implemented </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>If API is not enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab10942076ac47ecff29e924098049398" name="gab10942076ac47ecff29e924098049398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab10942076ac47ecff29e924098049398">&#9670;&nbsp;</a></span>uart_fifo_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int uart_fifo_read </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a3cb4a16b0e8d6af0af86d4fd6ba5fd9d">uint8_t</a> *&#160;</td>
          <td class="paramname"><em>rx_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="uart_8h.html">include/drivers/uart.h</a>&gt;</code></p>

<p>Read data from FIFO. </p>
<p >This function is expected to be called from UART interrupt handler (ISR), if <a class="el" href="group__uart__interrupt.html#gad04073b1b8e3de13b43ae1194561377b" title="Check if UART RX buffer has a received char.">uart_irq_rx_ready()</a> returns true. Result of calling this function not from an ISR is undefined (hardware-dependent). It's unspecified whether "RX ready" condition as returned by <a class="el" href="group__uart__interrupt.html#gad04073b1b8e3de13b43ae1194561377b" title="Check if UART RX buffer has a received char.">uart_irq_rx_ready()</a> is level- or edge- triggered. That means that once <a class="el" href="group__uart__interrupt.html#gad04073b1b8e3de13b43ae1194561377b" title="Check if UART RX buffer has a received char.">uart_irq_rx_ready()</a> is detected, <a class="el" href="group__uart__interrupt.html#gab10942076ac47ecff29e924098049398" title="Read data from FIFO.">uart_fifo_read()</a> must be called until it reads all available data in the FIFO (i.e. until it returns less data than was requested).</p>
<p >Note that the calling context only applies to physical UARTs and no to the virtual ones found in USB CDC ACM code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>UART device instance. </td></tr>
    <tr><td class="paramname">rx_data</td><td>Data container. </td></tr>
    <tr><td class="paramname">size</td><td>Container size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes read. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-ENOSYS</td><td>If this function is not implemented. </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>If API is not enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4a3c25dad2290f1f40e4b847e3b83f64" name="ga4a3c25dad2290f1f40e4b847e3b83f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a3c25dad2290f1f40e4b847e3b83f64">&#9670;&nbsp;</a></span>uart_fifo_read_u16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int uart_fifo_read_u16 </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a5debae8b2a1ec20a6694c0c443ee399e">uint16_t</a> *&#160;</td>
          <td class="paramname"><em>rx_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="uart_8h.html">include/drivers/uart.h</a>&gt;</code></p>

<p>Read wide data from FIFO. </p>
<p >This function is expected to be called from UART interrupt handler (ISR), if <a class="el" href="group__uart__interrupt.html#gad04073b1b8e3de13b43ae1194561377b" title="Check if UART RX buffer has a received char.">uart_irq_rx_ready()</a> returns true. Result of calling this function not from an ISR is undefined (hardware-dependent). It's unspecified whether "RX ready" condition as returned by <a class="el" href="group__uart__interrupt.html#gad04073b1b8e3de13b43ae1194561377b" title="Check if UART RX buffer has a received char.">uart_irq_rx_ready()</a> is level- or edge- triggered. That means that once <a class="el" href="group__uart__interrupt.html#gad04073b1b8e3de13b43ae1194561377b" title="Check if UART RX buffer has a received char.">uart_irq_rx_ready()</a> is detected, <a class="el" href="group__uart__interrupt.html#gab10942076ac47ecff29e924098049398" title="Read data from FIFO.">uart_fifo_read()</a> must be called until it reads all available data in the FIFO (i.e. until it returns less data than was requested).</p>
<p >Note that the calling context only applies to physical UARTs and no to the virtual ones found in USB CDC ACM code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>UART device instance. </td></tr>
    <tr><td class="paramname">rx_data</td><td>Wide data container. </td></tr>
    <tr><td class="paramname">size</td><td>Container size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of datum read. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-ENOSYS</td><td>If this function is not implemented. </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>If API is not enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac896825681a3febf24bb3cba5178f39f" name="gac896825681a3febf24bb3cba5178f39f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac896825681a3febf24bb3cba5178f39f">&#9670;&nbsp;</a></span>uart_irq_callback_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void uart_irq_callback_set </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__uart__interrupt.html#gad7a26b1a1d6212d7d39c05c8ad4ec926">uart_irq_callback_user_data_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="uart_8h.html">include/drivers/uart.h</a>&gt;</code></p>

<p>Set the IRQ callback function pointer (legacy). </p>
<p >This sets up the callback for IRQ. When an IRQ is triggered, the specified function will be called with the device pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>UART device instance. </td></tr>
    <tr><td class="paramname">cb</td><td>Pointer to the callback function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaef0210c791ac400d149dc0b67420eec5" name="gaef0210c791ac400d149dc0b67420eec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef0210c791ac400d149dc0b67420eec5">&#9670;&nbsp;</a></span>uart_irq_callback_user_data_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void uart_irq_callback_user_data_set </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__uart__interrupt.html#gad7a26b1a1d6212d7d39c05c8ad4ec926">uart_irq_callback_user_data_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="uart_8h.html">include/drivers/uart.h</a>&gt;</code></p>

<p>Set the IRQ callback function pointer. </p>
<p >This sets up the callback for IRQ. When an IRQ is triggered, the specified function will be called with specified user data. See description of <a class="el" href="group__uart__interrupt.html#gac5241e000d482c40b2a4856c58c106a6" title="Start processing interrupts in ISR.">uart_irq_update()</a> for the requirements on ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>UART device instance. </td></tr>
    <tr><td class="paramname">cb</td><td>Pointer to the callback function. </td></tr>
    <tr><td class="paramname">user_data</td><td>Data to pass to callback function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaf8a88361807e204f7227fbd1d0e75b2" name="gaaf8a88361807e204f7227fbd1d0e75b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf8a88361807e204f7227fbd1d0e75b2">&#9670;&nbsp;</a></span>uart_irq_err_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uart_irq_err_disable </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="uart_8h.html">include/drivers/uart.h</a>&gt;</code></p>

<p>Disable error interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>UART device instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7c24daae3326bc2959ea13a2be79969f" name="ga7c24daae3326bc2959ea13a2be79969f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c24daae3326bc2959ea13a2be79969f">&#9670;&nbsp;</a></span>uart_irq_err_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uart_irq_err_enable </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="uart_8h.html">include/drivers/uart.h</a>&gt;</code></p>

<p>Enable error interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>UART device instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga11ccae917c8b5fd76aaabdb047125f6a" name="ga11ccae917c8b5fd76aaabdb047125f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11ccae917c8b5fd76aaabdb047125f6a">&#9670;&nbsp;</a></span>uart_irq_is_pending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int uart_irq_is_pending </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="uart_8h.html">include/drivers/uart.h</a>&gt;</code></p>

<p>Check if any IRQs is pending. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>UART device instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>If an IRQ is pending. </td></tr>
    <tr><td class="paramname">0</td><td>If an IRQ is not pending. </td></tr>
    <tr><td class="paramname">-ENOSYS</td><td>If this function is not implemented. </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>If API is not enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa759d7935fdd9ab6ca0761f161389a29" name="gaa759d7935fdd9ab6ca0761f161389a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa759d7935fdd9ab6ca0761f161389a29">&#9670;&nbsp;</a></span>uart_irq_rx_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uart_irq_rx_disable </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="uart_8h.html">include/drivers/uart.h</a>&gt;</code></p>

<p>Disable RX interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>UART device instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4ec3ae3974da2b3ab94ae7b835d17bad" name="ga4ec3ae3974da2b3ab94ae7b835d17bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ec3ae3974da2b3ab94ae7b835d17bad">&#9670;&nbsp;</a></span>uart_irq_rx_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uart_irq_rx_enable </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="uart_8h.html">include/drivers/uart.h</a>&gt;</code></p>

<p>Enable RX interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>UART device instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad04073b1b8e3de13b43ae1194561377b" name="gad04073b1b8e3de13b43ae1194561377b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad04073b1b8e3de13b43ae1194561377b">&#9670;&nbsp;</a></span>uart_irq_rx_ready()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int uart_irq_rx_ready </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="uart_8h.html">include/drivers/uart.h</a>&gt;</code></p>

<p>Check if UART RX buffer has a received char. </p>
<p >Check if UART RX buffer has at least one pending character (i.e. <a class="el" href="group__uart__interrupt.html#gab10942076ac47ecff29e924098049398" title="Read data from FIFO.">uart_fifo_read()</a> will succeed and return non-zero). This function must be called in a UART interrupt handler, or its result is undefined. Before calling this function in the interrupt handler, <a class="el" href="group__uart__interrupt.html#gac5241e000d482c40b2a4856c58c106a6" title="Start processing interrupts in ISR.">uart_irq_update()</a> must be called once per the handler invocation. It's unspecified whether condition as returned by this function is level- or edge- triggered (i.e. if this function returns true when RX FIFO is non-empty, or when a new char was received since last call to it). See description of <a class="el" href="group__uart__interrupt.html#gab10942076ac47ecff29e924098049398" title="Read data from FIFO.">uart_fifo_read()</a> for implication of this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>UART device instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>If a received char is ready. </td></tr>
    <tr><td class="paramname">0</td><td>If a received char is not ready. </td></tr>
    <tr><td class="paramname">-ENOSYS</td><td>If this function is not implemented. </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>If API is not enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga917935a13bf6a5d1e32ef34339e96455" name="ga917935a13bf6a5d1e32ef34339e96455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga917935a13bf6a5d1e32ef34339e96455">&#9670;&nbsp;</a></span>uart_irq_tx_complete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int uart_irq_tx_complete </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="uart_8h.html">include/drivers/uart.h</a>&gt;</code></p>

<p>Check if UART TX block finished transmission. </p>
<p >Check if any outgoing data buffered in UART TX block was fully transmitted and TX block is idle. When this condition is true, UART device (or whole system) can be power off. Note that this function is <em>not</em> useful to check if UART TX can accept more data, use <a class="el" href="group__uart__interrupt.html#ga5e126b5f19549eb7f5b785b98ebe7638" title="Check if UART TX buffer can accept a new char.">uart_irq_tx_ready()</a> for that. This function must be called in a UART interrupt handler, or its result is undefined. Before calling this function in the interrupt handler, <a class="el" href="group__uart__interrupt.html#gac5241e000d482c40b2a4856c58c106a6" title="Start processing interrupts in ISR.">uart_irq_update()</a> must be called once per the handler invocation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>UART device instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>If nothing remains to be transmitted. </td></tr>
    <tr><td class="paramname">0</td><td>If transmission is not completed. </td></tr>
    <tr><td class="paramname">-ENOSYS</td><td>If this function is not implemented. </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>If API is not enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf8a5bc26cd7c32e7bc6516c6f873c45a" name="gaf8a5bc26cd7c32e7bc6516c6f873c45a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8a5bc26cd7c32e7bc6516c6f873c45a">&#9670;&nbsp;</a></span>uart_irq_tx_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uart_irq_tx_disable </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="uart_8h.html">include/drivers/uart.h</a>&gt;</code></p>

<p>Disable TX interrupt in IER. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>UART device instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9cbd6e33dce6a5b06233cf10077e19cc" name="ga9cbd6e33dce6a5b06233cf10077e19cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cbd6e33dce6a5b06233cf10077e19cc">&#9670;&nbsp;</a></span>uart_irq_tx_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uart_irq_tx_enable </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="uart_8h.html">include/drivers/uart.h</a>&gt;</code></p>

<p>Enable TX interrupt in IER. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>UART device instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5e126b5f19549eb7f5b785b98ebe7638" name="ga5e126b5f19549eb7f5b785b98ebe7638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e126b5f19549eb7f5b785b98ebe7638">&#9670;&nbsp;</a></span>uart_irq_tx_ready()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int uart_irq_tx_ready </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="uart_8h.html">include/drivers/uart.h</a>&gt;</code></p>

<p>Check if UART TX buffer can accept a new char. </p>
<p >Check if UART TX buffer can accept at least one character for transmission (i.e. <a class="el" href="group__uart__interrupt.html#gafe42e4719eada7e25904bc9ebfe87791" title="Fill FIFO with data.">uart_fifo_fill()</a> will succeed and return non-zero). This function must be called in a UART interrupt handler, or its result is undefined. Before calling this function in the interrupt handler, <a class="el" href="group__uart__interrupt.html#gac5241e000d482c40b2a4856c58c106a6" title="Start processing interrupts in ISR.">uart_irq_update()</a> must be called once per the handler invocation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>UART device instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>If TX interrupt is enabled and at least one char can be written to UART. </td></tr>
    <tr><td class="paramname">0</td><td>If device is not ready to write a new byte. </td></tr>
    <tr><td class="paramname">-ENOSYS</td><td>If this function is not implemented. </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>If API is not enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac5241e000d482c40b2a4856c58c106a6" name="gac5241e000d482c40b2a4856c58c106a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5241e000d482c40b2a4856c58c106a6">&#9670;&nbsp;</a></span>uart_irq_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int uart_irq_update </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdevice.html">device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="uart_8h.html">include/drivers/uart.h</a>&gt;</code></p>

<p>Start processing interrupts in ISR. </p>
<p >This function should be called the first thing in the ISR. Calling <a class="el" href="group__uart__interrupt.html#gad04073b1b8e3de13b43ae1194561377b" title="Check if UART RX buffer has a received char.">uart_irq_rx_ready()</a>, <a class="el" href="group__uart__interrupt.html#ga5e126b5f19549eb7f5b785b98ebe7638" title="Check if UART TX buffer can accept a new char.">uart_irq_tx_ready()</a>, <a class="el" href="group__uart__interrupt.html#ga917935a13bf6a5d1e32ef34339e96455" title="Check if UART TX block finished transmission.">uart_irq_tx_complete()</a> allowed only after this.</p>
<p >The purpose of this function is:</p>
<ul>
<li>For devices with auto-acknowledge of interrupt status on register read to cache the value of this register (rx_ready, etc. then use this case).</li>
<li>For devices with explicit acknowledgment of interrupts, to ack any pending interrupts and likewise to cache the original value.</li>
<li>For devices with implicit acknowledgment, this function will be empty. But the ISR must perform the actions needs to ack the interrupts (usually, call <a class="el" href="group__uart__interrupt.html#gab10942076ac47ecff29e924098049398" title="Read data from FIFO.">uart_fifo_read()</a> on rx_ready, and <a class="el" href="group__uart__interrupt.html#gafe42e4719eada7e25904bc9ebfe87791" title="Fill FIFO with data.">uart_fifo_fill()</a> on tx_ready).</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>UART device instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>On success. </td></tr>
    <tr><td class="paramname">-ENOSYS</td><td>If this function is not implemented. </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>If API is not enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Mar 5 2022 05:00:47 for Zephyr API Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
<script type="text/javascript">
  $(function() {
    toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
    toggleButton.title = "Toggle Light/Dark Mode"
    $(document).ready(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
    // every resize will remove the button, which is why it has to be added again:
    $(window).resize(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
  })
</script>
</body>
</html>
