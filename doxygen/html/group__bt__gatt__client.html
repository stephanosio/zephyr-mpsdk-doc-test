<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zephyr API Documentation: GATT Client APIs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-zephyr.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-zephyr.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Zephyr API Documentation
   &#160;<span id="projectnumber">3.0.0-rc3</span>
   </div>
   <div id="projectbrief">A Scalable Open Source RTOS</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__bt__gatt__client.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">GATT Client APIs<div class="ingroups"><a class="el" href="group__bluetooth.html">Bluetooth APIs</a> &raquo; <a class="el" href="group__bt__gatt.html">Generic Attribute Profile (GATT)</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__gatt__exchange__params.html">bt_gatt_exchange_params</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">GATT Exchange MTU parameters.  <a href="structbt__gatt__exchange__params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__gatt__discover__params.html">bt_gatt_discover_params</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">GATT Discover Attributes parameters.  <a href="structbt__gatt__discover__params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__gatt__read__params.html">bt_gatt_read_params</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">GATT Read parameters.  <a href="structbt__gatt__read__params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__gatt__write__params.html">bt_gatt_write_params</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">GATT Write parameters.  <a href="structbt__gatt__write__params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt__gatt__subscribe__params.html">bt_gatt_subscribe_params</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">GATT Subscribe parameters.  <a href="structbt__gatt__subscribe__params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga293c512555f2677f3c1b82c80f6fcfff"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="stdint_8h.html#a3cb4a16b0e8d6af0af86d4fd6ba5fd9d">uint8_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bt__gatt__client.html#ga293c512555f2677f3c1b82c80f6fcfff">bt_gatt_discover_func_t</a>) (struct bt_conn *conn, const struct <a class="el" href="structbt__gatt__attr.html">bt_gatt_attr</a> *attr, struct <a class="el" href="structbt__gatt__discover__params.html">bt_gatt_discover_params</a> *params)</td></tr>
<tr class="memdesc:ga293c512555f2677f3c1b82c80f6fcfff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discover attribute callback function.  <a href="group__bt__gatt__client.html#ga293c512555f2677f3c1b82c80f6fcfff">More...</a><br /></td></tr>
<tr class="separator:ga293c512555f2677f3c1b82c80f6fcfff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6961aab3df8b42f02f546516e15a0ad0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="stdint_8h.html#a3cb4a16b0e8d6af0af86d4fd6ba5fd9d">uint8_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bt__gatt__client.html#ga6961aab3df8b42f02f546516e15a0ad0">bt_gatt_read_func_t</a>) (struct bt_conn *conn, <a class="el" href="stdint_8h.html#a3cb4a16b0e8d6af0af86d4fd6ba5fd9d">uint8_t</a> err, struct <a class="el" href="structbt__gatt__read__params.html">bt_gatt_read_params</a> *params, const void *<a class="el" href="test__stack__fail_8c.html#a4bb6fa6c719fd9021449009ab8befc04">data</a>, <a class="el" href="stdint_8h.html#a5debae8b2a1ec20a6694c0c443ee399e">uint16_t</a> length)</td></tr>
<tr class="memdesc:ga6961aab3df8b42f02f546516e15a0ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read callback function.  <a href="group__bt__gatt__client.html#ga6961aab3df8b42f02f546516e15a0ad0">More...</a><br /></td></tr>
<tr class="separator:ga6961aab3df8b42f02f546516e15a0ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf70aa5f9a87d1edb1a7c50cd1f7ab234"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bt__gatt__client.html#gaf70aa5f9a87d1edb1a7c50cd1f7ab234">bt_gatt_write_func_t</a>) (struct bt_conn *conn, <a class="el" href="stdint_8h.html#a3cb4a16b0e8d6af0af86d4fd6ba5fd9d">uint8_t</a> err, struct <a class="el" href="structbt__gatt__write__params.html">bt_gatt_write_params</a> *params)</td></tr>
<tr class="memdesc:gaf70aa5f9a87d1edb1a7c50cd1f7ab234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write callback function.  <a href="group__bt__gatt__client.html#gaf70aa5f9a87d1edb1a7c50cd1f7ab234">More...</a><br /></td></tr>
<tr class="separator:gaf70aa5f9a87d1edb1a7c50cd1f7ab234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad38ed6884a40271e77b58632172674d5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="stdint_8h.html#a3cb4a16b0e8d6af0af86d4fd6ba5fd9d">uint8_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bt__gatt__client.html#gad38ed6884a40271e77b58632172674d5">bt_gatt_notify_func_t</a>) (struct bt_conn *conn, struct <a class="el" href="structbt__gatt__subscribe__params.html">bt_gatt_subscribe_params</a> *params, const void *<a class="el" href="test__stack__fail_8c.html#a4bb6fa6c719fd9021449009ab8befc04">data</a>, <a class="el" href="stdint_8h.html#a5debae8b2a1ec20a6694c0c443ee399e">uint16_t</a> length)</td></tr>
<tr class="memdesc:gad38ed6884a40271e77b58632172674d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notification callback function.  <a href="group__bt__gatt__client.html#gad38ed6884a40271e77b58632172674d5">More...</a><br /></td></tr>
<tr class="separator:gad38ed6884a40271e77b58632172674d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga9e93d8eae633734dfeb29e24a1f3a7c0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="group__bt__gatt__client.html#gga9e93d8eae633734dfeb29e24a1f3a7c0ada9ac33aa77f6043da8133dcf269478f">BT_GATT_DISCOVER_PRIMARY</a>
, <a class="el" href="group__bt__gatt__client.html#gga9e93d8eae633734dfeb29e24a1f3a7c0a21be62548b816c7960a54dd6e3b37a97">BT_GATT_DISCOVER_SECONDARY</a>
, <a class="el" href="group__bt__gatt__client.html#gga9e93d8eae633734dfeb29e24a1f3a7c0a80afff1c83bb5ebb5603af699f2c26da">BT_GATT_DISCOVER_INCLUDE</a>
, <a class="el" href="group__bt__gatt__client.html#gga9e93d8eae633734dfeb29e24a1f3a7c0a71355dfe0bf30c88f9fe2f7da1ba10ae">BT_GATT_DISCOVER_CHARACTERISTIC</a>
, <br />
&#160;&#160;<a class="el" href="group__bt__gatt__client.html#gga9e93d8eae633734dfeb29e24a1f3a7c0a0ccb2587aa8f21361c5d73847a33ecbe">BT_GATT_DISCOVER_DESCRIPTOR</a>
, <a class="el" href="group__bt__gatt__client.html#gga9e93d8eae633734dfeb29e24a1f3a7c0afe2167b873b848935d56f6ee7f2c444c">BT_GATT_DISCOVER_ATTRIBUTE</a>
, <a class="el" href="group__bt__gatt__client.html#gga9e93d8eae633734dfeb29e24a1f3a7c0a81a1f8737c415544a0f793f4e626bb61">BT_GATT_DISCOVER_STD_CHAR_DESC</a>
<br />
 }</td></tr>
<tr class="separator:ga9e93d8eae633734dfeb29e24a1f3a7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb8e1c282570d629a6b603a94a4650d6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="group__bt__gatt__client.html#ggaeb8e1c282570d629a6b603a94a4650d6aecdcb3baa850505f459523091c92a1cb">BT_GATT_SUBSCRIBE_FLAG_VOLATILE</a>
, <a class="el" href="group__bt__gatt__client.html#ggaeb8e1c282570d629a6b603a94a4650d6a30bfd3fb4bf4f17653ba00942ba2b2e6">BT_GATT_SUBSCRIBE_FLAG_NO_RESUB</a>
, <a class="el" href="group__bt__gatt__client.html#ggaeb8e1c282570d629a6b603a94a4650d6afe1c3dc9380c33debd32a275d5bce8ad">BT_GATT_SUBSCRIBE_FLAG_WRITE_PENDING</a>
, <a class="el" href="group__bt__gatt__client.html#ggaeb8e1c282570d629a6b603a94a4650d6a5640a1e06740a89859c5f4b183d58e79">BT_GATT_SUBSCRIBE_NUM_FLAGS</a>
 }</td></tr>
<tr class="separator:gaeb8e1c282570d629a6b603a94a4650d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0f41da23c6559a8254b04295aff8198d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bt__gatt__client.html#ga0f41da23c6559a8254b04295aff8198d">bt_gatt_exchange_mtu</a> (struct bt_conn *conn, struct <a class="el" href="structbt__gatt__exchange__params.html">bt_gatt_exchange_params</a> *params)</td></tr>
<tr class="memdesc:ga0f41da23c6559a8254b04295aff8198d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange MTU.  <a href="group__bt__gatt__client.html#ga0f41da23c6559a8254b04295aff8198d">More...</a><br /></td></tr>
<tr class="separator:ga0f41da23c6559a8254b04295aff8198d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac06a945e5f7939b6716bc4f2cea781bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bt__gatt__client.html#gac06a945e5f7939b6716bc4f2cea781bd">bt_gatt_discover</a> (struct bt_conn *conn, struct <a class="el" href="structbt__gatt__discover__params.html">bt_gatt_discover_params</a> *params)</td></tr>
<tr class="memdesc:gac06a945e5f7939b6716bc4f2cea781bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">GATT Discover function.  <a href="group__bt__gatt__client.html#gac06a945e5f7939b6716bc4f2cea781bd">More...</a><br /></td></tr>
<tr class="separator:gac06a945e5f7939b6716bc4f2cea781bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a18dd726ab960a88d7f85f2a014141a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bt__gatt__client.html#ga1a18dd726ab960a88d7f85f2a014141a">bt_gatt_read</a> (struct bt_conn *conn, struct <a class="el" href="structbt__gatt__read__params.html">bt_gatt_read_params</a> *params)</td></tr>
<tr class="memdesc:ga1a18dd726ab960a88d7f85f2a014141a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Attribute Value by handle.  <a href="group__bt__gatt__client.html#ga1a18dd726ab960a88d7f85f2a014141a">More...</a><br /></td></tr>
<tr class="separator:ga1a18dd726ab960a88d7f85f2a014141a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga843a42e68e0497d88d3f655f8ffd58d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bt__gatt__client.html#ga843a42e68e0497d88d3f655f8ffd58d4">bt_gatt_write</a> (struct bt_conn *conn, struct <a class="el" href="structbt__gatt__write__params.html">bt_gatt_write_params</a> *params)</td></tr>
<tr class="memdesc:ga843a42e68e0497d88d3f655f8ffd58d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write Attribute Value by handle.  <a href="group__bt__gatt__client.html#ga843a42e68e0497d88d3f655f8ffd58d4">More...</a><br /></td></tr>
<tr class="separator:ga843a42e68e0497d88d3f655f8ffd58d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49439413d12b5a8a1c68735e961ab6fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bt__gatt__client.html#ga49439413d12b5a8a1c68735e961ab6fa">bt_gatt_write_without_response_cb</a> (struct bt_conn *conn, <a class="el" href="stdint_8h.html#a5debae8b2a1ec20a6694c0c443ee399e">uint16_t</a> handle, const void *<a class="el" href="test__stack__fail_8c.html#a4bb6fa6c719fd9021449009ab8befc04">data</a>, <a class="el" href="stdint_8h.html#a5debae8b2a1ec20a6694c0c443ee399e">uint16_t</a> length, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> sign, <a class="el" href="group__bt__gatt__server.html#gac55832607b95f394d26a64ed1cfe5bba">bt_gatt_complete_func_t</a> func, void *<a class="el" href="timer_2timer__api_2src_2main_8c.html#a862de962130decf51321624c10294338">user_data</a>)</td></tr>
<tr class="memdesc:ga49439413d12b5a8a1c68735e961ab6fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write Attribute Value by handle without response with callback.  <a href="group__bt__gatt__client.html#ga49439413d12b5a8a1c68735e961ab6fa">More...</a><br /></td></tr>
<tr class="separator:ga49439413d12b5a8a1c68735e961ab6fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fc78e32230637a6f092da2400c50fe7"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bt__gatt__client.html#ga9fc78e32230637a6f092da2400c50fe7">bt_gatt_write_without_response</a> (struct bt_conn *conn, <a class="el" href="stdint_8h.html#a5debae8b2a1ec20a6694c0c443ee399e">uint16_t</a> handle, const void *<a class="el" href="test__stack__fail_8c.html#a4bb6fa6c719fd9021449009ab8befc04">data</a>, <a class="el" href="stdint_8h.html#a5debae8b2a1ec20a6694c0c443ee399e">uint16_t</a> length, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> sign)</td></tr>
<tr class="memdesc:ga9fc78e32230637a6f092da2400c50fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write Attribute Value by handle without response.  <a href="group__bt__gatt__client.html#ga9fc78e32230637a6f092da2400c50fe7">More...</a><br /></td></tr>
<tr class="separator:ga9fc78e32230637a6f092da2400c50fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d4a8e18f51ba6476886a15f81f48e5c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bt__gatt__client.html#ga7d4a8e18f51ba6476886a15f81f48e5c">bt_gatt_subscribe</a> (struct bt_conn *conn, struct <a class="el" href="structbt__gatt__subscribe__params.html">bt_gatt_subscribe_params</a> *params)</td></tr>
<tr class="memdesc:ga7d4a8e18f51ba6476886a15f81f48e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe Attribute Value Notification.  <a href="group__bt__gatt__client.html#ga7d4a8e18f51ba6476886a15f81f48e5c">More...</a><br /></td></tr>
<tr class="separator:ga7d4a8e18f51ba6476886a15f81f48e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga791b8bb8a4c085b022fafc0535a63511"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bt__gatt__client.html#ga791b8bb8a4c085b022fafc0535a63511">bt_gatt_resubscribe</a> (<a class="el" href="stdint_8h.html#a3cb4a16b0e8d6af0af86d4fd6ba5fd9d">uint8_t</a> id, const <a class="el" href="structbt__addr__le__t.html">bt_addr_le_t</a> *peer, struct <a class="el" href="structbt__gatt__subscribe__params.html">bt_gatt_subscribe_params</a> *params)</td></tr>
<tr class="memdesc:ga791b8bb8a4c085b022fafc0535a63511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resubscribe Attribute Value Notification subscription.  <a href="group__bt__gatt__client.html#ga791b8bb8a4c085b022fafc0535a63511">More...</a><br /></td></tr>
<tr class="separator:ga791b8bb8a4c085b022fafc0535a63511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56509c9b8f73f729cfa5e75be22d79ae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bt__gatt__client.html#ga56509c9b8f73f729cfa5e75be22d79ae">bt_gatt_unsubscribe</a> (struct bt_conn *conn, struct <a class="el" href="structbt__gatt__subscribe__params.html">bt_gatt_subscribe_params</a> *params)</td></tr>
<tr class="memdesc:ga56509c9b8f73f729cfa5e75be22d79ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe Attribute Value Notification.  <a href="group__bt__gatt__client.html#ga56509c9b8f73f729cfa5e75be22d79ae">More...</a><br /></td></tr>
<tr class="separator:ga56509c9b8f73f729cfa5e75be22d79ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5193dea59a016692f94cf950d6b4f4f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bt__gatt__client.html#ga5193dea59a016692f94cf950d6b4f4f7">bt_gatt_cancel</a> (struct bt_conn *conn, void *params)</td></tr>
<tr class="memdesc:ga5193dea59a016692f94cf950d6b4f4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to cancel the first pending request identified by <code>params</code>.  <a href="group__bt__gatt__client.html#ga5193dea59a016692f94cf950d6b4f4f7">More...</a><br /></td></tr>
<tr class="separator:ga5193dea59a016692f94cf950d6b4f4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga293c512555f2677f3c1b82c80f6fcfff" name="ga293c512555f2677f3c1b82c80f6fcfff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga293c512555f2677f3c1b82c80f6fcfff">&#9670;&nbsp;</a></span>bt_gatt_discover_func_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_gatt_discover_func_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="gatt_8h.html">include/bluetooth/gatt.h</a>&gt;</code></p>

<p>Discover attribute callback function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Connection object. </td></tr>
    <tr><td class="paramname">attr</td><td>Attribute found, or NULL if not found. </td></tr>
    <tr><td class="paramname">params</td><td>Discovery parameters given.</td></tr>
  </table>
  </dd>
</dl>
<p>If discovery procedure has completed this callback will be called with attr set to NULL. This will not happen if procedure was stopped by returning BT_GATT_ITER_STOP.</p>
<p >The attribute object as well as its UUID and value objects are temporary and must be copied to in order to cache its information. Only the following fields of the attribute contains valid information:</p><ul>
<li>uuid UUID representing the type of attribute.</li>
<li>handle Handle in the remote database.</li>
<li>user_data The value of the attribute. Will be NULL when discovering descriptors</li>
</ul>
<p >To be able to read the value of the discovered attribute the user_data must be cast to an appropriate type.</p><ul>
<li><a class="el" href="structbt__gatt__service__val.html">bt_gatt_service_val</a> when UUID is <a class="el" href="group__bt__uuid.html#ga6e87ce1575494eb90358e074e8dbe276">BT_UUID_GATT_PRIMARY</a> or <a class="el" href="group__bt__uuid.html#gad084d3658e663b6b8e200be256c54cdb">BT_UUID_GATT_SECONDARY</a>.</li>
<li><a class="el" href="structbt__gatt__include.html">bt_gatt_include</a> when UUID is <a class="el" href="group__bt__uuid.html#ga995596ff7374ebcb44d4706bc16234e4">BT_UUID_GATT_INCLUDE</a>.</li>
<li><a class="el" href="structbt__gatt__chrc.html">bt_gatt_chrc</a> when UUID is <a class="el" href="group__bt__uuid.html#gadcedbbe1c432c4ac737e54b318e01a0f">BT_UUID_GATT_CHRC</a>.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>BT_GATT_ITER_CONTINUE to continue discovery procedure. </dd>
<dd>
BT_GATT_ITER_STOP to stop discovery procedure. </dd></dl>

</div>
</div>
<a id="gad38ed6884a40271e77b58632172674d5" name="gad38ed6884a40271e77b58632172674d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad38ed6884a40271e77b58632172674d5">&#9670;&nbsp;</a></span>bt_gatt_notify_func_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_gatt_notify_func_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="gatt_8h.html">include/bluetooth/gatt.h</a>&gt;</code></p>

<p>Notification callback function. </p>
<p >In the case of an empty notification, the <code>data</code> pointer will be non-NULL while the <code>length</code> will be 0, which is due to the special case where a <code>data</code> NULL pointer means unsubscribed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Connection object. May be NULL, indicating that the peer is being unpaired </td></tr>
    <tr><td class="paramname">params</td><td>Subscription parameters. </td></tr>
    <tr><td class="paramname">data</td><td>Attribute value data. If NULL then subscription was removed. </td></tr>
    <tr><td class="paramname">length</td><td>Attribute value length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BT_GATT_ITER_CONTINUE to continue receiving value notifications. BT_GATT_ITER_STOP to unsubscribe from value notifications. </dd></dl>

</div>
</div>
<a id="ga6961aab3df8b42f02f546516e15a0ad0" name="ga6961aab3df8b42f02f546516e15a0ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6961aab3df8b42f02f546516e15a0ad0">&#9670;&nbsp;</a></span>bt_gatt_read_func_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_gatt_read_func_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="gatt_8h.html">include/bluetooth/gatt.h</a>&gt;</code></p>

<p>Read callback function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Connection object. </td></tr>
    <tr><td class="paramname">err</td><td>ATT error code. </td></tr>
    <tr><td class="paramname">params</td><td>Read parameters used. </td></tr>
    <tr><td class="paramname">data</td><td>Attribute value data. NULL means read has completed. </td></tr>
    <tr><td class="paramname">length</td><td>Attribute value length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BT_GATT_ITER_CONTINUE if should continue to the next attribute. </dd>
<dd>
BT_GATT_ITER_STOP to stop. </dd></dl>

</div>
</div>
<a id="gaf70aa5f9a87d1edb1a7c50cd1f7ab234" name="gaf70aa5f9a87d1edb1a7c50cd1f7ab234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf70aa5f9a87d1edb1a7c50cd1f7ab234">&#9670;&nbsp;</a></span>bt_gatt_write_func_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bt_gatt_write_func_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="gatt_8h.html">include/bluetooth/gatt.h</a>&gt;</code></p>

<p>Write callback function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Connection object. </td></tr>
    <tr><td class="paramname">err</td><td>ATT error code. </td></tr>
    <tr><td class="paramname">params</td><td>Write parameters used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga9e93d8eae633734dfeb29e24a1f3a7c0" name="ga9e93d8eae633734dfeb29e24a1f3a7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e93d8eae633734dfeb29e24a1f3a7c0">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="gatt_8h.html">include/bluetooth/gatt.h</a>&gt;</code></p>
<p >GATT Discover types </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9e93d8eae633734dfeb29e24a1f3a7c0ada9ac33aa77f6043da8133dcf269478f" name="gga9e93d8eae633734dfeb29e24a1f3a7c0ada9ac33aa77f6043da8133dcf269478f"></a>BT_GATT_DISCOVER_PRIMARY&#160;</td><td class="fielddoc"><p >Discover Primary Services. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9e93d8eae633734dfeb29e24a1f3a7c0a21be62548b816c7960a54dd6e3b37a97" name="gga9e93d8eae633734dfeb29e24a1f3a7c0a21be62548b816c7960a54dd6e3b37a97"></a>BT_GATT_DISCOVER_SECONDARY&#160;</td><td class="fielddoc"><p >Discover Secondary Services. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9e93d8eae633734dfeb29e24a1f3a7c0a80afff1c83bb5ebb5603af699f2c26da" name="gga9e93d8eae633734dfeb29e24a1f3a7c0a80afff1c83bb5ebb5603af699f2c26da"></a>BT_GATT_DISCOVER_INCLUDE&#160;</td><td class="fielddoc"><p >Discover Included Services. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9e93d8eae633734dfeb29e24a1f3a7c0a71355dfe0bf30c88f9fe2f7da1ba10ae" name="gga9e93d8eae633734dfeb29e24a1f3a7c0a71355dfe0bf30c88f9fe2f7da1ba10ae"></a>BT_GATT_DISCOVER_CHARACTERISTIC&#160;</td><td class="fielddoc"><p >Discover Characteristic Values. </p>
<pre class="fragment">    Discover Characteristic Value and its properties.
</pre> </td></tr>
<tr><td class="fieldname"><a id="gga9e93d8eae633734dfeb29e24a1f3a7c0a0ccb2587aa8f21361c5d73847a33ecbe" name="gga9e93d8eae633734dfeb29e24a1f3a7c0a0ccb2587aa8f21361c5d73847a33ecbe"></a>BT_GATT_DISCOVER_DESCRIPTOR&#160;</td><td class="fielddoc"><p >Discover Descriptors. </p>
<pre class="fragment">    Discover Attributes which are not services or characteristics.

    @note The use of this type of discover is not recommended for
          discovering in ranges across multiple services/characteristics
          as it may incur in extra round trips.
</pre> </td></tr>
<tr><td class="fieldname"><a id="gga9e93d8eae633734dfeb29e24a1f3a7c0afe2167b873b848935d56f6ee7f2c444c" name="gga9e93d8eae633734dfeb29e24a1f3a7c0afe2167b873b848935d56f6ee7f2c444c"></a>BT_GATT_DISCOVER_ATTRIBUTE&#160;</td><td class="fielddoc"><p >Discover Attributes. </p>
<pre class="fragment">    Discover Attributes of any type.

    @note The use of this type of discover is not recommended for
          discovering in ranges across multiple services/characteristics
          as it may incur in more round trips.
</pre> </td></tr>
<tr><td class="fieldname"><a id="gga9e93d8eae633734dfeb29e24a1f3a7c0a81a1f8737c415544a0f793f4e626bb61" name="gga9e93d8eae633734dfeb29e24a1f3a7c0a81a1f8737c415544a0f793f4e626bb61"></a>BT_GATT_DISCOVER_STD_CHAR_DESC&#160;</td><td class="fielddoc"><p >Discover standard characteristic descriptor values. </p>
<pre class="fragment">    Discover standard characterestic descriptor values and their
    properties.
    Supported descriptors:
     - Characteristic Extended Properties
     - Client Characteristic Configuration
     - Server Characteristic Configuration
     - Characteristic Presentation Format
</pre> </td></tr>
</table>

</div>
</div>
<a id="gaeb8e1c282570d629a6b603a94a4650d6" name="gaeb8e1c282570d629a6b603a94a4650d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb8e1c282570d629a6b603a94a4650d6">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="gatt_8h.html">include/bluetooth/gatt.h</a>&gt;</code></p>
<p >Subscription flags </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaeb8e1c282570d629a6b603a94a4650d6aecdcb3baa850505f459523091c92a1cb" name="ggaeb8e1c282570d629a6b603a94a4650d6aecdcb3baa850505f459523091c92a1cb"></a>BT_GATT_SUBSCRIBE_FLAG_VOLATILE&#160;</td><td class="fielddoc"><p >Persistence flag. </p>
<pre class="fragment">    If set, indicates that the subscription is not saved
    on the GATT server side. Therefore, upon disconnection,
    the subscription will be automatically removed
    from the client's subscriptions list and
    when the client reconnects, it will have to
    issue a new subscription.
</pre> </td></tr>
<tr><td class="fieldname"><a id="ggaeb8e1c282570d629a6b603a94a4650d6a30bfd3fb4bf4f17653ba00942ba2b2e6" name="ggaeb8e1c282570d629a6b603a94a4650d6a30bfd3fb4bf4f17653ba00942ba2b2e6"></a>BT_GATT_SUBSCRIBE_FLAG_NO_RESUB&#160;</td><td class="fielddoc"><p >No resubscribe flag. </p>
<pre class="fragment">    By default when BT_GATT_SUBSCRIBE_FLAG_VOLATILE is unset, the
    subscription will be automatically renewed when the client
    reconnects, as a workaround for GATT servers that do not persist
    subscriptions.

    This flag will disable the automatic resubscription. It is useful
    if the application layer knows that the GATT server remembers
    subscriptions from previous connections and wants to avoid renewing
    the subscriptions.
</pre> </td></tr>
<tr><td class="fieldname"><a id="ggaeb8e1c282570d629a6b603a94a4650d6afe1c3dc9380c33debd32a275d5bce8ad" name="ggaeb8e1c282570d629a6b603a94a4650d6afe1c3dc9380c33debd32a275d5bce8ad"></a>BT_GATT_SUBSCRIBE_FLAG_WRITE_PENDING&#160;</td><td class="fielddoc"><p >Write pending flag. </p>
<pre class="fragment">    If set, indicates write operation is pending waiting remote end to
    respond.
</pre> </td></tr>
<tr><td class="fieldname"><a id="ggaeb8e1c282570d629a6b603a94a4650d6a5640a1e06740a89859c5f4b183d58e79" name="ggaeb8e1c282570d629a6b603a94a4650d6a5640a1e06740a89859c5f4b183d58e79"></a>BT_GATT_SUBSCRIBE_NUM_FLAGS&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga5193dea59a016692f94cf950d6b4f4f7" name="ga5193dea59a016692f94cf950d6b4f4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5193dea59a016692f94cf950d6b4f4f7">&#9670;&nbsp;</a></span>bt_gatt_cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bt_gatt_cancel </td>
          <td>(</td>
          <td class="paramtype">struct bt_conn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="gatt_8h.html">include/bluetooth/gatt.h</a>&gt;</code></p>

<p>Try to cancel the first pending request identified by <code>params</code>. </p>
<p >This function does not release <code>params</code> for reuse. The usual callbacks for the request still apply. A successful cancel simulates a <a class="el" href="att_8h.html#a992baa1f0d763a00f314bdcf59965bdd">BT_ATT_ERR_UNLIKELY</a> response from the server.</p>
<p >This function can cancel the following request functions:</p><ul>
<li><a class="el" href="group__bt__gatt__client.html#ga0f41da23c6559a8254b04295aff8198d" title="Exchange MTU.">bt_gatt_exchange_mtu</a></li>
<li><a class="el" href="group__bt__gatt__client.html#gac06a945e5f7939b6716bc4f2cea781bd" title="GATT Discover function.">bt_gatt_discover</a></li>
<li><a class="el" href="group__bt__gatt__client.html#ga1a18dd726ab960a88d7f85f2a014141a" title="Read Attribute Value by handle.">bt_gatt_read</a></li>
<li><a class="el" href="group__bt__gatt__client.html#ga843a42e68e0497d88d3f655f8ffd58d4" title="Write Attribute Value by handle.">bt_gatt_write</a></li>
<li><a class="el" href="group__bt__gatt__client.html#ga7d4a8e18f51ba6476886a15f81f48e5c" title="Subscribe Attribute Value Notification.">bt_gatt_subscribe</a></li>
<li><a class="el" href="group__bt__gatt__client.html#ga56509c9b8f73f729cfa5e75be22d79ae" title="Unsubscribe Attribute Value Notification.">bt_gatt_unsubscribe</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>The connection the request was issued on. </td></tr>
    <tr><td class="paramname">params</td><td>The address <code>params</code> used in the request function call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac06a945e5f7939b6716bc4f2cea781bd" name="gac06a945e5f7939b6716bc4f2cea781bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac06a945e5f7939b6716bc4f2cea781bd">&#9670;&nbsp;</a></span>bt_gatt_discover()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bt_gatt_discover </td>
          <td>(</td>
          <td class="paramtype">struct bt_conn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbt__gatt__discover__params.html">bt_gatt_discover_params</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="gatt_8h.html">include/bluetooth/gatt.h</a>&gt;</code></p>

<p>GATT Discover function. </p>
<p >This procedure is used by a client to discover attributes on a server.</p>
<p >Primary Service Discovery: Procedure allows to discover specific Primary Service based on UUID. Include Service Discovery: Procedure allows to discover all Include Services within specified range. Characteristic Discovery: Procedure allows to discover all characteristics within specified handle range as well as discover characteristics with specified UUID. Descriptors Discovery: Procedure allows to discover all characteristic descriptors within specified range.</p>
<p >For each attribute found the callback is called which can then decide whether to continue discovering or stop.</p>
<p >The Response comes in callback <code>params-&gt;func</code>. The callback is run from the BT RX thread. <code>params</code> must remain valid until start of callback where iter <code>attr</code> is <code>NULL</code> or callback will return <code>BT_GATT_ITER_STOP</code>.</p>
<p >This function will block while the ATT request queue is full, except when called from the BT RX thread, as this would cause a deadlock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Connection object. </td></tr>
    <tr><td class="paramname">params</td><td>Discover parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Successfully queued request. Will call <code>params-&gt;func</code> on resolution.</td></tr>
    <tr><td class="paramname">-ENOMEM</td><td>ATT request queue is full and blocking would cause deadlock. Allow a pending request to resolve before retrying, or call this function outside the BT RX thread to get blocking behavior. Queue size is controlled by <pre class="fragment">embed:rst:inline :kconfig:`CONFIG_BT_L2CAP_TX_BUF_COUNT` </pre>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0f41da23c6559a8254b04295aff8198d" name="ga0f41da23c6559a8254b04295aff8198d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f41da23c6559a8254b04295aff8198d">&#9670;&nbsp;</a></span>bt_gatt_exchange_mtu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bt_gatt_exchange_mtu </td>
          <td>(</td>
          <td class="paramtype">struct bt_conn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbt__gatt__exchange__params.html">bt_gatt_exchange_params</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="gatt_8h.html">include/bluetooth/gatt.h</a>&gt;</code></p>

<p>Exchange MTU. </p>
<p >This client procedure can be used to set the MTU to the maximum possible size the buffers can hold.</p>
<dl class="section note"><dt>Note</dt><dd>Shall only be used once per connection.</dd></dl>
<p>The Response comes in callback <code>params-&gt;func</code>. The callback is run from the BT RX thread. <code>params</code> must remain valid until start of callback.</p>
<p >This function will block while the ATT request queue is full, except when called from the BT RX thread, as this would cause a deadlock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Connection object. </td></tr>
    <tr><td class="paramname">params</td><td>Exchange MTU parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Successfully queued request. Will call <code>params-&gt;func</code> on resolution.</td></tr>
    <tr><td class="paramname">-ENOMEM</td><td>ATT request queue is full and blocking would cause deadlock. Allow a pending request to resolve before retrying, or call this function outside the BT RX thread to get blocking behavior. Queue size is controlled by <pre class="fragment">embed:rst:inline :kconfig:`CONFIG_BT_L2CAP_TX_BUF_COUNT` </pre>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1a18dd726ab960a88d7f85f2a014141a" name="ga1a18dd726ab960a88d7f85f2a014141a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a18dd726ab960a88d7f85f2a014141a">&#9670;&nbsp;</a></span>bt_gatt_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bt_gatt_read </td>
          <td>(</td>
          <td class="paramtype">struct bt_conn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbt__gatt__read__params.html">bt_gatt_read_params</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="gatt_8h.html">include/bluetooth/gatt.h</a>&gt;</code></p>

<p>Read Attribute Value by handle. </p>
<p >This procedure read the attribute value and return it to the callback.</p>
<p >When reading attributes by UUID the callback can be called multiple times depending on how many instances of given the UUID exists with the start_handle being updated for each instance.</p>
<p >If an instance does contain a long value which cannot be read entirely the caller will need to read the remaining data separately using the handle and offset.</p>
<p >The Response comes in callback <code>params-&gt;func</code>. The callback is run from the BT RX thread. <code>params</code> must remain valid until start of callback.</p>
<p >This function will block while the ATT request queue is full, except when called from the BT RX thread, as this would cause a deadlock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Connection object. </td></tr>
    <tr><td class="paramname">params</td><td>Read parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Successfully queued request. Will call <code>params-&gt;func</code> on resolution.</td></tr>
    <tr><td class="paramname">-ENOMEM</td><td>ATT request queue is full and blocking would cause deadlock. Allow a pending request to resolve before retrying, or call this function outside the BT RX thread to get blocking behavior. Queue size is controlled by <pre class="fragment">embed:rst:inline :kconfig:`CONFIG_BT_L2CAP_TX_BUF_COUNT` </pre>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga791b8bb8a4c085b022fafc0535a63511" name="ga791b8bb8a4c085b022fafc0535a63511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga791b8bb8a4c085b022fafc0535a63511">&#9670;&nbsp;</a></span>bt_gatt_resubscribe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bt_gatt_resubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a3cb4a16b0e8d6af0af86d4fd6ba5fd9d">uint8_t</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbt__addr__le__t.html">bt_addr_le_t</a> *&#160;</td>
          <td class="paramname"><em>peer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbt__gatt__subscribe__params.html">bt_gatt_subscribe_params</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="gatt_8h.html">include/bluetooth/gatt.h</a>&gt;</code></p>

<p>Resubscribe Attribute Value Notification subscription. </p>
<p >Resubscribe to Attribute Value Notification when already subscribed from a previous connection. The GATT server will remember subscription from previous connections when bonded, so resubscribing can be done without performing a new subscribe procedure after a power cycle.</p>
<dl class="section note"><dt>Note</dt><dd>Notifications are asynchronous therefore the parameters need to remain valid while subscribed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Local identity (in most cases BT_ID_DEFAULT). </td></tr>
    <tr><td class="paramname">peer</td><td>Remote address. </td></tr>
    <tr><td class="paramname">params</td><td>Subscribe parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 in case of success or negative value in case of error. </dd></dl>

</div>
</div>
<a id="ga7d4a8e18f51ba6476886a15f81f48e5c" name="ga7d4a8e18f51ba6476886a15f81f48e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d4a8e18f51ba6476886a15f81f48e5c">&#9670;&nbsp;</a></span>bt_gatt_subscribe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bt_gatt_subscribe </td>
          <td>(</td>
          <td class="paramtype">struct bt_conn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbt__gatt__subscribe__params.html">bt_gatt_subscribe_params</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="gatt_8h.html">include/bluetooth/gatt.h</a>&gt;</code></p>

<p>Subscribe Attribute Value Notification. </p>
<p >This procedure subscribe to value notification using the Client Characteristic Configuration handle. If notification received subscribe value callback is called to return notified value. One may then decide whether to unsubscribe directly from this callback. Notification callback with NULL data will not be called if subscription was removed by this method.</p>
<p >The Response comes in callback <code>params-&gt;func</code>. The callback is run from the BT RX thread. <code>params</code> must remain valid until start of callback. The Notification callback <code>params-&gt;notify</code> is also called from the BT RX thread.</p>
<dl class="section note"><dt>Note</dt><dd>Notifications are asynchronous therefore the parameters need to remain valid while subscribed.</dd></dl>
<p>This function will block while the ATT request queue is full, except when called from the BT RX thread, as this would cause a deadlock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Connection object. </td></tr>
    <tr><td class="paramname">params</td><td>Subscribe parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Successfully queued request. Will call <code>params-&gt;write</code> on resolution.</td></tr>
    <tr><td class="paramname">-ENOMEM</td><td>ATT request queue is full and blocking would cause deadlock. Allow a pending request to resolve before retrying, or call this function outside the BT RX thread to get blocking behavior. Queue size is controlled by <pre class="fragment">embed:rst:inline :kconfig:`CONFIG_BT_L2CAP_TX_BUF_COUNT` </pre>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga56509c9b8f73f729cfa5e75be22d79ae" name="ga56509c9b8f73f729cfa5e75be22d79ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56509c9b8f73f729cfa5e75be22d79ae">&#9670;&nbsp;</a></span>bt_gatt_unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bt_gatt_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">struct bt_conn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbt__gatt__subscribe__params.html">bt_gatt_subscribe_params</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="gatt_8h.html">include/bluetooth/gatt.h</a>&gt;</code></p>

<p>Unsubscribe Attribute Value Notification. </p>
<p >This procedure unsubscribe to value notification using the Client Characteristic Configuration handle. Notification callback with NULL data will be called if subscription was removed by this call, until then the parameters cannot be reused.</p>
<p >The Response comes in callback <code>params-&gt;func</code>. The callback is run from the BT RX thread.</p>
<p >This function will block while the ATT request queue is full, except when called from the BT RX thread, as this would cause a deadlock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Connection object. </td></tr>
    <tr><td class="paramname">params</td><td>Subscribe parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Successfully queued request. Will call <code>params-&gt;write</code> on resolution.</td></tr>
    <tr><td class="paramname">-ENOMEM</td><td>ATT request queue is full and blocking would cause deadlock. Allow a pending request to resolve before retrying, or call this function outside the BT RX thread to get blocking behavior. Queue size is controlled by <pre class="fragment">embed:rst:inline :kconfig:`CONFIG_BT_L2CAP_TX_BUF_COUNT` </pre>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga843a42e68e0497d88d3f655f8ffd58d4" name="ga843a42e68e0497d88d3f655f8ffd58d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga843a42e68e0497d88d3f655f8ffd58d4">&#9670;&nbsp;</a></span>bt_gatt_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bt_gatt_write </td>
          <td>(</td>
          <td class="paramtype">struct bt_conn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbt__gatt__write__params.html">bt_gatt_write_params</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="gatt_8h.html">include/bluetooth/gatt.h</a>&gt;</code></p>

<p>Write Attribute Value by handle. </p>
<p >The Response comes in callback <code>params-&gt;func</code>. The callback is run from the BT RX thread. <code>params</code> must remain valid until start of callback.</p>
<p >This function will block while the ATT request queue is full, except when called from Bluetooth event context. When called from Bluetooth context, this function will instead instead return <code>-ENOMEM</code> if it would block to avoid a deadlock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Connection object. </td></tr>
    <tr><td class="paramname">params</td><td>Write parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Successfully queued request. Will call <code>params-&gt;func</code> on resolution.</td></tr>
    <tr><td class="paramname">-ENOMEM</td><td>ATT request queue is full and blocking would cause deadlock. Allow a pending request to resolve before retrying, or call this function outside Bluetooth event context to get blocking behavior. Queue size is controlled by <pre class="fragment">embed:rst:inline :kconfig:`CONFIG_BT_L2CAP_TX_BUF_COUNT` </pre>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9fc78e32230637a6f092da2400c50fe7" name="ga9fc78e32230637a6f092da2400c50fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fc78e32230637a6f092da2400c50fe7">&#9670;&nbsp;</a></span>bt_gatt_write_without_response()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int bt_gatt_write_without_response </td>
          <td>(</td>
          <td class="paramtype">struct bt_conn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a5debae8b2a1ec20a6694c0c443ee399e">uint16_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a5debae8b2a1ec20a6694c0c443ee399e">uint16_t</a>&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>sign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="gatt_8h.html">include/bluetooth/gatt.h</a>&gt;</code></p>

<p>Write Attribute Value by handle without response. </p>
<p >This procedure write the attribute value without requiring an acknowledgment that the write was successfully performed</p>
<p >This function will block while the ATT request queue is full, except when called from the BT RX thread, as this would cause a deadlock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Connection object. </td></tr>
    <tr><td class="paramname">handle</td><td>Attribute handle. </td></tr>
    <tr><td class="paramname">data</td><td>Data to be written. </td></tr>
    <tr><td class="paramname">length</td><td>Data length. </td></tr>
    <tr><td class="paramname">sign</td><td>Whether to sign data</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Successfully queued request.</td></tr>
    <tr><td class="paramname">-ENOMEM</td><td>ATT request queue is full and blocking would cause deadlock. Allow a pending request to resolve before retrying, or call this function outside the BT RX thread to get blocking behavior. Queue size is controlled by <pre class="fragment">embed:rst:inline :kconfig:`CONFIG_BT_L2CAP_TX_BUF_COUNT` </pre>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga49439413d12b5a8a1c68735e961ab6fa" name="ga49439413d12b5a8a1c68735e961ab6fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49439413d12b5a8a1c68735e961ab6fa">&#9670;&nbsp;</a></span>bt_gatt_write_without_response_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bt_gatt_write_without_response_cb </td>
          <td>(</td>
          <td class="paramtype">struct bt_conn *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a5debae8b2a1ec20a6694c0c443ee399e">uint16_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a5debae8b2a1ec20a6694c0c443ee399e">uint16_t</a>&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bt__gatt__server.html#gac55832607b95f394d26a64ed1cfe5bba">bt_gatt_complete_func_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="gatt_8h.html">include/bluetooth/gatt.h</a>&gt;</code></p>

<p>Write Attribute Value by handle without response with callback. </p>
<p >This function works in the same way as <a class="el" href="group__bt__gatt__client.html#ga9fc78e32230637a6f092da2400c50fe7">bt_gatt_write_without_response</a>. With the addition that after sending the write the callback function will be called.</p>
<p >The callback is run from System Workqueue context. When called from the System Workqueue context this API will not wait for resources for the callback but instead return an error. The number of pending callbacks can be increased with the </p><pre class="fragment">embed:rst:inline :kconfig:`CONFIG_BT_CONN_TX_MAX` </pre><p> option.</p>
<dl class="section note"><dt>Note</dt><dd>By using a callback it also disable the internal flow control which would prevent sending multiple commands without waiting for their transmissions to complete, so if that is required the caller shall not submit more data until the callback is called.</dd></dl>
<p>This function will block while the ATT request queue is full, except when called from the BT RX thread, as this would cause a deadlock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Connection object. </td></tr>
    <tr><td class="paramname">handle</td><td>Attribute handle. </td></tr>
    <tr><td class="paramname">data</td><td>Data to be written. </td></tr>
    <tr><td class="paramname">length</td><td>Data length. </td></tr>
    <tr><td class="paramname">sign</td><td>Whether to sign data </td></tr>
    <tr><td class="paramname">func</td><td>Transmission complete callback. </td></tr>
    <tr><td class="paramname">user_data</td><td>User data to be passed back to callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Successfully queued request.</td></tr>
    <tr><td class="paramname">-ENOMEM</td><td>ATT request queue is full and blocking would cause deadlock. Allow a pending request to resolve before retrying, or call this function outside the BT RX thread to get blocking behavior. Queue size is controlled by <pre class="fragment">embed:rst:inline :kconfig:`CONFIG_BT_L2CAP_TX_BUF_COUNT` </pre>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Feb 21 2022 04:59:41 for Zephyr API Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
<script type="text/javascript">
  $(function() {
    toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
    toggleButton.title = "Toggle Light/Dark Mode"
    $(document).ready(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
    // every resize will remove the button, which is why it has to be added again:
    $(window).resize(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
  })
</script>
</body>
</html>
