<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.2" xml:lang="en-US">
  <compounddef id="group__device__model" kind="group">
    <compoundname>device_model</compoundname>
    <title>Device Model APIs</title>
    <innerclass refid="structdevice__state" prot="public">device_state</innerclass>
    <innerclass refid="structdevice" prot="public">device</innerclass>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="group__device__model_1ga21415b8e9967ecd2c3d3d3b1724f93c3" prot="public" static="no">
        <type><ref refid="stdint_8h_1afe270aee8d96ad7f279a4020b9d58bdf" kindref="member">int16_t</ref></type>
        <definition>typedef int16_t device_handle_t</definition>
        <argsstring></argsstring>
        <name>device_handle_t</name>
        <briefdescription>
<para>Type used to represent a &quot;handle&quot; for a device. </para>
        </briefdescription>
        <detaileddescription>
<para>Every struct device has an associated handle. You can get a pointer to a device structure from its handle and vice versa, but the handle uses less space than a pointer. The device.h API mainly uses handles to store lists of multiple devices in a compact way.</para>
<para>The extreme values and zero have special significance. Negative values identify functionality that does not correspond to a Zephyr device, such as the system clock or a <ref refid="group__device__model_1ga1e50fdff086356a75b0e91179952cc8d" kindref="member">SYS_INIT()</ref> function.</para>
<para><simplesect kind="see"><para><ref refid="group__device__model_1ga456366a9ca0a8e97484c97c279745203" kindref="member">device_handle_get()</ref> </para>
</simplesect>
<simplesect kind="see"><para><ref refid="group__device__model_1ga73680daef9f8d7dc2541d83d09737f4a" kindref="member">device_from_handle()</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/device.h" line="53" column="17" bodyfile="include/device.h" bodystart="53" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__device__model_1ga9a1118e5c76c44c998f7258a7de0bfbb" prot="public" static="no">
        <type>int(*</type>
        <definition>typedef int(* device_visitor_callback_t) (const struct device *dev, void *context)</definition>
        <argsstring>)(const struct device *dev, void *context)</argsstring>
        <name>device_visitor_callback_t</name>
        <briefdescription>
<para>Prototype for functions used when iterating over a set of devices. </para>
        </briefdescription>
        <detaileddescription>
<para>Such a function may be used in API that identifies a set of devices and provides a visitor API supporting caller-specific interaction with each device in the set.</para>
<para>The visit is said to succeed if the visitor returns a non-negative value.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev</parametername>
</parameternamelist>
<parameterdescription>
<para>a device in the set being iterated</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>context</parametername>
</parameternamelist>
<parameterdescription>
<para>state used to support the visitor function</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A non-negative number to allow walking to continue, and a negative error code to case the iteration to stop.</para>
</simplesect>
<simplesect kind="see"><para><ref refid="group__device__model_1ga6e3b6dbb15ca28d6c94ee07702663245" kindref="member">device_required_foreach()</ref> </para>
</simplesect>
<simplesect kind="see"><para><ref refid="group__device__model_1gaf5fce5e93fd6d5e13aa8b20251b82b2a" kindref="member">device_supported_foreach()</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/device.h" line="541" column="9" bodyfile="include/device.h" bodystart="541" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__device__model_1ga456366a9ca0a8e97484c97c279745203" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="group__device__model_1ga21415b8e9967ecd2c3d3d3b1724f93c3" kindref="member">device_handle_t</ref></type>
        <definition>static device_handle_t device_handle_get</definition>
        <argsstring>(const struct device *dev)</argsstring>
        <name>device_handle_get</name>
        <param>
          <type>const struct <ref refid="structdevice" kindref="compound">device</ref> *</type>
          <declname>dev</declname>
        </param>
        <briefdescription>
<para>Get the handle for a given device. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev</parametername>
</parameternamelist>
<parameterdescription>
<para>the device for which a handle is desired.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the handle for the device, or DEVICE_HANDLE_NULL if the device does not have an associated handle. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/device.h" line="484" column="1" bodyfile="include/device.h" bodystart="484" bodyend="497"/>
      </memberdef>
      <memberdef kind="function" id="group__device__model_1ga73680daef9f8d7dc2541d83d09737f4a" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const struct <ref refid="structdevice" kindref="compound">device</ref> *</type>
        <definition>static const struct device * device_from_handle</definition>
        <argsstring>(device_handle_t dev_handle)</argsstring>
        <name>device_from_handle</name>
        <param>
          <type><ref refid="group__device__model_1ga21415b8e9967ecd2c3d3d3b1724f93c3" kindref="member">device_handle_t</ref></type>
          <declname>dev_handle</declname>
        </param>
        <briefdescription>
<para>Get the device corresponding to a handle. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>the device handle</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the device that has that handle, or a null pointer if <computeroutput>dev_handle</computeroutput> does not identify a device. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/device.h" line="508" column="1" bodyfile="include/device.h" bodystart="508" bodyend="520"/>
      </memberdef>
      <memberdef kind="function" id="group__device__model_1ga2157bbfc2deecfae6514f58221663618" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const <ref refid="group__device__model_1ga21415b8e9967ecd2c3d3d3b1724f93c3" kindref="member">device_handle_t</ref> *</type>
        <definition>static const device_handle_t * device_required_handles_get</definition>
        <argsstring>(const struct device *dev, size_t *count)</argsstring>
        <name>device_required_handles_get</name>
        <param>
          <type>const struct <ref refid="structdevice" kindref="compound">device</ref> *</type>
          <declname>dev</declname>
        </param>
        <param>
          <type>size_t *</type>
          <declname>count</declname>
        </param>
        <briefdescription>
<para>Get the device handles for devicetree dependencies of this device. </para>
        </briefdescription>
        <detaileddescription>
<para>This function returns a pointer to an array of device handles. The length of the array is stored in the <computeroutput>count</computeroutput> parameter.</para>
<para>The array contains a handle for each device that <computeroutput>dev</computeroutput> requires directly, as determined from the devicetree. This does not include transitive dependencies; you must recursively determine those.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev</parametername>
</parameternamelist>
<parameterdescription>
<para>the device for which dependencies are desired.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to where this function should store the length of the returned array. No value is stored if the call returns a null pointer. The value may be set to zero if the device has no devicetree dependencies.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a pointer to a sequence of <computeroutput>*count</computeroutput> device handles, or a null pointer if <computeroutput>dev</computeroutput> does not have any dependency data. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/device.h" line="564" column="1" bodyfile="include/device.h" bodystart="564" bodyend="580"/>
      </memberdef>
      <memberdef kind="function" id="group__device__model_1ga3c9ae15d3224c792b915b107b2d5d00f" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const <ref refid="group__device__model_1ga21415b8e9967ecd2c3d3d3b1724f93c3" kindref="member">device_handle_t</ref> *</type>
        <definition>static const device_handle_t * device_supported_handles_get</definition>
        <argsstring>(const struct device *dev, size_t *count)</argsstring>
        <name>device_supported_handles_get</name>
        <param>
          <type>const struct <ref refid="structdevice" kindref="compound">device</ref> *</type>
          <declname>dev</declname>
        </param>
        <param>
          <type>size_t *</type>
          <declname>count</declname>
        </param>
        <briefdescription>
<para>Get the set of handles that this device supports. </para>
        </briefdescription>
        <detaileddescription>
<para>This function returns a pointer to an array of device handles. The length of the array is stored in the <computeroutput>count</computeroutput> parameter.</para>
<para>The array contains a handle for each device that <computeroutput>dev</computeroutput> &quot;supports&quot; <ndash/> that is, devices that require <computeroutput>dev</computeroutput> directly <ndash/> as determined from the devicetree. This does not include transitive dependencies; you must recursively determine those.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev</parametername>
</parameternamelist>
<parameterdescription>
<para>the device for which supports are desired.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to where this function should store the length of the returned array. No value is stored if the call returns a null pointer. The value may be set to zero if nothing in the devicetree depends on <computeroutput>dev</computeroutput>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a pointer to a sequence of <computeroutput>*count</computeroutput> device handles, or a null pointer if <computeroutput>dev</computeroutput> does not have any dependency data. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/device.h" line="604" column="1" bodyfile="include/device.h" bodystart="604" bodyend="627"/>
      </memberdef>
      <memberdef kind="function" id="group__device__model_1ga6e3b6dbb15ca28d6c94ee07702663245" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int device_required_foreach</definition>
        <argsstring>(const struct device *dev, device_visitor_callback_t visitor_cb, void *context)</argsstring>
        <name>device_required_foreach</name>
        <param>
          <type>const struct <ref refid="structdevice" kindref="compound">device</ref> *</type>
          <declname>dev</declname>
        </param>
        <param>
          <type><ref refid="group__device__model_1ga9a1118e5c76c44c998f7258a7de0bfbb" kindref="member">device_visitor_callback_t</ref></type>
          <declname>visitor_cb</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>context</declname>
        </param>
        <briefdescription>
<para>Visit every device that <computeroutput>dev</computeroutput> directly requires. </para>
        </briefdescription>
        <detaileddescription>
<para>Zephyr maintains information about which devices are directly required by another device; for example an I2C-based sensor driver will require an I2C controller for communication. Required devices can derive from statically-defined devicetree relationships or dependencies registered at runtime.</para>
<para>This API supports operating on the set of required devices. Example uses include making sure required devices are ready before the requiring device is used, and releasing them when the requiring device is no longer needed.</para>
<para>There is no guarantee on the order in which required devices are visited.</para>
<para>If the <computeroutput>visitor</computeroutput> function returns a negative value iteration is halted, and the returned value from the visitor is returned from this function.</para>
<para><simplesect kind="note"><para>This API is not available to unprivileged threads.</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev</parametername>
</parameternamelist>
<parameterdescription>
<para>a device of interest. The devices that this device depends on will be used as the set of devices to visit. This parameter must not be null.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>visitor_cb</parametername>
</parameternamelist>
<parameterdescription>
<para>the function that should be invoked on each device in the dependency set. This parameter must not be null.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>context</parametername>
</parameternamelist>
<parameterdescription>
<para>state that is passed through to the visitor function. This parameter may be null if <computeroutput>visitor</computeroutput> tolerates a null <computeroutput>context</computeroutput>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The number of devices that were visited if all visits succeed, or the negative value returned from the first visit that did not succeed. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/device.h" line="662" column="5" declfile="include/device.h" declline="662" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__device__model_1gaf5fce5e93fd6d5e13aa8b20251b82b2a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int device_supported_foreach</definition>
        <argsstring>(const struct device *dev, device_visitor_callback_t visitor_cb, void *context)</argsstring>
        <name>device_supported_foreach</name>
        <param>
          <type>const struct <ref refid="structdevice" kindref="compound">device</ref> *</type>
          <declname>dev</declname>
        </param>
        <param>
          <type><ref refid="group__device__model_1ga9a1118e5c76c44c998f7258a7de0bfbb" kindref="member">device_visitor_callback_t</ref></type>
          <declname>visitor_cb</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>context</declname>
        </param>
        <briefdescription>
<para>Visit every device that <computeroutput>dev</computeroutput> directly supports. </para>
        </briefdescription>
        <detaileddescription>
<para>Zephyr maintains information about which devices are directly supported by another device; for example an I2C controller will support an I2C-based sensor driver. Supported devices can derive from statically-defined devicetree relationships.</para>
<para>This API supports operating on the set of supported devices. Example uses include iterating over the devices connected to a regulator when it is powered on.</para>
<para>There is no guarantee on the order in which required devices are visited.</para>
<para>If the <computeroutput>visitor</computeroutput> function returns a negative value iteration is halted, and the returned value from the visitor is returned from this function.</para>
<para><simplesect kind="note"><para>This API is not available to unprivileged threads.</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev</parametername>
</parameternamelist>
<parameterdescription>
<para>a device of interest. The devices that this device supports will be used as the set of devices to visit. This parameter must not be null.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>visitor_cb</parametername>
</parameternamelist>
<parameterdescription>
<para>the function that should be invoked on each device in the support set. This parameter must not be null.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>context</parametername>
</parameternamelist>
<parameterdescription>
<para>state that is passed through to the visitor function. This parameter may be null if <computeroutput>visitor</computeroutput> tolerates a null <computeroutput>context</computeroutput>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The number of devices that were visited if all visits succeed, or the negative value returned from the first visit that did not succeed. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/device.h" line="698" column="5" declfile="include/device.h" declline="698" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__device__model_1ga15386ca9ab38f3e30183c18f604fa835" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const struct <ref refid="structdevice" kindref="compound">device</ref> *</type>
        <definition>const struct device * device_get_binding</definition>
        <argsstring>(const char *name)</argsstring>
        <name>device_get_binding</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Get a <computeroutput>const struct device*</computeroutput> from its <computeroutput>name</computeroutput> field. </para>
        </briefdescription>
        <detaileddescription>
<para>This function iterates through the devices on the system. If a device with the given <computeroutput>name</computeroutput> field is found, and that device initialized successfully at boot time, this function returns a pointer to the device.</para>
<para>If no device has the given name, this function returns NULL.</para>
<para>This function also returns NULL when a device is found, but it failed to initialize successfully at boot time. (To troubleshoot this case, set a breakpoint on your device driver&apos;s initialization function.)</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>device name to search for. A null pointer, or a pointer to an empty string, will cause NULL to be returned.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>pointer to device structure with the given name; NULL if the device is not found or if the device with that name&apos;s initialization function failed. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/device.h" line="724" column="20" declfile="include/device.h" declline="724" declcolumn="20"/>
      </memberdef>
      <memberdef kind="function" id="group__device__model_1gaa4944bd850e90cbd52b0489f9b12edfb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="stdbool_8h_1abb452686968e48b67397da5f97445f5b" kindref="member">bool</ref></type>
        <definition>bool device_is_ready</definition>
        <argsstring>(const struct device *dev)</argsstring>
        <name>device_is_ready</name>
        <param>
          <type>const struct <ref refid="structdevice" kindref="compound">device</ref> *</type>
          <declname>dev</declname>
        </param>
        <briefdescription>
<para>Verify that a device is ready for use. </para>
        </briefdescription>
        <detaileddescription>
<para>Indicates whether the provided device pointer is for a device known to be in a state where it can be used with its standard API.</para>
<para>This can be used with device pointers captured from <ref refid="group__device__model_1ga9a65996ce21f43acb7db061e23b48ec7" kindref="member">DEVICE_DT_GET()</ref>, which does not include the readiness checks of <ref refid="group__device__model_1ga15386ca9ab38f3e30183c18f604fa835" kindref="member">device_get_binding()</ref>. At minimum this means that the device has been successfully initialized.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the device in question.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>true</parametername>
</parameternamelist>
<parameterdescription>
<para>If the device is ready for use. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>false</parametername>
</parameternamelist>
<parameterdescription>
<para>If the device is not ready for use or if a NULL device pointer is passed as argument. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/device.h" line="767" column="7" declfile="include/device.h" declline="767" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="group__device__model_1ga233b32dc38630069c1aee973fa52416e" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>static int device_usable_check</definition>
        <argsstring>(const struct device *dev)</argsstring>
        <name>device_usable_check</name>
        <param>
          <type>const struct <ref refid="structdevice" kindref="compound">device</ref> *</type>
          <declname>dev</declname>
        </param>
        <briefdescription>
<para>Determine whether a device is ready for use. </para>
        </briefdescription>
        <detaileddescription>
<para><xrefsect id="deprecated_1_deprecated000003"><xreftitle>Deprecated</xreftitle><xrefdescription><para>Use <ref refid="group__device__model_1gaa4944bd850e90cbd52b0489f9b12edfb" kindref="member">device_is_ready()</ref> instead.</para>
</xrefdescription></xrefsect></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev</parametername>
</parameternamelist>
<parameterdescription>
<para>Device instance.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>0</parametername>
</parameternamelist>
<parameterdescription>
<para>If device is usable. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>-ENODEV</parametername>
</parameternamelist>
<parameterdescription>
<para>If device is not usable. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/device.h" line="802" column="20" bodyfile="include/device.h" bodystart="802" bodyend="805"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="define">
      <memberdef kind="define" id="group__device__model_1ga5f1feab331ee737141f418030902aab0" prot="public" static="no">
        <name>DEVICE_HANDLE_SEP</name>
        <initializer><ref refid="stdint_8h_1ad4e9955955b27624963643eac448118a" kindref="member">INT16_MIN</ref></initializer>
        <briefdescription>
<para>Flag value used in lists of device handles to separate distinct groups. </para>
        </briefdescription>
        <detaileddescription>
<para>This is the minimum value for the device_handle_t type. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/device.h" line="60" column="9" bodyfile="include/device.h" bodystart="60" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__device__model_1gab83f6fdc3d5d6e68facad0ddc9f3e763" prot="public" static="no">
        <name>DEVICE_HANDLE_ENDS</name>
        <initializer><ref refid="stdint_8h_1ac58f2c111cc9989c86db2a7dc4fd84ca" kindref="member">INT16_MAX</ref></initializer>
        <briefdescription>
<para>Flag value used in lists of device handles to indicate the end of the list. </para>
        </briefdescription>
        <detaileddescription>
<para>This is the maximum value for the device_handle_t type. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/device.h" line="67" column="9" bodyfile="include/device.h" bodystart="67" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__device__model_1ga4dd918c3a59b8afa185a4851165d2ca0" prot="public" static="no">
        <name>DEVICE_HANDLE_NULL</name>
        <initializer>0</initializer>
        <briefdescription>
<para>Flag value used to identify an unknown device. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/device.h" line="70" column="9" bodyfile="include/device.h" bodystart="70" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__device__model_1ga51d735464c6c80e86ebae96b0b67947b" prot="public" static="no">
        <name>DEVICE_NAME_GET</name>
        <param><defname>name</defname></param>
        <initializer>_CONCAT(__device_, name)</initializer>
        <briefdescription>
<para>Expands to the name of a global device object. </para>
        </briefdescription>
        <detaileddescription>
<para>Return the full name of a device object symbol created by <ref refid="group__device__model_1gad08683c204de0996ca62b23813947009" kindref="member">DEVICE_DEFINE()</ref>, using the dev_name provided to <ref refid="group__device__model_1gad08683c204de0996ca62b23813947009" kindref="member">DEVICE_DEFINE()</ref>. This is the name of the global variable storing the device structure, not a pointer to the string in the device&apos;s <computeroutput>name</computeroutput> field.</para>
<para>It is meant to be used for declaring extern symbols pointing to device objects before using the DEVICE_GET macro to get the device object.</para>
<para>This macro is normally only useful within device driver source code. In other situations, you are probably looking for <ref refid="group__device__model_1ga15386ca9ab38f3e30183c18f604fa835" kindref="member">device_get_binding()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The same <computeroutput>dev_name</computeroutput> token given to <ref refid="group__device__model_1gad08683c204de0996ca62b23813947009" kindref="member">DEVICE_DEFINE()</ref></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The full name of the device object defined by <ref refid="group__device__model_1gad08683c204de0996ca62b23813947009" kindref="member">DEVICE_DEFINE()</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/device.h" line="96" column="9" bodyfile="include/device.h" bodystart="96" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__device__model_1ga42092d245664c3d59c30ceb4776bd642" prot="public" static="no">
        <name>SYS_DEVICE_DEFINE</name>
        <param><defname>drv_name</defname></param>
        <param><defname>init_fn</defname></param>
        <param><defname>level</defname></param>
        <param><defname>prio</defname></param>
        <initializer>	__DEPRECATED_MACRO <ref refid="early__sleep_2src_2main_8c_1a080adab9e7b88edfe90c6d2115d9d06e" kindref="member">SYS_INIT</ref>(init_fn, level, prio)</initializer>
        <briefdescription>
<para>Run an initialization function at boot at specified priority. </para>
        </briefdescription>
        <detaileddescription>
<para><xrefsect id="deprecated_1_deprecated000001"><xreftitle>Deprecated</xreftitle><xrefdescription><para>Use <ref refid="group__device__model_1ga1e50fdff086356a75b0e91179952cc8d" kindref="member">SYS_INIT()</ref> instead.</para>
</xrefdescription></xrefsect></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>drv_name</parametername>
</parameternamelist>
<parameterdescription>
<para>A string name for the pseudo-device (unused). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>init_fn</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the function which should run at boot time. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>level</parametername>
</parameternamelist>
<parameterdescription>
<para>Initialization level to run the function in. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>prio</parametername>
</parameternamelist>
<parameterdescription>
<para>Function&apos;s priority within its initialization level. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/device.h" line="110" column="9" bodyfile="include/device.h" bodystart="110" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__device__model_1gad08683c204de0996ca62b23813947009" prot="public" static="no">
        <name>DEVICE_DEFINE</name>
        <param><defname>dev_name</defname></param>
        <param><defname>drv_name</defname></param>
        <param><defname>init_fn</defname></param>
        <param><defname>pm_device</defname></param>
        <param><defname>data_ptr</defname></param>
        <param><defname>cfg_ptr</defname></param>
        <param><defname>level</defname></param>
        <param><defname>prio</defname></param>
        <param><defname>api_ptr</defname></param>
        <initializer>	Z_DEVICE_STATE_DEFINE(<ref refid="group__devicetree-generic-id_1ga710cc4455dd7e738f43f750153163855" kindref="member">DT_INVALID_NODE</ref>, dev_name) \
	Z_DEVICE_DEFINE(<ref refid="group__devicetree-generic-id_1ga710cc4455dd7e738f43f750153163855" kindref="member">DT_INVALID_NODE</ref>, dev_name, drv_name, init_fn,	\
			pm_device,					\
			data_ptr, cfg_ptr, level, prio, api_ptr,	\
			&amp;Z_DEVICE_STATE_NAME(dev_name))</initializer>
        <briefdescription>
<para>Create a device object and set it up for boot time initialization. </para>
        </briefdescription>
        <detaileddescription>
<para>This macro defines a <computeroutput>struct device</computeroutput> that is automatically configured by the kernel during system initialization. This macro should only be used when the device is not being allocated from a devicetree node. If you are allocating a device from a devicetree node, use <ref refid="group__device__model_1gaac590af7705a3223968164406a483548" kindref="member">DEVICE_DT_DEFINE()</ref> or <ref refid="group__device__model_1gada5ba4aca9e0662ccebb2232c7256419" kindref="member">DEVICE_DT_INST_DEFINE()</ref> instead.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev_name</parametername>
</parameternamelist>
<parameterdescription>
<para>A unique token which is used in the name of the global device structure as a C identifier.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>drv_name</parametername>
</parameternamelist>
<parameterdescription>
<para>A string name for the device, which will be stored in the device structure&apos;s <computeroutput>name</computeroutput> field. This name can be used to look up the device with <ref refid="group__device__model_1ga15386ca9ab38f3e30183c18f604fa835" kindref="member">device_get_binding()</ref>. This must be less than Z_DEVICE_MAX_NAME_LEN characters (including terminating NUL) in order to be looked up from user mode.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>init_fn</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the device&apos;s initialization function, which will be run by the kernel during system initialization.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pm_device</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the device&apos;s power management resources, a <computeroutput>struct pm_device</computeroutput>, which will be stored in the device structure&apos;s <computeroutput>pm</computeroutput> field. Use NULL if the device does not use PM.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>data_ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the device&apos;s private mutable data, which will be stored in the device structure&apos;s <computeroutput>data</computeroutput> field.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cfg_ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the device&apos;s private constant data, which will be stored in the device structure&apos;s <computeroutput>config</computeroutput> field.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>level</parametername>
</parameternamelist>
<parameterdescription>
<para>The device&apos;s initialization level. See <ref refid="group__device__model_1ga1e50fdff086356a75b0e91179952cc8d" kindref="member">SYS_INIT()</ref> for details.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>prio</parametername>
</parameternamelist>
<parameterdescription>
<para>The device&apos;s priority within its initialization level. See <ref refid="group__device__model_1ga1e50fdff086356a75b0e91179952cc8d" kindref="member">SYS_INIT()</ref> for details.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>api_ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the device&apos;s API structure. Can be NULL. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/device.h" line="182" column="9" bodyfile="include/device.h" bodystart="181" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__device__model_1gad864d7a50ee45285dacd68be1e5a49ce" prot="public" static="no">
        <name>DEVICE_DT_NAME</name>
        <param><defname>node_id</defname></param>
        <initializer>	<ref refid="group__devicetree-generic-prop_1ga5e5bfc9b1a6627b3f73014329e96340f" kindref="member">DT_PROP_OR</ref>(node_id, label, <ref refid="group__devicetree-generic-id_1ga8a8ab5d12fe59787433d1add94fb1667" kindref="member">DT_NODE_FULL_NAME</ref>(node_id))</initializer>
        <briefdescription>
<para>Return a string name for a devicetree node. </para>
        </briefdescription>
        <detaileddescription>
<para>This macro returns a string literal usable as a device&apos;s <computeroutput>name</computeroutput> field from a devicetree node identifier.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>node_id</parametername>
</parameternamelist>
<parameterdescription>
<para>The devicetree node identifier.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The value of the node&apos;s &quot;label&quot; property, if it has one. Otherwise, the node&apos;s full name in &quot;node-name@@unit-address&quot; form. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/device.h" line="202" column="9" bodyfile="include/device.h" bodystart="202" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__device__model_1gaac590af7705a3223968164406a483548" prot="public" static="no">
        <name>DEVICE_DT_DEFINE</name>
        <param><defname>node_id</defname></param>
        <param><defname>init_fn</defname></param>
        <param><defname>pm_device</defname></param>
        <param><defname>data_ptr</defname></param>
        <param><defname>cfg_ptr</defname></param>
        <param><defname>level</defname></param>
        <param><defname>prio</defname></param>
        <param><defname>api_ptr</defname></param>
        <param><defname>...</defname></param>
        <initializer>	Z_DEVICE_STATE_DEFINE(node_id, Z_DEVICE_DT_DEV_NAME(node_id)) \
	Z_DEVICE_DEFINE(node_id, Z_DEVICE_DT_DEV_NAME(node_id),		\
			<ref refid="group__device__model_1gad864d7a50ee45285dacd68be1e5a49ce" kindref="member">DEVICE_DT_NAME</ref>(node_id), init_fn,		\
			pm_device,					\
			data_ptr, cfg_ptr, level, prio,			\
			api_ptr,					\
			&amp;Z_DEVICE_STATE_NAME(Z_DEVICE_DT_DEV_NAME(node_id)),	\
			__VA_ARGS__)</initializer>
        <briefdescription>
<para>Create a device object from a devicetree node identifier and set it up for boot time initialization. </para>
        </briefdescription>
        <detaileddescription>
<para>This macro defines a <computeroutput>struct device</computeroutput> that is automatically configured by the kernel during system initialization. The global device object&apos;s name as a C identifier is derived from the node&apos;s dependency ordinal. The device structure&apos;s <computeroutput>name</computeroutput> field is set to <computeroutput><ref refid="group__device__model_1gad864d7a50ee45285dacd68be1e5a49ce" kindref="member">DEVICE_DT_NAME(node_id)</ref></computeroutput>.</para>
<para>The device is declared with extern visibility, so a pointer to a global device object can be obtained with <computeroutput><ref refid="group__device__model_1ga9a65996ce21f43acb7db061e23b48ec7" kindref="member">DEVICE_DT_GET(node_id)</ref></computeroutput> from any source file that includes device.h. Before using the pointer, the referenced object should be checked using <ref refid="group__device__model_1gaa4944bd850e90cbd52b0489f9b12edfb" kindref="member">device_is_ready()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>node_id</parametername>
</parameternamelist>
<parameterdescription>
<para>The devicetree node identifier.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>init_fn</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the device&apos;s initialization function, which will be run by the kernel during system initialization.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pm_device</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the device&apos;s power management resources, a <computeroutput>struct pm_device</computeroutput>, which will be stored in the device structure&apos;s <computeroutput>pm</computeroutput> field. Use NULL if the device does not use PM.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>data_ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the device&apos;s private mutable data, which will be stored in the device structure&apos;s <computeroutput>data</computeroutput> field.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cfg_ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the device&apos;s private constant data, which will be stored in the device structure&apos;s <computeroutput>config</computeroutput> field.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>level</parametername>
</parameternamelist>
<parameterdescription>
<para>The device&apos;s initialization level. See <ref refid="group__device__model_1ga1e50fdff086356a75b0e91179952cc8d" kindref="member">SYS_INIT()</ref> for details.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>prio</parametername>
</parameternamelist>
<parameterdescription>
<para>The device&apos;s priority within its initialization level. See <ref refid="group__device__model_1ga1e50fdff086356a75b0e91179952cc8d" kindref="member">SYS_INIT()</ref> for details.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>api_ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the device&apos;s API structure. Can be NULL. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/device.h" line="250" column="9" bodyfile="include/device.h" bodystart="248" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__device__model_1gada5ba4aca9e0662ccebb2232c7256419" prot="public" static="no">
        <name>DEVICE_DT_INST_DEFINE</name>
        <param><defname>inst</defname></param>
        <param><defname>...</defname></param>
        <initializer>	<ref refid="group__device__model_1gaac590af7705a3223968164406a483548" kindref="member">DEVICE_DT_DEFINE</ref>(<ref refid="group__devicetree-inst_1ga219f413efba2f4c0151468b9a25a8dc1" kindref="member">DT_DRV_INST</ref>(inst), __VA_ARGS__)</initializer>
        <briefdescription>
<para>Like <ref refid="group__device__model_1gaac590af7705a3223968164406a483548" kindref="member">DEVICE_DT_DEFINE()</ref>, but uses an instance of a DT_DRV_COMPAT compatible instead of a node identifier. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>inst</parametername>
</parameternamelist>
<parameterdescription>
<para>instance number. The <computeroutput>node_id</computeroutput> argument to DEVICE_DT_DEFINE is set to <computeroutput><ref refid="group__devicetree-inst_1ga219f413efba2f4c0151468b9a25a8dc1" kindref="member">DT_DRV_INST(inst)</ref></computeroutput>.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>...</parametername>
</parameternamelist>
<parameterdescription>
<para>other parameters as expected by DEVICE_DT_DEFINE. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/device.h" line="271" column="9" bodyfile="include/device.h" bodystart="271" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__device__model_1ga8ebbf17ef805817aa638f36f177a1a0e" prot="public" static="no">
        <name>DEVICE_DT_NAME_GET</name>
        <param><defname>node_id</defname></param>
        <initializer><ref refid="group__device__model_1ga51d735464c6c80e86ebae96b0b67947b" kindref="member">DEVICE_NAME_GET</ref>(Z_DEVICE_DT_DEV_NAME(node_id))</initializer>
        <briefdescription>
<para>The name of the global device object for <computeroutput>node_id</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>Returns the name of the global device structure as a C identifier. The device must be allocated using <ref refid="group__device__model_1gaac590af7705a3223968164406a483548" kindref="member">DEVICE_DT_DEFINE()</ref> or <ref refid="group__device__model_1gada5ba4aca9e0662ccebb2232c7256419" kindref="member">DEVICE_DT_INST_DEFINE()</ref> for this to work.</para>
<para>This macro is normally only useful within device driver source code. In other situations, you are probably looking for <ref refid="group__device__model_1ga9a65996ce21f43acb7db061e23b48ec7" kindref="member">DEVICE_DT_GET()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>node_id</parametername>
</parameternamelist>
<parameterdescription>
<para>Devicetree node identifier</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The name of the device object as a C identifier </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/device.h" line="291" column="9" bodyfile="include/device.h" bodystart="291" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__device__model_1ga9a65996ce21f43acb7db061e23b48ec7" prot="public" static="no">
        <name>DEVICE_DT_GET</name>
        <param><defname>node_id</defname></param>
        <initializer>(&amp;<ref refid="group__device__model_1ga8ebbf17ef805817aa638f36f177a1a0e" kindref="member">DEVICE_DT_NAME_GET</ref>(node_id))</initializer>
        <briefdescription>
<para>Get a <computeroutput>const struct device*</computeroutput> from a devicetree node identifier. </para>
        </briefdescription>
        <detaileddescription>
<para>Returns a pointer to a device object created from a devicetree node, if any device was allocated by a driver.</para>
<para>If no such device was allocated, this will fail at linker time. If you get an error that looks like <computeroutput>undefined reference to __device_dts_ord_&lt;N&gt;</computeroutput>, that is what happened. Check to make sure your device driver is being compiled, usually by enabling the Kconfig options it requires.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>node_id</parametername>
</parameternamelist>
<parameterdescription>
<para>A devicetree node identifier </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A pointer to the device object created for that node </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/device.h" line="311" column="9" bodyfile="include/device.h" bodystart="311" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__device__model_1ga9165e550ae175ce305eafe33390af78b" prot="public" static="no">
        <name>DEVICE_DT_INST_GET</name>
        <param><defname>inst</defname></param>
        <initializer><ref refid="group__device__model_1ga9a65996ce21f43acb7db061e23b48ec7" kindref="member">DEVICE_DT_GET</ref>(<ref refid="group__devicetree-inst_1ga219f413efba2f4c0151468b9a25a8dc1" kindref="member">DT_DRV_INST</ref>(inst))</initializer>
        <briefdescription>
<para>Get a <computeroutput>const struct device*</computeroutput> for an instance of a DT_DRV_COMPAT compatible. </para>
        </briefdescription>
        <detaileddescription>
<para>This is equivalent to <computeroutput><ref refid="group__device__model_1ga9a65996ce21f43acb7db061e23b48ec7" kindref="member">DEVICE_DT_GET(DT_DRV_INST(inst))</ref></computeroutput>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>inst</parametername>
</parameternamelist>
<parameterdescription>
<para>DT_DRV_COMPAT instance number </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A pointer to the device object created for that instance </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/device.h" line="323" column="9" bodyfile="include/device.h" bodystart="323" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__device__model_1gaadf3ffb63df544eb3de356ab2c5e9e3c" prot="public" static="no">
        <name>DEVICE_DT_GET_ANY</name>
        <param><defname>compat</defname></param>
        <initializer>	<ref refid="group__sys-util_1ga358bc3e7669c860a98839a51cd526b20" kindref="member">COND_CODE_1</ref>(<ref refid="group__devicetree-generic-exist_1ga916e11b66fdaab46e93c25241b62b52a" kindref="member">DT_HAS_COMPAT_STATUS_OKAY</ref>(compat),			    \
		    (<ref refid="group__device__model_1ga9a65996ce21f43acb7db061e23b48ec7" kindref="member">DEVICE_DT_GET</ref>(<ref refid="group__devicetree-generic-id_1ga4858c378b098dcb7c35de1db25442acc" kindref="member">DT_COMPAT_GET_ANY_STATUS_OKAY</ref>(compat))), \
		    (NULL))</initializer>
        <briefdescription>
<para>Get a <computeroutput>const struct device*</computeroutput> from a devicetree compatible. </para>
        </briefdescription>
        <detaileddescription>
<para>If an enabled devicetree node has the given compatible and a device object was created from it, this returns a pointer to that device.</para>
<para>If there no such devices, this returns NULL.</para>
<para>If there are multiple, this returns an arbitrary one.</para>
<para>If this returns non-NULL, the device must be checked for readiness before use, e.g. with <ref refid="group__device__model_1gaa4944bd850e90cbd52b0489f9b12edfb" kindref="member">device_is_ready()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>compat</parametername>
</parameternamelist>
<parameterdescription>
<para>lowercase-and-underscores devicetree compatible </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a pointer to a device, or NULL </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/device.h" line="343" column="9" bodyfile="include/device.h" bodystart="343" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__device__model_1ga39c760429534ef9ae77f3d996987cd2b" prot="public" static="no">
        <name>DEVICE_DT_GET_ONE</name>
        <param><defname>compat</defname></param>
        <initializer>	<ref refid="group__sys-util_1ga358bc3e7669c860a98839a51cd526b20" kindref="member">COND_CODE_1</ref>(<ref refid="group__devicetree-generic-exist_1ga916e11b66fdaab46e93c25241b62b52a" kindref="member">DT_HAS_COMPAT_STATUS_OKAY</ref>(compat),			    \
		    (<ref refid="group__device__model_1ga9a65996ce21f43acb7db061e23b48ec7" kindref="member">DEVICE_DT_GET</ref>(<ref refid="group__devicetree-generic-id_1ga4858c378b098dcb7c35de1db25442acc" kindref="member">DT_COMPAT_GET_ANY_STATUS_OKAY</ref>(compat))), \
		    (<ref refid="group__sys-util_1ga831cb8468911b8ebdb9b42682778e53d" kindref="member">ZERO_OR_COMPILE_ERROR</ref>(0)))</initializer>
        <briefdescription>
<para>Get a <computeroutput>const struct device*</computeroutput> from a devicetree compatible. </para>
        </briefdescription>
        <detaileddescription>
<para>If an enabled devicetree node has the given compatible and a device object was created from it, this returns a pointer to that device.</para>
<para>If there no such devices, this will fail at compile time.</para>
<para>If there are multiple, this returns an arbitrary one.</para>
<para>If this returns non-NULL, the device must be checked for readiness before use, e.g. with <ref refid="group__device__model_1gaa4944bd850e90cbd52b0489f9b12edfb" kindref="member">device_is_ready()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>compat</parametername>
</parameternamelist>
<parameterdescription>
<para>lowercase-and-underscores devicetree compatible </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a pointer to a device </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/device.h" line="367" column="9" bodyfile="include/device.h" bodystart="367" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__device__model_1ga6ce1dbfda6847ca6c3858712e9b41989" prot="public" static="no">
        <name>DEVICE_DT_GET_OR_NULL</name>
        <param><defname>node_id</defname></param>
        <initializer>	<ref refid="group__sys-util_1ga358bc3e7669c860a98839a51cd526b20" kindref="member">COND_CODE_1</ref>(<ref refid="group__devicetree-generic-exist_1ga3b769d8105c7679e1d0575a1e7f1f653" kindref="member">DT_NODE_HAS_STATUS</ref>(node_id, okay),			\
		    (<ref refid="group__device__model_1ga9a65996ce21f43acb7db061e23b48ec7" kindref="member">DEVICE_DT_GET</ref>(node_id)), (NULL))</initializer>
        <briefdescription>
<para>Utility macro to obtain an optional reference to a device. </para>
        </briefdescription>
        <detaileddescription>
<para>If the node identifier refers to a node with status &quot;okay&quot;, this returns <computeroutput><ref refid="group__device__model_1ga9a65996ce21f43acb7db061e23b48ec7" kindref="member">DEVICE_DT_GET(node_id)</ref></computeroutput>. Otherwise, it returns NULL.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>node_id</parametername>
</parameternamelist>
<parameterdescription>
<para>devicetree node identifier</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <computeroutput>const struct device*</computeroutput> for the node identifier, which may be NULL. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/device.h" line="386" column="9" bodyfile="include/device.h" bodystart="386" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__device__model_1ga78e63e230be7dfe525a2de03e503be53" prot="public" static="no">
        <name>DEVICE_GET</name>
        <param><defname>name</defname></param>
        <initializer>(&amp;<ref refid="group__device__model_1ga51d735464c6c80e86ebae96b0b67947b" kindref="member">DEVICE_NAME_GET</ref>(name))</initializer>
        <briefdescription>
<para>Obtain a pointer to a device object by name. </para>
        </briefdescription>
        <detaileddescription>
<para>Return the address of a device object created by <ref refid="group__device__model_1gad08683c204de0996ca62b23813947009" kindref="member">DEVICE_DEFINE()</ref>, using the dev_name provided to <ref refid="group__device__model_1gad08683c204de0996ca62b23813947009" kindref="member">DEVICE_DEFINE()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The same as dev_name provided to <ref refid="group__device__model_1gad08683c204de0996ca62b23813947009" kindref="member">DEVICE_DEFINE()</ref></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A pointer to the device object created by <ref refid="group__device__model_1gad08683c204de0996ca62b23813947009" kindref="member">DEVICE_DEFINE()</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/device.h" line="402" column="9" bodyfile="include/device.h" bodystart="402" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__device__model_1ga5d8d574ffe22938ca58dcb74bf289428" prot="public" static="no">
        <name>DEVICE_DECLARE</name>
        <param><defname>name</defname></param>
        <initializer>static const struct <ref refid="structdevice" kindref="compound">device</ref> <ref refid="group__device__model_1ga51d735464c6c80e86ebae96b0b67947b" kindref="member">DEVICE_NAME_GET</ref>(name)</initializer>
        <briefdescription>
<para>Declare a static device object. </para>
        </briefdescription>
        <detaileddescription>
<para>This macro can be used at the top-level to declare a device, such that <ref refid="group__device__model_1ga78e63e230be7dfe525a2de03e503be53" kindref="member">DEVICE_GET()</ref> may be used before the full declaration in <ref refid="group__device__model_1gad08683c204de0996ca62b23813947009" kindref="member">DEVICE_DEFINE()</ref>.</para>
<para>This is often useful when configuring interrupts statically in a device&apos;s init or per-instance config function, as the init function itself is required by <ref refid="group__device__model_1gad08683c204de0996ca62b23813947009" kindref="member">DEVICE_DEFINE()</ref> and use of <ref refid="group__device__model_1ga78e63e230be7dfe525a2de03e503be53" kindref="member">DEVICE_GET()</ref> inside it creates a circular dependency.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>Device name </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/device.h" line="419" column="9" bodyfile="include/device.h" bodystart="419" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__device__model_1ga1e50fdff086356a75b0e91179952cc8d" prot="public" static="no">
        <name>SYS_INIT</name>
        <param><defname>_init_fn</defname></param>
        <param><defname>_level</defname></param>
        <param><defname>_prio</defname></param>
        <initializer>	Z_INIT_ENTRY_DEFINE(Z_SYS_NAME(_init_fn), _init_fn, NULL, _level, _prio)</initializer>
        <briefdescription>
<para>Run an initialization function at boot at specified priority. </para>
        </briefdescription>
        <detaileddescription>
<para>This macro lets you run a function at system boot.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>_init_fn</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the boot function to run</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>_level</parametername>
</parameternamelist>
<parameterdescription>
<para>The initialization level at which configuration occurs. Must be one of the following symbols, which are listed in the order they are performed by the kernel: <linebreak/>
<itemizedlist>
<listitem><para>PRE_KERNEL_1: Used for initialization objects that have no dependencies, such as those that rely solely on hardware present in the processor/SOC. These objects cannot use any kernel services during configuration, since they are not yet available. <linebreak/>
</para>
</listitem>
<listitem><para>PRE_KERNEL_2: Used for initialization objects that rely on objects initialized as part of the PRE_KERNEL_1 level. These objects cannot use any kernel services during configuration, since they are not yet available. <linebreak/>
</para>
</listitem>
<listitem><para>POST_KERNEL: Used for initialization objects that require kernel services during configuration. <linebreak/>
</para>
</listitem>
<listitem><para>POST_KERNEL_SMP: Used for initialization objects that require kernel services during configuration after SMP initialization. <linebreak/>
</para>
</listitem>
<listitem><para>APPLICATION: Used for application components (i.e. non-kernel components) that need automatic configuration. These objects can use all services provided by the kernel during configuration.</para>
</listitem>
</itemizedlist>
</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>_prio</parametername>
</parameternamelist>
<parameterdescription>
<para>The initialization priority of the object, relative to other objects of the same initialization level. Specified as an integer value in the range 0 to 99; lower values indicate earlier initialization. Must be a decimal integer literal without leading zeroes or sign (e.g. 32), or an equivalent symbolic name (e.g. #define MY_INIT_PRIO 32); symbolic expressions are <emphasis>not</emphasis> permitted (e.g. CONFIG_KERNEL_INIT_PRIORITY_DEFAULT + 5). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/init.h" line="135" column="9" bodyfile="include/init.h" bodystart="135" bodyend="-1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Device Model APIs. </para>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
  </compounddef>
</doxygen>
