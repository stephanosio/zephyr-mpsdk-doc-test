<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.2" xml:lang="en-US">
  <compounddef id="mem__manage_8h" kind="file" language="C++">
    <compoundname>mem_manage.h</compoundname>
    <includes refid="util_8h" local="no">sys/util.h</includes>
    <includes refid="toolchain_8h" local="no">toolchain.h</includes>
    <includes refid="stdint_8h" local="no">stdint.h</includes>
    <includes local="no">stddef.h</includes>
    <includes refid="inttypes_8h" local="no">inttypes.h</includes>
    <includes refid="____assert_8h" local="no">sys/__assert.h</includes>
    <includes local="no">syscalls/mem_manage.h</includes>
    <includedby refid="linker-tool-gcc_8h" local="no">include/linker/linker-tool-gcc.h</includedby>
    <includedby refid="device__mmio_8h" local="no">include/sys/device_mmio.h</includedby>
    <includedby refid="fatal_2exception_2src_2main_8c" local="no">tests/kernel/fatal/exception/src/main.c</includedby>
    <includedby refid="mem__heap_2shared__multi__heap_2src_2main_8c" local="no">tests/kernel/mem_heap/shared_multi_heap/src/main.c</includedby>
    <includedby refid="mem__protect_2demand__paging_2src_2main_8c" local="no">tests/kernel/mem_protect/demand_paging/src/main.c</includedby>
    <includedby refid="mem__protect_2mem__map_2src_2main_8c" local="no">tests/kernel/mem_protect/mem_map/src/main.c</includedby>
    <incdepgraph>
      <node id="12">
        <label>sys/__assert.h</label>
        <link refid="____assert_8h_source"/>
        <childnode refid="6" relation="include">
        </childnode>
        <childnode refid="13" relation="include">
        </childnode>
      </node>
      <node id="1">
        <label>include/sys/mem_manage.h</label>
        <link refid="mem__manage_8h"/>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="11" relation="include">
        </childnode>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="15" relation="include">
        </childnode>
      </node>
      <node id="13">
        <label>sys/printk.h</label>
        <link refid="printk_8h"/>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="14" relation="include">
        </childnode>
        <childnode refid="11" relation="include">
        </childnode>
      </node>
      <node id="2">
        <label>sys/util.h</label>
        <link refid="util_8h"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
      </node>
      <node id="4">
        <label>sys/util_internal.h</label>
        <link refid="util__internal_8h"/>
        <childnode refid="5" relation="include">
        </childnode>
      </node>
      <node id="5">
        <label>util_loops.h</label>
        <link refid="util__loops_8h"/>
      </node>
      <node id="3">
        <label>sys/util_macro.h</label>
        <link refid="util__macro_8h"/>
        <childnode refid="4" relation="include">
        </childnode>
      </node>
      <node id="10">
        <label>toolchain.h</label>
        <link refid="toolchain_8h"/>
      </node>
      <node id="7">
        <label>zephyr/types.h</label>
        <link refid="include_2zephyr_2types_8h"/>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="9" relation="include">
        </childnode>
      </node>
      <node id="11">
        <label>inttypes.h</label>
        <link refid="inttypes_8h"/>
        <childnode refid="9" relation="include">
        </childnode>
      </node>
      <node id="6">
        <label>stdbool.h</label>
        <link refid="stdbool_8h"/>
      </node>
      <node id="9">
        <label>stdint.h</label>
        <link refid="stdint_8h"/>
      </node>
      <node id="14">
        <label>stdarg.h</label>
      </node>
      <node id="8">
        <label>stddef.h</label>
      </node>
      <node id="15">
        <label>syscalls/mem_manage.h</label>
      </node>
    </incdepgraph>
    <invincdepgraph>
      <node id="7">
        <label>include/arch/x86/arch.h</label>
        <link refid="x86_2arch_8h"/>
      </node>
      <node id="4">
        <label>include/device.h</label>
        <link refid="device_8h"/>
      </node>
      <node id="5">
        <label>include/drivers/interrupt_controller/loapic.h</label>
        <link refid="loapic_8h"/>
        <childnode refid="6" relation="include">
        </childnode>
      </node>
      <node id="6">
        <label>include/drivers/interrupt_controller/sysapic.h</label>
        <link refid="sysapic_8h"/>
        <childnode refid="7" relation="include">
        </childnode>
      </node>
      <node id="2">
        <label>include/linker/linker-tool-gcc.h</label>
        <link refid="linker-tool-gcc_8h"/>
      </node>
      <node id="3">
        <label>include/sys/device_mmio.h</label>
        <link refid="device__mmio_8h"/>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="5" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
      </node>
      <node id="1">
        <label>include/sys/mem_manage.h</label>
        <link refid="mem__manage_8h"/>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="11" relation="include">
        </childnode>
        <childnode refid="12" relation="include">
        </childnode>
      </node>
      <node id="8">
        <label>include/xen/console.h</label>
        <link refid="xen_2console_8h"/>
      </node>
      <node id="9">
        <label>tests/kernel/fatal/exception/src/main.c</label>
        <link refid="fatal_2exception_2src_2main_8c"/>
      </node>
      <node id="10">
        <label>tests/kernel/mem_heap/shared_multi_heap/src/main.c</label>
        <link refid="mem__heap_2shared__multi__heap_2src_2main_8c"/>
      </node>
      <node id="11">
        <label>tests/kernel/mem_protect/demand_paging/src/main.c</label>
        <link refid="mem__protect_2demand__paging_2src_2main_8c"/>
      </node>
      <node id="12">
        <label>tests/kernel/mem_protect/mem_map/src/main.c</label>
        <link refid="mem__protect_2mem__map_2src_2main_8c"/>
      </node>
    </invincdepgraph>
    <innerclass refid="structk__mem__paging__stats__t" prot="public">k_mem_paging_stats_t</innerclass>
    <innerclass refid="structk__mem__paging__histogram__t" prot="public">k_mem_paging_histogram_t</innerclass>
      <sectiondef kind="define">
      <memberdef kind="define" id="mem__manage_8h_1aae7605452be94d1bd6e0364e9db113c6" prot="public" static="no">
        <name>K_MEM_CACHE_NONE</name>
        <initializer>2</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>No caching. Most drivers want this. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/sys/mem_manage.h" line="18" column="9" bodyfile="include/sys/mem_manage.h" bodystart="18" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="mem__manage_8h_1a1c8d5fee98c68b08cc6acf781eb35320" prot="public" static="no">
        <name>K_MEM_CACHE_WT</name>
        <initializer>1</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Write-through caching. Used by certain drivers. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/sys/mem_manage.h" line="21" column="9" bodyfile="include/sys/mem_manage.h" bodystart="21" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="mem__manage_8h_1a802a69d7a53cafcf357861ab50258c99" prot="public" static="no">
        <name>K_MEM_CACHE_WB</name>
        <initializer>0</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Full write-back caching. Any RAM mapped wants this. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/sys/mem_manage.h" line="24" column="9" bodyfile="include/sys/mem_manage.h" bodystart="24" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="mem__manage_8h_1aae828c97c7bae5d235b863ff3b6b913e" prot="public" static="no">
        <name>K_MEM_CACHE_MASK</name>
        <initializer>(<ref refid="group__sys-util_1ga3a8ea58898cb58fc96013383d39f482c" kindref="member">BIT</ref>(3) - 1)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Reserved bits for cache modes in k_map() flags argument </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/sys/mem_manage.h" line="27" column="9" bodyfile="include/sys/mem_manage.h" bodystart="27" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="mem__manage_8h_1ab9ea94b7155e276f0b653bc1a081866e" prot="public" static="no">
        <name>K_MEM_PERM_RW</name>
        <initializer><ref refid="group__sys-util_1ga3a8ea58898cb58fc96013383d39f482c" kindref="member">BIT</ref>(3)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Region will have read/write access (and not read-only) </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/sys/mem_manage.h" line="34" column="9" bodyfile="include/sys/mem_manage.h" bodystart="34" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="mem__manage_8h_1af1b0db3c1c5b28b1810f39cdac03f9de" prot="public" static="no">
        <name>K_MEM_PERM_EXEC</name>
        <initializer><ref refid="group__sys-util_1ga3a8ea58898cb58fc96013383d39f482c" kindref="member">BIT</ref>(4)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Region will be executable (normally forbidden) </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/sys/mem_manage.h" line="37" column="9" bodyfile="include/sys/mem_manage.h" bodystart="37" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="mem__manage_8h_1aa96222e46728d507ca229796a5724425" prot="public" static="no">
        <name>K_MEM_PERM_USER</name>
        <initializer><ref refid="group__sys-util_1ga3a8ea58898cb58fc96013383d39f482c" kindref="member">BIT</ref>(5)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Region will be accessible to user mode (normally supervisor-only) </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/sys/mem_manage.h" line="40" column="9" bodyfile="include/sys/mem_manage.h" bodystart="40" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="mem__manage_8h_1a0a3569731c9a9f8e94e913f840b4be61" prot="public" static="no">
        <name>K_MEM_MAP_UNINIT</name>
        <initializer><ref refid="group__sys-util_1ga3a8ea58898cb58fc96013383d39f482c" kindref="member">BIT</ref>(16)</initializer>
        <briefdescription>
<para>The mapped region is not guaranteed to be zeroed. </para>
        </briefdescription>
        <detaileddescription>
<para>This may improve performance. The associated page frames may contain indeterminate data, zeroes, or even sensitive information.</para>
<para>This may not be used with K_MEM_PERM_USER as there are no circumstances where this is safe. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/sys/mem_manage.h" line="256" column="9" bodyfile="include/sys/mem_manage.h" bodystart="256" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="mem__manage_8h_1a7bed120eac76f03a55b1ab8a1f61ce8b" prot="public" static="no">
        <name>K_MEM_MAP_LOCK</name>
        <initializer><ref refid="group__sys-util_1ga3a8ea58898cb58fc96013383d39f482c" kindref="member">BIT</ref>(17)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Region will be pinned in memory and never paged</para>
<para>Such memory is guaranteed to never produce a page fault due to page-outs or copy-on-write once the mapping call has returned. Physical page frames will be pre-fetched as necessary and pinned. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/sys/mem_manage.h" line="267" column="9" bodyfile="include/sys/mem_manage.h" bodystart="267" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="mem__manage_8h_1a62b2f8cb1404f2f7b8784ae418abe7f7" prot="public" static="no">
        <name>K_MEM_MAP_GUARD</name>
        <initializer>__DEPRECATED_MACRO <ref refid="group__sys-util_1ga3a8ea58898cb58fc96013383d39f482c" kindref="member">BIT</ref>(18)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>A un-mapped virtual guard page will be placed in memory immediately preceding the mapped region. This page will still be noted as being used by the virtual memory manager. The total size of the allocation will be the requested size plus the size of this guard page. The returned address pointer will not include the guard page immediately below it. The typical use-case is downward-growing thread stacks.</para>
<para>Zephyr treats page faults on this guard page as a fatal K_ERR_STACK_CHK_FAIL if it determines it immediately precedes a stack buffer, this is implemented in the architecture layer.</para>
<para>DEPRECATED: <ref refid="mem__manage_8h_1ae9831427d79d64acfc9ad9c699d619d1" kindref="member">k_mem_map()</ref> will always allocate guard pages, so this bit no longer has any effect. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/sys/mem_manage.h" line="286" column="9" bodyfile="include/sys/mem_manage.h" bodystart="286" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="mem__manage_8h_1abb315b4994193147e9f51b0c3268bfcd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t k_mem_free_get</definition>
        <argsstring>(void)</argsstring>
        <name>k_mem_free_get</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return the amount of free memory available</para>
<para>The returned value will reflect how many free RAM page frames are available. If demand paging is enabled, it may still be possible to allocate more.</para>
<para>The information reported by this function may go stale immediately if concurrent memory mappings or page-ins take place.</para>
<para><simplesect kind="return"><para>Free physical RAM, in bytes </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/sys/mem_manage.h" line="299" column="8" declfile="include/sys/mem_manage.h" declline="299" declcolumn="8"/>
      </memberdef>
      <memberdef kind="function" id="mem__manage_8h_1ae9831427d79d64acfc9ad9c699d619d1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void *</type>
        <definition>void * k_mem_map</definition>
        <argsstring>(size_t size, uint32_t flags)</argsstring>
        <name>k_mem_map</name>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type><ref refid="stdint_8h_1a0a8582351ac627ee8bde2973c825e47f" kindref="member">uint32_t</ref></type>
          <declname>flags</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Map anonymous memory into Zephyr&apos;s address space</para>
<para>This function effectively increases the data space available to Zephyr. The kernel will choose a base virtual address and return it to the caller. The memory will have access permissions for all contexts set per the provided flags argument.</para>
<para>If user thread access control needs to be managed in any way, do not enable K_MEM_PERM_USER flags here; instead manage the region&apos;s permissions with memory domain APIs after the mapping has been established. Setting K_MEM_PERM_USER here will allow all user threads to access this memory which is usually undesirable.</para>
<para>Unless K_MEM_MAP_UNINIT is used, the returned memory will be zeroed.</para>
<para>The mapped region is not guaranteed to be physically contiguous in memory. Physically contiguous buffers should be allocated statically and pinned at build time.</para>
<para>Pages mapped in this way have write-back cache settings.</para>
<para>The returned virtual memory pointer will be page-aligned. The size parameter, and any base address for re-mapping purposes must be page- aligned.</para>
<para>Note that the allocation includes two guard pages immediately before and after the requested region. The total size of the allocation will be the requested size plus the size of these two guard pages.</para>
<para>Many K_MEM_MAP_* flags have been implemented to alter the behavior of this function, with details in the documentation for these flags.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the memory mapping. This must be page-aligned. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>flags</parametername>
</parameternamelist>
<parameterdescription>
<para>K_MEM_PERM_*, K_MEM_MAP_* control flags. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The mapped memory location, or NULL if insufficient virtual address space, insufficient physical memory to establish the mapping, or insufficient memory for paging structures. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/sys/mem_manage.h" line="340" column="6" declfile="include/sys/mem_manage.h" declline="340" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="mem__manage_8h_1adc321dd750d9bdf36dec2f77d21a7207" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void k_mem_unmap</definition>
        <argsstring>(void *addr, size_t size)</argsstring>
        <name>k_mem_unmap</name>
        <param>
          <type>void *</type>
          <declname>addr</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Un-map mapped memory</para>
<para>This removes a memory mapping for the provided page-aligned region. Associated page frames will be free and the kernel may re-use the associated virtual address region. Any paged out data pages may be discarded.</para>
<para>Calling this function on a region which was not mapped to begin with is undefined behavior.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>addr</parametername>
</parameternamelist>
<parameterdescription>
<para>Page-aligned memory region base virtual address </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Page-aligned memory region size </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/sys/mem_manage.h" line="355" column="6" declfile="include/sys/mem_manage.h" declline="355" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="mem__manage_8h_1ad9a0110394e8026e27deb15687321ee9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t k_mem_region_align</definition>
        <argsstring>(uintptr_t *aligned_addr, size_t *aligned_size, uintptr_t addr, size_t size, size_t align)</argsstring>
        <name>k_mem_region_align</name>
        <param>
          <type><ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref> *</type>
          <declname>aligned_addr</declname>
        </param>
        <param>
          <type>size_t *</type>
          <declname>aligned_size</declname>
        </param>
        <param>
          <type><ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref></type>
          <declname>addr</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>align</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Given an arbitrary region, provide a aligned region that covers it</para>
<para>The returned region will have both its base address and size aligned to the provided alignment value.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>aligned_addr</parametername>
</parameternamelist>
<parameterdescription>
<para>[out] Aligned address </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>aligned_size</parametername>
</parameternamelist>
<parameterdescription>
<para>[out] Aligned region size </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>addr</parametername>
</parameternamelist>
<parameterdescription>
<para>Region base address </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Region size </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>What to align the address and size to </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>between aligned_addr and addr </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/sys/mem_manage.h" line="370" column="8" declfile="include/sys/mem_manage.h" declline="370" declcolumn="8"/>
      </memberdef>
      <memberdef kind="function" id="group__mem-demand-paging_1ga0b18037209b4d8b5964bd9a1d760f703" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int k_mem_page_out</definition>
        <argsstring>(void *addr, size_t size)</argsstring>
        <name>k_mem_page_out</name>
        <param>
          <type>void *</type>
          <declname>addr</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Evict a page-aligned virtual memory region to the backing store</para>
<para>Useful if it is known that a memory region will not be used for some time. All the data pages within the specified region will be evicted to the backing store if they weren&apos;t already, with their associated page frames marked as available for mappings or page-ins.</para>
<para>None of the associated page frames mapped to the provided region should be pinned.</para>
<para>Note that there are no guarantees how long these pages will be evicted, they could take page faults immediately.</para>
<para>If CONFIG_DEMAND_PAGING_ALLOW_IRQ is enabled, this function may not be called by ISRs as the backing store may be in-use.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>addr</parametername>
</parameternamelist>
<parameterdescription>
<para>Base page-aligned virtual address </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Page-aligned data region size </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>0</parametername>
</parameternamelist>
<parameterdescription>
<para>Success </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>-ENOMEM</parametername>
</parameternamelist>
<parameterdescription>
<para>Insufficient space in backing store to satisfy request. The region may be partially paged out. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/sys/mem_manage.h" line="401" column="5" declfile="include/sys/mem_manage.h" declline="401" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__mem-demand-paging_1gab36c36a4e230677d2090514f7a34b408" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void k_mem_page_in</definition>
        <argsstring>(void *addr, size_t size)</argsstring>
        <name>k_mem_page_in</name>
        <param>
          <type>void *</type>
          <declname>addr</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Load a virtual data region into memory</para>
<para>After the function completes, all the page frames associated with this function will be paged in. However, they are not guaranteed to stay there. This is useful if the region is known to be used soon.</para>
<para>If CONFIG_DEMAND_PAGING_ALLOW_IRQ is enabled, this function may not be called by ISRs as the backing store may be in-use.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>addr</parametername>
</parameternamelist>
<parameterdescription>
<para>Base page-aligned virtual address </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Page-aligned data region size </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/sys/mem_manage.h" line="416" column="6" declfile="include/sys/mem_manage.h" declline="416" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__mem-demand-paging_1ga5f2d422edde7d366e81a870ce057589f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void k_mem_pin</definition>
        <argsstring>(void *addr, size_t size)</argsstring>
        <name>k_mem_pin</name>
        <param>
          <type>void *</type>
          <declname>addr</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Pin an aligned virtual data region, paging in as necessary</para>
<para>After the function completes, all the page frames associated with this region will be resident in memory and pinned such that they stay that way. This is a stronger version of z_mem_page_in().</para>
<para>If CONFIG_DEMAND_PAGING_ALLOW_IRQ is enabled, this function may not be called by ISRs as the backing store may be in-use.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>addr</parametername>
</parameternamelist>
<parameterdescription>
<para>Base page-aligned virtual address </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Page-aligned data region size </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/sys/mem_manage.h" line="431" column="6" declfile="include/sys/mem_manage.h" declline="431" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__mem-demand-paging_1ga3278aae5e24733c722b7d83c4b17dab3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void k_mem_unpin</definition>
        <argsstring>(void *addr, size_t size)</argsstring>
        <name>k_mem_unpin</name>
        <param>
          <type>void *</type>
          <declname>addr</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Un-pin an aligned virtual data region</para>
<para>After the function completes, all the page frames associated with this region will be no longer marked as pinned. This does not evict the region, follow this with z_mem_page_out() if you need that.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>addr</parametername>
</parameternamelist>
<parameterdescription>
<para>Base page-aligned virtual address </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Page-aligned data region size </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/sys/mem_manage.h" line="443" column="6" declfile="include/sys/mem_manage.h" declline="443" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__mem-demand-paging_1ga52ad88e0c0eed2aa27331bfd4707b7ec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void k_mem_paging_stats_get</definition>
        <argsstring>(struct k_mem_paging_stats_t *stats)</argsstring>
        <name>k_mem_paging_stats_get</name>
        <param>
          <type>struct <ref refid="structk__mem__paging__stats__t" kindref="compound">k_mem_paging_stats_t</ref> *</type>
          <declname>stats</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the paging statistics since system startup</para>
<para>This populates the paging statistics struct being passed in as argument.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="inout">stats</parametername>
</parameternamelist>
<parameterdescription>
<para>Paging statistics struct to be filled. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/sys/mem_manage.h" line="453" column="7" declfile="include/sys/mem_manage.h" declline="453" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="group__mem-demand-paging_1gafad6b39cb2faf3bb416cd4d3faaa8d8c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void k_mem_paging_thread_stats_get</definition>
        <argsstring>(struct k_thread *thread, struct k_mem_paging_stats_t *stats)</argsstring>
        <name>k_mem_paging_thread_stats_get</name>
        <param>
          <type>struct <ref refid="structk__thread" kindref="compound">k_thread</ref> *</type>
          <declname>thread</declname>
        </param>
        <param>
          <type>struct <ref refid="structk__mem__paging__stats__t" kindref="compound">k_mem_paging_stats_t</ref> *</type>
          <declname>stats</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the paging statistics since system startup for a thread</para>
<para>This populates the paging statistics struct being passed in as argument for a particular thread.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">thread</parametername>
</parameternamelist>
<parameterdescription>
<para>Thread </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="inout">stats</parametername>
</parameternamelist>
<parameterdescription>
<para>Paging statistics struct to be filled. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/sys/mem_manage.h" line="466" column="6" declfile="include/sys/mem_manage.h" declline="466" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__mem-demand-paging_1gaec64d019d819b00c7bc3804aac269199" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void k_mem_paging_histogram_eviction_get</definition>
        <argsstring>(struct k_mem_paging_histogram_t *hist)</argsstring>
        <name>k_mem_paging_histogram_eviction_get</name>
        <param>
          <type>struct <ref refid="structk__mem__paging__histogram__t" kindref="compound">k_mem_paging_histogram_t</ref> *</type>
          <declname>hist</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the eviction timing histogram</para>
<para>This populates the timing histogram struct being passed in as argument.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="inout">hist</parametername>
</parameternamelist>
<parameterdescription>
<para>Timing histogram struct to be filled. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/sys/mem_manage.h" line="477" column="7" declfile="include/sys/mem_manage.h" declline="477" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="group__mem-demand-paging_1ga1da0a643e8f85f98e29288e441a37dfa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void k_mem_paging_histogram_backing_store_page_in_get</definition>
        <argsstring>(struct k_mem_paging_histogram_t *hist)</argsstring>
        <name>k_mem_paging_histogram_backing_store_page_in_get</name>
        <param>
          <type>struct <ref refid="structk__mem__paging__histogram__t" kindref="compound">k_mem_paging_histogram_t</ref> *</type>
          <declname>hist</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the backing store page-in timing histogram</para>
<para>This populates the timing histogram struct being passed in as argument.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="inout">hist</parametername>
</parameternamelist>
<parameterdescription>
<para>Timing histogram struct to be filled. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/sys/mem_manage.h" line="488" column="7" declfile="include/sys/mem_manage.h" declline="488" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="group__mem-demand-paging_1gae4f80d14f88a46ddb9aeb7afba861864" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void k_mem_paging_histogram_backing_store_page_out_get</definition>
        <argsstring>(struct k_mem_paging_histogram_t *hist)</argsstring>
        <name>k_mem_paging_histogram_backing_store_page_out_get</name>
        <param>
          <type>struct <ref refid="structk__mem__paging__histogram__t" kindref="compound">k_mem_paging_histogram_t</ref> *</type>
          <declname>hist</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the backing store page-out timing histogram</para>
<para>This populates the timing histogram struct being passed in as argument.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="inout">hist</parametername>
</parameternamelist>
<parameterdescription>
<para>Timing histogram struct to be filled. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/sys/mem_manage.h" line="499" column="7" declfile="include/sys/mem_manage.h" declline="499" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="group__mem-demand-paging-eviction_1ga12641d53942529c7d7364c08473a6eca" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>struct z_page_frame *</type>
        <definition>struct z_page_frame * k_mem_paging_eviction_select</definition>
        <argsstring>(bool *dirty)</argsstring>
        <name>k_mem_paging_eviction_select</name>
        <param>
          <type><ref refid="stdbool_8h_1abb452686968e48b67397da5f97445f5b" kindref="member">bool</ref> *</type>
          <declname>dirty</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Select a page frame for eviction</para>
<para>The kernel will invoke this to choose a page frame to evict if there are no free page frames.</para>
<para>This function will never be called before the initial <ref refid="group__mem-demand-paging-eviction_1ga68dcfc0e5374de2c8ad7b9fe4e65c4f4" kindref="member">k_mem_paging_eviction_init()</ref>.</para>
<para>This function is invoked with interrupts locked.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">dirty</parametername>
</parameternamelist>
<parameterdescription>
<para>Whether the page to evict is dirty </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The page frame to evict </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/sys/mem_manage.h" line="527" column="19" declfile="include/sys/mem_manage.h" declline="527" declcolumn="19"/>
      </memberdef>
      <memberdef kind="function" id="group__mem-demand-paging-eviction_1ga68dcfc0e5374de2c8ad7b9fe4e65c4f4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void k_mem_paging_eviction_init</definition>
        <argsstring>(void)</argsstring>
        <name>k_mem_paging_eviction_init</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Initialization function</para>
<para>Called at POST_KERNEL to perform any necessary initialization tasks for the eviction algorithm. <ref refid="group__mem-demand-paging-eviction_1ga12641d53942529c7d7364c08473a6eca" kindref="member">k_mem_paging_eviction_select()</ref> is guaranteed to never be called until this has returned, and this will only be called once. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/sys/mem_manage.h" line="536" column="6" declfile="include/sys/mem_manage.h" declline="536" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__mem-demand-paging-backing-store_1gaadedcda81ca04a2044332a8f6787967a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int k_mem_paging_backing_store_location_get</definition>
        <argsstring>(struct z_page_frame *pf, uintptr_t *location, bool page_fault)</argsstring>
        <name>k_mem_paging_backing_store_location_get</name>
        <param>
          <type>struct z_page_frame *</type>
          <declname>pf</declname>
        </param>
        <param>
          <type><ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref> *</type>
          <declname>location</declname>
        </param>
        <param>
          <type><ref refid="stdbool_8h_1abb452686968e48b67397da5f97445f5b" kindref="member">bool</ref></type>
          <declname>page_fault</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Reserve or fetch a storage location for a data page loaded into a page frame</para>
<para>The returned location token must be unique to the mapped virtual address. This location will be used in the backing store to page out data page contents for later retrieval. The location value must be page-aligned.</para>
<para>This function may be called multiple times on the same data page. If its page frame has its Z_PAGE_FRAME_BACKED bit set, it is expected to return the previous backing store location for the data page containing a cached clean copy. This clean copy may be updated on page-out, or used to discard clean pages without needing to write out their contents.</para>
<para>If the backing store is full, some other backing store location which caches a loaded data page may be selected, in which case its associated page frame will have the Z_PAGE_FRAME_BACKED bit cleared (as it is no longer cached).</para>
<para>pf-&gt;addr will indicate the virtual address the page is currently mapped to. Large, sparse backing stores which can contain the entire address space may simply generate location tokens purely as a function of pf-&gt;addr with no other management necessary.</para>
<para>This function distinguishes whether it was called on behalf of a page fault. A free backing store location must always be reserved in order for page faults to succeed. If the page_fault parameter is not set, this function should return -ENOMEM even if one location is available.</para>
<para>This function is invoked with interrupts locked.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pf</parametername>
</parameternamelist>
<parameterdescription>
<para>Virtual address to obtain a storage location </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">location</parametername>
</parameternamelist>
<parameterdescription>
<para>storage location token </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>page_fault</parametername>
</parameternamelist>
<parameterdescription>
<para>Whether this request was for a page fault </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 Success </para>
</simplesect>
<simplesect kind="return"><para>-ENOMEM Backing store is full </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/sys/mem_manage.h" line="582" column="5" declfile="include/sys/mem_manage.h" declline="582" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__mem-demand-paging-backing-store_1ga6ad421ad5671d9df3d96e03361f672e8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void k_mem_paging_backing_store_location_free</definition>
        <argsstring>(uintptr_t location)</argsstring>
        <name>k_mem_paging_backing_store_location_free</name>
        <param>
          <type><ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref></type>
          <declname>location</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Free a backing store location</para>
<para>Any stored data may be discarded, and the location token associated with this address may be re-used for some other data page.</para>
<para>This function is invoked with interrupts locked.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>location</parametername>
</parameternamelist>
<parameterdescription>
<para>Location token to free </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/sys/mem_manage.h" line="596" column="6" declfile="include/sys/mem_manage.h" declline="596" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__mem-demand-paging-backing-store_1ga51f663e0a8c31367082e78097359af6d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void k_mem_paging_backing_store_page_out</definition>
        <argsstring>(uintptr_t location)</argsstring>
        <name>k_mem_paging_backing_store_page_out</name>
        <param>
          <type><ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref></type>
          <declname>location</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copy a data page from Z_SCRATCH_PAGE to the specified location</para>
<para>Immediately before this is called, Z_SCRATCH_PAGE will be mapped read-write to the intended source page frame for the calling context.</para>
<para>Calls to this and <ref refid="group__mem-demand-paging-backing-store_1ga9becb4908cc7840ece93a2360692962d" kindref="member">k_mem_paging_backing_store_page_in()</ref> will always be serialized, but interrupts may be enabled.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>location</parametername>
</parameternamelist>
<parameterdescription>
<para>Location token for the data page, for later retrieval </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/sys/mem_manage.h" line="609" column="6" declfile="include/sys/mem_manage.h" declline="609" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__mem-demand-paging-backing-store_1ga9becb4908cc7840ece93a2360692962d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void k_mem_paging_backing_store_page_in</definition>
        <argsstring>(uintptr_t location)</argsstring>
        <name>k_mem_paging_backing_store_page_in</name>
        <param>
          <type><ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref></type>
          <declname>location</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copy a data page from the provided location to Z_SCRATCH_PAGE.</para>
<para>Immediately before this is called, Z_SCRATCH_PAGE will be mapped read-write to the intended destination page frame for the calling context.</para>
<para>Calls to this and <ref refid="group__mem-demand-paging-backing-store_1ga51f663e0a8c31367082e78097359af6d" kindref="member">k_mem_paging_backing_store_page_out()</ref> will always be serialized, but interrupts may be enabled.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>location</parametername>
</parameternamelist>
<parameterdescription>
<para>Location token for the data page </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/sys/mem_manage.h" line="622" column="6" declfile="include/sys/mem_manage.h" declline="622" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__mem-demand-paging-backing-store_1ga0902bc03fecfe8c7b51eb1f3efe587b7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void k_mem_paging_backing_store_page_finalize</definition>
        <argsstring>(struct z_page_frame *pf, uintptr_t location)</argsstring>
        <name>k_mem_paging_backing_store_page_finalize</name>
        <param>
          <type>struct z_page_frame *</type>
          <declname>pf</declname>
        </param>
        <param>
          <type><ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref></type>
          <declname>location</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Update internal accounting after a page-in</para>
<para>This is invoked after <ref refid="group__mem-demand-paging-backing-store_1ga9becb4908cc7840ece93a2360692962d" kindref="member">k_mem_paging_backing_store_page_in()</ref> and interrupts have been* re-locked, making it safe to access the z_page_frame data. The location value will be the same passed to <ref refid="group__mem-demand-paging-backing-store_1ga9becb4908cc7840ece93a2360692962d" kindref="member">k_mem_paging_backing_store_page_in()</ref>.</para>
<para>The primary use-case for this is to update custom fields for the backing store in the page frame, to reflect where the data should be evicted to if it is paged out again. This may be a no-op in some implementations.</para>
<para>If the backing store caches paged-in data pages, this is the appropriate time to set the Z_PAGE_FRAME_BACKED bit. The kernel only skips paging out clean data pages if they are noted as clean in the page tables and the Z_PAGE_FRAME_BACKED bit is set in their associated page frame.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pf</parametername>
</parameternamelist>
<parameterdescription>
<para>Page frame that was loaded in </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>location</parametername>
</parameternamelist>
<parameterdescription>
<para>Location of where the loaded data page was retrieved </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/sys/mem_manage.h" line="644" column="6" declfile="include/sys/mem_manage.h" declline="644" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__mem-demand-paging-backing-store_1ga7ff441f23619b2678bfb72559d5bd592" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void k_mem_paging_backing_store_init</definition>
        <argsstring>(void)</argsstring>
        <name>k_mem_paging_backing_store_init</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Backing store initialization function.</para>
<para>The implementation may expect to receive page in/out calls as soon as this returns, but not before that. Called at POST_KERNEL.</para>
<para>This function is expected to do two things:<itemizedlist>
<listitem><para>Initialize any internal data structures and accounting for the backing store.</para>
</listitem><listitem><para>If the backing store already contains all or some loaded kernel data pages at boot time, Z_PAGE_FRAME_BACKED should be appropriately set for their associated page frames, and any internal accounting set up appropriately. </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/sys/mem_manage.h" line="660" column="6" declfile="include/sys/mem_manage.h" declline="660" declcolumn="6"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="comment">/*</highlight></codeline>
<codeline lineno="2"><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(c)<sp/>2020<sp/>Intel<sp/>Corporation</highlight></codeline>
<codeline lineno="3"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="4"><highlight class="comment"><sp/>*<sp/>SPDX-License-Identifier:<sp/>Apache-2.0</highlight></codeline>
<codeline lineno="5"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6"><highlight class="normal"></highlight></codeline>
<codeline lineno="7"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>ZEPHYR_INCLUDE_SYS_MEM_MANAGE_H</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>ZEPHYR_INCLUDE_SYS_MEM_MANAGE_H</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9"><highlight class="normal"></highlight></codeline>
<codeline lineno="10"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="util_8h" kindref="compound">sys/util.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="toolchain_8h" kindref="compound">toolchain.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12"><highlight class="normal"></highlight></codeline>
<codeline lineno="13"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="14"><highlight class="comment"><sp/>*<sp/>Caching<sp/>mode<sp/>definitions.<sp/>These<sp/>are<sp/>mutually<sp/>exclusive.</highlight></codeline>
<codeline lineno="15"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16"><highlight class="normal"></highlight></codeline>
<codeline lineno="18" refid="mem__manage_8h_1aae7605452be94d1bd6e0364e9db113c6" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>K_MEM_CACHE_NONE<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>2</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="19"><highlight class="normal"></highlight></codeline>
<codeline lineno="21" refid="mem__manage_8h_1a1c8d5fee98c68b08cc6acf781eb35320" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>K_MEM_CACHE_WT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="22"><highlight class="normal"></highlight></codeline>
<codeline lineno="24" refid="mem__manage_8h_1a802a69d7a53cafcf357861ab50258c99" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>K_MEM_CACHE_WB<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="25"><highlight class="normal"></highlight></codeline>
<codeline lineno="27" refid="mem__manage_8h_1aae828c97c7bae5d235b863ff3b6b913e" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>K_MEM_CACHE_MASK<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(BIT(3)<sp/>-<sp/>1)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="28"><highlight class="normal"></highlight></codeline>
<codeline lineno="29"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="30"><highlight class="comment"><sp/>*<sp/>Region<sp/>permission<sp/>attributes.<sp/>Default<sp/>is<sp/>read-only,<sp/>no<sp/>user,<sp/>no<sp/>exec</highlight></codeline>
<codeline lineno="31"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="32"><highlight class="normal"></highlight></codeline>
<codeline lineno="34" refid="mem__manage_8h_1ab9ea94b7155e276f0b653bc1a081866e" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>K_MEM_PERM_RW<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>BIT(3)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="35"><highlight class="normal"></highlight></codeline>
<codeline lineno="37" refid="mem__manage_8h_1af1b0db3c1c5b28b1810f39cdac03f9de" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>K_MEM_PERM_EXEC<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>BIT(4)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="38"><highlight class="normal"></highlight></codeline>
<codeline lineno="40" refid="mem__manage_8h_1aa96222e46728d507ca229796a5724425" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>K_MEM_PERM_USER<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>BIT(5)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="41"><highlight class="normal"></highlight></codeline>
<codeline lineno="42"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="43"><highlight class="comment"><sp/>*<sp/>This<sp/>is<sp/>the<sp/>offset<sp/>to<sp/>subtract<sp/>from<sp/>a<sp/>virtual<sp/>address<sp/>mapped<sp/>in<sp/>the</highlight></codeline>
<codeline lineno="44"><highlight class="comment"><sp/>*<sp/>kernel&apos;s<sp/>permanent<sp/>mapping<sp/>of<sp/>RAM,<sp/>to<sp/>obtain<sp/>its<sp/>physical<sp/>address.</highlight></codeline>
<codeline lineno="45"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="46"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>virt_addr<sp/>=<sp/>phys_addr<sp/>+<sp/>Z_MEM_VM_OFFSET</highlight></codeline>
<codeline lineno="47"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="48"><highlight class="comment"><sp/>*<sp/>This<sp/>only<sp/>works<sp/>for<sp/>virtual<sp/>addresses<sp/>within<sp/>the<sp/>interval</highlight></codeline>
<codeline lineno="49"><highlight class="comment"><sp/>*<sp/>[CONFIG_KERNEL_VM_BASE,<sp/>CONFIG_KERNEL_VM_BASE<sp/>+<sp/>(CONFIG_SRAM_SIZE<sp/>*<sp/>1024)).</highlight></codeline>
<codeline lineno="50"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="51"><highlight class="comment"><sp/>*<sp/>These<sp/>macros<sp/>are<sp/>intended<sp/>for<sp/>assembly,<sp/>linker<sp/>code,<sp/>and<sp/>static<sp/>initializers.</highlight></codeline>
<codeline lineno="52"><highlight class="comment"><sp/>*<sp/>Use<sp/>with<sp/>care.</highlight></codeline>
<codeline lineno="53"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="54"><highlight class="comment"><sp/>*<sp/>Note<sp/>that<sp/>when<sp/>demand<sp/>paging<sp/>is<sp/>active,<sp/>these<sp/>will<sp/>only<sp/>work<sp/>with<sp/>page</highlight></codeline>
<codeline lineno="55"><highlight class="comment"><sp/>*<sp/>frames<sp/>that<sp/>are<sp/>pinned<sp/>to<sp/>their<sp/>virtual<sp/>mapping<sp/>at<sp/>boot.</highlight></codeline>
<codeline lineno="56"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="57"><highlight class="comment"><sp/>*<sp/>TODO:<sp/>This<sp/>will<sp/>likely<sp/>need<sp/>to<sp/>move<sp/>to<sp/>an<sp/>arch<sp/>API<sp/>or<sp/>need<sp/>additional</highlight></codeline>
<codeline lineno="58"><highlight class="comment"><sp/>*<sp/>constraints<sp/>defined.</highlight></codeline>
<codeline lineno="59"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="60"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CONFIG_MMU</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="61"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>Z_MEM_VM_OFFSET<sp/>((CONFIG_KERNEL_VM_BASE<sp/>+<sp/>CONFIG_KERNEL_VM_OFFSET)<sp/>-<sp/>\</highlight></codeline>
<codeline lineno="62"><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(CONFIG_SRAM_BASE_ADDRESS<sp/>+<sp/>CONFIG_SRAM_OFFSET))</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="63"><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="64"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>Z_MEM_VM_OFFSET<sp/>0</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="65"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="66"><highlight class="normal"></highlight></codeline>
<codeline lineno="67"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>Z_MEM_PHYS_ADDR(virt)<sp/><sp/><sp/>((virt)<sp/>-<sp/>Z_MEM_VM_OFFSET)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="68"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>Z_MEM_VIRT_ADDR(phys)<sp/><sp/><sp/>((phys)<sp/>+<sp/>Z_MEM_VM_OFFSET)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="69"><highlight class="normal"></highlight></codeline>
<codeline lineno="70"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>Z_MEM_VM_OFFSET<sp/>!=<sp/>0</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="71"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>Z_VM_KERNEL<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="72"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CONFIG_XIP</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="73"><highlight class="normal"></highlight><highlight class="preprocessor">#error<sp/>&quot;XIP<sp/>and<sp/>a<sp/>virtual<sp/>memory<sp/>kernel<sp/>are<sp/>not<sp/>allowed&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="74"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="75"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="76"><highlight class="normal"></highlight></codeline>
<codeline lineno="77"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_ASMLANGUAGE</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="78"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="stdint_8h" kindref="compound">stdint.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="79"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stddef.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="80"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="inttypes_8h" kindref="compound">inttypes.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="81"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="____assert_8h" kindref="compound">sys/__assert.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="82"><highlight class="normal"></highlight></codeline>
<codeline lineno="83" refid="structk__mem__paging__stats__t" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structk__mem__paging__stats__t" kindref="compound">k_mem_paging_stats_t</ref><sp/>{</highlight></codeline>
<codeline lineno="84"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CONFIG_DEMAND_PAGING_STATS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="85"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="87"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cnt;</highlight></codeline>
<codeline lineno="88"><highlight class="normal"></highlight></codeline>
<codeline lineno="90"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>irq_locked;</highlight></codeline>
<codeline lineno="91"><highlight class="normal"></highlight></codeline>
<codeline lineno="93"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>irq_unlocked;</highlight></codeline>
<codeline lineno="94"><highlight class="normal"></highlight></codeline>
<codeline lineno="95"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>CONFIG_DEMAND_PAGING_ALLOW_IRQ</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="97"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>in_isr;</highlight></codeline>
<codeline lineno="98"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="99"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/>pagefaults;</highlight></codeline>
<codeline lineno="100"><highlight class="normal"></highlight></codeline>
<codeline lineno="101"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="103"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>clean;</highlight></codeline>
<codeline lineno="104"><highlight class="normal"></highlight></codeline>
<codeline lineno="106"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dirty;</highlight></codeline>
<codeline lineno="107"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/>eviction;</highlight></codeline>
<codeline lineno="108"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">/*<sp/>CONFIG_DEMAND_PAGING_STATS<sp/>*/</highlight><highlight class="preprocessor"></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="109"><highlight class="normal">};</highlight></codeline>
<codeline lineno="110"><highlight class="normal"></highlight></codeline>
<codeline lineno="111" refid="structk__mem__paging__histogram__t" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structk__mem__paging__histogram__t" kindref="compound">k_mem_paging_histogram_t</ref><sp/>{</highlight></codeline>
<codeline lineno="112"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CONFIG_DEMAND_PAGING_TIMING_HISTOGRAM</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="113"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Counts<sp/>for<sp/>each<sp/>bin<sp/>in<sp/>timing<sp/>histogram<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="114"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/><sp/><sp/>counts[CONFIG_DEMAND_PAGING_TIMING_HISTOGRAM_NUM_BINS];</highlight></codeline>
<codeline lineno="115"><highlight class="normal"></highlight></codeline>
<codeline lineno="116"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Bounds<sp/>for<sp/>the<sp/>bins<sp/>in<sp/>timing<sp/>histogram,</highlight></codeline>
<codeline lineno="117"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>excluding<sp/>the<sp/>first<sp/>and<sp/>last<sp/>(hence,<sp/>NUM_SLOTS<sp/>-<sp/>1).</highlight></codeline>
<codeline lineno="118"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="119"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/><sp/><sp/>bounds[CONFIG_DEMAND_PAGING_TIMING_HISTOGRAM_NUM_BINS];</highlight></codeline>
<codeline lineno="120"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">/*<sp/>CONFIG_DEMAND_PAGING_TIMING_HISTOGRAM<sp/>*/</highlight><highlight class="preprocessor"></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="121"><highlight class="normal">};</highlight></codeline>
<codeline lineno="122"><highlight class="normal"></highlight></codeline>
<codeline lineno="123"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Just<sp/>like<sp/>Z_MEM_PHYS_ADDR()<sp/>but<sp/>with<sp/>type<sp/>safety<sp/>and<sp/>assertions<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="124"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/><ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref><sp/>z_mem_phys_addr(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*virt)</highlight></codeline>
<codeline lineno="125"><highlight class="normal">{</highlight></codeline>
<codeline lineno="126"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref><sp/>addr<sp/>=<sp/>(<ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref>)virt;</highlight></codeline>
<codeline lineno="127"><highlight class="normal"></highlight></codeline>
<codeline lineno="128"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CONFIG_MMU</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="129"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__ASSERT((addr<sp/>&gt;=<sp/>CONFIG_KERNEL_VM_BASE)<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="130"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(addr<sp/>&lt;<sp/>(CONFIG_KERNEL_VM_BASE<sp/>+</highlight></codeline>
<codeline lineno="131"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(CONFIG_KERNEL_VM_SIZE))),</highlight></codeline>
<codeline lineno="132"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;address<sp/>%p<sp/>not<sp/>in<sp/>permanent<sp/>mappings&quot;</highlight><highlight class="normal">,<sp/>virt);</highlight></codeline>
<codeline lineno="133"><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="134"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Should<sp/>be<sp/>identity-mapped<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="135"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__ASSERT((addr<sp/>&gt;=<sp/>CONFIG_SRAM_BASE_ADDRESS)<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="136"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(addr<sp/>&lt;<sp/>(CONFIG_SRAM_BASE_ADDRESS<sp/>+</highlight></codeline>
<codeline lineno="137"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(CONFIG_SRAM_SIZE<sp/>*<sp/>1024UL))),</highlight></codeline>
<codeline lineno="138"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;physical<sp/>address<sp/>0x%lx<sp/>not<sp/>in<sp/>RAM&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="139"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal">)addr);</highlight></codeline>
<codeline lineno="140"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">/*<sp/>CONFIG_MMU<sp/>*/</highlight><highlight class="preprocessor"></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="141"><highlight class="normal"></highlight></codeline>
<codeline lineno="142"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>TODO<sp/>add<sp/>assertion<sp/>that<sp/>this<sp/>page<sp/>is<sp/>pinned<sp/>to<sp/>boot<sp/>mapping,</highlight></codeline>
<codeline lineno="143"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>the<sp/>above<sp/>checks<sp/>won&apos;t<sp/>be<sp/>sufficient<sp/>with<sp/>demand<sp/>paging</highlight></codeline>
<codeline lineno="144"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="145"><highlight class="normal"></highlight></codeline>
<codeline lineno="146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Z_MEM_PHYS_ADDR(addr);</highlight></codeline>
<codeline lineno="147"><highlight class="normal">}</highlight></codeline>
<codeline lineno="148"><highlight class="normal"></highlight></codeline>
<codeline lineno="149"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Just<sp/>like<sp/>Z_MEM_VIRT_ADDR()<sp/>but<sp/>with<sp/>type<sp/>safety<sp/>and<sp/>assertions<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="150"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*z_mem_virt_addr(<ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref><sp/>phys)</highlight></codeline>
<codeline lineno="151"><highlight class="normal">{</highlight></codeline>
<codeline lineno="152"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__ASSERT((phys<sp/>&gt;=<sp/>CONFIG_SRAM_BASE_ADDRESS)<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="153"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(phys<sp/>&lt;<sp/>(CONFIG_SRAM_BASE_ADDRESS<sp/>+</highlight></codeline>
<codeline lineno="154"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(CONFIG_SRAM_SIZE<sp/>*<sp/>1024UL))),</highlight></codeline>
<codeline lineno="155"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;physical<sp/>address<sp/>0x%lx<sp/>not<sp/>in<sp/>RAM&quot;</highlight><highlight class="normal">,<sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal">)phys);</highlight></codeline>
<codeline lineno="156"><highlight class="normal"></highlight></codeline>
<codeline lineno="157"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>TODO<sp/>add<sp/>assertion<sp/>that<sp/>this<sp/>page<sp/>frame<sp/>is<sp/>pinned<sp/>to<sp/>boot<sp/>mapping,</highlight></codeline>
<codeline lineno="158"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>the<sp/>above<sp/>check<sp/>won&apos;t<sp/>be<sp/>sufficient<sp/>with<sp/>demand<sp/>paging</highlight></codeline>
<codeline lineno="159"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="160"><highlight class="normal"></highlight></codeline>
<codeline lineno="161"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*)Z_MEM_VIRT_ADDR(phys);</highlight></codeline>
<codeline lineno="162"><highlight class="normal">}</highlight></codeline>
<codeline lineno="163"><highlight class="normal"></highlight></codeline>
<codeline lineno="164"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>__cplusplus</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="165"><highlight class="normal"></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/></highlight><highlight class="stringliteral">&quot;C&quot;</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="166"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="167"><highlight class="normal"></highlight></codeline>
<codeline lineno="209"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>z_phys_map(<ref refid="stdint_8h_1a3cb4a16b0e8d6af0af86d4fd6ba5fd9d" kindref="member">uint8_t</ref><sp/>**virt_ptr,<sp/><ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref><sp/>phys,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size,</highlight></codeline>
<codeline lineno="210"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="stdint_8h_1a0a8582351ac627ee8bde2973c825e47f" kindref="member">uint32_t</ref><sp/><ref refid="http__parser_8h_1ab6b306ef981f5e21bb41ea2c2dbe8cd9" kindref="member">flags</ref>);</highlight></codeline>
<codeline lineno="211"><highlight class="normal"></highlight></codeline>
<codeline lineno="239"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>z_phys_unmap(<ref refid="stdint_8h_1a3cb4a16b0e8d6af0af86d4fd6ba5fd9d" kindref="member">uint8_t</ref><sp/>*virt,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size);</highlight></codeline>
<codeline lineno="240"><highlight class="normal"></highlight></codeline>
<codeline lineno="241"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="242"><highlight class="comment"><sp/>*<sp/>k_mem_map()<sp/>control<sp/>flags</highlight></codeline>
<codeline lineno="243"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="244"><highlight class="normal"></highlight></codeline>
<codeline lineno="256" refid="mem__manage_8h_1a0a3569731c9a9f8e94e913f840b4be61" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>K_MEM_MAP_UNINIT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>BIT(16)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="257"><highlight class="normal"></highlight></codeline>
<codeline lineno="267" refid="mem__manage_8h_1a7bed120eac76f03a55b1ab8a1f61ce8b" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>K_MEM_MAP_LOCK<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>BIT(17)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="268"><highlight class="normal"></highlight></codeline>
<codeline lineno="286" refid="mem__manage_8h_1a62b2f8cb1404f2f7b8784ae418abe7f7" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>K_MEM_MAP_GUARD<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__DEPRECATED_MACRO<sp/>BIT(18)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="287"><highlight class="normal"></highlight></codeline>
<codeline lineno="299" refid="mem__manage_8h_1abb315b4994193147e9f51b0c3268bfcd" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/><ref refid="mem__manage_8h_1abb315b4994193147e9f51b0c3268bfcd" kindref="member">k_mem_free_get</ref>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="300"><highlight class="normal"></highlight></codeline>
<codeline lineno="340" refid="mem__manage_8h_1ae9831427d79d64acfc9ad9c699d619d1" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*<ref refid="mem__manage_8h_1ae9831427d79d64acfc9ad9c699d619d1" kindref="member">k_mem_map</ref>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size,<sp/><ref refid="stdint_8h_1a0a8582351ac627ee8bde2973c825e47f" kindref="member">uint32_t</ref><sp/><ref refid="http__parser_8h_1ab6b306ef981f5e21bb41ea2c2dbe8cd9" kindref="member">flags</ref>);</highlight></codeline>
<codeline lineno="341"><highlight class="normal"></highlight></codeline>
<codeline lineno="355" refid="mem__manage_8h_1adc321dd750d9bdf36dec2f77d21a7207" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="mem__manage_8h_1adc321dd750d9bdf36dec2f77d21a7207" kindref="member">k_mem_unmap</ref>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*addr,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size);</highlight></codeline>
<codeline lineno="356"><highlight class="normal"></highlight></codeline>
<codeline lineno="370" refid="mem__manage_8h_1ad9a0110394e8026e27deb15687321ee9" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/><ref refid="mem__manage_8h_1ad9a0110394e8026e27deb15687321ee9" kindref="member">k_mem_region_align</ref>(<ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref><sp/>*aligned_addr,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>*aligned_size,</highlight></codeline>
<codeline lineno="371"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref><sp/>addr,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>align);</highlight></codeline>
<codeline lineno="372"><highlight class="normal"></highlight></codeline>
<codeline lineno="401" refid="group__mem-demand-paging_1ga0b18037209b4d8b5964bd9a1d760f703" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="group__mem-demand-paging_1ga0b18037209b4d8b5964bd9a1d760f703" kindref="member">k_mem_page_out</ref>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*addr,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size);</highlight></codeline>
<codeline lineno="402"><highlight class="normal"></highlight></codeline>
<codeline lineno="416" refid="group__mem-demand-paging_1gab36c36a4e230677d2090514f7a34b408" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__mem-demand-paging_1gab36c36a4e230677d2090514f7a34b408" kindref="member">k_mem_page_in</ref>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*addr,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size);</highlight></codeline>
<codeline lineno="417"><highlight class="normal"></highlight></codeline>
<codeline lineno="431" refid="group__mem-demand-paging_1ga5f2d422edde7d366e81a870ce057589f" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__mem-demand-paging_1ga5f2d422edde7d366e81a870ce057589f" kindref="member">k_mem_pin</ref>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*addr,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size);</highlight></codeline>
<codeline lineno="432"><highlight class="normal"></highlight></codeline>
<codeline lineno="443" refid="group__mem-demand-paging_1ga3278aae5e24733c722b7d83c4b17dab3" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__mem-demand-paging_1ga3278aae5e24733c722b7d83c4b17dab3" kindref="member">k_mem_unpin</ref>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*addr,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size);</highlight></codeline>
<codeline lineno="444"><highlight class="normal"></highlight></codeline>
<codeline lineno="453" refid="group__mem-demand-paging_1ga52ad88e0c0eed2aa27331bfd4707b7ec" refkind="member"><highlight class="normal">__syscall<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__mem-demand-paging_1ga52ad88e0c0eed2aa27331bfd4707b7ec" kindref="member">k_mem_paging_stats_get</ref>(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/><ref refid="structk__mem__paging__stats__t" kindref="compound">k_mem_paging_stats_t</ref><sp/>*stats);</highlight></codeline>
<codeline lineno="454"><highlight class="normal"></highlight></codeline>
<codeline lineno="455"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structk__thread" kindref="compound">k_thread</ref>;</highlight></codeline>
<codeline lineno="465"><highlight class="normal">__syscall</highlight></codeline>
<codeline lineno="466" refid="group__mem-demand-paging_1gafad6b39cb2faf3bb416cd4d3faaa8d8c" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__mem-demand-paging_1gafad6b39cb2faf3bb416cd4d3faaa8d8c" kindref="member">k_mem_paging_thread_stats_get</ref>(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/><ref refid="structk__thread" kindref="compound">k_thread</ref><sp/>*<ref refid="atomic_8c_1ae3e7b70821cb2fc4b41ff1189e70bc92" kindref="member">thread</ref>,</highlight></codeline>
<codeline lineno="467"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/><ref refid="structk__mem__paging__stats__t" kindref="compound">k_mem_paging_stats_t</ref><sp/>*stats);</highlight></codeline>
<codeline lineno="468"><highlight class="normal"></highlight></codeline>
<codeline lineno="477" refid="group__mem-demand-paging_1gaec64d019d819b00c7bc3804aac269199" refkind="member"><highlight class="normal">__syscall<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__mem-demand-paging_1gaec64d019d819b00c7bc3804aac269199" kindref="member">k_mem_paging_histogram_eviction_get</ref>(</highlight></codeline>
<codeline lineno="478"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/><ref refid="structk__mem__paging__histogram__t" kindref="compound">k_mem_paging_histogram_t</ref><sp/>*hist);</highlight></codeline>
<codeline lineno="479"><highlight class="normal"></highlight></codeline>
<codeline lineno="488" refid="group__mem-demand-paging_1ga1da0a643e8f85f98e29288e441a37dfa" refkind="member"><highlight class="normal">__syscall<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__mem-demand-paging_1ga1da0a643e8f85f98e29288e441a37dfa" kindref="member">k_mem_paging_histogram_backing_store_page_in_get</ref>(</highlight></codeline>
<codeline lineno="489"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/><ref refid="structk__mem__paging__histogram__t" kindref="compound">k_mem_paging_histogram_t</ref><sp/>*hist);</highlight></codeline>
<codeline lineno="490"><highlight class="normal"></highlight></codeline>
<codeline lineno="499" refid="group__mem-demand-paging_1gae4f80d14f88a46ddb9aeb7afba861864" refkind="member"><highlight class="normal">__syscall<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__mem-demand-paging_1gae4f80d14f88a46ddb9aeb7afba861864" kindref="member">k_mem_paging_histogram_backing_store_page_out_get</ref>(</highlight></codeline>
<codeline lineno="500"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/><ref refid="structk__mem__paging__histogram__t" kindref="compound">k_mem_paging_histogram_t</ref><sp/>*hist);</highlight></codeline>
<codeline lineno="501"><highlight class="normal"></highlight></codeline>
<codeline lineno="502"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;syscalls/mem_manage.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="503"><highlight class="normal"></highlight></codeline>
<codeline lineno="527" refid="group__mem-demand-paging-eviction_1ga12641d53942529c7d7364c08473a6eca" refkind="member"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">z_page_frame<sp/>*<ref refid="group__mem-demand-paging-eviction_1ga12641d53942529c7d7364c08473a6eca" kindref="member">k_mem_paging_eviction_select</ref>(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>*dirty);</highlight></codeline>
<codeline lineno="528"><highlight class="normal"></highlight></codeline>
<codeline lineno="536" refid="group__mem-demand-paging-eviction_1ga68dcfc0e5374de2c8ad7b9fe4e65c4f4" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__mem-demand-paging-eviction_1ga68dcfc0e5374de2c8ad7b9fe4e65c4f4" kindref="member">k_mem_paging_eviction_init</ref>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="537"><highlight class="normal"></highlight></codeline>
<codeline lineno="582" refid="group__mem-demand-paging-backing-store_1gaadedcda81ca04a2044332a8f6787967a" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="group__mem-demand-paging-backing-store_1gaadedcda81ca04a2044332a8f6787967a" kindref="member">k_mem_paging_backing_store_location_get</ref>(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/>z_page_frame<sp/>*pf,</highlight></codeline>
<codeline lineno="583"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref><sp/>*location,</highlight></codeline>
<codeline lineno="584"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>page_fault);</highlight></codeline>
<codeline lineno="585"><highlight class="normal"></highlight></codeline>
<codeline lineno="596" refid="group__mem-demand-paging-backing-store_1ga6ad421ad5671d9df3d96e03361f672e8" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__mem-demand-paging-backing-store_1ga6ad421ad5671d9df3d96e03361f672e8" kindref="member">k_mem_paging_backing_store_location_free</ref>(<ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref><sp/>location);</highlight></codeline>
<codeline lineno="597"><highlight class="normal"></highlight></codeline>
<codeline lineno="609" refid="group__mem-demand-paging-backing-store_1ga51f663e0a8c31367082e78097359af6d" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__mem-demand-paging-backing-store_1ga51f663e0a8c31367082e78097359af6d" kindref="member">k_mem_paging_backing_store_page_out</ref>(<ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref><sp/>location);</highlight></codeline>
<codeline lineno="610"><highlight class="normal"></highlight></codeline>
<codeline lineno="622" refid="group__mem-demand-paging-backing-store_1ga9becb4908cc7840ece93a2360692962d" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__mem-demand-paging-backing-store_1ga9becb4908cc7840ece93a2360692962d" kindref="member">k_mem_paging_backing_store_page_in</ref>(<ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref><sp/>location);</highlight></codeline>
<codeline lineno="623"><highlight class="normal"></highlight></codeline>
<codeline lineno="644" refid="group__mem-demand-paging-backing-store_1ga0902bc03fecfe8c7b51eb1f3efe587b7" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__mem-demand-paging-backing-store_1ga0902bc03fecfe8c7b51eb1f3efe587b7" kindref="member">k_mem_paging_backing_store_page_finalize</ref>(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/>z_page_frame<sp/>*pf,</highlight></codeline>
<codeline lineno="645"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref><sp/>location);</highlight></codeline>
<codeline lineno="646"><highlight class="normal"></highlight></codeline>
<codeline lineno="660" refid="group__mem-demand-paging-backing-store_1ga7ff441f23619b2678bfb72559d5bd592" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__mem-demand-paging-backing-store_1ga7ff441f23619b2678bfb72559d5bd592" kindref="member">k_mem_paging_backing_store_init</ref>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="661"><highlight class="normal"></highlight></codeline>
<codeline lineno="664"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>__cplusplus</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="665"><highlight class="normal">}</highlight></codeline>
<codeline lineno="666"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="667"><highlight class="normal"></highlight></codeline>
<codeline lineno="668"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">/*<sp/>!_ASMLANGUAGE<sp/>*/</highlight><highlight class="preprocessor"></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="669"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">/*<sp/>ZEPHYR_INCLUDE_SYS_MEM_MANAGE_H<sp/>*/</highlight><highlight class="preprocessor"></highlight></codeline>
    </programlisting>
    <location file="include/sys/mem_manage.h"/>
  </compounddef>
</doxygen>
