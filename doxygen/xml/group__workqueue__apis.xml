<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.2" xml:lang="en-US">
  <compounddef id="group__workqueue__apis" kind="group">
    <compoundname>workqueue_apis</compoundname>
    <title>Work Queue APIs</title>
    <innerclass refid="structk__work" prot="public">k_work</innerclass>
    <innerclass refid="structk__work__delayable" prot="public">k_work_delayable</innerclass>
    <innerclass refid="structk__work__sync" prot="public">k_work_sync</innerclass>
    <innerclass refid="structk__work__queue__config" prot="public">k_work_queue_config</innerclass>
    <innerclass refid="structk__work__q" prot="public">k_work_q</innerclass>
    <innerclass refid="structk__delayed__work" prot="public">k_delayed_work</innerclass>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="group__workqueue__apis_1ga15b3bbe041870ee299f7e042b0305e3c" prot="public" static="no" strong="no">
        <type></type>
        <name>@119</name>
        <enumvalue id="group__workqueue__apis_1gga15b3bbe041870ee299f7e042b0305e3cac6bee9a104cf6ee3853579f5eb15c165" prot="public">
          <name>K_WORK_RUNNING</name>
          <initializer>= BIT(K_WORK_RUNNING_BIT)</initializer>
          <briefdescription>
<para>Flag indicating a work item that is running under a work queue thread. </para>
          </briefdescription>
          <detaileddescription>
<para>Accessed via <ref refid="group__workqueue__apis_1gaba8a8734768d768b433f9d8490e7df7b" kindref="member">k_work_busy_get()</ref>. May co-occur with other flags. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__workqueue__apis_1gga15b3bbe041870ee299f7e042b0305e3ca9fdc4327489bcdcca3de0ee9eed6b732" prot="public">
          <name>K_WORK_CANCELING</name>
          <initializer>= BIT(K_WORK_CANCELING_BIT)</initializer>
          <briefdescription>
<para>Flag indicating a work item that is being canceled. </para>
          </briefdescription>
          <detaileddescription>
<para><verbatim>   Accessed via k_work_busy_get().  May co-occur with other flags.
</verbatim> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__workqueue__apis_1gga15b3bbe041870ee299f7e042b0305e3caa7f8855bc9931bff79062ce53b06eb85" prot="public">
          <name>K_WORK_QUEUED</name>
          <initializer>= BIT(K_WORK_QUEUED_BIT)</initializer>
          <briefdescription>
<para>Flag indicating a work item that has been submitted to a queue but has not started running. </para>
          </briefdescription>
          <detaileddescription>
<para>Accessed via <ref refid="group__workqueue__apis_1gaba8a8734768d768b433f9d8490e7df7b" kindref="member">k_work_busy_get()</ref>. May co-occur with other flags. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__workqueue__apis_1gga15b3bbe041870ee299f7e042b0305e3cab4bf9e74435077b2bbfe1de1f4e80aed" prot="public">
          <name>K_WORK_DELAYED</name>
          <initializer>= BIT(K_WORK_DELAYED_BIT)</initializer>
          <briefdescription>
<para>Flag indicating a delayed work item that is scheduled for submission to a queue. </para>
          </briefdescription>
          <detaileddescription>
<para>Accessed via <ref refid="group__workqueue__apis_1gaba8a8734768d768b433f9d8490e7df7b" kindref="member">k_work_busy_get()</ref>. May co-occur with other flags. </para>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3500" column="1" bodyfile="include/kernel.h" bodystart="3500" bodyend="3569"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="group__workqueue__apis_1ga5add9ef0dce306a08413c4140fc0bdda" prot="public" static="no">
        <type>void(*</type>
        <definition>typedef void(* k_work_handler_t) (struct k_work *work)</definition>
        <argsstring>)(struct k_work *work)</argsstring>
        <name>k_work_handler_t</name>
        <briefdescription>
<para>The signature for a work item handler function. </para>
        </briefdescription>
        <detaileddescription>
<para>The function will be invoked by the thread animating a work queue.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>work</parametername>
</parameternamelist>
<parameterdescription>
<para>the work item that provided the handler. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="2980" column="9" bodyfile="include/kernel.h" bodystart="2980" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__workqueue__apis_1gafdb3f5f2225b3d5d1fe682cb97f3b328" prot="public" static="no">
        <type>void(*</type>
        <definition>k_work_user_handler_t</definition>
        <argsstring>)(struct k_work_user *work)</argsstring>
        <name>k_work_user_handler_t</name>
        <briefdescription>
<para>Work item handler function type for user work queues. </para>
        </briefdescription>
        <detaileddescription>
<para>A work item&apos;s handler function is executed by a user workqueue&apos;s thread when the work item is processed by the workqueue.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>work</parametername>
</parameternamelist>
<parameterdescription>
<para>Address of the work item. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3917" column="9" bodyfile="include/kernel.h" bodystart="3917" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__workqueue__apis_1gaf20080884a2893d39cd8e862b34a2a30" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void k_work_init</definition>
        <argsstring>(struct k_work *work, k_work_handler_t handler)</argsstring>
        <name>k_work_init</name>
        <param>
          <type>struct <ref refid="structk__work" kindref="compound">k_work</ref> *</type>
          <declname>work</declname>
        </param>
        <param>
          <type><ref refid="group__workqueue__apis_1ga5add9ef0dce306a08413c4140fc0bdda" kindref="member">k_work_handler_t</ref></type>
          <declname>handler</declname>
        </param>
        <briefdescription>
<para>Initialize a (non-delayable) work structure. </para>
        </briefdescription>
        <detaileddescription>
<para>This must be invoked before submitting a work structure for the first time. It need not be invoked again on the same work structure. It can be re-invoked to change the associated handler, but this must be done when the work item is idle.</para>
<para><simplesect kind="par"><title>Function properties (list may not be complete)</title><para><htmlonly> isr-ok </htmlonly>  <verbatim>embed:rst:inline :ref:`api_term_isr-ok`</verbatim> </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>work</parametername>
</parameternamelist>
<parameterdescription>
<para>the work structure to be initialized.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>handler</parametername>
</parameternamelist>
<parameterdescription>
<para>the handler to be invoked by the work item. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="2995" column="6" declfile="include/kernel.h" declline="2995" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1gaba8a8734768d768b433f9d8490e7df7b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int k_work_busy_get</definition>
        <argsstring>(const struct k_work *work)</argsstring>
        <name>k_work_busy_get</name>
        <param>
          <type>const struct <ref refid="structk__work" kindref="compound">k_work</ref> *</type>
          <declname>work</declname>
        </param>
        <briefdescription>
<para>Busy state flags from the work item. </para>
        </briefdescription>
        <detaileddescription>
<para>A zero return value indicates the work item appears to be idle.</para>
<para><simplesect kind="note"><para>This is a live snapshot of state, which may change before the result is checked. Use locks where appropriate.</para>
</simplesect>
<simplesect kind="par"><title>Function properties (list may not be complete)</title><para><htmlonly> isr-ok </htmlonly>  <verbatim>embed:rst:inline :ref:`api_term_isr-ok`</verbatim> </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>work</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the work item.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a mask of flags K_WORK_DELAYED, K_WORK_QUEUED, K_WORK_RUNNING, and K_WORK_CANCELING. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3012" column="5" declfile="include/kernel.h" declline="3012" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1ga0d1d2e1d2ba2e89a560a1bdc5365d9e0" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="stdbool_8h_1abb452686968e48b67397da5f97445f5b" kindref="member">bool</ref></type>
        <definition>static bool k_work_is_pending</definition>
        <argsstring>(const struct k_work *work)</argsstring>
        <name>k_work_is_pending</name>
        <param>
          <type>const struct <ref refid="structk__work" kindref="compound">k_work</ref> *</type>
          <declname>work</declname>
        </param>
        <briefdescription>
<para>Test whether a work item is currently pending. </para>
        </briefdescription>
        <detaileddescription>
<para>Wrapper to determine whether a work item is in a non-idle dstate.</para>
<para><simplesect kind="note"><para>This is a live snapshot of state, which may change before the result is checked. Use locks where appropriate.</para>
</simplesect>
<simplesect kind="par"><title>Function properties (list may not be complete)</title><para><htmlonly> isr-ok </htmlonly>  <verbatim>embed:rst:inline :ref:`api_term_isr-ok`</verbatim> </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>work</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the work item.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if and only if <ref refid="group__workqueue__apis_1gaba8a8734768d768b433f9d8490e7df7b" kindref="member">k_work_busy_get()</ref> returns a non-zero value. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3742" column="20" bodyfile="include/kernel.h" bodystart="3742" bodyend="3745" declfile="include/kernel.h" declline="3027" declcolumn="20"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1ga5353e76f73db070614f50d06d292d05c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int k_work_submit_to_queue</definition>
        <argsstring>(struct k_work_q *queue, struct k_work *work)</argsstring>
        <name>k_work_submit_to_queue</name>
        <param>
          <type>struct <ref refid="structk__work__q" kindref="compound">k_work_q</ref> *</type>
          <declname>queue</declname>
        </param>
        <param>
          <type>struct <ref refid="structk__work" kindref="compound">k_work</ref> *</type>
          <declname>work</declname>
        </param>
        <briefdescription>
<para>Submit a work item to a queue. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>queue</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the work queue on which the item should run. If NULL the queue from the most recent submission will be used.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="par"><title>Function properties (list may not be complete)</title><para><htmlonly> isr-ok </htmlonly>  <verbatim>embed:rst:inline :ref:`api_term_isr-ok`</verbatim> </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>work</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the work item.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>0</parametername>
</parameternamelist>
<parameterdescription>
<para>if work was already submitted to a queue </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>1</parametername>
</parameternamelist>
<parameterdescription>
<para>if work was not submitted and has been queued to <computeroutput>queue</computeroutput> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>2</parametername>
</parameternamelist>
<parameterdescription>
<para>if work was running and has been queued to the queue that was running it </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>-EBUSY</parametername>
</parameternamelist>
<parameterdescription>
<para><itemizedlist>
<listitem><para>if work submission was rejected because the work item is cancelling; or</para>
</listitem><listitem><para><computeroutput>queue</computeroutput> is draining; or</para>
</listitem><listitem><para><computeroutput>queue</computeroutput> is plugged. </para>
</listitem></itemizedlist>
</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>-EINVAL</parametername>
</parameternamelist>
<parameterdescription>
<para>if <computeroutput>queue</computeroutput> is null and the work item has never been run. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>-ENODEV</parametername>
</parameternamelist>
<parameterdescription>
<para>if <computeroutput>queue</computeroutput> has not been started. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3049" column="5" declfile="include/kernel.h" declline="3049" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1gace61b59575093d7442f39ccb7be686d7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int k_work_submit</definition>
        <argsstring>(struct k_work *work)</argsstring>
        <name>k_work_submit</name>
        <param>
          <type>struct <ref refid="structk__work" kindref="compound">k_work</ref> *</type>
          <declname>work</declname>
        </param>
        <briefdescription>
<para>Submit a work item to the system queue. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="par"><title>Function properties (list may not be complete)</title><para><htmlonly> isr-ok </htmlonly>  <verbatim>embed:rst:inline :ref:`api_term_isr-ok`</verbatim> </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>work</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the work item.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>as with <ref refid="group__workqueue__apis_1ga5353e76f73db070614f50d06d292d05c" kindref="member">k_work_submit_to_queue()</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3060" column="12" declfile="include/kernel.h" declline="3060" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1gabd1cda459bab538fb2d6dfd84a73b253" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="stdbool_8h_1abb452686968e48b67397da5f97445f5b" kindref="member">bool</ref></type>
        <definition>bool k_work_flush</definition>
        <argsstring>(struct k_work *work, struct k_work_sync *sync)</argsstring>
        <name>k_work_flush</name>
        <param>
          <type>struct <ref refid="structk__work" kindref="compound">k_work</ref> *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>struct <ref refid="structk__work__sync" kindref="compound">k_work_sync</ref> *</type>
          <declname>sync</declname>
        </param>
        <briefdescription>
<para>Wait for last-submitted instance to complete. </para>
        </briefdescription>
        <detaileddescription>
<para>Resubmissions may occur while waiting, including chained submissions (from within the handler).</para>
<para><simplesect kind="note"><para>Be careful of caller and work queue thread relative priority. If this function sleeps it will not return until the work queue thread completes the tasks that allow this thread to resume.</para>
</simplesect>
<simplesect kind="note"><para>Behavior is undefined if this function is invoked on <computeroutput>work</computeroutput> from a work queue running <computeroutput>work</computeroutput>.</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>work</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the work item.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sync</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to an opaque item containing state related to the pending cancellation. The object must persist until the call returns, and be accessible from both the caller thread and the work queue thread. The object must not be used for any other flush or cancel operation until this one completes. On architectures with CONFIG_KERNEL_COHERENCE the object must be allocated in coherent memory.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>true</parametername>
</parameternamelist>
<parameterdescription>
<para>if call had to wait for completion </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>false</parametername>
</parameternamelist>
<parameterdescription>
<para>if work was already idle </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3086" column="6" declfile="include/kernel.h" declline="3086" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1ga389fe2a8fb20f9bd593cf8d990727078" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int k_work_cancel</definition>
        <argsstring>(struct k_work *work)</argsstring>
        <name>k_work_cancel</name>
        <param>
          <type>struct <ref refid="structk__work" kindref="compound">k_work</ref> *</type>
          <declname>work</declname>
        </param>
        <briefdescription>
<para>Cancel a work item. </para>
        </briefdescription>
        <detaileddescription>
<para>This attempts to prevent a pending (non-delayable) work item from being processed by removing it from the work queue. If the item is being processed, the work item will continue to be processed, but resubmissions are rejected until cancellation completes.</para>
<para>If this returns zero cancellation is complete, otherwise something (probably a work queue thread) is still referencing the item.</para>
<para>See also <ref refid="group__workqueue__apis_1gab2b05cfe3af08f7d32c3946fa1c808f9" kindref="member">k_work_cancel_sync()</ref>.</para>
<para><simplesect kind="par"><title>Function properties (list may not be complete)</title><para><htmlonly> isr-ok </htmlonly>  <verbatim>embed:rst:inline :ref:`api_term_isr-ok`</verbatim> </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>work</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the work item.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the <ref refid="group__workqueue__apis_1gaba8a8734768d768b433f9d8490e7df7b" kindref="member">k_work_busy_get()</ref> status indicating the state of the item after all cancellation steps performed by this call are completed. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3108" column="5" declfile="include/kernel.h" declline="3108" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1gab2b05cfe3af08f7d32c3946fa1c808f9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="stdbool_8h_1abb452686968e48b67397da5f97445f5b" kindref="member">bool</ref></type>
        <definition>bool k_work_cancel_sync</definition>
        <argsstring>(struct k_work *work, struct k_work_sync *sync)</argsstring>
        <name>k_work_cancel_sync</name>
        <param>
          <type>struct <ref refid="structk__work" kindref="compound">k_work</ref> *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>struct <ref refid="structk__work__sync" kindref="compound">k_work_sync</ref> *</type>
          <declname>sync</declname>
        </param>
        <briefdescription>
<para>Cancel a work item and wait for it to complete. </para>
        </briefdescription>
        <detaileddescription>
<para>Same as <ref refid="group__workqueue__apis_1ga389fe2a8fb20f9bd593cf8d990727078" kindref="member">k_work_cancel()</ref> but does not return until cancellation is complete. This can be invoked by a thread after <ref refid="group__workqueue__apis_1ga389fe2a8fb20f9bd593cf8d990727078" kindref="member">k_work_cancel()</ref> to synchronize with a previous cancellation.</para>
<para>On return the work structure will be idle unless something submits it after the cancellation was complete.</para>
<para><simplesect kind="note"><para>Be careful of caller and work queue thread relative priority. If this function sleeps it will not return until the work queue thread completes the tasks that allow this thread to resume.</para>
</simplesect>
<simplesect kind="note"><para>Behavior is undefined if this function is invoked on <computeroutput>work</computeroutput> from a work queue running <computeroutput>work</computeroutput>.</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>work</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the work item.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sync</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to an opaque item containing state related to the pending cancellation. The object must persist until the call returns, and be accessible from both the caller thread and the work queue thread. The object must not be used for any other flush or cancel operation until this one completes. On architectures with CONFIG_KERNEL_COHERENCE the object must be allocated in coherent memory.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>true</parametername>
</parameternamelist>
<parameterdescription>
<para>if work was pending (call had to wait for cancellation of a running handler to complete, or scheduled or submitted operations were cancelled); </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>false</parametername>
</parameternamelist>
<parameterdescription>
<para>otherwise </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3140" column="6" declfile="include/kernel.h" declline="3140" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1gada77d818ea9e4d07c14a960872ed5492" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void k_work_queue_init</definition>
        <argsstring>(struct k_work_q *queue)</argsstring>
        <name>k_work_queue_init</name>
        <param>
          <type>struct <ref refid="structk__work__q" kindref="compound">k_work_q</ref> *</type>
          <declname>queue</declname>
        </param>
        <briefdescription>
<para>Initialize a work queue structure. </para>
        </briefdescription>
        <detaileddescription>
<para>This must be invoked before starting a work queue structure for the first time. It need not be invoked again on the same work queue structure.</para>
<para><simplesect kind="par"><title>Function properties (list may not be complete)</title><para><htmlonly> isr-ok </htmlonly>  <verbatim>embed:rst:inline :ref:`api_term_isr-ok`</verbatim> </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>queue</parametername>
</parameternamelist>
<parameterdescription>
<para>the queue structure to be initialized. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3151" column="6" declfile="include/kernel.h" declline="3151" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1gadfc56554f9bfe7b52309d79660188593" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void k_work_queue_start</definition>
        <argsstring>(struct k_work_q *queue, k_thread_stack_t *stack, size_t stack_size, int prio, const struct k_work_queue_config *cfg)</argsstring>
        <name>k_work_queue_start</name>
        <param>
          <type>struct <ref refid="structk__work__q" kindref="compound">k_work_q</ref> *</type>
          <declname>queue</declname>
        </param>
        <param>
          <type><ref refid="arch__interface_8h_1a3e4bde3075edb41069b258d999333b0e" kindref="member">k_thread_stack_t</ref> *</type>
          <declname>stack</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>stack_size</declname>
        </param>
        <param>
          <type>int</type>
          <declname>prio</declname>
        </param>
        <param>
          <type>const struct <ref refid="structk__work__queue__config" kindref="compound">k_work_queue_config</ref> *</type>
          <declname>cfg</declname>
        </param>
        <briefdescription>
<para>Initialize a work queue. </para>
        </briefdescription>
        <detaileddescription>
<para>This configures the work queue thread and starts it running. The function should not be re-invoked on a queue.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>queue</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the queue structure. It must be initialized in zeroed/bss memory or with <ref refid="group__workqueue__apis_1gada77d818ea9e4d07c14a960872ed5492" kindref="member">k_work_queue_init</ref> before use.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stack</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the work thread stack area.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stack_size</parametername>
</parameternamelist>
<parameterdescription>
<para>size of the the work thread stack area, in bytes.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>prio</parametername>
</parameternamelist>
<parameterdescription>
<para>initial thread priority</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cfg</parametername>
</parameternamelist>
<parameterdescription>
<para>optional additional configuration parameters. Pass <computeroutput>NULL</computeroutput> if not required, to use the defaults documented in <ref refid="structk__work__queue__config" kindref="compound">k_work_queue_config</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3172" column="6" declfile="include/kernel.h" declline="3172" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1ga0b8b496f7e7bd82d08590a07293e38d7" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="kernel_2thread_8h_1a6379f5a1f19ffbc262a6877c4f6e3647" kindref="member">k_tid_t</ref></type>
        <definition>static k_tid_t k_work_queue_thread_get</definition>
        <argsstring>(struct k_work_q *queue)</argsstring>
        <name>k_work_queue_thread_get</name>
        <param>
          <type>struct <ref refid="structk__work__q" kindref="compound">k_work_q</ref> *</type>
          <declname>queue</declname>
        </param>
        <briefdescription>
<para>Access the thread that animates a work queue. </para>
        </briefdescription>
        <detaileddescription>
<para>This is necessary to grant a work queue thread access to things the work items it will process are expected to use.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>queue</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the queue structure.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the thread associated with the work queue. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3771" column="23" bodyfile="include/kernel.h" bodystart="3771" bodyend="3774" declfile="include/kernel.h" declline="3185" declcolumn="23"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1ga0fefe3e0225ac99b47b250849f6cd863" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int k_work_queue_drain</definition>
        <argsstring>(struct k_work_q *queue, bool plug)</argsstring>
        <name>k_work_queue_drain</name>
        <param>
          <type>struct <ref refid="structk__work__q" kindref="compound">k_work_q</ref> *</type>
          <declname>queue</declname>
        </param>
        <param>
          <type><ref refid="stdbool_8h_1abb452686968e48b67397da5f97445f5b" kindref="member">bool</ref></type>
          <declname>plug</declname>
        </param>
        <briefdescription>
<para>Wait until the work queue has drained, optionally plugging it. </para>
        </briefdescription>
        <detaileddescription>
<para>This blocks submission to the work queue except when coming from queue thread, and blocks the caller until no more work items are available in the queue.</para>
<para>If <computeroutput>plug</computeroutput> is true then submission will continue to be blocked after the drain operation completes until <ref refid="group__workqueue__apis_1gaa0463bb79af3ec470f7d3be02052139f" kindref="member">k_work_queue_unplug()</ref> is invoked.</para>
<para>Note that work items that are delayed are not yet associated with their work queue. They must be cancelled externally if a goal is to ensure the work queue remains empty. The <computeroutput>plug</computeroutput> feature can be used to prevent delayed items from being submitted after the drain completes.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>queue</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the queue structure.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>plug</parametername>
</parameternamelist>
<parameterdescription>
<para>if true the work queue will continue to block new submissions after all items have drained.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>1</parametername>
</parameternamelist>
<parameterdescription>
<para>if call had to wait for the drain to complete </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>0</parametername>
</parameternamelist>
<parameterdescription>
<para>if call did not have to wait </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>negative</parametername>
</parameternamelist>
<parameterdescription>
<para>if wait was interrupted or failed </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3210" column="5" declfile="include/kernel.h" declline="3210" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1gaa0463bb79af3ec470f7d3be02052139f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int k_work_queue_unplug</definition>
        <argsstring>(struct k_work_q *queue)</argsstring>
        <name>k_work_queue_unplug</name>
        <param>
          <type>struct <ref refid="structk__work__q" kindref="compound">k_work_q</ref> *</type>
          <declname>queue</declname>
        </param>
        <briefdescription>
<para>Release a work queue to accept new submissions. </para>
        </briefdescription>
        <detaileddescription>
<para>This releases the block on new submissions placed when <ref refid="group__workqueue__apis_1ga0fefe3e0225ac99b47b250849f6cd863" kindref="member">k_work_queue_drain()</ref> is invoked with the <computeroutput>plug</computeroutput> option enabled. If this is invoked before the drain completes new items may be submitted as soon as the drain completes.</para>
<para><simplesect kind="par"><title>Function properties (list may not be complete)</title><para><htmlonly> isr-ok </htmlonly>  <verbatim>embed:rst:inline :ref:`api_term_isr-ok`</verbatim> </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>queue</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the queue structure.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>0</parametername>
</parameternamelist>
<parameterdescription>
<para>if successfully unplugged </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>-EALREADY</parametername>
</parameternamelist>
<parameterdescription>
<para>if the work queue was not plugged. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3225" column="5" declfile="include/kernel.h" declline="3225" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1ga2876c5d82fb2340a093bc4d689a55465" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void k_work_init_delayable</definition>
        <argsstring>(struct k_work_delayable *dwork, k_work_handler_t handler)</argsstring>
        <name>k_work_init_delayable</name>
        <param>
          <type>struct <ref refid="structk__work__delayable" kindref="compound">k_work_delayable</ref> *</type>
          <declname>dwork</declname>
        </param>
        <param>
          <type><ref refid="group__workqueue__apis_1ga5add9ef0dce306a08413c4140fc0bdda" kindref="member">k_work_handler_t</ref></type>
          <declname>handler</declname>
        </param>
        <briefdescription>
<para>Initialize a delayable work structure. </para>
        </briefdescription>
        <detaileddescription>
<para>This must be invoked before scheduling a delayable work structure for the first time. It need not be invoked again on the same work structure. It can be re-invoked to change the associated handler, but this must be done when the work item is idle.</para>
<para><simplesect kind="par"><title>Function properties (list may not be complete)</title><para><htmlonly> isr-ok </htmlonly>  <verbatim>embed:rst:inline :ref:`api_term_isr-ok`</verbatim> </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dwork</parametername>
</parameternamelist>
<parameterdescription>
<para>the delayable work structure to be initialized.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>handler</parametername>
</parameternamelist>
<parameterdescription>
<para>the handler to be invoked by the work item. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3240" column="6" declfile="include/kernel.h" declline="3240" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1gabcb822a03ce7ea9ee1ed046afe31ffca" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>struct <ref refid="structk__work__delayable" kindref="compound">k_work_delayable</ref> *</type>
        <definition>static struct k_work_delayable * k_work_delayable_from_work</definition>
        <argsstring>(struct k_work *work)</argsstring>
        <name>k_work_delayable_from_work</name>
        <param>
          <type>struct <ref refid="structk__work" kindref="compound">k_work</ref> *</type>
          <declname>work</declname>
        </param>
        <briefdescription>
<para>Get the parent delayable work structure from a work pointer. </para>
        </briefdescription>
        <detaileddescription>
<para>This function is necessary when a <computeroutput>k_work_handler_t</computeroutput> function is passed to <ref refid="group__workqueue__apis_1ga17f863c9f6ff2fb41dc0f3b7de4fdf23" kindref="member">k_work_schedule_for_queue()</ref> and the handler needs to access data from the container of the containing <computeroutput><ref refid="structk__work__delayable" kindref="compound">k_work_delayable</ref></computeroutput>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>work</parametername>
</parameternamelist>
<parameterdescription>
<para>Address passed to the work handler</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Address of the containing <computeroutput><ref refid="structk__work__delayable" kindref="compound">k_work_delayable</ref></computeroutput> structure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3748" column="1" bodyfile="include/kernel.h" bodystart="3748" bodyend="3751" declfile="include/kernel.h" declline="3255" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1ga1b76969667844f0981d348c9c671bc9f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int k_work_delayable_busy_get</definition>
        <argsstring>(const struct k_work_delayable *dwork)</argsstring>
        <name>k_work_delayable_busy_get</name>
        <param>
          <type>const struct <ref refid="structk__work__delayable" kindref="compound">k_work_delayable</ref> *</type>
          <declname>dwork</declname>
        </param>
        <briefdescription>
<para>Busy state flags from the delayable work item. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="par"><title>Function properties (list may not be complete)</title><para><htmlonly> isr-ok </htmlonly>  <verbatim>embed:rst:inline :ref:`api_term_isr-ok`</verbatim> </para>
</simplesect>
<simplesect kind="note"><para>This is a live snapshot of state, which may change before the result can be inspected. Use locks where appropriate.</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dwork</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the delayable work item.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a mask of flags K_WORK_DELAYED, K_WORK_QUEUED, K_WORK_RUNNING, and K_WORK_CANCELING. A zero return value indicates the work item appears to be idle. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3270" column="5" declfile="include/kernel.h" declline="3270" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1ga66e598dbc73f653cbfec03c21168df2e" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="stdbool_8h_1abb452686968e48b67397da5f97445f5b" kindref="member">bool</ref></type>
        <definition>static bool k_work_delayable_is_pending</definition>
        <argsstring>(const struct k_work_delayable *dwork)</argsstring>
        <name>k_work_delayable_is_pending</name>
        <param>
          <type>const struct <ref refid="structk__work__delayable" kindref="compound">k_work_delayable</ref> *</type>
          <declname>dwork</declname>
        </param>
        <briefdescription>
<para>Test whether a delayed work item is currently pending. </para>
        </briefdescription>
        <detaileddescription>
<para>Wrapper to determine whether a delayed work item is in a non-idle state.</para>
<para><simplesect kind="note"><para>This is a live snapshot of state, which may change before the result can be inspected. Use locks where appropriate.</para>
</simplesect>
<simplesect kind="par"><title>Function properties (list may not be complete)</title><para><htmlonly> isr-ok </htmlonly>  <verbatim>embed:rst:inline :ref:`api_term_isr-ok`</verbatim> </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dwork</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the delayable work item.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if and only if <ref refid="group__workqueue__apis_1ga1b76969667844f0981d348c9c671bc9f" kindref="member">k_work_delayable_busy_get()</ref> returns a non-zero value. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3753" column="20" bodyfile="include/kernel.h" bodystart="3753" bodyend="3757" declfile="include/kernel.h" declline="3286" declcolumn="20"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1ga1772c37bc62b86180d5cf48fe3037624" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="group__clock__apis_1ga9832cb0adc2d1866420e5c370a0863e2" kindref="member">k_ticks_t</ref></type>
        <definition>static k_ticks_t k_work_delayable_expires_get</definition>
        <argsstring>(const struct k_work_delayable *dwork)</argsstring>
        <name>k_work_delayable_expires_get</name>
        <param>
          <type>const struct <ref refid="structk__work__delayable" kindref="compound">k_work_delayable</ref> *</type>
          <declname>dwork</declname>
        </param>
        <briefdescription>
<para>Get the absolute tick count at which a scheduled delayable work will be submitted. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>This is a live snapshot of state, which may change before the result can be inspected. Use locks where appropriate.</para>
</simplesect>
<simplesect kind="par"><title>Function properties (list may not be complete)</title><para><htmlonly> isr-ok </htmlonly>  <verbatim>embed:rst:inline :ref:`api_term_isr-ok`</verbatim> </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dwork</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the delayable work item.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the tick count when the timer that will schedule the work item will expire, or the current tick count if the work is not scheduled. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3759" column="25" bodyfile="include/kernel.h" bodystart="3759" bodyend="3763" declfile="include/kernel.h" declline="3302" declcolumn="25"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1gabce78598a014f3ed87730fe6a9fe61b4" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="group__clock__apis_1ga9832cb0adc2d1866420e5c370a0863e2" kindref="member">k_ticks_t</ref></type>
        <definition>static k_ticks_t k_work_delayable_remaining_get</definition>
        <argsstring>(const struct k_work_delayable *dwork)</argsstring>
        <name>k_work_delayable_remaining_get</name>
        <param>
          <type>const struct <ref refid="structk__work__delayable" kindref="compound">k_work_delayable</ref> *</type>
          <declname>dwork</declname>
        </param>
        <briefdescription>
<para>Get the number of ticks until a scheduled delayable work will be submitted. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>This is a live snapshot of state, which may change before the result can be inspected. Use locks where appropriate.</para>
</simplesect>
<simplesect kind="par"><title>Function properties (list may not be complete)</title><para><htmlonly> isr-ok </htmlonly>  <verbatim>embed:rst:inline :ref:`api_term_isr-ok`</verbatim> </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dwork</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the delayable work item.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the number of ticks until the timer that will schedule the work item will expire, or zero if the item is not scheduled. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3765" column="25" bodyfile="include/kernel.h" bodystart="3765" bodyend="3769" declfile="include/kernel.h" declline="3318" declcolumn="25"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1ga17f863c9f6ff2fb41dc0f3b7de4fdf23" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int k_work_schedule_for_queue</definition>
        <argsstring>(struct k_work_q *queue, struct k_work_delayable *dwork, k_timeout_t delay)</argsstring>
        <name>k_work_schedule_for_queue</name>
        <param>
          <type>struct <ref refid="structk__work__q" kindref="compound">k_work_q</ref> *</type>
          <declname>queue</declname>
        </param>
        <param>
          <type>struct <ref refid="structk__work__delayable" kindref="compound">k_work_delayable</ref> *</type>
          <declname>dwork</declname>
        </param>
        <param>
          <type><ref refid="structk__timeout__t" kindref="compound">k_timeout_t</ref></type>
          <declname>delay</declname>
        </param>
        <briefdescription>
<para>Submit an idle work item to a queue after a delay. </para>
        </briefdescription>
        <detaileddescription>
<para>Unlike <ref refid="group__workqueue__apis_1gabf5db091eac19b19a4e12c0cb381f0a8" kindref="member">k_work_reschedule_for_queue()</ref> this is a no-op if the work item is already scheduled or submitted, even if <computeroutput>delay</computeroutput> is <computeroutput>K_NO_WAIT</computeroutput>.</para>
<para><simplesect kind="par"><title>Function properties (list may not be complete)</title><para><htmlonly> isr-ok </htmlonly>  <verbatim>embed:rst:inline :ref:`api_term_isr-ok`</verbatim> </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>queue</parametername>
</parameternamelist>
<parameterdescription>
<para>the queue on which the work item should be submitted after the delay.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dwork</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the delayable work item.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>delay</parametername>
</parameternamelist>
<parameterdescription>
<para>the time to wait before submitting the work item. If <computeroutput>K_NO_WAIT</computeroutput> and the work is not pending this is equivalent to <ref refid="group__workqueue__apis_1ga5353e76f73db070614f50d06d292d05c" kindref="member">k_work_submit_to_queue()</ref>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>0</parametername>
</parameternamelist>
<parameterdescription>
<para>if work was already scheduled or submitted. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>1</parametername>
</parameternamelist>
<parameterdescription>
<para>if work has been scheduled. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>-EBUSY</parametername>
</parameternamelist>
<parameterdescription>
<para>if <computeroutput>delay</computeroutput> is <computeroutput>K_NO_WAIT</computeroutput> and <ref refid="group__workqueue__apis_1ga5353e76f73db070614f50d06d292d05c" kindref="member">k_work_submit_to_queue()</ref> fails with this code. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>-EINVAL</parametername>
</parameternamelist>
<parameterdescription>
<para>if <computeroutput>delay</computeroutput> is <computeroutput>K_NO_WAIT</computeroutput> and <ref refid="group__workqueue__apis_1ga5353e76f73db070614f50d06d292d05c" kindref="member">k_work_submit_to_queue()</ref> fails with this code. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>-ENODEV</parametername>
</parameternamelist>
<parameterdescription>
<para>if <computeroutput>delay</computeroutput> is <computeroutput>K_NO_WAIT</computeroutput> and <ref refid="group__workqueue__apis_1ga5353e76f73db070614f50d06d292d05c" kindref="member">k_work_submit_to_queue()</ref> fails with this code. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3346" column="5" declfile="include/kernel.h" declline="3346" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1ga5c113ea2bc8e8e5cd7a5c8bc5ec595d3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int k_work_schedule</definition>
        <argsstring>(struct k_work_delayable *dwork, k_timeout_t delay)</argsstring>
        <name>k_work_schedule</name>
        <param>
          <type>struct <ref refid="structk__work__delayable" kindref="compound">k_work_delayable</ref> *</type>
          <declname>dwork</declname>
        </param>
        <param>
          <type><ref refid="structk__timeout__t" kindref="compound">k_timeout_t</ref></type>
          <declname>delay</declname>
        </param>
        <briefdescription>
<para>Submit an idle work item to the system work queue after a delay. </para>
        </briefdescription>
        <detaileddescription>
<para>This is a thin wrapper around <ref refid="group__workqueue__apis_1ga17f863c9f6ff2fb41dc0f3b7de4fdf23" kindref="member">k_work_schedule_for_queue()</ref>, with all the API characteristcs of that function.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dwork</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the delayable work item.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>delay</parametername>
</parameternamelist>
<parameterdescription>
<para>the time to wait before submitting the work item. If <computeroutput>K_NO_WAIT</computeroutput> this is equivalent to <ref refid="group__workqueue__apis_1ga5353e76f73db070614f50d06d292d05c" kindref="member">k_work_submit_to_queue()</ref>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>as with <ref refid="group__workqueue__apis_1ga17f863c9f6ff2fb41dc0f3b7de4fdf23" kindref="member">k_work_schedule_for_queue()</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3363" column="12" declfile="include/kernel.h" declline="3363" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1gabf5db091eac19b19a4e12c0cb381f0a8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int k_work_reschedule_for_queue</definition>
        <argsstring>(struct k_work_q *queue, struct k_work_delayable *dwork, k_timeout_t delay)</argsstring>
        <name>k_work_reschedule_for_queue</name>
        <param>
          <type>struct <ref refid="structk__work__q" kindref="compound">k_work_q</ref> *</type>
          <declname>queue</declname>
        </param>
        <param>
          <type>struct <ref refid="structk__work__delayable" kindref="compound">k_work_delayable</ref> *</type>
          <declname>dwork</declname>
        </param>
        <param>
          <type><ref refid="structk__timeout__t" kindref="compound">k_timeout_t</ref></type>
          <declname>delay</declname>
        </param>
        <briefdescription>
<para>Reschedule a work item to a queue after a delay. </para>
        </briefdescription>
        <detaileddescription>
<para>Unlike <ref refid="group__workqueue__apis_1ga17f863c9f6ff2fb41dc0f3b7de4fdf23" kindref="member">k_work_schedule_for_queue()</ref> this function can change the deadline of a scheduled work item, and will schedule a work item that isn&apos;t idle (e.g. is submitted or running). This function does not affect (&quot;unsubmit&quot;) a work item that has been submitted to a queue.</para>
<para><simplesect kind="par"><title>Function properties (list may not be complete)</title><para><htmlonly> isr-ok </htmlonly>  <verbatim>embed:rst:inline :ref:`api_term_isr-ok`</verbatim> </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>queue</parametername>
</parameternamelist>
<parameterdescription>
<para>the queue on which the work item should be submitted after the delay.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dwork</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the delayable work item.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>delay</parametername>
</parameternamelist>
<parameterdescription>
<para>the time to wait before submitting the work item. If <computeroutput>K_NO_WAIT</computeroutput> this is equivalent to <ref refid="group__workqueue__apis_1ga5353e76f73db070614f50d06d292d05c" kindref="member">k_work_submit_to_queue()</ref> after canceling any previous scheduled submission.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>If delay is <computeroutput>K_NO_WAIT</computeroutput> (&quot;no delay&quot;) the return values are as with <ref refid="group__workqueue__apis_1ga5353e76f73db070614f50d06d292d05c" kindref="member">k_work_submit_to_queue()</ref>.</para>
</simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>0</parametername>
</parameternamelist>
<parameterdescription>
<para>if delay is <computeroutput>K_NO_WAIT</computeroutput> and work was already on a queue </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>1</parametername>
</parameternamelist>
<parameterdescription>
<para>if<itemizedlist>
<listitem><para>delay is <computeroutput>K_NO_WAIT</computeroutput> and work was not submitted but has now been queued to <computeroutput>queue</computeroutput>; or</para>
</listitem><listitem><para>delay not <computeroutput>K_NO_WAIT</computeroutput> and work has been scheduled </para>
</listitem></itemizedlist>
</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>2</parametername>
</parameternamelist>
<parameterdescription>
<para>if delay is <computeroutput>K_NO_WAIT</computeroutput> and work was running and has been queued to the queue that was running it </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>-EBUSY</parametername>
</parameternamelist>
<parameterdescription>
<para>if <computeroutput>delay</computeroutput> is <computeroutput>K_NO_WAIT</computeroutput> and <ref refid="group__workqueue__apis_1ga5353e76f73db070614f50d06d292d05c" kindref="member">k_work_submit_to_queue()</ref> fails with this code. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>-EINVAL</parametername>
</parameternamelist>
<parameterdescription>
<para>if <computeroutput>delay</computeroutput> is <computeroutput>K_NO_WAIT</computeroutput> and <ref refid="group__workqueue__apis_1ga5353e76f73db070614f50d06d292d05c" kindref="member">k_work_submit_to_queue()</ref> fails with this code. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>-ENODEV</parametername>
</parameternamelist>
<parameterdescription>
<para>if <computeroutput>delay</computeroutput> is <computeroutput>K_NO_WAIT</computeroutput> and <ref refid="group__workqueue__apis_1ga5353e76f73db070614f50d06d292d05c" kindref="member">k_work_submit_to_queue()</ref> fails with this code. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3401" column="5" declfile="include/kernel.h" declline="3401" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1gaacaab408fb7c848d466ad1f069dfa648" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int k_work_reschedule</definition>
        <argsstring>(struct k_work_delayable *dwork, k_timeout_t delay)</argsstring>
        <name>k_work_reschedule</name>
        <param>
          <type>struct <ref refid="structk__work__delayable" kindref="compound">k_work_delayable</ref> *</type>
          <declname>dwork</declname>
        </param>
        <param>
          <type><ref refid="structk__timeout__t" kindref="compound">k_timeout_t</ref></type>
          <declname>delay</declname>
        </param>
        <briefdescription>
<para>Reschedule a work item to the system work queue after a delay. </para>
        </briefdescription>
        <detaileddescription>
<para>This is a thin wrapper around <ref refid="group__workqueue__apis_1gabf5db091eac19b19a4e12c0cb381f0a8" kindref="member">k_work_reschedule_for_queue()</ref>, with all the API characteristcs of that function.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dwork</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the delayable work item.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>delay</parametername>
</parameternamelist>
<parameterdescription>
<para>the time to wait before submitting the work item.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>as with <ref refid="group__workqueue__apis_1gabf5db091eac19b19a4e12c0cb381f0a8" kindref="member">k_work_reschedule_for_queue()</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3417" column="12" declfile="include/kernel.h" declline="3417" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1gad47d54e513030304be2600d75b1a965f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="stdbool_8h_1abb452686968e48b67397da5f97445f5b" kindref="member">bool</ref></type>
        <definition>bool k_work_flush_delayable</definition>
        <argsstring>(struct k_work_delayable *dwork, struct k_work_sync *sync)</argsstring>
        <name>k_work_flush_delayable</name>
        <param>
          <type>struct <ref refid="structk__work__delayable" kindref="compound">k_work_delayable</ref> *</type>
          <declname>dwork</declname>
        </param>
        <param>
          <type>struct <ref refid="structk__work__sync" kindref="compound">k_work_sync</ref> *</type>
          <declname>sync</declname>
        </param>
        <briefdescription>
<para>Flush delayable work. </para>
        </briefdescription>
        <detaileddescription>
<para>If the work is scheduled, it is immediately submitted. Then the caller blocks until the work completes, as with <ref refid="group__workqueue__apis_1gabd1cda459bab538fb2d6dfd84a73b253" kindref="member">k_work_flush()</ref>.</para>
<para><simplesect kind="note"><para>Be careful of caller and work queue thread relative priority. If this function sleeps it will not return until the work queue thread completes the tasks that allow this thread to resume.</para>
</simplesect>
<simplesect kind="note"><para>Behavior is undefined if this function is invoked on <computeroutput>dwork</computeroutput> from a work queue running <computeroutput>dwork</computeroutput>.</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dwork</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the delayable work item.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sync</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to an opaque item containing state related to the pending cancellation. The object must persist until the call returns, and be accessible from both the caller thread and the work queue thread. The object must not be used for any other flush or cancel operation until this one completes. On architectures with CONFIG_KERNEL_COHERENCE the object must be allocated in coherent memory.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>true</parametername>
</parameternamelist>
<parameterdescription>
<para>if call had to wait for completion </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>false</parametername>
</parameternamelist>
<parameterdescription>
<para>if work was already idle </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3444" column="6" declfile="include/kernel.h" declline="3444" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1ga92355914ee178d4c3e848a1946bed3e4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int k_work_cancel_delayable</definition>
        <argsstring>(struct k_work_delayable *dwork)</argsstring>
        <name>k_work_cancel_delayable</name>
        <param>
          <type>struct <ref refid="structk__work__delayable" kindref="compound">k_work_delayable</ref> *</type>
          <declname>dwork</declname>
        </param>
        <briefdescription>
<para>Cancel delayable work. </para>
        </briefdescription>
        <detaileddescription>
<para>Similar to <ref refid="group__workqueue__apis_1ga389fe2a8fb20f9bd593cf8d990727078" kindref="member">k_work_cancel()</ref> but for delayable work. If the work is scheduled or submitted it is canceled. This function does not wait for the cancellation to complete.</para>
<para><simplesect kind="note"><para>The work may still be running when this returns. Use <ref refid="group__workqueue__apis_1gad47d54e513030304be2600d75b1a965f" kindref="member">k_work_flush_delayable()</ref> or <ref refid="group__workqueue__apis_1ga7e7ec237648556fc16bfda8d35f7cd86" kindref="member">k_work_cancel_delayable_sync()</ref> to ensure it is not running.</para>
</simplesect>
<simplesect kind="note"><para>Canceling delayable work does not prevent rescheduling it. It does prevent submitting it until the cancellation completes.</para>
</simplesect>
<simplesect kind="par"><title>Function properties (list may not be complete)</title><para><htmlonly> isr-ok </htmlonly>  <verbatim>embed:rst:inline :ref:`api_term_isr-ok`</verbatim> </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dwork</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the delayable work item.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the <ref refid="group__workqueue__apis_1ga1b76969667844f0981d348c9c671bc9f" kindref="member">k_work_delayable_busy_get()</ref> status indicating the state of the item after all cancellation steps performed by this call are completed. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3467" column="5" declfile="include/kernel.h" declline="3467" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1ga7e7ec237648556fc16bfda8d35f7cd86" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="stdbool_8h_1abb452686968e48b67397da5f97445f5b" kindref="member">bool</ref></type>
        <definition>bool k_work_cancel_delayable_sync</definition>
        <argsstring>(struct k_work_delayable *dwork, struct k_work_sync *sync)</argsstring>
        <name>k_work_cancel_delayable_sync</name>
        <param>
          <type>struct <ref refid="structk__work__delayable" kindref="compound">k_work_delayable</ref> *</type>
          <declname>dwork</declname>
        </param>
        <param>
          <type>struct <ref refid="structk__work__sync" kindref="compound">k_work_sync</ref> *</type>
          <declname>sync</declname>
        </param>
        <briefdescription>
<para>Cancel delayable work and wait. </para>
        </briefdescription>
        <detaileddescription>
<para>Like <ref refid="group__workqueue__apis_1ga92355914ee178d4c3e848a1946bed3e4" kindref="member">k_work_cancel_delayable()</ref> but waits until the work becomes idle.</para>
<para><simplesect kind="note"><para>Canceling delayable work does not prevent rescheduling it. It does prevent submitting it until the cancellation completes.</para>
</simplesect>
<simplesect kind="note"><para>Be careful of caller and work queue thread relative priority. If this function sleeps it will not return until the work queue thread completes the tasks that allow this thread to resume.</para>
</simplesect>
<simplesect kind="note"><para>Behavior is undefined if this function is invoked on <computeroutput>dwork</computeroutput> from a work queue running <computeroutput>dwork</computeroutput>.</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dwork</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the delayable work item.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sync</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to an opaque item containing state related to the pending cancellation. The object must persist until the call returns, and be accessible from both the caller thread and the work queue thread. The object must not be used for any other flush or cancel operation until this one completes. On architectures with CONFIG_KERNEL_COHERENCE the object must be allocated in coherent memory.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>true</parametername>
</parameternamelist>
<parameterdescription>
<para>if work was not idle (call had to wait for cancellation of a running handler to complete, or scheduled or submitted operations were cancelled); </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>false</parametername>
</parameternamelist>
<parameterdescription>
<para>otherwise </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3497" column="6" declfile="include/kernel.h" declline="3497" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1ga7ab20a3405d7132870ee5e4b5610bfe3" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="stdbool_8h_1abb452686968e48b67397da5f97445f5b" kindref="member">bool</ref></type>
        <definition>static bool k_work_pending</definition>
        <argsstring>(const struct k_work *work)</argsstring>
        <name>k_work_pending</name>
        <param>
          <type>const struct <ref refid="structk__work" kindref="compound">k_work</ref> *</type>
          <declname>work</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3779" column="20" bodyfile="include/kernel.h" bodystart="3779" bodyend="3782"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1gad4b913b161ebf5958f7c42ed5e1a6c25" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void k_work_q_start</definition>
        <argsstring>(struct k_work_q *work_q, k_thread_stack_t *stack, size_t stack_size, int prio)</argsstring>
        <name>k_work_q_start</name>
        <param>
          <type>struct <ref refid="structk__work__q" kindref="compound">k_work_q</ref> *</type>
          <declname>work_q</declname>
        </param>
        <param>
          <type><ref refid="arch__interface_8h_1a3e4bde3075edb41069b258d999333b0e" kindref="member">k_thread_stack_t</ref> *</type>
          <declname>stack</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>stack_size</declname>
        </param>
        <param>
          <type>int</type>
          <declname>prio</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3785" column="20" bodyfile="include/kernel.h" bodystart="3785" bodyend="3790"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1gaf484b980ae3dbbd620b96e883c4b4fe6" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void k_delayed_work_init</definition>
        <argsstring>(struct k_delayed_work *work, k_work_handler_t handler)</argsstring>
        <name>k_delayed_work_init</name>
        <param>
          <type>struct <ref refid="structk__delayed__work" kindref="compound">k_delayed_work</ref> *</type>
          <declname>work</declname>
        </param>
        <param>
          <type><ref refid="group__workqueue__apis_1ga5add9ef0dce306a08413c4140fc0bdda" kindref="member">k_work_handler_t</ref></type>
          <declname>handler</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3802" column="20" bodyfile="include/kernel.h" bodystart="3802" bodyend="3806"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1ga9d96cee1aa79b9fd01aa3ea7892f74d0" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>static int k_delayed_work_submit_to_queue</definition>
        <argsstring>(struct k_work_q *work_q, struct k_delayed_work *work, k_timeout_t delay)</argsstring>
        <name>k_delayed_work_submit_to_queue</name>
        <param>
          <type>struct <ref refid="structk__work__q" kindref="compound">k_work_q</ref> *</type>
          <declname>work_q</declname>
        </param>
        <param>
          <type>struct <ref refid="structk__delayed__work" kindref="compound">k_delayed_work</ref> *</type>
          <declname>work</declname>
        </param>
        <param>
          <type><ref refid="structk__timeout__t" kindref="compound">k_timeout_t</ref></type>
          <declname>delay</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3809" column="19" bodyfile="include/kernel.h" bodystart="3809" bodyend="3817"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1gabc2b985a4edddd17d1a7406d69167e0c" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>static int k_delayed_work_submit</definition>
        <argsstring>(struct k_delayed_work *work, k_timeout_t delay)</argsstring>
        <name>k_delayed_work_submit</name>
        <param>
          <type>struct <ref refid="structk__delayed__work" kindref="compound">k_delayed_work</ref> *</type>
          <declname>work</declname>
        </param>
        <param>
          <type><ref refid="structk__timeout__t" kindref="compound">k_timeout_t</ref></type>
          <declname>delay</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3820" column="19" bodyfile="include/kernel.h" bodystart="3820" bodyend="3827"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1ga00189a735a3a557118c035b7d69feeb0" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>static int k_delayed_work_cancel</definition>
        <argsstring>(struct k_delayed_work *work)</argsstring>
        <name>k_delayed_work_cancel</name>
        <param>
          <type>struct <ref refid="structk__delayed__work" kindref="compound">k_delayed_work</ref> *</type>
          <declname>work</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3830" column="19" bodyfile="include/kernel.h" bodystart="3830" bodyend="3868"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1ga47b86afff751340829339566a9932f72" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="stdbool_8h_1abb452686968e48b67397da5f97445f5b" kindref="member">bool</ref></type>
        <definition>static bool k_delayed_work_pending</definition>
        <argsstring>(struct k_delayed_work *work)</argsstring>
        <name>k_delayed_work_pending</name>
        <param>
          <type>struct <ref refid="structk__delayed__work" kindref="compound">k_delayed_work</ref> *</type>
          <declname>work</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3871" column="20" bodyfile="include/kernel.h" bodystart="3871" bodyend="3874"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1ga3c5c9af0fb7c0518a87e04f110c27105" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="stdint_8h_1a0c18914b3041c2f583aba76f418399c2" kindref="member">int32_t</ref></type>
        <definition>static int32_t k_delayed_work_remaining_get</definition>
        <argsstring>(struct k_delayed_work *work)</argsstring>
        <name>k_delayed_work_remaining_get</name>
        <param>
          <type>struct <ref refid="structk__delayed__work" kindref="compound">k_delayed_work</ref> *</type>
          <declname>work</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3877" column="23" bodyfile="include/kernel.h" bodystart="3877" bodyend="3883"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1gacbde6358fe7676d8a6bcf286e7802997" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="group__clock__apis_1ga9832cb0adc2d1866420e5c370a0863e2" kindref="member">k_ticks_t</ref></type>
        <definition>static k_ticks_t k_delayed_work_expires_ticks</definition>
        <argsstring>(struct k_delayed_work *work)</argsstring>
        <name>k_delayed_work_expires_ticks</name>
        <param>
          <type>struct <ref refid="structk__delayed__work" kindref="compound">k_delayed_work</ref> *</type>
          <declname>work</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3886" column="25" bodyfile="include/kernel.h" bodystart="3886" bodyend="3890"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1ga1d0f51e16f52308bb258bf63b4b26915" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="group__clock__apis_1ga9832cb0adc2d1866420e5c370a0863e2" kindref="member">k_ticks_t</ref></type>
        <definition>static k_ticks_t k_delayed_work_remaining_ticks</definition>
        <argsstring>(struct k_delayed_work *work)</argsstring>
        <name>k_delayed_work_remaining_ticks</name>
        <param>
          <type>struct <ref refid="structk__delayed__work" kindref="compound">k_delayed_work</ref> *</type>
          <declname>work</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3893" column="25" bodyfile="include/kernel.h" bodystart="3893" bodyend="3897"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1ga9de9c7a7f13cc6b325e5453e34afe62d" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void k_work_user_init</definition>
        <argsstring>(struct k_work_user *work, k_work_user_handler_t handler)</argsstring>
        <name>k_work_user_init</name>
        <param>
          <type>struct k_work_user *</type>
          <declname>work</declname>
        </param>
        <param>
          <type><ref refid="group__workqueue__apis_1gafdb3f5f2225b3d5d1fe682cb97f3b328" kindref="member">k_work_user_handler_t</ref></type>
          <declname>handler</declname>
        </param>
        <briefdescription>
<para>Initialize a userspace work item. </para>
        </briefdescription>
        <detaileddescription>
<para>This routine initializes a user workqueue work item, prior to its first use.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>work</parametername>
</parameternamelist>
<parameterdescription>
<para>Address of work item. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>handler</parametername>
</parameternamelist>
<parameterdescription>
<para>Function to invoke each time work item is processed. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3976" column="20" bodyfile="include/kernel.h" bodystart="3976" bodyend="3980"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1ga58d05d4127e4cd51104a1f1a87f626cd" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="stdbool_8h_1abb452686968e48b67397da5f97445f5b" kindref="member">bool</ref></type>
        <definition>static bool k_work_user_is_pending</definition>
        <argsstring>(struct k_work_user *work)</argsstring>
        <name>k_work_user_is_pending</name>
        <param>
          <type>struct k_work_user *</type>
          <declname>work</declname>
        </param>
        <briefdescription>
<para>Check if a userspace work item is pending. </para>
        </briefdescription>
        <detaileddescription>
<para>This routine indicates if user work item <emphasis>work</emphasis> is pending in a workqueue&apos;s queue.</para>
<para><simplesect kind="note"><para>Checking if the work is pending gives no guarantee that the work will still be pending when this information is used. It is up to the caller to make sure that this information is used in a safe manner.</para>
</simplesect>
<simplesect kind="par"><title>Function properties (list may not be complete)</title><para><htmlonly> isr-ok </htmlonly>  <verbatim>embed:rst:inline :ref:`api_term_isr-ok`</verbatim> </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>work</parametername>
</parameternamelist>
<parameterdescription>
<para>Address of work item.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if work item is pending, or false if it is not pending. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3998" column="20" bodyfile="include/kernel.h" bodystart="3998" bodyend="4001"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1ga50ae1f6f74c0bc0a41dbbf789fff8856" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>static int k_work_user_submit_to_queue</definition>
        <argsstring>(struct k_work_user_q *work_q, struct k_work_user *work)</argsstring>
        <name>k_work_user_submit_to_queue</name>
        <param>
          <type>struct k_work_user_q *</type>
          <declname>work_q</declname>
        </param>
        <param>
          <type>struct k_work_user *</type>
          <declname>work</declname>
        </param>
        <briefdescription>
<para>Submit a work item to a user mode workqueue. </para>
        </briefdescription>
        <detaileddescription>
<para>Submits a work item to a workqueue that runs in user mode. A temporary memory allocation is made from the caller&apos;s resource pool which is freed once the worker thread consumes the <ref refid="structk__work" kindref="compound">k_work</ref> item. The workqueue thread must have memory access to the <ref refid="structk__work" kindref="compound">k_work</ref> item being submitted. The caller must have permission granted on the work_q parameter&apos;s queue object.</para>
<para><simplesect kind="par"><title>Function properties (list may not be complete)</title><para><htmlonly> isr-ok </htmlonly>  <verbatim>embed:rst:inline :ref:`api_term_isr-ok`</verbatim> </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>work_q</parametername>
</parameternamelist>
<parameterdescription>
<para>Address of workqueue. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>work</parametername>
</parameternamelist>
<parameterdescription>
<para>Address of work item.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>-EBUSY</parametername>
</parameternamelist>
<parameterdescription>
<para>if the work item was already in some workqueue </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>-ENOMEM</parametername>
</parameternamelist>
<parameterdescription>
<para>if no memory for thread resource pool allocation </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>0</parametername>
</parameternamelist>
<parameterdescription>
<para>Success </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="4021" column="19" bodyfile="include/kernel.h" bodystart="4021" bodyend="4040"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1ga3091bc8fab5311252e41634a97a18589" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void k_work_user_queue_start</definition>
        <argsstring>(struct k_work_user_q *work_q, k_thread_stack_t *stack, size_t stack_size, int prio, const char *name)</argsstring>
        <name>k_work_user_queue_start</name>
        <param>
          <type>struct k_work_user_q *</type>
          <declname>work_q</declname>
        </param>
        <param>
          <type><ref refid="arch__interface_8h_1a3e4bde3075edb41069b258d999333b0e" kindref="member">k_thread_stack_t</ref> *</type>
          <declname>stack</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>stack_size</declname>
        </param>
        <param>
          <type>int</type>
          <declname>prio</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Start a workqueue in user mode. </para>
        </briefdescription>
        <detaileddescription>
<para>This works identically to <ref refid="group__workqueue__apis_1gadfc56554f9bfe7b52309d79660188593" kindref="member">k_work_queue_start()</ref> except it is callable from user mode, and the worker thread created will run in user mode. The caller must have permissions granted on both the work_q parameter&apos;s thread and queue objects, and the same restrictions on priority apply as <ref refid="group__thread__apis_1gad5b0bff3102f1656089f5875d999a367" kindref="member">k_thread_create()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>work_q</parametername>
</parameternamelist>
<parameterdescription>
<para>Address of workqueue. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stack</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to work queue thread&apos;s stack space, as defined by <ref refid="group__thread__stack__api_1gac5368ce24fdeab3863b5c8dee2ebd955" kindref="member">K_THREAD_STACK_DEFINE()</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stack_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the work queue thread&apos;s stack (in bytes), which should either be the same constant passed to <ref refid="group__thread__stack__api_1gac5368ce24fdeab3863b5c8dee2ebd955" kindref="member">K_THREAD_STACK_DEFINE()</ref> or the value of <ref refid="group__thread__stack__api_1ga775f8e6b4144cfdd24f3261b6db64150" kindref="member">K_THREAD_STACK_SIZEOF()</ref>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>prio</parametername>
</parameternamelist>
<parameterdescription>
<para>Priority of the work queue&apos;s thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>optional thread name. If not null a copy is made into the thread&apos;s name buffer. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="4061" column="13" declfile="include/kernel.h" declline="4061" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1ga371dab33a40622bea19b07d852863443" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void k_work_poll_init</definition>
        <argsstring>(struct k_work_poll *work, k_work_handler_t handler)</argsstring>
        <name>k_work_poll_init</name>
        <param>
          <type>struct k_work_poll *</type>
          <declname>work</declname>
        </param>
        <param>
          <type><ref refid="group__workqueue__apis_1ga5add9ef0dce306a08413c4140fc0bdda" kindref="member">k_work_handler_t</ref></type>
          <declname>handler</declname>
        </param>
        <briefdescription>
<para>Initialize a triggered work item. </para>
        </briefdescription>
        <detaileddescription>
<para>This routine initializes a workqueue triggered work item, prior to its first use.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>work</parametername>
</parameternamelist>
<parameterdescription>
<para>Address of triggered work item. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>handler</parametername>
</parameternamelist>
<parameterdescription>
<para>Function to invoke each time work item is processed. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="4129" column="13" declfile="include/kernel.h" declline="4129" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1ga0abafd7f851e42fd3572c8438e600a53" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int k_work_poll_submit_to_queue</definition>
        <argsstring>(struct k_work_q *work_q, struct k_work_poll *work, struct k_poll_event *events, int num_events, k_timeout_t timeout)</argsstring>
        <name>k_work_poll_submit_to_queue</name>
        <param>
          <type>struct <ref refid="structk__work__q" kindref="compound">k_work_q</ref> *</type>
          <declname>work_q</declname>
        </param>
        <param>
          <type>struct k_work_poll *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>struct <ref refid="structk__poll__event" kindref="compound">k_poll_event</ref> *</type>
          <declname>events</declname>
        </param>
        <param>
          <type>int</type>
          <declname>num_events</declname>
        </param>
        <param>
          <type><ref refid="structk__timeout__t" kindref="compound">k_timeout_t</ref></type>
          <declname>timeout</declname>
        </param>
        <briefdescription>
<para>Submit a triggered work item. </para>
        </briefdescription>
        <detaileddescription>
<para>This routine schedules work item <emphasis>work</emphasis> to be processed by workqueue <emphasis>work_q</emphasis> when one of the given <emphasis>events</emphasis> is signaled. The routine initiates internal poller for the work item and then returns to the caller. Only when one of the watched events happen the work item is actually submitted to the workqueue and becomes pending.</para>
<para>Submitting a previously submitted triggered work item that is still waiting for the event cancels the existing submission and reschedules it the using the new event list. Note that this behavior is inherently subject to race conditions with the pre-existing triggered work item and work queue, so care must be taken to synchronize such resubmissions externally.</para>
<para><simplesect kind="par"><title>Function properties (list may not be complete)</title><para><htmlonly> isr-ok </htmlonly>  <verbatim>embed:rst:inline :ref:`api_term_isr-ok`</verbatim> </para>
</simplesect>
<simplesect kind="warning"><para>Provided array of events as well as a triggered work item must be placed in persistent memory (valid until work handler execution or work cancellation) and cannot be modified after submission.</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>work_q</parametername>
</parameternamelist>
<parameterdescription>
<para>Address of workqueue. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>work</parametername>
</parameternamelist>
<parameterdescription>
<para>Address of delayed work item. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>events</parametername>
</parameternamelist>
<parameterdescription>
<para>An array of events which trigger the work. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>num_events</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of events in the array. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>timeout</parametername>
</parameternamelist>
<parameterdescription>
<para>Timeout after which the work will be scheduled for execution even if not triggered.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>0</parametername>
</parameternamelist>
<parameterdescription>
<para>Work item started watching for events. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>-EINVAL</parametername>
</parameternamelist>
<parameterdescription>
<para>Work item is being processed or has completed its work. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>-EADDRINUSE</parametername>
</parameternamelist>
<parameterdescription>
<para>Work item is pending on a different workqueue. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="4166" column="12" declfile="include/kernel.h" declline="4166" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1gad9f222e46d72c4f98739395a0c8bb4ea" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int k_work_poll_submit</definition>
        <argsstring>(struct k_work_poll *work, struct k_poll_event *events, int num_events, k_timeout_t timeout)</argsstring>
        <name>k_work_poll_submit</name>
        <param>
          <type>struct k_work_poll *</type>
          <declname>work</declname>
        </param>
        <param>
          <type>struct <ref refid="structk__poll__event" kindref="compound">k_poll_event</ref> *</type>
          <declname>events</declname>
        </param>
        <param>
          <type>int</type>
          <declname>num_events</declname>
        </param>
        <param>
          <type><ref refid="structk__timeout__t" kindref="compound">k_timeout_t</ref></type>
          <declname>timeout</declname>
        </param>
        <briefdescription>
<para>Submit a triggered work item to the system workqueue. </para>
        </briefdescription>
        <detaileddescription>
<para>This routine schedules work item <emphasis>work</emphasis> to be processed by system workqueue when one of the given <emphasis>events</emphasis> is signaled. The routine initiates internal poller for the work item and then returns to the caller. Only when one of the watched events happen the work item is actually submitted to the workqueue and becomes pending.</para>
<para>Submitting a previously submitted triggered work item that is still waiting for the event cancels the existing submission and reschedules it the using the new event list. Note that this behavior is inherently subject to race conditions with the pre-existing triggered work item and work queue, so care must be taken to synchronize such resubmissions externally.</para>
<para><simplesect kind="par"><title>Function properties (list may not be complete)</title><para><htmlonly> isr-ok </htmlonly>  <verbatim>embed:rst:inline :ref:`api_term_isr-ok`</verbatim> </para>
</simplesect>
<simplesect kind="warning"><para>Provided array of events as well as a triggered work item must not be modified until the item has been processed by the workqueue.</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>work</parametername>
</parameternamelist>
<parameterdescription>
<para>Address of delayed work item. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>events</parametername>
</parameternamelist>
<parameterdescription>
<para>An array of events which trigger the work. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>num_events</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of events in the array. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>timeout</parametername>
</parameternamelist>
<parameterdescription>
<para>Timeout after which the work will be scheduled for execution even if not triggered.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>0</parametername>
</parameternamelist>
<parameterdescription>
<para>Work item started watching for events. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>-EINVAL</parametername>
</parameternamelist>
<parameterdescription>
<para>Work item is being processed or has completed its work. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>-EADDRINUSE</parametername>
</parameternamelist>
<parameterdescription>
<para>Work item is pending on a different workqueue. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="4203" column="12" declfile="include/kernel.h" declline="4203" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="group__workqueue__apis_1ga2a19547d04dc1a202e80b752e3177215" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int k_work_poll_cancel</definition>
        <argsstring>(struct k_work_poll *work)</argsstring>
        <name>k_work_poll_cancel</name>
        <param>
          <type>struct k_work_poll *</type>
          <declname>work</declname>
        </param>
        <briefdescription>
<para>Cancel a triggered work item. </para>
        </briefdescription>
        <detaileddescription>
<para>This routine cancels the submission of triggered work item <emphasis>work</emphasis>. A triggered work item can only be canceled if no event triggered work submission.</para>
<para><simplesect kind="par"><title>Function properties (list may not be complete)</title><para><htmlonly> isr-ok </htmlonly>  <verbatim>embed:rst:inline :ref:`api_term_isr-ok`</verbatim> </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>work</parametername>
</parameternamelist>
<parameterdescription>
<para>Address of delayed work item.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>0</parametername>
</parameternamelist>
<parameterdescription>
<para>Work item canceled. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>-EINVAL</parametername>
</parameternamelist>
<parameterdescription>
<para>Work item is being processed or has completed its work. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="4222" column="12" declfile="include/kernel.h" declline="4222" declcolumn="12"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="define">
      <memberdef kind="define" id="group__workqueue__apis_1ga893b281f3d2bc0088650536899e17903" prot="public" static="no">
        <name>K_WORK_DELAYABLE_DEFINE</name>
        <param><defname>work</defname></param>
        <param><defname>work_handler</defname></param>
        <initializer>	struct <ref refid="structk__work__delayable" kindref="compound">k_work_delayable</ref> <ref refid="workq_2work_2src_2main_8c_1a147e2d2d335d9181395da44aa45b7694" kindref="member">work</ref> \
	  = Z_WORK_DELAYABLE_INITIALIZER(<ref refid="workq_2work__queue_2src_2main_8c_1a79d59599a7df302be796206c85bb7437" kindref="member">work_handler</ref>)</initializer>
        <briefdescription>
<para>Initialize a statically-defined delayable work item. </para>
        </briefdescription>
        <detaileddescription>
<para>This macro can be used to initialize a statically-defined delayable work item, prior to its first use. For example,</para>
<para><programlisting><codeline><highlight class="normal">static<sp/>K_WORK_DELAYABLE_DEFINE(&lt;dwork&gt;,<sp/>&lt;work_handler&gt;);<sp/></highlight></codeline>
</programlisting></para>
<para>Note that if the runtime dependencies support initialization with <ref refid="group__workqueue__apis_1ga2876c5d82fb2340a093bc4d689a55465" kindref="member">k_work_init_delayable()</ref> using that will eliminate the initialized object in ROM that is produced by this macro and copied in at system startup.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>work</parametername>
</parameternamelist>
<parameterdescription>
<para>Symbol name for delayable work item object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>work_handler</parametername>
</parameternamelist>
<parameterdescription>
<para>Function to invoke each time work item is processed. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3634" column="9" bodyfile="include/kernel.h" bodystart="3634" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__workqueue__apis_1ga4f3eac1fc56d5c9c21a3afa9b964b0bf" prot="public" static="no">
        <name>K_WORK_USER_DEFINE</name>
        <param><defname>work</defname></param>
        <param><defname>work_handler</defname></param>
        <initializer>	struct k_work_user <ref refid="workq_2work_2src_2main_8c_1a147e2d2d335d9181395da44aa45b7694" kindref="member">work</ref> = Z_WORK_USER_INITIALIZER(<ref refid="workq_2work__queue_2src_2main_8c_1a79d59599a7df302be796206c85bb7437" kindref="member">work_handler</ref>)</initializer>
        <briefdescription>
<para>Initialize a statically-defined user work item. </para>
        </briefdescription>
        <detaileddescription>
<para>This macro can be used to initialize a statically-defined user work item, prior to its first use. For example,</para>
<para><programlisting><codeline><highlight class="normal">static<sp/>K_WORK_USER_DEFINE(&lt;work&gt;,<sp/>&lt;work_handler&gt;);<sp/></highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>work</parametername>
</parameternamelist>
<parameterdescription>
<para>Symbol name for work item object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>work_handler</parametername>
</parameternamelist>
<parameterdescription>
<para>Function to invoke each time work item is processed. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="3964" column="9" bodyfile="include/kernel.h" bodystart="3964" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__workqueue__apis_1gaf8e003eefa5dd66ba883688f9d39c333" prot="public" static="no">
        <name>K_WORK_DEFINE</name>
        <param><defname>work</defname></param>
        <param><defname>work_handler</defname></param>
        <initializer>	struct <ref refid="structk__work" kindref="compound">k_work</ref> <ref refid="workq_2work_2src_2main_8c_1a147e2d2d335d9181395da44aa45b7694" kindref="member">work</ref> = Z_WORK_INITIALIZER(<ref refid="workq_2work__queue_2src_2main_8c_1a79d59599a7df302be796206c85bb7437" kindref="member">work_handler</ref>)</initializer>
        <briefdescription>
<para>Initialize a statically-defined work item. </para>
        </briefdescription>
        <detaileddescription>
<para>This macro can be used to initialize a statically-defined workqueue work item, prior to its first use. For example,</para>
<para><programlisting><codeline><highlight class="normal">static<sp/>K_WORK_DEFINE(&lt;work&gt;,<sp/>&lt;work_handler&gt;);<sp/></highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>work</parametername>
</parameternamelist>
<parameterdescription>
<para>Symbol name for work item object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>work_handler</parametername>
</parameternamelist>
<parameterdescription>
<para>Function to invoke each time work item is processed. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="4103" column="9" bodyfile="include/kernel.h" bodystart="4103" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__workqueue__apis_1ga41c8a64e854c6cca3a6956079cce2826" prot="public" static="no">
        <name>K_DELAYED_WORK_DEFINE</name>
        <param><defname>work</defname></param>
        <param><defname>work_handler</defname></param>
        <initializer>	__DEPRECATED_MACRO \
	struct <ref refid="structk__delayed__work" kindref="compound">k_delayed_work</ref> <ref refid="workq_2work_2src_2main_8c_1a147e2d2d335d9181395da44aa45b7694" kindref="member">work</ref> = Z_DELAYED_WORK_INITIALIZER(<ref refid="workq_2work__queue_2src_2main_8c_1a79d59599a7df302be796206c85bb7437" kindref="member">work_handler</ref>)</initializer>
        <briefdescription>
<para>Initialize a statically-defined delayed work item. </para>
        </briefdescription>
        <detaileddescription>
<para>This macro can be used to initialize a statically-defined workqueue delayed work item, prior to its first use. For example,</para>
<para><programlisting><codeline><highlight class="normal">static<sp/>K_DELAYED_WORK_DEFINE(&lt;work&gt;,<sp/>&lt;work_handler&gt;);<sp/></highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>work</parametername>
</parameternamelist>
<parameterdescription>
<para>Symbol name for delayed work item object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>work_handler</parametername>
</parameternamelist>
<parameterdescription>
<para>Function to invoke each time work item is processed. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/kernel.h" line="4117" column="9" bodyfile="include/kernel.h" bodystart="4117" bodyend="-1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
  </compounddef>
</doxygen>
