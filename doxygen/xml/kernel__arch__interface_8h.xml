<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.2" xml:lang="en-US">
  <compounddef id="kernel__arch__interface_8h" kind="file" language="C++">
    <compoundname>kernel_arch_interface.h</compoundname>
    <includes local="no">kernel.h</includes>
    <includes refid="arch__interface_8h" local="no">sys/arch_interface.h</includes>
    <includes local="no">kernel_arch_func.h</includes>
    <incdepgraph>
      <node id="11">
        <label>arch/arch_inlines.h</label>
        <link refid="arch__inlines_8h"/>
      </node>
      <node id="9">
        <label>irq_offload.h</label>
        <link refid="irq__offload_8h"/>
      </node>
      <node id="3">
        <label>sys/arch_interface.h</label>
        <link refid="arch__interface_8h"/>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="5" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="11" relation="include">
        </childnode>
      </node>
      <node id="10">
        <label>timing/types.h</label>
        <link refid="include_2timing_2types_8h"/>
      </node>
      <node id="4">
        <label>toolchain.h</label>
        <link refid="toolchain_8h"/>
      </node>
      <node id="6">
        <label>zephyr/types.h</label>
        <link refid="include_2zephyr_2types_8h"/>
        <childnode refid="5" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
      </node>
      <node id="1">
        <label>kernel/include/kernel_arch_interface.h</label>
        <link refid="kernel__arch__interface_8h"/>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="12" relation="include">
        </childnode>
      </node>
      <node id="7">
        <label>stdint.h</label>
        <link refid="stdint_8h"/>
      </node>
      <node id="8">
        <label>arch/cpu.h</label>
      </node>
      <node id="2">
        <label>kernel.h</label>
      </node>
      <node id="12">
        <label>kernel_arch_func.h</label>
      </node>
      <node id="5">
        <label>stddef.h</label>
      </node>
    </incdepgraph>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="group__arch-mmu_1ga65e10c80055d7e695add000f2ccfbb0b" prot="public" static="no" strong="no">
        <type></type>
        <name>arch_page_location</name>
        <enumvalue id="group__arch-mmu_1gga65e10c80055d7e695add000f2ccfbb0bacf9e624eac380ea2bfa37632c4d17a3a" prot="public">
          <name>ARCH_PAGE_LOCATION_PAGED_OUT</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__arch-mmu_1gga65e10c80055d7e695add000f2ccfbb0bae378a008f497ae10ab50cab06f8c36db" prot="public">
          <name>ARCH_PAGE_LOCATION_PAGED_IN</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__arch-mmu_1gga65e10c80055d7e695add000f2ccfbb0ba7ff70acdf02345b5fa4c42ed2b2adde9" prot="public">
          <name>ARCH_PAGE_LOCATION_BAD</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="kernel/include/kernel_arch_interface.h" line="405" column="1" bodyfile="kernel/include/kernel_arch_interface.h" bodystart="405" bodyend="409"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__arch-timing_1gaffc9f3013d53e72c25243ce4f972549f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void arch_busy_wait</definition>
        <argsstring>(uint32_t usec_to_wait)</argsstring>
        <name>arch_busy_wait</name>
        <param>
          <type><ref refid="stdint_8h_1a0a8582351ac627ee8bde2973c825e47f" kindref="member">uint32_t</ref></type>
          <declname>usec_to_wait</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Architecture-specific implementation of busy-waiting</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>usec_to_wait</parametername>
</parameternamelist>
<parameterdescription>
<para>Wait period, in microseconds </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="kernel/include/kernel_arch_interface.h" line="39" column="6" declfile="kernel/include/kernel_arch_interface.h" declline="39" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__arch-threads_1gade449838e445fa8201266e38215c616c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void arch_new_thread</definition>
        <argsstring>(struct k_thread *thread, k_thread_stack_t *stack, char *stack_ptr, k_thread_entry_t entry, void *p1, void *p2, void *p3)</argsstring>
        <name>arch_new_thread</name>
        <param>
          <type>struct <ref refid="structk__thread" kindref="compound">k_thread</ref> *</type>
          <declname>thread</declname>
        </param>
        <param>
          <type><ref refid="arch__interface_8h_1a3e4bde3075edb41069b258d999333b0e" kindref="member">k_thread_stack_t</ref> *</type>
          <declname>stack</declname>
        </param>
        <param>
          <type>char *</type>
          <declname>stack_ptr</declname>
        </param>
        <param>
          <type><ref refid="arch__interface_8h_1af1bd193a26c6e6a8658140185cae42e1" kindref="member">k_thread_entry_t</ref></type>
          <declname>entry</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>p1</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>p2</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>p3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Handle arch-specific logic for setting up new threads</para>
<para>The stack and arch-specific thread state variables must be set up such that a later attempt to switch to this thread will succeed and we will enter z_thread_entry with the requested thread and arguments as its parameters.</para>
<para>At some point in this function&apos;s implementation, z_setup_new_thread() must be called with the true bounds of the available stack buffer within the thread&apos;s stack object.</para>
<para>The provided stack pointer is guaranteed to be properly aligned with respect to the CPU and ABI requirements. There may be space reserved between the stack pointer and the bounds of the stack buffer for initial stack pointer randomization and thread-local storage.</para>
<para>Fields in thread-&gt;base will be initialized when this is called.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>thread</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to uninitialized struct <ref refid="structk__thread" kindref="compound">k_thread</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stack</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the stack object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stack_ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>Aligned initial stack pointer </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>entry</parametername>
</parameternamelist>
<parameterdescription>
<para>Thread entry function </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>p1</parametername>
</parameternamelist>
<parameterdescription>
<para>1st entry point parameter </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>p2</parametername>
</parameternamelist>
<parameterdescription>
<para>2nd entry point parameter </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>p3</parametername>
</parameternamelist>
<parameterdescription>
<para>3rd entry point parameter </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="kernel/include/kernel_arch_interface.h" line="76" column="6" declfile="kernel/include/kernel_arch_interface.h" declline="76" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__arch-threads_1gab411d82ce5b60f062171f5a19e33e025" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void arch_switch</definition>
        <argsstring>(void *switch_to, void **switched_from)</argsstring>
        <name>arch_switch</name>
        <param>
          <type>void *</type>
          <declname>switch_to</declname>
        </param>
        <param>
          <type>void **</type>
          <declname>switched_from</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Cooperative context switch primitive</para>
<para>The action of <ref refid="group__arch-threads_1gab411d82ce5b60f062171f5a19e33e025" kindref="member">arch_switch()</ref> should be to switch to a new context passed in the first argument, and save a pointer to the current context into the address passed in the second argument.</para>
<para>The actual type and interpretation of the switch handle is specified by the architecture. It is the same data structure stored in the &quot;switch_handle&quot; field of a newly-created thread in <ref refid="group__arch-threads_1gade449838e445fa8201266e38215c616c" kindref="member">arch_new_thread()</ref>, and passed to the kernel as the &quot;interrupted&quot; argument to z_get_next_switch_handle().</para>
<para>Note that on SMP systems, the kernel uses the store through the second pointer as a synchronization point to detect when a thread context is completely saved (so another CPU can know when it is safe to switch). This store must be done AFTER all relevant state is saved, and must include whatever memory barriers or cache management code is required to be sure another CPU will see the result correctly.</para>
<para>The simplest implementation of <ref refid="group__arch-threads_1gab411d82ce5b60f062171f5a19e33e025" kindref="member">arch_switch()</ref> is generally to push state onto the thread stack and use the resulting stack pointer as the switch handle. Some architectures may instead decide to use a pointer into the thread struct as the &quot;switch handle&quot; type. These can legally assume that the second argument to <ref refid="group__arch-threads_1gab411d82ce5b60f062171f5a19e33e025" kindref="member">arch_switch()</ref> is the address of the switch_handle field of struct thread_base and can use an offset on this value to find other parts of the thread struct. For example a (C pseudocode) implementation of <ref refid="group__arch-threads_1gab411d82ce5b60f062171f5a19e33e025" kindref="member">arch_switch()</ref> might look like:</para>
<para>void <ref refid="group__arch-threads_1gab411d82ce5b60f062171f5a19e33e025" kindref="member">arch_switch(void *switch_to, void **switched_from)</ref> { struct <ref refid="structk__thread" kindref="compound">k_thread</ref> *new = switch_to; struct <ref refid="structk__thread" kindref="compound">k_thread</ref> *old = CONTAINER_OF(switched_from, struct <ref refid="structk__thread" kindref="compound">k_thread</ref>, switch_handle);</para>
<para>// save old context... *switched_from = old; // restore new context... }</para>
<para>Note that the kernel manages the switch_handle field for synchronization as described above. So it is not legal for architecture code to assume that it has any particular value at any other time. In particular it is not legal to read the field from the address passed in the second argument.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>switch_to</parametername>
</parameternamelist>
<parameterdescription>
<para>Incoming thread&apos;s switch handle </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>switched_from</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to outgoing thread&apos;s switch handle storage location, which must be updated. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="kernel/include/kernel_arch_interface.h" line="131" column="20" declfile="kernel/include/kernel_arch_interface.h" declline="131" declcolumn="20"/>
      </memberdef>
      <memberdef kind="function" id="group__arch-threads_1ga3ddd51635018a2e0235d5599401f5269" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void arch_switch_to_main_thread</definition>
        <argsstring>(struct k_thread *main_thread, char *stack_ptr, k_thread_entry_t _main)</argsstring>
        <name>arch_switch_to_main_thread</name>
        <param>
          <type>struct <ref refid="structk__thread" kindref="compound">k_thread</ref> *</type>
          <declname>main_thread</declname>
        </param>
        <param>
          <type>char *</type>
          <declname>stack_ptr</declname>
        </param>
        <param>
          <type><ref refid="arch__interface_8h_1af1bd193a26c6e6a8658140185cae42e1" kindref="member">k_thread_entry_t</ref></type>
          <declname>_main</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Custom logic for entering main thread context at early boot</para>
<para>Used by architectures where the typical trick of setting up a dummy thread in early boot context to &quot;switch out&quot; of isn&apos;t workable.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>main_thread</parametername>
</parameternamelist>
<parameterdescription>
<para>main thread object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stack_ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>Initial stack pointer </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>_main</parametername>
</parameternamelist>
<parameterdescription>
<para>Entry point for application main function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="kernel/include/kernel_arch_interface.h" line="170" column="6" declfile="kernel/include/kernel_arch_interface.h" declline="170" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__arch-threads_1ga7c2f0ee0bee6f9de0bd23a0aa321a46d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int arch_float_disable</definition>
        <argsstring>(struct k_thread *thread)</argsstring>
        <name>arch_float_disable</name>
        <param>
          <type>struct <ref refid="structk__thread" kindref="compound">k_thread</ref> *</type>
          <declname>thread</declname>
        </param>
        <briefdescription>
<para>Disable floating point context preservation. </para>
        </briefdescription>
        <detaileddescription>
<para>The function is used to disable the preservation of floating point context information for a particular thread.</para>
<para><simplesect kind="note"><para>For ARM architecture, disabling floating point preservation may only be requested for the current thread and cannot be requested in ISRs.</para>
</simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>0</parametername>
</parameternamelist>
<parameterdescription>
<para>On success. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>-EINVAL</parametername>
</parameternamelist>
<parameterdescription>
<para>If the floating point disabling could not be performed. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>-ENOTSUP</parametername>
</parameternamelist>
<parameterdescription>
<para>If the operation is not supported </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="kernel/include/kernel_arch_interface.h" line="188" column="5" declfile="kernel/include/kernel_arch_interface.h" declline="188" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__arch-threads_1gacd40e26783f3dbd8a658fc1af512fb18" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int arch_float_enable</definition>
        <argsstring>(struct k_thread *thread, unsigned int options)</argsstring>
        <name>arch_float_enable</name>
        <param>
          <type>struct <ref refid="structk__thread" kindref="compound">k_thread</ref> *</type>
          <declname>thread</declname>
        </param>
        <param>
          <type><ref refid="lib_2libc_2minimal_2include_2sys_2types_8h_1a4089fb16419d359081465355db05f846" kindref="member">unsigned</ref> int</type>
          <declname>options</declname>
        </param>
        <briefdescription>
<para>Enable floating point context preservation. </para>
        </briefdescription>
        <detaileddescription>
<para>The function is used to enable the preservation of floating point context information for a particular thread. This API depends on each architecture implimentation. If the architecture does not support enabling, this API will always be failed.</para>
<para>The <emphasis>options</emphasis> parameter indicates which floating point register sets will be used by the specified thread. Currently it is used by x86 only.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>thread</parametername>
</parameternamelist>
<parameterdescription>
<para>ID of thread. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>options</parametername>
</parameternamelist>
<parameterdescription>
<para>architecture dependent options</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>0</parametername>
</parameternamelist>
<parameterdescription>
<para>On success. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>-EINVAL</parametername>
</parameternamelist>
<parameterdescription>
<para>If the floating point enabling could not be performed. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>-ENOTSUP</parametername>
</parameternamelist>
<parameterdescription>
<para>If the operation is not supported </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="kernel/include/kernel_arch_interface.h" line="208" column="5" declfile="kernel/include/kernel_arch_interface.h" declline="208" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__arch-pm_1gada83bf3beb5004a39a1f9c8c7ce35348" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>FUNC_NORETURN void</type>
        <definition>FUNC_NORETURN void arch_system_halt</definition>
        <argsstring>(unsigned int reason)</argsstring>
        <name>arch_system_halt</name>
        <param>
          <type><ref refid="lib_2libc_2minimal_2include_2sys_2types_8h_1a4089fb16419d359081465355db05f846" kindref="member">unsigned</ref> int</type>
          <declname>reason</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Halt the system, optionally propagating a reason code </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="kernel/include/kernel_arch_interface.h" line="219" column="20" declfile="kernel/include/kernel_arch_interface.h" declline="219" declcolumn="20"/>
      </memberdef>
      <memberdef kind="function" id="group__arch-irq_1ga1dda03646da3989f08a3bad1b258c691" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="stdbool_8h_1abb452686968e48b67397da5f97445f5b" kindref="member">bool</ref></type>
        <definition>static bool arch_is_in_isr</definition>
        <argsstring>(void)</argsstring>
        <name>arch_is_in_isr</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Test if the current context is in interrupt context</para>
<para>XXX: This is inconsistently handled among arches wrt exception context See: #17656</para>
<para><simplesect kind="return"><para>true if we are in interrupt context </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="kernel/include/kernel_arch_interface.h" line="238" column="20" declfile="kernel/include/kernel_arch_interface.h" declline="238" declcolumn="20"/>
      </memberdef>
      <memberdef kind="function" id="group__arch-mmu_1ga627bee468e54bb2d5ebe6ac53bb7fc94" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void arch_mem_map</definition>
        <argsstring>(void *virt, uintptr_t phys, size_t size, uint32_t flags)</argsstring>
        <name>arch_mem_map</name>
        <param>
          <type>void *</type>
          <declname>virt</declname>
        </param>
        <param>
          <type><ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref></type>
          <declname>phys</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type><ref refid="stdint_8h_1a0a8582351ac627ee8bde2973c825e47f" kindref="member">uint32_t</ref></type>
          <declname>flags</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Map physical memory into the virtual address space</para>
<para>This is a low-level interface to mapping pages into the address space. Behavior when providing unaligned addresses/sizes is undefined, these are assumed to be aligned to CONFIG_MMU_PAGE_SIZE.</para>
<para>The core kernel handles all management of the virtual address space; by the time we invoke this function, we know exactly where this mapping will be established. If the page tables already had mappings installed for the virtual memory region, these will be overwritten.</para>
<para>If the target architecture supports multiple page sizes, currently only the smallest page size will be used.</para>
<para>The memory range itself is never accessed by this operation.</para>
<para>This API must be safe to call in ISRs or exception handlers. Calls to this API are assumed to be serialized, and indeed all usage will originate from kernel/mm.c which handles virtual memory management.</para>
<para>Architectures are expected to pre-allocate page tables for the entire address space, as defined by CONFIG_KERNEL_VM_BASE and CONFIG_KERNEL_VM_SIZE. This operation should never require any kind of allocation for paging structures.</para>
<para>Validation of arguments should be done via assertions.</para>
<para>This API is part of infrastructure still under development and may change.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>virt</parametername>
</parameternamelist>
<parameterdescription>
<para>Page-aligned Destination virtual address to map </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>phys</parametername>
</parameternamelist>
<parameterdescription>
<para>Page-aligned Source physical address to map </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Page-aligned size of the mapped memory region in bytes </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>flags</parametername>
</parameternamelist>
<parameterdescription>
<para>Caching, access and control flags, see K_MAP_* macros </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="kernel/include/kernel_arch_interface.h" line="284" column="6" declfile="kernel/include/kernel_arch_interface.h" declline="284" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__arch-mmu_1ga8783e1d292510477b3816b6686d7d8cd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void arch_mem_unmap</definition>
        <argsstring>(void *addr, size_t size)</argsstring>
        <name>arch_mem_unmap</name>
        <param>
          <type>void *</type>
          <declname>addr</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Remove mappings for a provided virtual address range</para>
<para>This is a low-level interface for un-mapping pages from the address space. When this completes, the relevant page table entries will be updated as if no mapping was ever made for that memory range. No previous context needs to be preserved. This function must update mappings in all active page tables.</para>
<para>Behavior when providing unaligned addresses/sizes is undefined, these are assumed to be aligned to CONFIG_MMU_PAGE_SIZE.</para>
<para>Behavior when providing an address range that is not already mapped is undefined.</para>
<para>This function should never require memory allocations for paging structures, and it is not necessary to free any paging structures. Empty page tables due to all contained entries being un-mapped may remain in place.</para>
<para>Implementations must invalidate TLBs as necessary.</para>
<para>This API is part of infrastructure still under development and may change.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>addr</parametername>
</parameternamelist>
<parameterdescription>
<para>Page-aligned base virtual address to un-map </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Page-aligned region size </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="kernel/include/kernel_arch_interface.h" line="312" column="6" declfile="kernel/include/kernel_arch_interface.h" declline="312" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__arch-mmu_1gaa31a233dab4ad575a9a969de10965200" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int arch_page_phys_get</definition>
        <argsstring>(void *virt, uintptr_t *phys)</argsstring>
        <name>arch_page_phys_get</name>
        <param>
          <type>void *</type>
          <declname>virt</declname>
        </param>
        <param>
          <type><ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref> *</type>
          <declname>phys</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the mapped physical memory address from virtual address.</para>
<para>The function only needs to query the current set of page tables as the information it reports must be common to all of them if multiple page tables are in use. If multiple page tables are active it is unnecessary to iterate over all of them.</para>
<para>Unless otherwise specified, virtual pages have the same mappings across all page tables. Calling this function on data pages that are exceptions to this rule (such as the scratch page) is undefined behavior. Just check the currently installed page tables and return the information in that.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>virt</parametername>
</parameternamelist>
<parameterdescription>
<para>Page-aligned virtual address </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">phys</parametername>
</parameternamelist>
<parameterdescription>
<para>Mapped physical address (can be NULL if only checking if virtual address is mapped)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>0</parametername>
</parameternamelist>
<parameterdescription>
<para>if mapping is found and valid </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>-EFAULT</parametername>
</parameternamelist>
<parameterdescription>
<para>if virtual address is not mapped </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="kernel/include/kernel_arch_interface.h" line="335" column="5" declfile="kernel/include/kernel_arch_interface.h" declline="335" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__arch-mmu_1ga229fa5699ad47951235af494f3d2a06a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void arch_reserved_pages_update</definition>
        <argsstring>(void)</argsstring>
        <name>arch_reserved_pages_update</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Update page frame database with reserved pages</para>
<para>Some page frames within system RAM may not be available for use. A good example of this is reserved regions in the first megabyte on PC-like systems.</para>
<para>Implementations of this function should mark all relavent entries in z_page_frames with K_PAGE_FRAME_RESERVED. This function is called at early system initialization with mm_lock held. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="kernel/include/kernel_arch_interface.h" line="347" column="6" declfile="kernel/include/kernel_arch_interface.h" declline="347" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__arch-mmu_1ga4c13ffab5b5a5f8c93971c4d3b51bd8f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void arch_mem_page_out</definition>
        <argsstring>(void *addr, uintptr_t location)</argsstring>
        <name>arch_mem_page_out</name>
        <param>
          <type>void *</type>
          <declname>addr</declname>
        </param>
        <param>
          <type><ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref></type>
          <declname>location</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Update all page tables for a paged-out data page</para>
<para>This function:<itemizedlist>
<listitem><para>Sets the data page virtual address to trigger a fault if accessed that can be distinguished from access violations or un-mapped pages.</para>
</listitem><listitem><para>Saves the provided location value so that it can retrieved for that data page in the page fault handler.</para>
</listitem><listitem><para>The location value semantics are undefined here but the value will be always be page-aligned. It could be 0.</para>
</listitem></itemizedlist>
</para>
<para>If multiple page tables are in use, this must update all page tables. This function is called with interrupts locked.</para>
<para>Calling this function on data pages which are already paged out is undefined behavior.</para>
<para>This API is part of infrastructure still under development and may change. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="kernel/include/kernel_arch_interface.h" line="368" column="6" declfile="kernel/include/kernel_arch_interface.h" declline="368" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__arch-mmu_1ga3c446aea862e37d479a809582322b3ae" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void arch_mem_page_in</definition>
        <argsstring>(void *addr, uintptr_t phys)</argsstring>
        <name>arch_mem_page_in</name>
        <param>
          <type>void *</type>
          <declname>addr</declname>
        </param>
        <param>
          <type><ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref></type>
          <declname>phys</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Update all page tables for a paged-in data page</para>
<para>This function:<itemizedlist>
<listitem><para>Maps the specified virtual data page address to the provided physical page frame address, such that future memory accesses will function as expected. Access and caching attributes are undisturbed.</para>
</listitem><listitem><para>Clears any accounting for &quot;accessed&quot; and &quot;dirty&quot; states.</para>
</listitem></itemizedlist>
</para>
<para>If multiple page tables are in use, this must update all page tables. This function is called with interrupts locked.</para>
<para>Calling this function on data pages which are already paged in is undefined behavior.</para>
<para>This API is part of infrastructure still under development and may change. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="kernel/include/kernel_arch_interface.h" line="387" column="6" declfile="kernel/include/kernel_arch_interface.h" declline="387" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__arch-mmu_1gae4e82c3100b08bdfdcd9361d316735a1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void arch_mem_scratch</definition>
        <argsstring>(uintptr_t phys)</argsstring>
        <name>arch_mem_scratch</name>
        <param>
          <type><ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref></type>
          <declname>phys</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Update current page tables for a temporary mapping</para>
<para>Map a physical page frame address to a special virtual address Z_SCRATCH_PAGE, with read/write access to supervisor mode, such that when this function returns, the calling context can read/write the page frame&apos;s contents from the Z_SCRATCH_PAGE address.</para>
<para>This mapping only needs to be done on the current set of page tables, as it is only used for a short period of time exclusively by the caller. This function is called with interrupts locked.</para>
<para>This API is part of infrastructure still under development and may change. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="kernel/include/kernel_arch_interface.h" line="403" column="6" declfile="kernel/include/kernel_arch_interface.h" declline="403" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__arch-mmu_1ga74b3ce1173b91a8f82c25ef89f9fbbc0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>enum <ref refid="group__arch-mmu_1ga65e10c80055d7e695add000f2ccfbb0b" kindref="member">arch_page_location</ref></type>
        <definition>enum arch_page_location arch_page_location_get</definition>
        <argsstring>(void *addr, uintptr_t *location)</argsstring>
        <name>arch_page_location_get</name>
        <param>
          <type>void *</type>
          <declname>addr</declname>
        </param>
        <param>
          <type><ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref> *</type>
          <declname>location</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Fetch location information about a page at a particular address</para>
<para>The function only needs to query the current set of page tables as the information it reports must be common to all of them if multiple page tables are in use. If multiple page tables are active it is unnecessary to iterate over all of them. This may allow certain types of optimizations (such as reverse page table mapping on x86).</para>
<para>This function is called with interrupts locked, so that the reported information can&apos;t become stale while decisions are being made based on it.</para>
<para>Unless otherwise specified, virtual data pages have the same mappings across all page tables. Calling this function on data pages that are exceptions to this rule (such as the scratch page) is undefined behavior. Just check the currently installed page tables and return the information in that.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>addr</parametername>
</parameternamelist>
<parameterdescription>
<para>Virtual data page address that took the page fault </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">location</parametername>
</parameternamelist>
<parameterdescription>
<para>In the case of ARCH_PAGE_FAULT_PAGED_OUT, the backing store location value used to retrieve the data page. In the case of ARCH_PAGE_FAULT_PAGED_IN, the physical address the page is mapped to. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>ARCH_PAGE_FAULT_PAGED_OUT</parametername>
</parameternamelist>
<parameterdescription>
<para>The page was evicted to the backing store. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ARCH_PAGE_FAULT_PAGED_IN</parametername>
</parameternamelist>
<parameterdescription>
<para>The data page is resident in memory. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ARCH_PAGE_FAULT_BAD</parametername>
</parameternamelist>
<parameterdescription>
<para>The page is un-mapped or otherwise has had invalid access </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="kernel/include/kernel_arch_interface.h" line="438" column="24" declfile="kernel/include/kernel_arch_interface.h" declline="438" declcolumn="24"/>
      </memberdef>
      <memberdef kind="function" id="group__arch-mmu_1gab32a4bb6b3d44c126d63a473caf28b70" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref></type>
        <definition>uintptr_t arch_page_info_get</definition>
        <argsstring>(void *addr, uintptr_t *location, bool clear_accessed)</argsstring>
        <name>arch_page_info_get</name>
        <param>
          <type>void *</type>
          <declname>addr</declname>
        </param>
        <param>
          <type><ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref> *</type>
          <declname>location</declname>
        </param>
        <param>
          <type><ref refid="stdbool_8h_1abb452686968e48b67397da5f97445f5b" kindref="member">bool</ref></type>
          <declname>clear_accessed</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Retrieve page characteristics from the page table(s)</para>
<para>The architecture is responsible for maintaining &quot;accessed&quot; and &quot;dirty&quot; states of data pages to support marking eviction algorithms. This can either be directly supported by hardware or emulated by modifying protection policy to generate faults on reads or writes. In all cases the architecture must maintain this information in some way.</para>
<para>For the provided virtual address, report the logical OR of the accessed and dirty states for the relevant entries in all active page tables in the system if the page is mapped and not paged out.</para>
<para>If clear_accessed is true, the ARCH_DATA_PAGE_ACCESSED flag will be reset. This function will report its prior state. If multiple page tables are in use, this function clears accessed state in all of them.</para>
<para>This function is called with interrupts locked, so that the reported information can&apos;t become stale while decisions are being made based on it.</para>
<para>The return value may have other bits set which the caller must ignore.</para>
<para>Clearing accessed state for data pages that are not ARCH_DATA_PAGE_LOADED is undefined behavior.</para>
<para>ARCH_DATA_PAGE_DIRTY and ARCH_DATA_PAGE_ACCESSED bits in the return value are only significant if ARCH_DATA_PAGE_LOADED is set, otherwise ignore them.</para>
<para>ARCH_DATA_PAGE_NOT_MAPPED bit in the return value is only significant if ARCH_DATA_PAGE_LOADED is un-set, otherwise ignore it.</para>
<para>Unless otherwise specified, virtual data pages have the same mappings across all page tables. Calling this function on data pages that are exceptions to this rule (such as the scratch page) is undefined behavior.</para>
<para>This API is part of infrastructure still under development and may change.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>addr</parametername>
</parameternamelist>
<parameterdescription>
<para>Virtual address to look up in page tables </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">location</parametername>
</parameternamelist>
<parameterdescription>
<para>If non-NULL, updated with either physical page frame address or backing store location depending on ARCH_DATA_PAGE_LOADED state. This is not touched if ARCH_DATA_PAGE_NOT_MAPPED. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>clear_accessed</parametername>
</parameternamelist>
<parameterdescription>
<para>Whether to clear ARCH_DATA_PAGE_ACCESSED state </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>Value</parametername>
</parameternamelist>
<parameterdescription>
<para>with ARCH_DATA_PAGE_* bits set reflecting the data page configuration </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="kernel/include/kernel_arch_interface.h" line="523" column="11" declfile="kernel/include/kernel_arch_interface.h" declline="523" declcolumn="11"/>
      </memberdef>
      <memberdef kind="function" id="group__arch-misc_1ga6860efc93b8ba35911cfb0afbe372623" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int arch_printk_char_out</definition>
        <argsstring>(int c)</argsstring>
        <name>arch_printk_char_out</name>
        <param>
          <type>int</type>
          <declname>c</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Early boot console output hook</para>
<para>Definition of this function is optional. If implemented, any invocation of <ref refid="printk_8h_1a768a7dff8592b69f327a08f96b00fa54" kindref="member">printk()</ref> (or logging calls with CONFIG_LOG_MODE_MINIMAL which are backed by printk) will default to sending characters to this function. It is useful for early boot debugging before main serial or console drivers come up.</para>
<para>This can be overridden at runtime with __printk_hook_install().</para>
<para>The default __weak implementation of this does nothing.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>Character to print </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The character printed </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="kernel/include/kernel_arch_interface.h" line="550" column="5" declfile="kernel/include/kernel_arch_interface.h" declline="550" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__arch-misc_1ga62cc65268b396d2683e47c09c9b62af5" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void arch_kernel_init</definition>
        <argsstring>(void)</argsstring>
        <name>arch_kernel_init</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Architecture-specific kernel initialization hook</para>
<para>This function is invoked near the top of _Cstart, for additional architecture-specific setup before the rest of the kernel is brought up.</para>
<para>TODO: Deprecate, most arches are using a prep_c() function to do the same thing in a simpler way </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="kernel/include/kernel_arch_interface.h" line="561" column="20" declfile="kernel/include/kernel_arch_interface.h" declline="561" declcolumn="20"/>
      </memberdef>
      <memberdef kind="function" id="group__arch-misc_1gabb087b9e158824121212d65646ae4154" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void arch_nop</definition>
        <argsstring>(void)</argsstring>
        <name>arch_nop</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Do nothing and return. Yawn. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="kernel/include/kernel_arch_interface.h" line="564" column="20" declfile="kernel/include/kernel_arch_interface.h" declline="564" declcolumn="20"/>
      </memberdef>
      <memberdef kind="function" id="group__arch-coredump_1ga081b713e38ca635184f5f07bd7fd7a16" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void arch_coredump_info_dump</definition>
        <argsstring>(const z_arch_esf_t *esf)</argsstring>
        <name>arch_coredump_info_dump</name>
        <param>
          <type>const z_arch_esf_t *</type>
          <declname>esf</declname>
        </param>
        <briefdescription>
<para>Architecture-specific handling during coredump. </para>
        </briefdescription>
        <detaileddescription>
<para>This dumps architecture-specific information during coredump.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>esf</parametername>
</parameternamelist>
<parameterdescription>
<para>Exception Stack Frame (arch-specific) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="kernel/include/kernel_arch_interface.h" line="581" column="6" declfile="kernel/include/kernel_arch_interface.h" declline="581" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__arch-coredump_1ga1d9b0c011a03434272ff9bec120f273d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="stdint_8h_1a5debae8b2a1ec20a6694c0c443ee399e" kindref="member">uint16_t</ref></type>
        <definition>uint16_t arch_coredump_tgt_code_get</definition>
        <argsstring>(void)</argsstring>
        <name>arch_coredump_tgt_code_get</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
<para>Get the target code specified by the architecture. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="kernel/include/kernel_arch_interface.h" line="586" column="10" declfile="kernel/include/kernel_arch_interface.h" declline="586" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="group__arch-tls_1ga7f159caca46063b04cf03a54b39255fc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t arch_tls_stack_setup</definition>
        <argsstring>(struct k_thread *new_thread, char *stack_ptr)</argsstring>
        <name>arch_tls_stack_setup</name>
        <param>
          <type>struct <ref refid="structk__thread" kindref="compound">k_thread</ref> *</type>
          <declname>new_thread</declname>
        </param>
        <param>
          <type>char *</type>
          <declname>stack_ptr</declname>
        </param>
        <briefdescription>
<para>Setup Architecture-specific TLS area in stack. </para>
        </briefdescription>
        <detaileddescription>
<para>This sets up the stack area for thread local storage. The structure inside in area is architecture specific.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>new_thread</parametername>
</parameternamelist>
<parameterdescription>
<para>New thread object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stack_ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>Stack pointer </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Number of bytes taken by the TLS area </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="kernel/include/kernel_arch_interface.h" line="606" column="8" declfile="kernel/include/kernel_arch_interface.h" declline="606" declcolumn="8"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Internal kernel APIs implemented at the architecture layer. </para>
    </briefdescription>
    <detaileddescription>
<para>Not all architecture-specific defines are here, APIs that are used by public functions and macros are defined in <ref refid="arch__interface_8h" kindref="compound">include/sys/arch_interface.h</ref>.</para>
<para>For all inline functions prototyped here, the implementation is expected to be provided by arch/ARCH/include/kernel_arch_func.h </para>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="comment">/*</highlight></codeline>
<codeline lineno="2"><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(c)<sp/>2019<sp/>Intel<sp/>Corporation.</highlight></codeline>
<codeline lineno="3"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="4"><highlight class="comment"><sp/>*<sp/>SPDX-License-Identifier:<sp/>Apache-2.0</highlight></codeline>
<codeline lineno="5"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6"><highlight class="normal"></highlight></codeline>
<codeline lineno="17"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>ZEPHYR_KERNEL_INCLUDE_KERNEL_ARCH_INTERFACE_H_</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="18"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>ZEPHYR_KERNEL_INCLUDE_KERNEL_ARCH_INTERFACE_H_</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="19"><highlight class="normal"></highlight></codeline>
<codeline lineno="20"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="21"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="arch__interface_8h" kindref="compound">sys/arch_interface.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="22"><highlight class="normal"></highlight></codeline>
<codeline lineno="23"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_ASMLANGUAGE</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="24"><highlight class="normal"></highlight></codeline>
<codeline lineno="25"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>__cplusplus</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="26"><highlight class="normal"></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/></highlight><highlight class="stringliteral">&quot;C&quot;</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="27"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="28"><highlight class="normal"></highlight></codeline>
<codeline lineno="33"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="39" refid="group__arch-timing_1gaffc9f3013d53e72c25243ce4f972549f" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__arch-timing_1gaffc9f3013d53e72c25243ce4f972549f" kindref="member">arch_busy_wait</ref>(<ref refid="stdint_8h_1a0a8582351ac627ee8bde2973c825e47f" kindref="member">uint32_t</ref><sp/>usec_to_wait);</highlight></codeline>
<codeline lineno="40"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="41"><highlight class="normal"></highlight></codeline>
<codeline lineno="76" refid="group__arch-threads_1gade449838e445fa8201266e38215c616c" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__arch-threads_1gade449838e445fa8201266e38215c616c" kindref="member">arch_new_thread</ref>(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/><ref refid="structk__thread" kindref="compound">k_thread</ref><sp/>*<ref refid="atomic_8c_1ae3e7b70821cb2fc4b41ff1189e70bc92" kindref="member">thread</ref>,<sp/><ref refid="arch__interface_8h_1a3e4bde3075edb41069b258d999333b0e" kindref="member">k_thread_stack_t</ref><sp/>*<ref refid="smp__boot__delay_2src_2main_8c_1a96786824adbf96016a9dbf6eded02b94" kindref="member">stack</ref>,</highlight></codeline>
<codeline lineno="77"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*stack_ptr,<sp/><ref refid="arch__interface_8h_1af1bd193a26c6e6a8658140185cae42e1" kindref="member">k_thread_entry_t</ref><sp/>entry,</highlight></codeline>
<codeline lineno="78"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*p1,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*p2,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*p3);</highlight></codeline>
<codeline lineno="79"><highlight class="normal"></highlight></codeline>
<codeline lineno="80"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CONFIG_USE_SWITCH</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="131" refid="group__arch-threads_1gab411d82ce5b60f062171f5a19e33e025" refkind="member"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__arch-threads_1gab411d82ce5b60f062171f5a19e33e025" kindref="member">arch_switch</ref>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*switch_to,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>**switched_from);</highlight></codeline>
<codeline lineno="132"><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="145"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>arch_swap(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="spinlock__error__case_8c_1ac67cfa528fbe6d605bc5a011b74611cc" kindref="member">key</ref>);</highlight></codeline>
<codeline lineno="146"><highlight class="normal"></highlight></codeline>
<codeline lineno="155"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="common_8h_1aa1dec568e79152c892dcf63f445cbd7a" kindref="member">ALWAYS_INLINE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="156"><highlight class="normal">arch_thread_return_value_set(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/><ref refid="structk__thread" kindref="compound">k_thread</ref><sp/>*<ref refid="atomic_8c_1ae3e7b70821cb2fc4b41ff1189e70bc92" kindref="member">thread</ref>,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>value);</highlight></codeline>
<codeline lineno="157"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">/*<sp/>CONFIG_USE_SWITCH<sp/>i*/</highlight><highlight class="preprocessor"></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="158"><highlight class="normal"></highlight></codeline>
<codeline lineno="159"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="170" refid="group__arch-threads_1ga3ddd51635018a2e0235d5599401f5269" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__arch-threads_1ga3ddd51635018a2e0235d5599401f5269" kindref="member">arch_switch_to_main_thread</ref>(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/><ref refid="structk__thread" kindref="compound">k_thread</ref><sp/>*<ref refid="workq_2user__work_2src_2main_8c_1a1a57fef890c6b3defdc54c18c1c47a1c" kindref="member">main_thread</ref>,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*stack_ptr,</highlight></codeline>
<codeline lineno="171"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="arch__interface_8h_1af1bd193a26c6e6a8658140185cae42e1" kindref="member">k_thread_entry_t</ref><sp/>_main);</highlight></codeline>
<codeline lineno="172"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">/*<sp/>CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN<sp/>*/</highlight><highlight class="preprocessor"></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="173"><highlight class="normal"></highlight></codeline>
<codeline lineno="174"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>defined(CONFIG_FPU)<sp/>&amp;&amp;<sp/>defined(CONFIG_FPU_SHARING)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="188" refid="group__arch-threads_1ga7c2f0ee0bee6f9de0bd23a0aa321a46d" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="group__arch-threads_1ga7c2f0ee0bee6f9de0bd23a0aa321a46d" kindref="member">arch_float_disable</ref>(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/><ref refid="structk__thread" kindref="compound">k_thread</ref><sp/>*<ref refid="atomic_8c_1ae3e7b70821cb2fc4b41ff1189e70bc92" kindref="member">thread</ref>);</highlight></codeline>
<codeline lineno="189"><highlight class="normal"></highlight></codeline>
<codeline lineno="208" refid="group__arch-threads_1gacd40e26783f3dbd8a658fc1af512fb18" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="group__arch-threads_1gacd40e26783f3dbd8a658fc1af512fb18" kindref="member">arch_float_enable</ref>(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/><ref refid="structk__thread" kindref="compound">k_thread</ref><sp/>*<ref refid="atomic_8c_1ae3e7b70821cb2fc4b41ff1189e70bc92" kindref="member">thread</ref>,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>options);</highlight></codeline>
<codeline lineno="209"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">/*<sp/>CONFIG_FPU<sp/>&amp;&amp;<sp/>CONFIG_FPU_SHARING<sp/>*/</highlight><highlight class="preprocessor"></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="210"><highlight class="normal"></highlight></codeline>
<codeline lineno="219" refid="group__arch-pm_1gada83bf3beb5004a39a1f9c8c7ce35348" refkind="member"><highlight class="normal">FUNC_NORETURN<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__arch-pm_1gada83bf3beb5004a39a1f9c8c7ce35348" kindref="member">arch_system_halt</ref>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>reason);</highlight></codeline>
<codeline lineno="220"><highlight class="normal"></highlight></codeline>
<codeline lineno="238" refid="group__arch-irq_1ga1dda03646da3989f08a3bad1b258c691" refkind="member"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/><ref refid="group__arch-irq_1ga1dda03646da3989f08a3bad1b258c691" kindref="member">arch_is_in_isr</ref>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="239"><highlight class="normal"></highlight></codeline>
<codeline lineno="284" refid="group__arch-mmu_1ga627bee468e54bb2d5ebe6ac53bb7fc94" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__arch-mmu_1ga627bee468e54bb2d5ebe6ac53bb7fc94" kindref="member">arch_mem_map</ref>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*virt,<sp/><ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref><sp/>phys,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size,<sp/><ref refid="stdint_8h_1a0a8582351ac627ee8bde2973c825e47f" kindref="member">uint32_t</ref><sp/><ref refid="http__parser_8h_1ab6b306ef981f5e21bb41ea2c2dbe8cd9" kindref="member">flags</ref>);</highlight></codeline>
<codeline lineno="285"><highlight class="normal"></highlight></codeline>
<codeline lineno="312" refid="group__arch-mmu_1ga8783e1d292510477b3816b6686d7d8cd" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__arch-mmu_1ga8783e1d292510477b3816b6686d7d8cd" kindref="member">arch_mem_unmap</ref>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*addr,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size);</highlight></codeline>
<codeline lineno="313"><highlight class="normal"></highlight></codeline>
<codeline lineno="335" refid="group__arch-mmu_1gaa31a233dab4ad575a9a969de10965200" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="group__arch-mmu_1gaa31a233dab4ad575a9a969de10965200" kindref="member">arch_page_phys_get</ref>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*virt,<sp/><ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref><sp/>*phys);</highlight></codeline>
<codeline lineno="336"><highlight class="normal"></highlight></codeline>
<codeline lineno="347" refid="group__arch-mmu_1ga229fa5699ad47951235af494f3d2a06a" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__arch-mmu_1ga229fa5699ad47951235af494f3d2a06a" kindref="member">arch_reserved_pages_update</ref>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="348"><highlight class="normal"></highlight></codeline>
<codeline lineno="368" refid="group__arch-mmu_1ga4c13ffab5b5a5f8c93971c4d3b51bd8f" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__arch-mmu_1ga4c13ffab5b5a5f8c93971c4d3b51bd8f" kindref="member">arch_mem_page_out</ref>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*addr,<sp/><ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref><sp/>location);</highlight></codeline>
<codeline lineno="369"><highlight class="normal"></highlight></codeline>
<codeline lineno="387" refid="group__arch-mmu_1ga3c446aea862e37d479a809582322b3ae" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__arch-mmu_1ga3c446aea862e37d479a809582322b3ae" kindref="member">arch_mem_page_in</ref>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*addr,<sp/><ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref><sp/>phys);</highlight></codeline>
<codeline lineno="388"><highlight class="normal"></highlight></codeline>
<codeline lineno="403" refid="group__arch-mmu_1gae4e82c3100b08bdfdcd9361d316735a1" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__arch-mmu_1gae4e82c3100b08bdfdcd9361d316735a1" kindref="member">arch_mem_scratch</ref>(<ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref><sp/>phys);</highlight></codeline>
<codeline lineno="404"><highlight class="normal"></highlight></codeline>
<codeline lineno="405" refid="group__arch-mmu_1ga65e10c80055d7e695add000f2ccfbb0b" refkind="member"><highlight class="normal"></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/><ref refid="group__arch-mmu_1ga65e10c80055d7e695add000f2ccfbb0b" kindref="member">arch_page_location</ref><sp/>{</highlight></codeline>
<codeline lineno="406" refid="group__arch-mmu_1gga65e10c80055d7e695add000f2ccfbb0bacf9e624eac380ea2bfa37632c4d17a3a" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__arch-mmu_1gga65e10c80055d7e695add000f2ccfbb0bacf9e624eac380ea2bfa37632c4d17a3a" kindref="member">ARCH_PAGE_LOCATION_PAGED_OUT</ref>,</highlight></codeline>
<codeline lineno="407" refid="group__arch-mmu_1gga65e10c80055d7e695add000f2ccfbb0bae378a008f497ae10ab50cab06f8c36db" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__arch-mmu_1gga65e10c80055d7e695add000f2ccfbb0bae378a008f497ae10ab50cab06f8c36db" kindref="member">ARCH_PAGE_LOCATION_PAGED_IN</ref>,</highlight></codeline>
<codeline lineno="408"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__arch-mmu_1gga65e10c80055d7e695add000f2ccfbb0ba7ff70acdf02345b5fa4c42ed2b2adde9" kindref="member">ARCH_PAGE_LOCATION_BAD</ref></highlight></codeline>
<codeline lineno="409" refid="group__arch-mmu_1gga65e10c80055d7e695add000f2ccfbb0ba7ff70acdf02345b5fa4c42ed2b2adde9" refkind="member"><highlight class="normal">};</highlight></codeline>
<codeline lineno="410"><highlight class="normal"></highlight></codeline>
<codeline lineno="438" refid="group__arch-mmu_1ga74b3ce1173b91a8f82c25ef89f9fbbc0" refkind="member"><highlight class="normal"></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/><ref refid="group__arch-mmu_1ga65e10c80055d7e695add000f2ccfbb0b" kindref="member">arch_page_location</ref><sp/><ref refid="group__arch-mmu_1ga74b3ce1173b91a8f82c25ef89f9fbbc0" kindref="member">arch_page_location_get</ref>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*addr,<sp/><ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref><sp/>*location);</highlight></codeline>
<codeline lineno="439"><highlight class="normal"></highlight></codeline>
<codeline lineno="523" refid="group__arch-mmu_1gab32a4bb6b3d44c126d63a473caf28b70" refkind="member"><highlight class="normal"><ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref><sp/><ref refid="group__arch-mmu_1gab32a4bb6b3d44c126d63a473caf28b70" kindref="member">arch_page_info_get</ref>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*addr,<sp/><ref refid="stdint_8h_1a4788399d1d0b37ccf098a7da82254808" kindref="member">uintptr_t</ref><sp/>*location,</highlight></codeline>
<codeline lineno="524"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>clear_accessed);</highlight></codeline>
<codeline lineno="525"><highlight class="normal"></highlight></codeline>
<codeline lineno="550" refid="group__arch-misc_1ga6860efc93b8ba35911cfb0afbe372623" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="group__arch-misc_1ga6860efc93b8ba35911cfb0afbe372623" kindref="member">arch_printk_char_out</ref>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="printk_8c_1adc08ed1554f35803d229aeaf11216b3f" kindref="member">c</ref>);</highlight></codeline>
<codeline lineno="551"><highlight class="normal"></highlight></codeline>
<codeline lineno="561" refid="group__arch-misc_1ga62cc65268b396d2683e47c09c9b62af5" refkind="member"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__arch-misc_1ga62cc65268b396d2683e47c09c9b62af5" kindref="member">arch_kernel_init</ref>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="562"><highlight class="normal"></highlight></codeline>
<codeline lineno="564" refid="group__arch-misc_1gabb087b9e158824121212d65646ae4154" refkind="member"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__arch-misc_1gabb087b9e158824121212d65646ae4154" kindref="member">arch_nop</ref>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="565"><highlight class="normal"></highlight></codeline>
<codeline lineno="581" refid="group__arch-coredump_1ga081b713e38ca635184f5f07bd7fd7a16" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__arch-coredump_1ga081b713e38ca635184f5f07bd7fd7a16" kindref="member">arch_coredump_info_dump</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>z_arch_esf_t<sp/>*esf);</highlight></codeline>
<codeline lineno="582"><highlight class="normal"></highlight></codeline>
<codeline lineno="586" refid="group__arch-coredump_1ga1d9b0c011a03434272ff9bec120f273d" refkind="member"><highlight class="normal"><ref refid="stdint_8h_1a5debae8b2a1ec20a6694c0c443ee399e" kindref="member">uint16_t</ref><sp/><ref refid="group__arch-coredump_1ga1d9b0c011a03434272ff9bec120f273d" kindref="member">arch_coredump_tgt_code_get</ref>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="587"><highlight class="normal"></highlight></codeline>
<codeline lineno="606" refid="group__arch-tls_1ga7f159caca46063b04cf03a54b39255fc" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/><ref refid="group__arch-tls_1ga7f159caca46063b04cf03a54b39255fc" kindref="member">arch_tls_stack_setup</ref>(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/><ref refid="structk__thread" kindref="compound">k_thread</ref><sp/>*new_thread,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*stack_ptr);</highlight></codeline>
<codeline lineno="607"><highlight class="normal"></highlight></codeline>
<codeline lineno="610"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Include<sp/>arch-specific<sp/>inline<sp/>function<sp/>implementation<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="611"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;kernel_arch_func.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="612"><highlight class="normal"></highlight></codeline>
<codeline lineno="613"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>__cplusplus</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="614"><highlight class="normal">}</highlight></codeline>
<codeline lineno="615"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="616"><highlight class="normal"></highlight></codeline>
<codeline lineno="617"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">/*<sp/>_ASMLANGUAGE<sp/>*/</highlight><highlight class="preprocessor"></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="618"><highlight class="normal"></highlight></codeline>
<codeline lineno="619"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">/*<sp/>ZEPHYR_KERNEL_INCLUDE_KERNEL_ARCH_INTERFACE_H_<sp/>*/</highlight><highlight class="preprocessor"></highlight></codeline>
    </programlisting>
    <location file="kernel/include/kernel_arch_interface.h"/>
  </compounddef>
</doxygen>
