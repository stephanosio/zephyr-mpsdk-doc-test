<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Architecture Porting Guide &mdash; Zephyr Project Documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/custom.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/tabs.css" type="text/css" />
    <link rel="shortcut icon" href="../../_static/favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script type="module" src="../../_static/js/dark-mode-toggle.min.mjs"></script>
        <script src="https://www.googletagmanager.com/gtag/js?id=UA-831873-47"></script>
        <script src="../../_static/js/ga-tracker.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="copyright" title="Copyright" href="../../copyright.html" />
    <link rel="next" title="Board Porting Guide" href="board_porting.html" />
    <link rel="prev" title="Porting" href="index.html" />
  <meta name="color-scheme" content="dark light">
  
  <link rel="stylesheet" href="../../_static/css/light.css" type="text/css" media="(prefers-color-scheme: light)"/>
  <link rel="stylesheet" href="../../_static/css/dark.css" type="text/css" media="(prefers-color-scheme: dark)"/>

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html">
            <img src="../../_static/logo.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                3.0.99
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
  
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Zephyr Project</span>
      v: latest
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl>
        <dt>Document Release Versions</dt>
        
          <dd><a href="/">latest</a></dd>
        
          <dd><a href="/3.0.0/">3.0.0</a></dd>
        
          <dd><a href="/2.7.0/">2.7.0</a></dd>
        
          <dd><a href="/2.6.0/">2.6.0</a></dd>
        
          <dd><a href="/2.5.0/">2.5.0</a></dd>
        
          <dd><a href="/2.4.0/">2.4.0</a></dd>
        
          <dd><a href="/2.3.0/">2.3.0</a></dd>
        
          <dd><a href="/1.14.1/">1.14.1</a></dd>
        
      </dl>
      <dl>
        <dt>Downloads</dt>
        
        <dd><a href="/latest/zephyr.pdf">PDF</a></dd>
      </dl>
      <dl>
        <dt>zephyrproject.org Links</dt>
          <dd>
            <a href="https://www.zephyrproject.org/">Project Home</a>
          </dd>
          <dd>
            <a href="https://github.com/zephyrproject-rtos/sdk-ng/releases">SDK</a>
          </dd>
          <dd>
            <a href="https://github.com/zephyrproject-rtos/zephyr/releases">Releases</a>
          </dd>
      </dl>
    </div>
  </div>
  
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../introduction/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/index.html">Getting Started Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/index.html">Contribution Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../development_process/index.html">Development and Contribution Process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../build/index.html">Build and Configuration Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../application/index.html">Application Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/index.html">API Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">User and Developer Guides</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../beyond-GSG.html">Beyond the Getting Started Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arch/index.html">Architecture-related Guides</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bluetooth/index.html">Bluetooth</a></li>
<li class="toctree-l2"><a class="reference internal" href="../docs/index.html">Documentation Generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../coccinelle.html">Coccinelle</a></li>
<li class="toctree-l2"><a class="reference internal" href="../code-relocation.html">Code And Data Relocation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crypto/index.html">Cryptography</a></li>
<li class="toctree-l2"><a class="reference internal" href="../flash_debug/index.html">Flashing and Hardware Debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="../debug_tools/index.html">Debugging and Tracing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_mgmt/index.html">Device Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dts/index.html">Devicetree Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../env_vars.html">Environment Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pinctrl/index.html">Pin Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pm/index.html">Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../emulator/index.html">Peripheral and Hardware Emulators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules.html">Modules (External projects)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../networking/index.html">Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../platformio/index.html">Using with PlatformIO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../portability/index.html">OS Abstraction</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Porting</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Architecture Porting Guide</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#early-boot-sequence">Early Boot Sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interrupt-and-exception-handling">Interrupt and Exception Handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="#thread-context-switching">Thread Context Switching</a></li>
<li class="toctree-l4"><a class="reference internal" href="#thread-creation-and-termination">Thread Creation and Termination</a></li>
<li class="toctree-l4"><a class="reference internal" href="#thread-local-storage">Thread Local Storage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#device-drivers">Device Drivers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#utility-libraries">Utility Libraries</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cpu-idling-power-management">CPU Idling/Power Management</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fault-management">Fault Management</a></li>
<li class="toctree-l4"><a class="reference internal" href="#toolchain-and-linking">Toolchain and Linking</a></li>
<li class="toctree-l4"><a class="reference internal" href="#memory-management">Memory Management</a></li>
<li class="toctree-l4"><a class="reference internal" href="#stack-objects">Stack Objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="#user-mode-threads">User Mode Threads</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gdb-stub">GDB Stub</a></li>
<li class="toctree-l4"><a class="reference internal" href="#api-reference">API Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="board_porting.html">Board Porting Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="shields.html">Shields</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../smf/index.html">State Machine Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../test/index.html">Testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tfm/index.html">Trusted Firmware-M</a></li>
<li class="toctree-l2"><a class="reference internal" href="../west/index.html">West (Zephyr’s meta-tool)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../optimizations/index.html">Optimizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../zephyr_cmake_package.html">Zephyr CMake Package</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../samples/index.html">Samples and Demos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../boards/index.html">Supported Boards</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../releases/index.html">Release Notes</a></li>
</ul>

  
  <div class="toctree-wrapper compound">
    <p class="caption"><span class="caption-text">Reference</span></p>
    <ul>
      
      <li class="toctree-l1">
        <a class="reference internal" href="/latest/doxygen/html/index.html">API</a>
      </li>
      
      <li class="toctree-l1">
        <a class="reference internal" href="/latest/kconfig.html">Kconfig Options</a>
      </li>
      
      <li class="toctree-l1">
        <a class="reference internal" href="/latest/reference/devicetree/bindings.html">Devicetree Bindings</a>
      </li>
      
    </ul>
  </div>
  

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Zephyr Project</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
  <!-- Docs / Latest -->
  
  

  <li><a href="../../index.html">Docs / Latest</a> &raquo;</li>
  
     <li><a href="../index.html">User and Developer Guides</a> &raquo;</li>
  
     <li><a href="index.html">Porting</a> &raquo;</li>
  
  <li>Architecture Porting Guide</li>


  <li class="wy-breadcrumbs-aside">
    <dark-mode-toggle id="dark-mode-toggle" appearance="toggle" permanent="true"/>
  </li>
  <li class="wy-breadcrumbs-aside">
      
      
        <a href="https://github.com/zephyrproject-rtos/zephyr/blob/main/doc/guides/porting/arch.rst" class="fa fa-github"> Open on GitHub</a>
      
    
  </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
  
    <div class="wy-alert wy-alert-danger">
     This is the documentation for the latest (main) development branch of
     Zephyr. If you are looking for the documentation of previous releases, use
     the drop-down menu on the left and select the desired version.
    </div>
  
  
           <div itemprop="articleBody">
             
  <div class="section" id="architecture-porting-guide">
<span id="id1"></span><h1>Architecture Porting Guide<a class="headerlink" href="#architecture-porting-guide" title="Permalink to this headline">¶</a></h1>
<p>An architecture port is needed to enable Zephyr to run on an <abbr title="instruction set architecture">ISA</abbr> or an <abbr title="Application Binary Interface">ABI</abbr> that is not currently supported.</p>
<p>The following are examples of ISAs and ABIs that Zephyr supports:</p>
<ul class="simple">
<li><p>x86_32 ISA with System V ABI</p></li>
<li><p>ARMv7-M ISA with Thumb2 instruction set and ARM Embedded ABI (aeabi)</p></li>
<li><p>ARCv2 ISA</p></li>
</ul>
<p>For information on Kconfig configuration, see
<a class="reference internal" href="../build/kconfig/setting.html#setting-configuration-values"><span class="std std-ref">Setting Kconfig configuration values</span></a>. Architectures use a Kconfig configuration
scheme similar to boards.</p>
<p>An architecture port can be divided in several parts; most are required and
some are optional:</p>
<ul class="simple">
<li><p><strong>The early boot sequence</strong>: each architecture has different steps it must
take when the CPU comes out of reset (required).</p></li>
<li><p><strong>Interrupt and exception handling</strong>: each architecture handles asynchronous
and unrequested events in a specific manner (required).</p></li>
<li><p><strong>Thread context switching</strong>: the Zephyr context switch is dependent on the
ABI and each ISA has a different set of registers to save (required).</p></li>
<li><p><strong>Thread creation and termination</strong>: A thread’s initial stack frame is ABI
and architecture-dependent, and thread abortion possibly as well (required).</p></li>
<li><p><strong>Device drivers</strong>: most often, the system clock timer and the interrupt
controller are tied to the architecture (some required, some optional).</p></li>
<li><p><strong>Utility libraries</strong>: some common kernel APIs rely on a
architecture-specific implementation for performance reasons (required).</p></li>
<li><p><strong>CPU idling/power management</strong>: most architectures implement instructions
for putting the CPU to sleep (partly optional, most likely very desired).</p></li>
<li><p><strong>Fault management</strong>: for implementing architecture-specific debug help and
handling of fatal error in threads (partly optional).</p></li>
<li><p><strong>Linker scripts and toolchains</strong>: architecture-specific details will most
likely be needed in the build system and when linking the image (required).</p></li>
</ul>
<div class="section" id="early-boot-sequence">
<h2>Early Boot Sequence<a class="headerlink" href="#early-boot-sequence" title="Permalink to this headline">¶</a></h2>
<p>The goal of the early boot sequence is to take the system from the state it is
after reset to a state where is can run C code and thus the common kernel
initialization sequence. Most of the time, very few steps are needed, while
some architectures require a bit more work to be performed.</p>
<p>Common steps for all architectures:</p>
<ul class="simple">
<li><p>Setup an initial stack.</p></li>
<li><p>If running an <abbr title="eXecute-In-Place">XIP</abbr> kernel, copy initialized data</p></li>
<li><p>from ROM to RAM.</p></li>
<li><p>If not using an ELF loader, zero the BSS section.</p></li>
<li><p>Jump to <code class="code docutils literal notranslate"><span class="pre">_Cstart()</span></code>, the early kernel initialization</p>
<ul>
<li><p><code class="code docutils literal notranslate"><span class="pre">_Cstart()</span></code> is responsible for context switching out of the fake
context running at startup into the main thread.</p></li>
</ul>
</li>
</ul>
<p>Some examples of architecture-specific steps that have to be taken:</p>
<ul class="simple">
<li><p>If given control in real mode on x86_32, switch to 32-bit protected mode.</p></li>
<li><p>Setup the segment registers on x86_32 to handle boot loaders that leave them
in an unknown or broken state.</p></li>
<li><p>Initialize a board-specific watchdog on Cortex-M3/4.</p></li>
<li><p>Switch stacks from MSP to PSP on Cortex-M.</p></li>
<li><p>Use a different approach than calling into _Swap() on Cortex-M to prevent
race conditions.</p></li>
<li><p>Setup FIRQ and regular IRQ handling on ARCv2.</p></li>
</ul>
</div>
<div class="section" id="interrupt-and-exception-handling">
<h2>Interrupt and Exception Handling<a class="headerlink" href="#interrupt-and-exception-handling" title="Permalink to this headline">¶</a></h2>
<p>Each architecture defines interrupt and exception handling differently.</p>
<p>When a device wants to signal the processor that there is some work to be done
on its behalf, it raises an interrupt. When a thread does an operation that is
not handled by the serial flow of the software itself, it raises an exception.
Both, interrupts and exceptions, pass control to a handler. The handler is
known as an <abbr title="Interrupt Service Routine">ISR</abbr> in the case of
interrupts. The handler performs the work required by the exception or the
interrupt.  For interrupts, that work is device-specific. For exceptions, it
depends on the exception, but most often the core kernel itself is responsible
for providing the handler.</p>
<p>The kernel has to perform some work in addition to the work the handler itself
performs. For example:</p>
<ul class="simple">
<li><p>Prior to handing control to the handler:</p>
<ul>
<li><p>Save the currently executing context.</p></li>
<li><p>Possibly getting out of power saving mode, which includes waking up
devices.</p></li>
<li><p>Updating the kernel uptime if getting out of tickless idle mode.</p></li>
</ul>
</li>
<li><p>After getting control back from the handler:</p>
<ul>
<li><p>Decide whether to perform a context switch.</p></li>
<li><p>When performing a context switch, restore the context being context
switched in.</p></li>
</ul>
</li>
</ul>
<p>This work is conceptually the same across architectures, but the details are
completely different:</p>
<ul class="simple">
<li><p>The registers to save and restore.</p></li>
<li><p>The processor instructions to perform the work.</p></li>
<li><p>The numbering of the exceptions.</p></li>
<li><p>etc.</p></li>
</ul>
<p>It thus needs an architecture-specific implementation, called the
interrupt/exception stub.</p>
<p>Another issue is that the kernel defines the signature of ISRs as:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">isr</span><span class="p">)(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">parameter</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Architectures do not have a consistent or native way of handling parameters to
an ISR. As such there are two commonly used methods for handling the
parameter.</p>
<ul class="simple">
<li><p>Using some architecture defined mechanism, the parameter value is forced in
the stub. This is commonly found in X86-based architectures.</p></li>
<li><p>The parameters to the ISR are inserted and tracked via a separate table
requiring the architecture to discover at runtime which interrupt is
executing. A common interrupt handler demuxer is installed for all entries of
the real interrupt vector table, which then fetches the device’s ISR and
parameter from the separate table. This approach is commonly used in the ARC
and ARM architectures via the <a class="reference internal" href="../../kconfig.html#CONFIG_GEN_ISR_TABLES" title="CONFIG_GEN_ISR_TABLES"><code class="xref kconfig kconfig-option docutils literal notranslate"><span class="pre">CONFIG_GEN_ISR_TABLES</span></code></a> implementation.
You can find examples of the stubs by looking at <code class="code docutils literal notranslate"><span class="pre">_interrupt_enter()</span></code> in
x86, <code class="code docutils literal notranslate"><span class="pre">_IntExit()</span></code> in ARM, <code class="code docutils literal notranslate"><span class="pre">_isr_wrapper()</span></code> in ARM, or the full
implementation description for ARC in <a class="reference external" href="https://github.com/zephyrproject-rtos/zephyr/blob/main/arch/arc/core/isr_wrapper.S">arch/arc/core/isr_wrapper.S</a>.</p></li>
</ul>
<p>Each architecture also has to implement primitives for interrupt control:</p>
<ul class="simple">
<li><p>locking interrupts: <a class="reference internal" href="../../reference/kernel/other/interrupts.html#c.irq_lock" title="irq_lock"><code class="xref c c-macro docutils literal notranslate"><span class="pre">irq_lock()</span></code></a>, <a class="reference internal" href="../../reference/kernel/other/interrupts.html#c.irq_unlock" title="irq_unlock"><code class="xref c c-macro docutils literal notranslate"><span class="pre">irq_unlock()</span></code></a>.</p></li>
<li><p>registering interrupts: <a class="reference internal" href="../../reference/kernel/other/interrupts.html#c.IRQ_CONNECT" title="IRQ_CONNECT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">IRQ_CONNECT()</span></code></a>.</p></li>
<li><p>programming the priority if possible <code class="xref c c-func docutils literal notranslate"><span class="pre">irq_priority_set()</span></code>.</p></li>
<li><p>enabling/disabling interrupts: <a class="reference internal" href="../../reference/kernel/other/interrupts.html#c.irq_enable" title="irq_enable"><code class="xref c c-macro docutils literal notranslate"><span class="pre">irq_enable()</span></code></a>, <a class="reference internal" href="../../reference/kernel/other/interrupts.html#c.irq_disable" title="irq_disable"><code class="xref c c-macro docutils literal notranslate"><span class="pre">irq_disable()</span></code></a>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="../../reference/kernel/other/interrupts.html#c.IRQ_CONNECT" title="IRQ_CONNECT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">IRQ_CONNECT</span></code></a> is a macro that uses assembler and/or linker script
tricks to connect interrupts at build time, saving boot time and text size.</p>
</div>
<p>The vector table should contain a handler for each interrupt and exception that
can possibly occur. The handler can be as simple as a spinning loop. However,
we strongly suggest that handlers at least print some debug information. The
information helps figuring out what went wrong when hitting an exception that
is a fault, like divide-by-zero or invalid memory access, or an interrupt that
is not expected (<em class="dfn">spurious interrupt</em>). See the ARM implementation in
<a class="reference external" href="https://github.com/zephyrproject-rtos/zephyr/blob/main/arch/arm/core/aarch32/cortex_m/fault.c">arch/arm/core/aarch32/cortex_m/fault.c</a> for an example.</p>
</div>
<div class="section" id="thread-context-switching">
<h2>Thread Context Switching<a class="headerlink" href="#thread-context-switching" title="Permalink to this headline">¶</a></h2>
<p>Multi-threading is the basic purpose to have a kernel at all. Zephyr supports
two types of threads: preemptible and cooperative.</p>
<p>Two crucial concepts when writing an architecture port are the following:</p>
<ul class="simple">
<li><p>Cooperative threads run at a higher priority than preemptible ones, and
always preempt them.</p></li>
<li><p>After handling an interrupt, if a cooperative thread was interrupted, the
kernel always goes back to running that thread, since it is not preemptible.</p></li>
</ul>
<p>A context switch can happen in several circumstances:</p>
<ul class="simple">
<li><p>When a thread executes a blocking operation, such as taking a semaphore that
is currently unavailable.</p></li>
<li><p>When a preemptible thread unblocks a thread of higher priority by releasing
the object on which it was blocked.</p></li>
<li><p>When an interrupt unblocks a thread of higher priority than the one currently
executing, if the currently executing thread is preemptible.</p></li>
<li><p>When a thread runs to completion.</p></li>
<li><p>When a thread causes a fatal exception and is removed from the running
threads. For example, referencing invalid memory,</p></li>
</ul>
<p>Therefore, the context switching must thus be able to handle all these cases.</p>
<p>The kernel keeps the next thread to run in a “cache”, and thus the context
switching code only has to fetch from that cache to select which thread to run.</p>
<p>There are two types of context switches: <em class="dfn">cooperative</em> and <em class="dfn">preemptive</em>.</p>
<ul class="simple">
<li><p>A <em>cooperative</em> context switch happens when a thread willfully gives the
control to another thread. There are two cases where this happens</p>
<ul>
<li><p>When a thread explicitly yields.</p></li>
<li><p>When a thread tries to take an object that is currently unavailable and is
willing to wait until the object becomes available.</p></li>
</ul>
</li>
<li><p>A <em>preemptive</em> context switch happens either because an ISR or a
thread causes an operation that schedules a thread of higher priority than the
one currently running, if the currently running thread is preemptible.
An example of such an operation is releasing an object on which the thread
of higher priority was waiting.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Control is never taken from cooperative thread when one of them is the
running thread.</p>
</div>
<p>A cooperative context switch is always done by having a thread call the
<code class="code docutils literal notranslate"><span class="pre">_Swap()</span></code> kernel internal symbol. When <code class="code docutils literal notranslate"><span class="pre">_Swap</span></code> is called, the
kernel logic knows that a context switch has to happen: <code class="code docutils literal notranslate"><span class="pre">_Swap</span></code> does not
check to see if a context switch must happen. Rather, <code class="code docutils literal notranslate"><span class="pre">_Swap</span></code> decides
what thread to context switch in. <code class="code docutils literal notranslate"><span class="pre">_Swap</span></code> is called by the kernel logic
when an object being operated on is unavailable, and some thread
yielding/sleeping primitives.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>On x86 and Nios2, <code class="code docutils literal notranslate"><span class="pre">_Swap</span></code> is generic enough and the architecture
flexible enough that <code class="code docutils literal notranslate"><span class="pre">_Swap</span></code> can be called when exiting an interrupt
to provoke the context switch. This should not be taken as a rule, since
neither the ARM Cortex-M or ARCv2 port do this.</p>
</div>
<p>Since <code class="code docutils literal notranslate"><span class="pre">_Swap</span></code> is cooperative, the caller-saved registers from the ABI are
already on the stack. There is no need to save them in the k_thread structure.</p>
<p>A context switch can also be performed preemptively. This happens upon exiting
an ISR, in the kernel interrupt exit stub:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">_interrupt_enter</span></code> on x86 after the handler is called.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">_IntExit</span></code> on ARM.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">_firq_exit</span></code> and <code class="code docutils literal notranslate"><span class="pre">_rirq_exit</span></code> on ARCv2.</p></li>
</ul>
<p>In this case, the context switch must only be invoked when the interrupted
thread was preemptible, not when it was a cooperative one, and only when the
current interrupt is not nested.</p>
<p>The kernel also has the concept of “locking the scheduler”. This is a concept
similar to locking the interrupts, but lighter-weight since interrupts can
still occur. If a thread has locked the scheduler, is it temporarily
non-preemptible.</p>
<p>So, the decision logic to invoke the context switch when exiting an interrupt
is simple:</p>
<ul class="simple">
<li><p>If the interrupted thread is not preemptible, do not invoke it.</p></li>
<li><p>Else, fetch the cached thread from the ready queue, and:</p>
<ul>
<li><p>If the cached thread is not the current thread, invoke the context switch.</p></li>
<li><p>Else, do not invoke it.</p></li>
</ul>
</li>
</ul>
<p>This is simple, but crucial: if this is not implemented correctly, the kernel
will not function as intended and will experience bizarre crashes, mostly due
to stack corruption.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If running a coop-only system, i.e. if <a class="reference internal" href="../../kconfig.html#CONFIG_NUM_PREEMPT_PRIORITIES" title="CONFIG_NUM_PREEMPT_PRIORITIES"><code class="xref kconfig kconfig-option docutils literal notranslate"><span class="pre">CONFIG_NUM_PREEMPT_PRIORITIES</span></code></a>
is 0, no preemptive context switch ever happens. The interrupt code can be
optimized to not take any scheduling decision when this is the case.</p>
</div>
</div>
<div class="section" id="thread-creation-and-termination">
<h2>Thread Creation and Termination<a class="headerlink" href="#thread-creation-and-termination" title="Permalink to this headline">¶</a></h2>
<p>To start a new thread, a stack frame must be constructed so that the context
switch can pop it the same way it would pop one from a thread that had been
context switched out. This is to be implemented in an architecture-specific
<code class="code docutils literal notranslate"><span class="pre">_new_thread</span></code> internal routine.</p>
<p>The thread entry point is also not to be called directly, i.e. it should not be
set as the <abbr title="program counter">PC</abbr> for the new thread. Rather it must be
wrapped in <code class="code docutils literal notranslate"><span class="pre">_thread_entry</span></code>. This means that the PC in the stack
frame shall be set to <code class="code docutils literal notranslate"><span class="pre">_thread_entry</span></code>, and the thread entry point shall
be passed as the first parameter to <code class="code docutils literal notranslate"><span class="pre">_thread_entry</span></code>. The specifics of
this depend on the ABI.</p>
<p>The need for an architecture-specific thread termination implementation depends
on the architecture. There is a generic implementation, but it might not work
for a given architecture.</p>
<p>One reason that has been encountered for having an architecture-specific
implementation of thread termination is that aborting a thread might be
different if aborting because of a graceful exit or because of an exception.
This is the case for ARM Cortex-M, where the CPU has to be taken out of handler
mode if the thread triggered a fatal exception, but not if the thread
gracefully exits its entry point function.</p>
<p>This means implementing an architecture-specific version of
<a class="reference internal" href="../../reference/kernel/threads/index.html#c.k_thread_abort" title="k_thread_abort"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_thread_abort()</span></code></a>, and setting the Kconfig option
<code class="xref kconfig kconfig-option docutils literal notranslate"><span class="pre">CONFIG_ARCH_HAS_THREAD_ABORT</span></code> as needed for the architecture (e.g. see
<a class="reference external" href="https://github.com/zephyrproject-rtos/zephyr/blob/main/arch/arm/core/aarch32/cortex_m/Kconfig">arch/arm/core/aarch32/cortex_m/Kconfig</a>).</p>
</div>
<div class="section" id="thread-local-storage">
<h2>Thread Local Storage<a class="headerlink" href="#thread-local-storage" title="Permalink to this headline">¶</a></h2>
<p>To enable thread local storage on a new architecture:</p>
<ol class="arabic simple">
<li><p>Implement <a class="reference internal" href="#c.arch_tls_stack_setup" title="arch_tls_stack_setup"><code class="xref c c-func docutils literal notranslate"><span class="pre">arch_tls_stack_setup()</span></code></a> to setup the TLS storage area in
stack. Refer to the toolchain documentation on how the storage area needs
to be structured. Some helper functions can be used:</p>
<ul class="simple">
<li><p>Function <code class="xref c c-func docutils literal notranslate"><span class="pre">z_tls_data_size()</span></code> returns the size
needed for thread local variables (excluding any extra data required by
toolchain and architecture).</p></li>
<li><p>Function <code class="xref c c-func docutils literal notranslate"><span class="pre">z_tls_copy()</span></code> prepares the TLS storage area for
thread local variables. This only copies the variable themselves and
does not do architecture and/or toolchain specific data.</p></li>
</ul>
</li>
<li><p>In the context switching, grab the <code class="docutils literal notranslate"><span class="pre">tls</span></code> field inside the new thread’s
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">k_thread</span></code> and put it into an appropriate register (or some
other variable) for access to the TLS storage area. Refer to toolchain
and architecture documentation on which registers to use.</p></li>
<li><p>In kconfig, add <code class="docutils literal notranslate"><span class="pre">select</span> <span class="pre">CONFIG_ARCH_HAS_THREAD_LOCAL_STORAGE</span></code> to
kconfig related to the new architecture.</p></li>
<li><p>Run the <code class="docutils literal notranslate"><span class="pre">tests/kernel/threads/tls</span></code> to make sure the new code works.</p></li>
</ol>
</div>
<div class="section" id="device-drivers">
<h2>Device Drivers<a class="headerlink" href="#device-drivers" title="Permalink to this headline">¶</a></h2>
<p>The kernel requires very few hardware devices to function. In theory, the only
required device is the interrupt controller, since the kernel can run without a
system clock. In practice, to get access to most, if not all, of the sanity
check test suite, a system clock is needed as well. Since these two are usually
tied to the architecture, they are part of the architecture port.</p>
<div class="section" id="interrupt-controllers">
<h3>Interrupt Controllers<a class="headerlink" href="#interrupt-controllers" title="Permalink to this headline">¶</a></h3>
<p>There can be significant differences between the interrupt controllers and the
interrupt concepts across architectures.</p>
<p>For example, x86 has the concept of an <abbr title="Interrupt Descriptor Table">IDT</abbr>
and different interrupt controllers. The position of an interrupt in the IDT
determines its priority.</p>
<p>On the other hand, the ARM Cortex-M has the <abbr title="Nested Vectored Interrupt Controller">NVIC</abbr> as part of the architecture definition. There is no need
for an IDT-like table that is separate from the NVIC vector table. The position
in the table has nothing to do with priority of an IRQ: priorities are
programmable per-entry.</p>
<p>The ARCv2 has its interrupt unit as part of the architecture definition, which
is somewhat similar to the NVIC. However, where ARC defines interrupts as
having a one-to-one mapping between exception and interrupt numbers (i.e.
exception 1 is IRQ1, and device IRQs start at 16), ARM has IRQ0 being
equivalent to exception 16 (and weirdly enough, exception 1 can be seen as
IRQ-15).</p>
<p>All these differences mean that very little, if anything, can be shared between
architectures with regards to interrupt controllers.</p>
</div>
<div class="section" id="system-clock">
<h3>System Clock<a class="headerlink" href="#system-clock" title="Permalink to this headline">¶</a></h3>
<p>x86 has APIC timers and the HPET as part of its architecture definition. ARM
Cortex-M has the SYSTICK exception. Finally, ARCv2 has the timer0/1 device.</p>
<p>Kernel timeouts are handled in the context of the system clock timer driver’s
interrupt handler.</p>
</div>
<div class="section" id="console-over-serial-line">
<h3>Console Over Serial Line<a class="headerlink" href="#console-over-serial-line" title="Permalink to this headline">¶</a></h3>
<p>There is one other device that is almost a requirement for an architecture
port, since it is so useful for debugging. It is a simple polling, output-only,
serial port driver on which to send the console (<code class="code docutils literal notranslate"><span class="pre">printk</span></code>,
<code class="code docutils literal notranslate"><span class="pre">printf</span></code>) output.</p>
<p>It is not required, and a RAM console (<a class="reference internal" href="../../kconfig.html#CONFIG_RAM_CONSOLE" title="CONFIG_RAM_CONSOLE"><code class="xref kconfig kconfig-option docutils literal notranslate"><span class="pre">CONFIG_RAM_CONSOLE</span></code></a>)
can be used to send all output to a circular buffer that can be read
by a debugger instead.</p>
</div>
</div>
<div class="section" id="utility-libraries">
<h2>Utility Libraries<a class="headerlink" href="#utility-libraries" title="Permalink to this headline">¶</a></h2>
<p>The kernel depends on a few functions that can be implemented with very few
instructions or in a lock-less manner in modern processors. Those are thus
expected to be implemented as part of an architecture port.</p>
<ul class="simple">
<li><p>Atomic operators.</p>
<ul>
<li><p>If instructions do exist for a given architecture, the implementation is
configured using the <a class="reference internal" href="../../kconfig.html#CONFIG_ATOMIC_OPERATIONS_ARCH" title="CONFIG_ATOMIC_OPERATIONS_ARCH"><code class="xref kconfig kconfig-option docutils literal notranslate"><span class="pre">CONFIG_ATOMIC_OPERATIONS_ARCH</span></code></a> Kconfig
option.</p></li>
<li><p>If instructions do not exist for a given architecture,
a generic version that wraps <a class="reference internal" href="../../reference/kernel/other/interrupts.html#c.irq_lock" title="irq_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_lock()</span></code></a> or <a class="reference internal" href="../../reference/kernel/other/interrupts.html#c.irq_unlock" title="irq_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_unlock()</span></code></a>
around non-atomic operations exists. It is configured using the
<a class="reference internal" href="../../kconfig.html#CONFIG_ATOMIC_OPERATIONS_C" title="CONFIG_ATOMIC_OPERATIONS_C"><code class="xref kconfig kconfig-option docutils literal notranslate"><span class="pre">CONFIG_ATOMIC_OPERATIONS_C</span></code></a> Kconfig option.</p></li>
</ul>
</li>
<li><p>Find-least-significant-bit-set and find-most-significant-bit-set.</p>
<ul>
<li><p>If instructions do not exist for a given architecture, it is always
possible to implement these functions as generic C functions.</p></li>
</ul>
</li>
</ul>
<p>It is possible to use compiler built-ins to implement these, but be careful
they use the required compiler barriers.</p>
</div>
<div class="section" id="cpu-idling-power-management">
<h2>CPU Idling/Power Management<a class="headerlink" href="#cpu-idling-power-management" title="Permalink to this headline">¶</a></h2>
<p>The kernel provides support for CPU power management with two functions:
<a class="reference internal" href="#c.arch_cpu_idle" title="arch_cpu_idle"><code class="xref c c-func docutils literal notranslate"><span class="pre">arch_cpu_idle()</span></code></a> and <a class="reference internal" href="#c.arch_cpu_atomic_idle" title="arch_cpu_atomic_idle"><code class="xref c c-func docutils literal notranslate"><span class="pre">arch_cpu_atomic_idle()</span></code></a>.</p>
<p><a class="reference internal" href="#c.arch_cpu_idle" title="arch_cpu_idle"><code class="xref c c-func docutils literal notranslate"><span class="pre">arch_cpu_idle()</span></code></a> can be as simple as calling the power saving
instruction for the architecture with interrupts unlocked, for example
<code class="code docutils literal notranslate"><span class="pre">hlt</span></code> on x86, <code class="code docutils literal notranslate"><span class="pre">wfi</span></code> or <code class="code docutils literal notranslate"><span class="pre">wfe</span></code> on ARM, <code class="code docutils literal notranslate"><span class="pre">sleep</span></code> on ARC.
This function can be called in a loop within a context that does not care if it
get interrupted or not by an interrupt before going to sleep. There are
basically two scenarios when it is correct to use this function:</p>
<ul class="simple">
<li><p>In a single-threaded system, in the only thread when the thread is not used
for doing real work after initialization, i.e. it is sitting in a loop doing
nothing for the duration of the application.</p></li>
<li><p>In the idle thread.</p></li>
</ul>
<p><a class="reference internal" href="#c.arch_cpu_atomic_idle" title="arch_cpu_atomic_idle"><code class="xref c c-func docutils literal notranslate"><span class="pre">arch_cpu_atomic_idle()</span></code></a>, on the other hand, must be able to atomically
re-enable interrupts and invoke the power saving instruction. It can thus be
used in real application code, again in single-threaded systems.</p>
<p>Normally, idling the CPU should be left to the idle thread, but in some very
special scenarios, these APIs can be used by applications.</p>
<p>Both functions must exist for a given architecture. However, the implementation
can be simply the following steps, if desired:</p>
<ol class="arabic simple">
<li><p>unlock interrupts</p></li>
<li><p>NOP</p></li>
</ol>
<p>However, a real implementation is strongly recommended.</p>
</div>
<div class="section" id="fault-management">
<h2>Fault Management<a class="headerlink" href="#fault-management" title="Permalink to this headline">¶</a></h2>
<p>In the event of an unhandled CPU exception, the architecture
code must call into <code class="xref c c-func docutils literal notranslate"><span class="pre">z_fatal_error()</span></code>.  This function dumps
out architecture-agnostic information and makes a policy
decision on what to do next by invoking <code class="xref c c-func docutils literal notranslate"><span class="pre">k_sys_fatal_error()</span></code>.
This function can be overridden to implement application-specific
policies that could include locking interrupts and spinning forever
(the default implementation) or even powering off the
system (if supported).</p>
</div>
<div class="section" id="toolchain-and-linking">
<h2>Toolchain and Linking<a class="headerlink" href="#toolchain-and-linking" title="Permalink to this headline">¶</a></h2>
<p>Toolchain support has to be added to the build system.</p>
<p>Some architecture-specific definitions are needed in <a class="reference external" href="https://github.com/zephyrproject-rtos/zephyr/blob/main/include/toolchain/gcc.h">include/toolchain/gcc.h</a>.
See what exists in that file for currently supported architectures.</p>
<p>Each architecture also needs its own linker script, even if most sections can
be derived from the linker scripts of other architectures. Some sections might
be specific to the new architecture, for example the SCB section on ARM and the
IDT section on x86.</p>
</div>
<div class="section" id="memory-management">
<h2>Memory Management<a class="headerlink" href="#memory-management" title="Permalink to this headline">¶</a></h2>
<p>If the target platform enables paging and requires drivers to memory-map
their I/O regions, <a class="reference internal" href="../../kconfig.html#CONFIG_MMU" title="CONFIG_MMU"><code class="xref kconfig kconfig-option docutils literal notranslate"><span class="pre">CONFIG_MMU</span></code></a> needs to be enabled and the
<a class="reference internal" href="#c.arch_mem_map" title="arch_mem_map"><code class="xref c c-func docutils literal notranslate"><span class="pre">arch_mem_map()</span></code></a> API implemented.</p>
</div>
<div class="section" id="stack-objects">
<h2>Stack Objects<a class="headerlink" href="#stack-objects" title="Permalink to this headline">¶</a></h2>
<p>The presence of memory protection hardware affects how stack objects are
created. All architecture ports must specify the required alignment of the
stack pointer, which is some combination of CPU and ABI requirements. This
is defined in architecture headers with <code class="xref c c-macro docutils literal notranslate"><span class="pre">ARCH_STACK_PTR_ALIGN</span></code> and
is typically something small like 4, 8, or 16 bytes.</p>
<p>Two types of thread stacks exist:</p>
<ul class="simple">
<li><p>“kernel” stacks defined with <a class="reference internal" href="../../reference/kernel/threads/index.html#c.K_KERNEL_STACK_DEFINE" title="K_KERNEL_STACK_DEFINE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">K_KERNEL_STACK_DEFINE()</span></code></a> and related
APIs, which can host kernel threads running in supervisor mode or
used as the stack for interrupt/exception handling. These have significantly
relaxed alignment requirements and use less reserved data. No memory is
reserved for prvilege elevation stacks.</p></li>
<li><p>“thread” stacks which typically use more memory, but are capable of hosting
thread running in user mode, as well as any use-cases for kernel stacks.</p></li>
</ul>
<p>If <a class="reference internal" href="../../kconfig.html#CONFIG_USERSPACE" title="CONFIG_USERSPACE"><code class="xref kconfig kconfig-option docutils literal notranslate"><span class="pre">CONFIG_USERSPACE</span></code></a> is not enabled, “thread” and “kernel” stacks are
equivalent.</p>
<p>Additional macros may be defined in the architecture layer to specify
the alignment of the base of stack objects, any reserved data inside the
stack object not used for the thread’s stack buffer, and how to round up
stack sizes to support user mode threads. In the absence of definitions
some defaults are assumed:</p>
<ul class="simple">
<li><p><code class="xref c c-macro docutils literal notranslate"><span class="pre">ARCH_KERNEL_STACK_RESERVED</span></code>: default no reserved space</p></li>
<li><p><code class="xref c c-macro docutils literal notranslate"><span class="pre">ARCH_THREAD_STACK_RESERVED</span></code>: default no reserved space</p></li>
<li><p><code class="xref c c-macro docutils literal notranslate"><span class="pre">ARCH_KERNEL_STACK_OBJ_ALIGN</span></code>: default align to
<code class="xref c c-macro docutils literal notranslate"><span class="pre">ARCH_STACK_PTR_ALIGN</span></code></p></li>
<li><p><code class="xref c c-macro docutils literal notranslate"><span class="pre">ARCH_THREAD_STACK_OBJ_ALIGN</span></code>: default align to
<code class="xref c c-macro docutils literal notranslate"><span class="pre">ARCH_STACK_PTR_ALIGN</span></code></p></li>
<li><p><code class="xref c c-macro docutils literal notranslate"><span class="pre">ARCH_THREAD_STACK_SIZE_ALIGN</span></code>: default round up to
<code class="xref c c-macro docutils literal notranslate"><span class="pre">ARCH_STACK_PTR_ALIGN</span></code></p></li>
</ul>
<p>All stack creation macros are defined in terms of these.</p>
<p>Stack objects all have the following layout, with some regions potentially
zero-sized depending on configuration. There are always two main parts:
reserved memory at the beginning, and then the stack buffer itself. The
bounds of some areas can only be determined at runtime in the context of
its associated thread object. Other areas are entirely computable at build
time.</p>
<p>Some architectures may need to carve-out reserved memory at runtime from the
stack buffer, instead of unconditionally reserving it at build time, or to
supplement an existing reserved area (as is the case with the ARM FPU).
Such carve-outs will always be tracked in <code class="docutils literal notranslate"><span class="pre">thread.stack_info.start</span></code>.
The region specified by <code class="docutils literal notranslate"><span class="pre">thread.stack_info.start</span></code> and
<code class="docutils literal notranslate"><span class="pre">thread.stack_info.size</span></code> is always fully accessible by a user mode thread.
<code class="docutils literal notranslate"><span class="pre">thread.stack_info.delta</span></code> denotes an offset which can be used to compute
the initial stack pointer from the very end of the stack object, taking into
account storage for TLS and ASLR random offsets.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+---------------------+</span> <span class="o">&lt;-</span> <span class="n">thread</span><span class="o">.</span><span class="n">stack_obj</span>
<span class="o">|</span> <span class="n">Reserved</span> <span class="n">Memory</span>     <span class="o">|</span> <span class="p">}</span> <span class="n">K_</span><span class="p">(</span><span class="n">THREAD</span><span class="o">|</span><span class="n">KERNEL</span><span class="p">)</span><span class="n">_STACK_RESERVED</span>
<span class="o">+---------------------+</span>
<span class="o">|</span> <span class="n">Carved</span><span class="o">-</span><span class="n">out</span> <span class="n">memory</span>   <span class="o">|</span>
<span class="o">|.....................|</span> <span class="o">&lt;-</span> <span class="n">thread</span><span class="o">.</span><span class="n">stack_info</span><span class="o">.</span><span class="n">start</span>
<span class="o">|</span> <span class="n">Unused</span> <span class="n">stack</span> <span class="n">buffer</span> <span class="o">|</span>
<span class="o">|</span>                     <span class="o">|</span>
<span class="o">|.....................|</span> <span class="o">&lt;-</span> <span class="n">thread</span><span class="s1">&#39;s current stack pointer</span>
<span class="o">|</span> <span class="n">Used</span> <span class="n">stack</span> <span class="n">buffer</span>   <span class="o">|</span>
<span class="o">|</span>                     <span class="o">|</span>
<span class="o">|.....................|</span> <span class="o">&lt;-</span> <span class="n">Initial</span> <span class="n">stack</span> <span class="n">pointer</span><span class="o">.</span> <span class="n">Computable</span>
<span class="o">|</span> <span class="n">ASLR</span> <span class="n">Random</span> <span class="n">offset</span>  <span class="o">|</span>      <span class="k">with</span> <span class="n">thread</span><span class="o">.</span><span class="n">stack_info</span><span class="o">.</span><span class="n">delta</span>
<span class="o">+---------------------|</span> <span class="o">&lt;-</span> <span class="n">thread</span><span class="o">.</span><span class="n">userspace_local_data</span>
<span class="o">|</span> <span class="n">Thread</span><span class="o">-</span><span class="n">local</span> <span class="n">data</span>   <span class="o">|</span>
<span class="o">+---------------------+</span> <span class="o">&lt;-</span> <span class="n">thread</span><span class="o">.</span><span class="n">stack_info</span><span class="o">.</span><span class="n">start</span> <span class="o">+</span>
                             <span class="n">thread</span><span class="o">.</span><span class="n">stack_info</span><span class="o">.</span><span class="n">size</span>
</pre></div>
</div>
<p>At present, Zephyr does not support stacks that grow upward.</p>
<div class="section" id="no-memory-protection">
<h3>No Memory Protection<a class="headerlink" href="#no-memory-protection" title="Permalink to this headline">¶</a></h3>
<p>If no memory protection is in use, then the defaults are sufficient.</p>
</div>
<div class="section" id="hw-based-stack-overflow-detection">
<h3>HW-based stack overflow detection<a class="headerlink" href="#hw-based-stack-overflow-detection" title="Permalink to this headline">¶</a></h3>
<p>This option uses hardware features to generate a fatal error if a thread
in supervisor mode overflows its stack. This is useful for debugging, although
for a couple reasons, you can’t reliably make any assertions about the state
of the system after this happens:</p>
<ul class="simple">
<li><p>The kernel could have been inside a critical section when the overflow
occurs, leaving important global data structures in a corrupted state.</p></li>
<li><p>For systems that implement stack protection using a guard memory region,
it’s possible to overshoot the guard and corrupt adjacent data structures
before the hardware detects this situation.</p></li>
</ul>
<p>To enable the <a class="reference internal" href="../../kconfig.html#CONFIG_HW_STACK_PROTECTION" title="CONFIG_HW_STACK_PROTECTION"><code class="xref kconfig kconfig-option docutils literal notranslate"><span class="pre">CONFIG_HW_STACK_PROTECTION</span></code></a> feature, the system must
provide some kind of hardware-based stack overflow protection, and enable the
<code class="xref kconfig kconfig-option docutils literal notranslate"><span class="pre">CONFIG_ARCH_HAS_STACK_PROTECTION</span></code> option.</p>
<p>Two forms of HW-based stack overflow detection are supported: dedicated
CPU features for this purpose, or special read-only guard regions immediately
preceding stack buffers.</p>
<p><a class="reference internal" href="../../kconfig.html#CONFIG_HW_STACK_PROTECTION" title="CONFIG_HW_STACK_PROTECTION"><code class="xref kconfig kconfig-option docutils literal notranslate"><span class="pre">CONFIG_HW_STACK_PROTECTION</span></code></a> only catches stack overflows for
supervisor threads. This is not required to catch stack overflow from user
threads; <a class="reference internal" href="../../kconfig.html#CONFIG_USERSPACE" title="CONFIG_USERSPACE"><code class="xref kconfig kconfig-option docutils literal notranslate"><span class="pre">CONFIG_USERSPACE</span></code></a> is orthogonal.</p>
<p>This feature only detects supervisor mode stack overflows, including stack
overflows when handling system calls. It doesn’t guarantee that the kernel has
not been corrupted. Any stack overflow in supervisor mode should be treated as
a fatal error, with no assertions about the integrity of the overall system
possible.</p>
<p>Stack overflows in user mode are recoverable (from the kernel’s perspective)
and require no special configuration; <a class="reference internal" href="../../kconfig.html#CONFIG_HW_STACK_PROTECTION" title="CONFIG_HW_STACK_PROTECTION"><code class="xref kconfig kconfig-option docutils literal notranslate"><span class="pre">CONFIG_HW_STACK_PROTECTION</span></code></a>
only applies to catching overflows when the CPU is in sueprvisor mode.</p>
<div class="section" id="cpu-based-stack-overflow-detection">
<h4>CPU-based stack overflow detection<a class="headerlink" href="#cpu-based-stack-overflow-detection" title="Permalink to this headline">¶</a></h4>
<p>If we are detecting stack overflows in supervisor mode via special CPU
registers (like ARM’s SPLIM), then the defaults are sufficient.</p>
</div>
<div class="section" id="guard-based-stack-overflow-detection">
<h4>Guard-based stack overflow detection<a class="headerlink" href="#guard-based-stack-overflow-detection" title="Permalink to this headline">¶</a></h4>
<p>We are detecting supervisor mode stack overflows via special memory protection
region located immediately before the stack buffer that generates an exception
on write. Reserved memory will be used for the guard region.</p>
<p><code class="xref c c-macro docutils literal notranslate"><span class="pre">ARCH_KERNEL_STACK_RESERVED</span></code> should be defined to the minimum size
of a memory protection region. On most ARM CPUs this is 32 bytes.
<code class="xref c c-macro docutils literal notranslate"><span class="pre">ARCH_KERNEL_STACK_OBJ_ALIGN</span></code> should also be set to the required
alignment for this region.</p>
<p>MMU-based systems should not reserve RAM for the guard region and instead
simply leave an non-present virtual page below every stack when it is mapped
into the address space. The stack object will still need to be properly aligned
and sized to page granularity.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+-----------------------------+</span> <span class="o">&lt;-</span> <span class="n">thread</span><span class="o">.</span><span class="n">stack_obj</span>
<span class="o">|</span> <span class="n">Guard</span> <span class="n">reserved</span> <span class="n">memory</span>       <span class="o">|</span> <span class="p">}</span> <span class="n">K_KERNEL_STACK_RESERVED</span>
<span class="o">+-----------------------------+</span>
<span class="o">|</span> <span class="n">Guard</span> <span class="n">carve</span><span class="o">-</span><span class="n">out</span>             <span class="o">|</span>
<span class="o">|.............................|</span> <span class="o">&lt;-</span> <span class="n">thread</span><span class="o">.</span><span class="n">stack_info</span><span class="o">.</span><span class="n">start</span>
<span class="o">|</span> <span class="n">Stack</span> <span class="n">buffer</span>                <span class="o">|</span>
<span class="o">.</span>                             <span class="o">.</span>
</pre></div>
</div>
<p>Guard carve-outs for kernel stacks are uncommon and should be avoided if
possible. They tend to be needed for two situations:</p>
<ul class="simple">
<li><p>The same stack may be re-purposed to host a user thread, in which case
the guard is unnecessary and shouldn’t be unconditionally reserved.
This is the case when privilege elevation stacks are not inside the stack
object.</p></li>
<li><p>The required guard size is variable and depends on context. For example, some
ARM CPUs have lazy floating point stacking during exceptions and may
decrement the stack pointer by a large value without writing anything,
completely overshooting a minimally-sized guard and corrupting adjacent
memory. Rather than unconditionally reserving a larger guard, the extra
memory is carved out if the thread uses floating point.</p></li>
</ul>
</div>
</div>
<div class="section" id="user-mode-enabled">
<h3>User mode enabled<a class="headerlink" href="#user-mode-enabled" title="Permalink to this headline">¶</a></h3>
<p>Enabling user mode activates two new requirements:</p>
<ul class="simple">
<li><p>A separate fixed-sized privilege mode stack, specified by
<a class="reference internal" href="../../kconfig.html#CONFIG_PRIVILEGED_STACK_SIZE" title="CONFIG_PRIVILEGED_STACK_SIZE"><code class="xref kconfig kconfig-option docutils literal notranslate"><span class="pre">CONFIG_PRIVILEGED_STACK_SIZE</span></code></a>, must be allocated that the user
thread cannot access. It is used as the stack by the kernel when handling
system calls. If stack guards are implemented, a stack guard region must
be able to be placed before it, with support for carve-outs if necessary.</p></li>
<li><p>The memory protection hardware must be able to program a region that exactly
covers the thread’s stack buffer, tracked in <code class="docutils literal notranslate"><span class="pre">thread.stack_info</span></code>. This
implies that <code class="xref c c-macro docutils literal notranslate"><span class="pre">ARCH_THREAD_STACK_SIZE_ADJUST()</span></code> will need to round
up the requested stack size so that a region may cover it, and that
<code class="xref c c-macro docutils literal notranslate"><span class="pre">ARCH_THREAD_STACK_OBJ_ALIGN()</span></code> is also specified per the
granularity of the memory protection hardware.</p></li>
</ul>
<p>This becomes more complicated if the memory protection hardware requires that
all memory regions be sized to a power of two, and aligned to their own size.
This is common on older MPUs and is known with
<a class="reference internal" href="../../kconfig.html#CONFIG_MPU_REQUIRES_POWER_OF_TWO_ALIGNMENT" title="CONFIG_MPU_REQUIRES_POWER_OF_TWO_ALIGNMENT"><code class="xref kconfig kconfig-option docutils literal notranslate"><span class="pre">CONFIG_MPU_REQUIRES_POWER_OF_TWO_ALIGNMENT</span></code></a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">thread.stack_info</span></code> always tracks the user-accessible part of the stack
object, it must always be correct to program a memory protection region with
user access using the range stored within.</p>
<div class="section" id="non-power-of-two-memory-region-requirements">
<h4>Non power-of-two memory region requirements<a class="headerlink" href="#non-power-of-two-memory-region-requirements" title="Permalink to this headline">¶</a></h4>
<p>On systems without power-of-two region requirements, the reserved memory area
for threads stacks defined by <code class="xref c c-macro docutils literal notranslate"><span class="pre">K_THREAD_STACK_RESERVED</span></code> may be used to
contain the privilege mode stack. The layout could be something like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+------------------------------+</span> <span class="o">&lt;-</span> <span class="n">thread</span><span class="o">.</span><span class="n">stack_obj</span>
<span class="o">|</span> <span class="n">Other</span> <span class="n">platform</span> <span class="n">data</span>          <span class="o">|</span>
<span class="o">+------------------------------+</span>
<span class="o">|</span> <span class="n">Guard</span> <span class="n">region</span> <span class="p">(</span><span class="k">if</span> <span class="n">enabled</span><span class="p">)</span>    <span class="o">|</span>
<span class="o">+------------------------------+</span>
<span class="o">|</span> <span class="n">Guard</span> <span class="n">carve</span><span class="o">-</span><span class="n">out</span> <span class="p">(</span><span class="k">if</span> <span class="n">needed</span><span class="p">)</span>  <span class="o">|</span>
<span class="o">|..............................|</span>
<span class="o">|</span> <span class="n">Privilege</span> <span class="n">elevation</span> <span class="n">stack</span>    <span class="o">|</span>
<span class="o">+------------------------------|</span> <span class="o">&lt;-</span> <span class="n">thread</span><span class="o">.</span><span class="n">stack_obj</span> <span class="o">+</span>
<span class="o">|</span> <span class="n">Stack</span> <span class="n">buffer</span>                 <span class="o">|</span>      <span class="n">K_THREAD_STACK_RESERVED</span> <span class="o">=</span>
<span class="o">.</span>                              <span class="o">.</span>      <span class="n">thread</span><span class="o">.</span><span class="n">stack_info</span><span class="o">.</span><span class="n">start</span>
</pre></div>
</div>
<p>The guard region, and any carve-out (if needed) would be configured as a
read-only region when the thread is created.</p>
<ul class="simple">
<li><p>If the thread is a supervisor thread, the privilege elevation region is just
extra stack memory. An overflow will eventually crash into the guard region.</p></li>
<li><p>If the thread is running in user mode, a memory protection region will be
configured to allow user threads access to the stack buffer, but nothing
before or after it. An overflow in user mode will crash into the privilege
elevation stack, which the user thread has no access to. An overflow when
handling a system call will crash into the guard region.</p></li>
</ul>
<p>On an MMU system there should be no physical guards; the privilege mode stack
will be mapped into kernel memory, and the stack buffer in the user part of
memory, each with non-present virtual guard pages below them to catch runtime
stack overflows.</p>
<p>Other platform data may be stored before the guard region, but this is highly
discouraged if such data could be stored in <code class="docutils literal notranslate"><span class="pre">thread.arch</span></code> somewhere.</p>
<p><code class="xref c c-macro docutils literal notranslate"><span class="pre">ARCH_THREAD_STACK_RESERVED</span></code> will need to be defined to capture
the size of the reserved region containing platform data, privilege elevation
stacks, and guards. It must be appropriately sized such that an MPU region
to grant user mode access to the stack buffer can be placed immediately
after it.</p>
</div>
<div class="section" id="power-of-two-memory-region-requirements">
<h4>Power-of-two memory region requirements<a class="headerlink" href="#power-of-two-memory-region-requirements" title="Permalink to this headline">¶</a></h4>
<p>Thread stack objects must be sized and aligned to the same power of two,
without any reserved memory to allow efficient packing in memory. Thus,
any guards in the thread stack must be completely carved out, and the
privilege elevation stack must be allocated elsewhere.</p>
<p><code class="xref c c-macro docutils literal notranslate"><span class="pre">ARCH_THREAD_STACK_SIZE_ADJUST()</span></code> and
<code class="xref c c-macro docutils literal notranslate"><span class="pre">ARCH_THREAD_STACK_OBJ_ALIGN()</span></code> should both be defined to
<code class="xref c c-macro docutils literal notranslate"><span class="pre">Z_POW2_CEIL()</span></code>. <code class="xref c c-macro docutils literal notranslate"><span class="pre">K_THREAD_STACK_RESERVED</span></code> must be 0.</p>
<p>For the privilege stacks, the <a class="reference internal" href="../../kconfig.html#CONFIG_GEN_PRIV_STACKS" title="CONFIG_GEN_PRIV_STACKS"><code class="xref kconfig kconfig-option docutils literal notranslate"><span class="pre">CONFIG_GEN_PRIV_STACKS</span></code></a> must be,
enabled. For every thread stack found in the system, a corresponding fixed-
size kernel stack used for handling system calls is generated. The address
of the privilege stacks can be looked up quickly at runtime based on the
thread stack address using <code class="xref c c-func docutils literal notranslate"><span class="pre">z_priv_stack_find()</span></code>. These stacks are
laid out the same way as other kernel-only stacks.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+-----------------------------+</span> <span class="o">&lt;-</span> <span class="n">z_priv_stack_find</span><span class="p">(</span><span class="n">thread</span><span class="o">.</span><span class="n">stack_obj</span><span class="p">)</span>
<span class="o">|</span> <span class="n">Reserved</span> <span class="n">memory</span>             <span class="o">|</span> <span class="p">}</span> <span class="n">K_KERNEL_STACK_RESERVED</span>
<span class="o">+-----------------------------+</span>
<span class="o">|</span> <span class="n">Guard</span> <span class="n">carve</span><span class="o">-</span><span class="n">out</span> <span class="p">(</span><span class="k">if</span> <span class="n">needed</span><span class="p">)</span> <span class="o">|</span>
<span class="o">|.............................|</span>
<span class="o">|</span> <span class="n">Privilege</span> <span class="n">elevation</span> <span class="n">stack</span>   <span class="o">|</span>
<span class="o">|</span>                             <span class="o">|</span>
<span class="o">+-----------------------------+</span> <span class="o">&lt;-</span> <span class="n">z_priv_stack_find</span><span class="p">(</span><span class="n">thread</span><span class="o">.</span><span class="n">stack_obj</span><span class="p">)</span> <span class="o">+</span>
                                     <span class="n">K_KERNEL_STACK_RESERVED</span> <span class="o">+</span>
                                     <span class="n">CONFIG_PRIVILEGED_STACK_SIZE</span>

<span class="o">+-----------------------------+</span> <span class="o">&lt;-</span> <span class="n">thread</span><span class="o">.</span><span class="n">stack_obj</span>
<span class="o">|</span> <span class="n">MPU</span> <span class="n">guard</span> <span class="n">carve</span><span class="o">-</span><span class="n">out</span>         <span class="o">|</span>
<span class="o">|</span> <span class="p">(</span><span class="n">supervisor</span> <span class="n">mode</span> <span class="n">only</span><span class="p">)</span>      <span class="o">|</span>
<span class="o">|.............................|</span> <span class="o">&lt;-</span> <span class="n">thread</span><span class="o">.</span><span class="n">stack_info</span><span class="o">.</span><span class="n">start</span>
<span class="o">|</span> <span class="n">Stack</span> <span class="n">buffer</span>                <span class="o">|</span>
<span class="o">.</span>                             <span class="o">.</span>
</pre></div>
</div>
<p>The guard carve-out in the thread stack object is only used if the thread is
running in supervisor mode. If the thread drops to user mode, there is no guard
and the entire object is used as the stack buffer, with full access to the
associated user mode thread and <code class="docutils literal notranslate"><span class="pre">thread.stack_info</span></code> updated appropriately.</p>
</div>
</div>
</div>
<div class="section" id="user-mode-threads">
<h2>User Mode Threads<a class="headerlink" href="#user-mode-threads" title="Permalink to this headline">¶</a></h2>
<p>To support user mode threads, several kernel-to-arch APIs need to be
implemented, and the system must enable the <code class="xref kconfig kconfig-option docutils literal notranslate"><span class="pre">CONFIG_ARCH_HAS_USERSPACE</span></code>
option. Please see the documentation for each of these functions for more
details:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#c.arch_buffer_validate" title="arch_buffer_validate"><code class="xref c c-func docutils literal notranslate"><span class="pre">arch_buffer_validate()</span></code></a> to test whether the current thread has
access permissions to a particular memory region</p></li>
<li><p><a class="reference internal" href="#c.arch_user_mode_enter" title="arch_user_mode_enter"><code class="xref c c-func docutils literal notranslate"><span class="pre">arch_user_mode_enter()</span></code></a> which will irreversibly drop a supervisor
thread to user mode privileges. The stack must be wiped.</p></li>
<li><p><a class="reference internal" href="#c.arch_syscall_oops" title="arch_syscall_oops"><code class="xref c c-func docutils literal notranslate"><span class="pre">arch_syscall_oops()</span></code></a> which generates a kernel oops when system
call parameters can’t be validated, in such a way that the oops appears to be
generated from where the system call was invoked in the user thread</p></li>
<li><p><a class="reference internal" href="#c.arch_syscall_invoke0" title="arch_syscall_invoke0"><code class="xref c c-func docutils literal notranslate"><span class="pre">arch_syscall_invoke0()</span></code></a> through
<a class="reference internal" href="#c.arch_syscall_invoke6" title="arch_syscall_invoke6"><code class="xref c c-func docutils literal notranslate"><span class="pre">arch_syscall_invoke6()</span></code></a> invoke a system call with the
appropriate number of arguments which must all be passed in during the
privilege elevation via registers.</p></li>
<li><p><a class="reference internal" href="#c.arch_is_user_context" title="arch_is_user_context"><code class="xref c c-func docutils literal notranslate"><span class="pre">arch_is_user_context()</span></code></a> return nonzero if the CPU is currently
running in user mode</p></li>
<li><p><a class="reference internal" href="#c.arch_mem_domain_max_partitions_get" title="arch_mem_domain_max_partitions_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">arch_mem_domain_max_partitions_get()</span></code></a> which indicates the max
number of regions for a memory domain. MMU systems have an unlimited amount,
MPU systems have constraints on this.</p></li>
</ul>
<p>Some architectures may need to update software memory management structures
or modify hardware registers on another CPU when memory domain APIs are invoked.
If so, <a class="reference internal" href="../../kconfig.html#CONFIG_ARCH_MEM_DOMAIN_SYNCHRONOUS_API" title="CONFIG_ARCH_MEM_DOMAIN_SYNCHRONOUS_API"><code class="xref kconfig kconfig-option docutils literal notranslate"><span class="pre">CONFIG_ARCH_MEM_DOMAIN_SYNCHRONOUS_API</span></code></a> must be selected by the
architecture and some additional APIs must be implemented. This is common
on MMU systems and uncommon on MPU systems:</p>
<ul class="simple">
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">arch_mem_domain_thread_add()</span></code></p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">arch_mem_domain_thread_remove()</span></code></p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">arch_mem_domain_partition_add()</span></code></p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">arch_mem_domain_partition_remove()</span></code></p></li>
</ul>
<p>Please see the doxygen documentation of these APIs for details.</p>
<p>In addition to implementing these APIs, there are some other tasks as well:</p>
<ul class="simple">
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">_new_thread()</span></code> needs to spawn threads with <a class="reference internal" href="../../reference/kernel/threads/index.html#c.K_USER" title="K_USER"><code class="xref c c-macro docutils literal notranslate"><span class="pre">K_USER</span></code></a> in
user mode</p></li>
<li><p>On context switch, the outgoing thread’s stack memory should be marked
inaccessible to user mode by making the appropriate configuration changes in
the memory management hardware.. The incoming thread’s stack memory should
likewise be marked as accessible. This ensures that threads can’t mess with
other thread stacks.</p></li>
<li><p>On context switch, the system needs to switch between memory domains for
the incoming and outgoing threads.</p></li>
<li><p>Thread stack areas must include a kernel stack region. This should be
inaccessible to user threads at all times. This stack will be used when
system calls are made. This should be fixed size for all threads, and must
be large enough to handle any system call.</p></li>
<li><p>A software interrupt or some kind of privilege elevation mechanism needs to
be established. This is closely tied to how the _arch_syscall_invoke macros
are implemented. On system call, the appropriate handler function needs to
be looked up in _k_syscall_table. Bad system call IDs should jump to the
<code class="xref c c-enum docutils literal notranslate"><span class="pre">K_SYSCALL_BAD</span></code> handler. Upon completion of the system call, care
must be taken not to leak any register state back to user mode.</p></li>
</ul>
</div>
<div class="section" id="gdb-stub">
<h2>GDB Stub<a class="headerlink" href="#gdb-stub" title="Permalink to this headline">¶</a></h2>
<p>To enable GDB stub for remote debugging on a new architecture:</p>
<ol class="arabic simple">
<li><p>Create a new <code class="docutils literal notranslate"><span class="pre">gdbstub.h</span></code> header file under appropriate architecture
include directory (<code class="docutils literal notranslate"><span class="pre">include/arch/&lt;arch&gt;/gdbstub.h</span></code>).</p>
<ul class="simple">
<li><p>Create a new struct <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gdb_ctx</span></code> as the GDB context.</p>
<ul>
<li><p>Must define a member named <code class="docutils literal notranslate"><span class="pre">exception</span></code> of type <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code> to
store the GDB exception reason. This value needs to be set before
entering <code class="xref c c-func docutils literal notranslate"><span class="pre">z_gdb_main_loop()</span></code>.</p></li>
<li><p>Architecture can define as many members as needed for GDB stub to
function.</p></li>
<li><p>Pointer to this struct needs to be passed to <code class="xref c c-func docutils literal notranslate"><span class="pre">z_gdb_main_loop()</span></code>,
where this pointer will be passed to other GDB stub functions.</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Functions for entering and exiting GDB stub main loop.</p>
<ul class="simple">
<li><p>If the architecture relies on interrupts to service breakpoints,
interrupt service routines (ISR) need to be implemented, which
will serve as the entry point to GDB stub main loop.</p></li>
<li><p>These functions need to save and restore context so code execution
can continue as if no breakpoints have been encountered.</p></li>
<li><p>These functions need to call <code class="xref c c-func docutils literal notranslate"><span class="pre">z_gdb_main_loop()</span></code> after saving
execution context to go into the GDB stub main loop to receive commands
from GDB.</p></li>
<li><p>Before calling <code class="xref c c-func docutils literal notranslate"><span class="pre">z_gdb_main_loop()</span></code>, <code class="xref c c-member docutils literal notranslate"><span class="pre">gdb_ctx.exception</span></code>
must be set to specify the exception reason.</p></li>
</ul>
</li>
<li><p>Implementat necessary functions to support GDB stub functionality:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#c.arch_gdb_init" title="arch_gdb_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">arch_gdb_init()</span></code></a></p>
<ul>
<li><p>This needs to initialize necessary bits to support GDB stub functionality,
for example, setting up the GDB context and connecting debug interrupts.</p></li>
<li><p>This must stop code execution via architecture specific method (e.g.
raising debug interrupts). This allows GDB to connect during boot.</p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#c.arch_gdb_continue" title="arch_gdb_continue"><code class="xref c c-func docutils literal notranslate"><span class="pre">arch_gdb_continue()</span></code></a></p>
<ul>
<li><p>This function is called when GDB sends a <code class="docutils literal notranslate"><span class="pre">c</span></code> or <code class="docutils literal notranslate"><span class="pre">continue</span></code> command
to continue code execution.</p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#c.arch_gdb_step" title="arch_gdb_step"><code class="xref c c-func docutils literal notranslate"><span class="pre">arch_gdb_step()</span></code></a></p>
<ul>
<li><p>This function is called when GDB sends a <code class="docutils literal notranslate"><span class="pre">si</span></code> or <code class="docutils literal notranslate"><span class="pre">stepi</span></code> command
to execute one machine instruction, before returning to GDB prompt.</p></li>
</ul>
</li>
<li><p>Hardware register read/write functions:</p>
<ul>
<li><p>Since the GDB stub is running on the target, manipulation of hardware
registers need to cached to avoid affecting the execution of GDB stub.
Think of it as context switching, where the execution context is
changed to the GDB stub. So that the register values of the running
thread before context switch need to be stored. Manipulation of
register values must only be done to this cached copy. The updated
values will then be written to hardware registers before switching
back to the previous running thread.</p></li>
<li><p><a class="reference internal" href="#c.arch_gdb_reg_readall" title="arch_gdb_reg_readall"><code class="xref c c-func docutils literal notranslate"><span class="pre">arch_gdb_reg_readall()</span></code></a></p>
<ul>
<li><p>This collects all hardware register values that would appear in
a <code class="docutils literal notranslate"><span class="pre">g</span></code>/<code class="docutils literal notranslate"><span class="pre">G</span></code> packets which will be sent back to GDB. The format of
the G-packet is architecture specific. Consult GDB on what is
expected.</p></li>
<li><p>Note that, for most architectures, a valid G-packet must be returned
and sent to GDB. If a packet without incorrect length is sent to
GDB, GDB will abort the debugging session.</p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#c.arch_gdb_reg_writeall" title="arch_gdb_reg_writeall"><code class="xref c c-func docutils literal notranslate"><span class="pre">arch_gdb_reg_writeall()</span></code></a></p>
<ul>
<li><p>This takes a G-packet sent by GDB and populates the hardware
registers with values from the G-packet.</p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#c.arch_gdb_reg_readone" title="arch_gdb_reg_readone"><code class="xref c c-func docutils literal notranslate"><span class="pre">arch_gdb_reg_readone()</span></code></a></p>
<ul>
<li><p>This reads the value of one hardware register and sends
the result to GDB.</p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#c.arch_gdb_reg_writeone" title="arch_gdb_reg_writeone"><code class="xref c c-func docutils literal notranslate"><span class="pre">arch_gdb_reg_writeone()</span></code></a></p>
<ul>
<li><p>This writes the value of one hardware register received from GDB.</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Breakpoints:</p>
<ul>
<li><p><a class="reference internal" href="#c.arch_gdb_add_breakpoint" title="arch_gdb_add_breakpoint"><code class="xref c c-func docutils literal notranslate"><span class="pre">arch_gdb_add_breakpoint()</span></code></a> and
<a class="reference internal" href="#c.arch_gdb_remove_breakpoint" title="arch_gdb_remove_breakpoint"><code class="xref c c-func docutils literal notranslate"><span class="pre">arch_gdb_remove_breakpoint()</span></code></a></p></li>
<li><p>GDB may decide to use software breakpoints which modifies
the memory at the breakpoint locations to replace the instruction
with software breakpoint or trap instructions. GDB will then
restore the memory content once execution reaches the breakpoints.
GDB supports this by default and there is usually no need to
handle software breakpoints in the architecture code (where
breakpoint type is <code class="docutils literal notranslate"><span class="pre">0</span></code>).</p></li>
<li><p>Hardware breakpoints (type <code class="docutils literal notranslate"><span class="pre">1</span></code>) are required if the code is
in ROM or flash that cannot be modified at runtime. Consult
the architecture datasheet on how to enable hardware breakpoints.</p></li>
<li><p>If hardware breakpoints are not supported by the architecture,
there is no need to implement these in architecture code.
GDB will then rely on software breakpoints.</p></li>
</ul>
</li>
</ul>
</li>
<li><p>For architecture where certain memory regions are not accessible,
an array named <code class="xref c c-var docutils literal notranslate"><span class="pre">gdb_mem_region_array</span></code> of type
<code class="xref c c-struct docutils literal notranslate"><span class="pre">gdb_mem_region</span></code> needs to be defined to specify regions
that are accessible. For each array item:</p>
<ul class="simple">
<li><p><code class="xref c c-member docutils literal notranslate"><span class="pre">gdb_mem_region.start</span></code> specifies the start of a memory
region.</p></li>
<li><p><code class="xref c c-member docutils literal notranslate"><span class="pre">gdb_mem_region.end</span></code> specifies the end of a memory
region.</p></li>
<li><p><code class="xref c c-member docutils literal notranslate"><span class="pre">gdb_mem_region.attribites</span></code> specifies the permission
of a memory region.</p>
<ul>
<li><p><code class="xref c c-macro docutils literal notranslate"><span class="pre">GDB_MEM_REGION_RO</span></code>: region is read-only.</p></li>
<li><p><code class="xref c c-macro docutils literal notranslate"><span class="pre">GDB_MEM_REGION_RW</span></code>: region is read-write.</p></li>
</ul>
</li>
<li><p><code class="xref c c-member docutils literal notranslate"><span class="pre">gdb_mem_region.alignment</span></code> specifies read/write alignment
of a memory region. Use <code class="docutils literal notranslate"><span class="pre">0</span></code> if there is no alignment requirement
and read/write can be done byte-by-byte.</p></li>
</ul>
</li>
</ol>
</div>
<div class="section" id="api-reference">
<h2>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h2>
<div class="section" id="timing">
<h3>Timing<a class="headerlink" href="#timing" title="Permalink to this headline">¶</a></h3>
<dl>
<dt class="sig sig-object cpp">
<span class="target" id="group__arch-timing"></span><em><span class="pre">group</span></em> <span class="sig-name descname"><span class="pre">arch-timing</span></span></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-unnamed-group">Unnamed Group</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.arch_timing_init">
<span class="target" id="group__arch-timing_1ga5d9923569b40437c28879ff4b3ff77c2"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_timing_init</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_timing_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize the timing subsystem. </p>
<p>Perform the necessary steps to initialize the timing subsystem.</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../../reference/timing_functions/index.html#group__timing__api_1ga50ff9040b99d95c56f494014831e4b47"><span class="std std-ref">timing_init()</span></a> </p>
</div>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_timing_start">
<span class="target" id="group__arch-timing_1gaf8cd88e81c2104b5eb0fbe42967b7834"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_timing_start</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_timing_start" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Signal the start of the timing information gathering. </p>
<p>Signal to the timing subsystem that timing information will be gathered from this point forward.</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../../reference/timing_functions/index.html#group__timing__api_1ga3c28bb4ced0467c284d33c800e070bde"><span class="std std-ref">timing_start()</span></a> </p>
</div>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_timing_stop">
<span class="target" id="group__arch-timing_1ga566483c64f5c5d2f0465e3f969303fd3"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_timing_stop</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_timing_stop" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Signal the end of the timing information gathering. </p>
<p>Signal to the timing subsystem that timing information is no longer being gathered from this point forward.</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../../reference/timing_functions/index.html#group__timing__api_1gade1584bf683c9c61905513efa4d99cf2"><span class="std std-ref">timing_stop()</span></a> </p>
</div>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_timing_counter_get">
<span class="target" id="group__arch-timing_1gad7a709477650c8596a96fe080f583fdd"></span><span class="n"><span class="pre">timing_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_timing_counter_get</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_timing_counter_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return timing counter. </p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../../reference/timing_functions/index.html#group__timing__api_1gaa5736c87362de09749af1d8ff30b8208"><span class="std std-ref">timing_counter_get()</span></a> </p>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Timing counter.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_timing_cycles_get">
<span class="target" id="group__arch-timing_1ga44d3a7bd8b7008c9cd6c0524e97f128c"></span><span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_timing_cycles_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">volatile</span></span><span class="w"> </span><span class="n"><span class="pre">timing_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="k"><span class="pre">volatile</span></span><span class="w"> </span><span class="n"><span class="pre">timing_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">end</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_timing_cycles_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get number of cycles between <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">end</span></code>. </p>
<p>For some architectures or SoCs, the raw numbers from counter need to be scaled to obtain actual number of cycles.</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../../reference/timing_functions/index.html#group__timing__api_1gaa12074c7645b19578e7ca573c6aa2955"><span class="std std-ref">timing_cycles_get()</span></a> </p>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start</strong> – Pointer to counter at start of a measured execution. </p></li>
<li><p><strong>end</strong> – Pointer to counter at stop of a measured execution. </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Number of cycles between start and end.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_timing_freq_get">
<span class="target" id="group__arch-timing_1ga026409e1dc323ceddb82b2a6f1cc7ca2"></span><span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_timing_freq_get</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_timing_freq_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get frequency of counter used (in Hz). </p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../../reference/timing_functions/index.html#group__timing__api_1gab72ed08d19630cb4cbea4977f2e6723b"><span class="std std-ref">timing_freq_get()</span></a> </p>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Frequency of counter used for timing in Hz.</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_timing_cycles_to_ns">
<span class="target" id="group__arch-timing_1ga8424bc96c05dcae34b7ffd445e2916fe"></span><span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_timing_cycles_to_ns</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="n"><span class="pre">cycles</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_timing_cycles_to_ns" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Convert number of <code class="docutils literal notranslate"><span class="pre">cycles</span></code> into nanoseconds. </p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../../reference/timing_functions/index.html#group__timing__api_1ga14a85981068350f33c63c93c4b71afe2"><span class="std std-ref">timing_cycles_to_ns()</span></a> </p>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cycles</strong> – Number of cycles </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Converted time value</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_timing_cycles_to_ns_avg">
<span class="target" id="group__arch-timing_1ga925b4caff80f1dbac36531b479b24364"></span><span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_timing_cycles_to_ns_avg</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="n"><span class="pre">cycles</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_timing_cycles_to_ns_avg" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Convert number of <code class="docutils literal notranslate"><span class="pre">cycles</span></code> into nanoseconds with averaging. </p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../../reference/timing_functions/index.html#group__timing__api_1ga28b0252f3395b6e6b549cb03ea4dbef4"><span class="std std-ref">timing_cycles_to_ns_avg()</span></a> </p>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cycles</strong> – Number of cycles </p></li>
<li><p><strong>count</strong> – Times of accumulated cycles to average over </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Converted time value</p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_timing_freq_get_mhz">
<span class="target" id="group__arch-timing_1ga1f7bfb9ce0588f3b423c2a63933d40eb"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_timing_freq_get_mhz</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_timing_freq_get_mhz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get frequency of counter used (in MHz). </p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../../reference/timing_functions/index.html#group__timing__api_1ga65370ad32eadf61c84b90dc04ecd1d56"><span class="std std-ref">timing_freq_get_mhz()</span></a> </p>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Frequency of counter used for timing in MHz.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.arch_k_cycle_get_32">
<span class="target" id="group__arch-timing_1ga9ee9f897ec750957de45bf8d43349d5e"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_k_cycle_get_32</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_k_cycle_get_32" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Obtain the current cycle count, in units that are hardware-specific</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../../reference/kernel/timing/clocks.html#group__clock__apis_1ga208687de625e0036558343b4e66143d3"><span class="std std-ref">k_cycle_get_32()</span></a> </p>
</div>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_k_cycle_get_64">
<span class="target" id="group__arch-timing_1gacc1ed8d949f694a1d39e389334caf971"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_k_cycle_get_64</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_k_cycle_get_64" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Obtain the current cycle count, in units that are hardware-specific</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../../reference/kernel/timing/clocks.html#group__clock__apis_1gae09f509d02bf75a7b45d2800d823bb3a"><span class="std std-ref">k_cycle_get_64()</span></a> </p>
</div>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_busy_wait">
<span class="target" id="group__arch-timing_1gaffc9f3013d53e72c25243ce4f972549f"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_busy_wait</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">usec_to_wait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_busy_wait" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Architecture-specific implementation of busy-waiting</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>usec_to_wait</strong> – Wait period, in microseconds </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="threads">
<h3>Threads<a class="headerlink" href="#threads" title="Permalink to this headline">¶</a></h3>
<dl>
<dt class="sig sig-object cpp">
<span class="target" id="group__arch-threads"></span><em><span class="pre">group</span></em> <span class="sig-name descname"><span class="pre">arch-threads</span></span></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.arch_new_thread">
<span class="target" id="group__arch-threads_1gade449838e445fa8201266e38215c616c"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_new_thread</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../../reference/kernel/threads/index.html#c.k_thread" title="k_thread"><span class="n"><span class="pre">k_thread</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">thread</span></span>, <span class="n"><span class="pre">k_thread_stack_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">stack</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">stack_ptr</span></span>, <span class="n"><span class="pre">k_thread_entry_t</span></span><span class="w"> </span><span class="n"><span class="pre">entry</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p1</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p2</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p3</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_new_thread" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Handle arch-specific logic for setting up new threads</p>
<p>The stack and arch-specific thread state variables must be set up such that a later attempt to switch to this thread will succeed and we will enter z_thread_entry with the requested thread and arguments as its parameters.</p>
<p>At some point in this function’s implementation, z_setup_new_thread() must be called with the true bounds of the available stack buffer within the thread’s stack object.</p>
<p>The provided stack pointer is guaranteed to be properly aligned with respect to the CPU and ABI requirements. There may be space reserved between the stack pointer and the bounds of the stack buffer for initial stack pointer randomization and thread-local storage.</p>
<p>Fields in thread-&gt;base will be initialized when this is called.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>thread</strong> – Pointer to uninitialized struct <a class="reference internal" href="../../reference/kernel/threads/index.html#structk__thread"><span class="std std-ref">k_thread</span></a> </p></li>
<li><p><strong>stack</strong> – Pointer to the stack object </p></li>
<li><p><strong>stack_ptr</strong> – Aligned initial stack pointer </p></li>
<li><p><strong>entry</strong> – Thread entry function </p></li>
<li><p><strong>p1</strong> – 1st entry point parameter </p></li>
<li><p><strong>p2</strong> – 2nd entry point parameter </p></li>
<li><p><strong>p3</strong> – 3rd entry point parameter </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_switch">
<span class="target" id="group__arch-threads_1gab411d82ce5b60f062171f5a19e33e025"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_switch</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">switch_to</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">switched_from</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_switch" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Cooperative context switch primitive</p>
<p>The action of <a class="reference internal" href="#group__arch-threads_1gab411d82ce5b60f062171f5a19e33e025"><span class="std std-ref">arch_switch()</span></a> should be to switch to a new context passed in the first argument, and save a pointer to the current context into the address passed in the second argument.</p>
<p>The actual type and interpretation of the switch handle is specified by the architecture. It is the same data structure stored in the “switch_handle” field of a newly-created thread in <a class="reference internal" href="#group__arch-threads_1gade449838e445fa8201266e38215c616c"><span class="std std-ref">arch_new_thread()</span></a>, and passed to the kernel as the “interrupted” argument to z_get_next_switch_handle().</p>
<p>Note that on SMP systems, the kernel uses the store through the second pointer as a synchronization point to detect when a thread context is completely saved (so another CPU can know when it is safe to switch). This store must be done AFTER all relevant state is saved, and must include whatever memory barriers or cache management code is required to be sure another CPU will see the result correctly.</p>
<p>The simplest implementation of <a class="reference internal" href="#group__arch-threads_1gab411d82ce5b60f062171f5a19e33e025"><span class="std std-ref">arch_switch()</span></a> is generally to push state onto the thread stack and use the resulting stack pointer as the switch handle. Some architectures may instead decide to use a pointer into the thread struct as the “switch handle” type. These can legally assume that the second argument to <a class="reference internal" href="#group__arch-threads_1gab411d82ce5b60f062171f5a19e33e025"><span class="std std-ref">arch_switch()</span></a> is the address of the switch_handle field of struct thread_base and can use an offset on this value to find other parts of the thread struct. For example a (C pseudocode) implementation of <a class="reference internal" href="#group__arch-threads_1gab411d82ce5b60f062171f5a19e33e025"><span class="std std-ref">arch_switch()</span></a> might look like:</p>
<p>void <a class="reference internal" href="#group__arch-threads_1gab411d82ce5b60f062171f5a19e33e025"><span class="std std-ref">arch_switch(void *switch_to, void **switched_from)</span></a> { struct <a class="reference internal" href="../../reference/kernel/threads/index.html#structk__thread"><span class="std std-ref">k_thread</span></a> *new = switch_to; struct <a class="reference internal" href="../../reference/kernel/threads/index.html#structk__thread"><span class="std std-ref">k_thread</span></a> *old = CONTAINER_OF(switched_from, struct <a class="reference internal" href="../../reference/kernel/threads/index.html#structk__thread"><span class="std std-ref">k_thread</span></a>, switch_handle);</p>
<p>// save old context… *switched_from = old; // restore new context… }</p>
<p>Note that the kernel manages the switch_handle field for synchronization as described above. So it is not legal for architecture code to assume that it has any particular value at any other time. In particular it is not legal to read the field from the address passed in the second argument.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>switch_to</strong> – Incoming thread’s switch handle </p></li>
<li><p><strong>switched_from</strong> – Pointer to outgoing thread’s switch handle storage location, which must be updated. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_switch_to_main_thread">
<span class="target" id="group__arch-threads_1ga3ddd51635018a2e0235d5599401f5269"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_switch_to_main_thread</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../../reference/kernel/threads/index.html#c.k_thread" title="k_thread"><span class="n"><span class="pre">k_thread</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">main_thread</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">stack_ptr</span></span>, <span class="n"><span class="pre">k_thread_entry_t</span></span><span class="w"> </span><span class="n"><span class="pre">_main</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_switch_to_main_thread" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Custom logic for entering main thread context at early boot</p>
<p>Used by architectures where the typical trick of setting up a dummy thread in early boot context to “switch out” of isn’t workable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>main_thread</strong> – main thread object </p></li>
<li><p><strong>stack_ptr</strong> – Initial stack pointer </p></li>
<li><p><strong>_main</strong> – Entry point for application main function. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_float_disable">
<span class="target" id="group__arch-threads_1ga7c2f0ee0bee6f9de0bd23a0aa321a46d"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_float_disable</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../../reference/kernel/threads/index.html#c.k_thread" title="k_thread"><span class="n"><span class="pre">k_thread</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">thread</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_float_disable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Disable floating point context preservation. </p>
<p>The function is used to disable the preservation of floating point context information for a particular thread.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For ARM architecture, disabling floating point preservation may only be requested for the current thread and cannot be requested in ISRs.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Return values</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>0</strong> – On success. </p></li>
<li><p><strong>-EINVAL</strong> – If the floating point disabling could not be performed. </p></li>
<li><p><strong>-ENOTSUP</strong> – If the operation is not supported </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_float_enable">
<span class="target" id="group__arch-threads_1gacd40e26783f3dbd8a658fc1af512fb18"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_float_enable</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../../reference/kernel/threads/index.html#c.k_thread" title="k_thread"><span class="n"><span class="pre">k_thread</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">thread</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">options</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_float_enable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Enable floating point context preservation. </p>
<p>The function is used to enable the preservation of floating point context information for a particular thread. This API depends on each architecture implimentation. If the architecture does not support enabling, this API will always be failed.</p>
<p>The <em>options</em> parameter indicates which floating point register sets will be used by the specified thread. Currently it is used by x86 only.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>thread</strong> – ID of thread. </p></li>
<li><p><strong>options</strong> – architecture dependent options</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>0</strong> – On success. </p></li>
<li><p><strong>-EINVAL</strong> – If the floating point enabling could not be performed. </p></li>
<li><p><strong>-ENOTSUP</strong> – If the operation is not supported </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
</dd></dl>

<dl>
<dt class="sig sig-object cpp">
<span class="target" id="group__arch-tls"></span><em><span class="pre">group</span></em> <span class="sig-name descname"><span class="pre">arch-tls</span></span></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.arch_tls_stack_setup">
<span class="target" id="group__arch-tls_1ga7f159caca46063b04cf03a54b39255fc"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_tls_stack_setup</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../../reference/kernel/threads/index.html#c.k_thread" title="k_thread"><span class="n"><span class="pre">k_thread</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new_thread</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">stack_ptr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_tls_stack_setup" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Setup Architecture-specific TLS area in stack. </p>
<p>This sets up the stack area for thread local storage. The structure inside in area is architecture specific.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>new_thread</strong> – New thread object </p></li>
<li><p><strong>stack_ptr</strong> – Stack pointer </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Number of bytes taken by the TLS area </p>
</dd>
</dl>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="power-management">
<h3>Power Management<a class="headerlink" href="#power-management" title="Permalink to this headline">¶</a></h3>
<dl>
<dt class="sig sig-object cpp">
<span class="target" id="group__arch-pm"></span><em><span class="pre">group</span></em> <span class="sig-name descname"><span class="pre">arch-pm</span></span></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.arch_cpu_idle">
<span class="target" id="group__arch-pm_1ga6ce051203e6cc091d0fb42a15f662a48"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_cpu_idle</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_cpu_idle" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Power save idle routine. </p>
<p>This function will be called by the kernel idle loop or possibly within an implementation of z_pm_save_idle in the kernel when the ‘_pm_save_flag’ variable is non-zero.</p>
<p>Architectures that do not implement power management instructions may immediately return, otherwise a power-saving instruction should be issued to wait for an interrupt.</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../../reference/kernel/other/cpu_idle.html#group__cpu__idle__apis_1ga7b25e1bed511a813b32fbd0f91b09356"><span class="std std-ref">k_cpu_idle()</span></a> </p>
</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The function is expected to return after the interrupt that has caused the CPU to exit power-saving mode has been serviced, although this is not a firm requirement.</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_cpu_atomic_idle">
<span class="target" id="group__arch-pm_1ga4d0297717c23a3cc5df434549e26924d"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_cpu_atomic_idle</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">key</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_cpu_atomic_idle" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Atomically re-enable interrupts and enter low power mode. </p>
<p>The requirements for <a class="reference internal" href="#group__arch-pm_1ga4d0297717c23a3cc5df434549e26924d"><span class="std std-ref">arch_cpu_atomic_idle()</span></a> are as follows:</p>
<p><ol class="loweralpha simple">
<li><p>Enabling interrupts and entering a low-power mode needs to be atomic, i.e. there should be no period of time where interrupts are enabled before the processor enters a low-power mode. See the comments in <a class="reference internal" href="../../reference/kernel/data_passing/lifos.html#group__lifo__apis_1gad5f1775947b07a2a77f667aa9e41db5a"><span class="std std-ref">k_lifo_get()</span></a>, for example, of the race condition that occurs if this requirement is not met.</p></li>
<li><p>After waking up from the low-power mode, the interrupt lockout state must be restored as indicated in the ‘key’ input parameter.</p></li>
</ol>
</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../../reference/kernel/other/cpu_idle.html#group__cpu__idle__apis_1gadf88ece6447b65b7d0d2f3a70ab4fe8f"><span class="std std-ref">k_cpu_atomic_idle()</span></a></p>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>key</strong> – Lockout key returned by previous invocation of <a class="reference internal" href="#group__arch-irq_1ga25bca3069cb999b6d4f924b87bf7de38"><span class="std std-ref">arch_irq_lock()</span></a> </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_system_halt">
<span class="target" id="group__arch-pm_1gada83bf3beb5004a39a1f9c8c7ce35348"></span><span class="pre">FUNC_NORETURN</span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_system_halt</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">reason</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_system_halt" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Halt the system, optionally propagating a reason code </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="symmetric-multi-processing">
<h3>Symmetric Multi-Processing<a class="headerlink" href="#symmetric-multi-processing" title="Permalink to this headline">¶</a></h3>
<dl>
<dt class="sig sig-object cpp">
<span class="target" id="group__arch-smp"></span><em><span class="pre">group</span></em> <span class="sig-name descname"><span class="pre">arch-smp</span></span></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-typedefs">Typedefs</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.arch_cpustart_t">
<span class="target" id="group__arch-smp_1gacf11540c44fdc8e74b060007b7e5a456"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="pre">FUNC_NORETURN</span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">arch_cpustart_t</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">)</span></span><a class="headerlink" href="#c.arch_cpustart_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Per-cpu entry function</p>
<dl class="field-list simple">
<dt class="field-odd">Param data</dt>
<dd class="field-odd"><p>context parameter, implementation specific </p>
</dd>
</dl>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.arch_start_cpu">
<span class="target" id="group__arch-smp_1gad25e65419116c6bb3e6d6362e780fb83"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_start_cpu</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cpu_num</span></span>, <span class="n"><span class="pre">k_thread_stack_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">stack</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sz</span></span>, <a class="reference internal" href="#c.arch_cpustart_t" title="arch_cpustart_t"><span class="n"><span class="pre">arch_cpustart_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">fn</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">arg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_start_cpu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Start a numbered CPU on a MP-capable system. </p>
<p>This starts and initializes a specific CPU. The main thread on startup is running on CPU zero, other processors are numbered sequentially. On return from this function, the CPU is known to have begun operating and will enter the provided function. Its interrupts will be initialized but disabled such that <a class="reference internal" href="../../reference/kernel/other/interrupts.html#group__isr__apis_1ga646045943b3b2a130738bcc48867bf57"><span class="std std-ref">irq_unlock()</span></a> with the provided key will work to enable them.</p>
<p>Normally, in SMP mode this function will be called by the kernel initialization and should not be used as a user API. But it is defined here for special-purpose apps which want Zephyr running on one core and to use others for design-specific processing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cpu_num</strong> – Integer number of the CPU </p></li>
<li><p><strong>stack</strong> – Stack memory for the CPU </p></li>
<li><p><strong>sz</strong> – Stack buffer size, in bytes </p></li>
<li><p><strong>fn</strong> – Function to begin running on the CPU. </p></li>
<li><p><strong>arg</strong> – Untyped argument to be passed to “fn” </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_cpu_active">
<span class="target" id="group__arch-smp_1ga5a7f0198ee061551c300129bffe64717"></span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_cpu_active</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cpu_num</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_cpu_active" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return CPU power status. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cpu_num</strong> – Integer number of the CPU </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_curr_cpu">
<span class="target" id="group__arch-smp_1gad42138d41dff6a4aad8abf7d77fcd8b2"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">_cpu</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">arch_curr_cpu</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_curr_cpu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the CPU struct for the currently executing CPU </p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_sched_ipi">
<span class="target" id="group__arch-smp_1gadd3d6c84e3c57babc859314718e0f231"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_sched_ipi</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_sched_ipi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Broadcast an interrupt to all CPUs</p>
<p>This will invoke z_sched_ipi() on other CPUs in the system. </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="interrupts">
<h3>Interrupts<a class="headerlink" href="#interrupts" title="Permalink to this headline">¶</a></h3>
<dl>
<dt class="sig sig-object cpp">
<span class="target" id="group__arch-irq"></span><em><span class="pre">group</span></em> <span class="sig-name descname"><span class="pre">arch-irq</span></span></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.arch_irq_lock">
<span class="target" id="group__arch-irq_1ga25bca3069cb999b6d4f924b87bf7de38"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_irq_lock</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_irq_lock" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Lock interrupts on the current CPU</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../../reference/kernel/other/interrupts.html#group__isr__apis_1ga19fdde73c3b02fcca6cf1d1e67631228"><span class="std std-ref">irq_lock()</span></a> </p>
</div>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_irq_unlock">
<span class="target" id="group__arch-irq_1gaa2b2745d8e99b8730b44805f4d3bbf05"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_irq_unlock</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">key</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_irq_unlock" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unlock interrupts on the current CPU</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../../reference/kernel/other/interrupts.html#group__isr__apis_1ga646045943b3b2a130738bcc48867bf57"><span class="std std-ref">irq_unlock()</span></a> </p>
</div>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_irq_unlocked">
<span class="target" id="group__arch-irq_1ga1b827afafc622d412962f568b78726dc"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_irq_unlocked</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">key</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_irq_unlocked" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test if calling <a class="reference internal" href="#group__arch-irq_1gaa2b2745d8e99b8730b44805f4d3bbf05"><span class="std std-ref">arch_irq_unlock()</span></a> with this key would unlock irqs</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>key</strong> – value returned by <a class="reference internal" href="#group__arch-irq_1ga25bca3069cb999b6d4f924b87bf7de38"><span class="std std-ref">arch_irq_lock()</span></a> </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>true if interrupts were unlocked prior to the <a class="reference internal" href="#group__arch-irq_1ga25bca3069cb999b6d4f924b87bf7de38"><span class="std std-ref">arch_irq_lock()</span></a> call that produced the key argument. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_irq_disable">
<span class="target" id="group__arch-irq_1ga216d692e87bfba955a60f8e570e127df"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_irq_disable</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">irq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_irq_disable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Disable the specified interrupt line</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../../reference/kernel/other/interrupts.html#group__isr__apis_1ga82c3a15d812f58e0f6525f358d031e6d"><span class="std std-ref">irq_disable()</span></a> </p>
</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>: The behavior of interrupts that arrive after this call returns and before the corresponding call to <a class="reference internal" href="#group__arch-irq_1gaa278d630653b33cb339621d725ed295a"><span class="std std-ref">arch_irq_enable()</span></a> is undefined. The hardware is not required to latch and deliver such an interrupt, though on some architectures that may work. Other architectures will simply lose such an interrupt and never deliver it. Many drivers and subsystems are not tolerant of such dropped interrupts and it is the job of the application layer to ensure that behavior remains correct.</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_irq_enable">
<span class="target" id="group__arch-irq_1gaa278d630653b33cb339621d725ed295a"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_irq_enable</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">irq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_irq_enable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Enable the specified interrupt line</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../../reference/kernel/other/interrupts.html#group__isr__apis_1ga7ea700ee31e4ff036c997a554dbedfeb"><span class="std std-ref">irq_enable()</span></a> </p>
</div>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_irq_is_enabled">
<span class="target" id="group__arch-irq_1ga3bd8e963a124421bb372dab4bdc6cd83"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_irq_is_enabled</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">irq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_irq_is_enabled" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test if an interrupt line is enabled</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../../reference/kernel/other/interrupts.html#group__isr__apis_1ga71fef3867ba9818cf0a5baf8410a6354"><span class="std std-ref">irq_is_enabled()</span></a> </p>
</div>
</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_irq_connect_dynamic">
<span class="target" id="group__arch-irq_1gaa4d733913e12a12e104dc4781cca7308"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_irq_connect_dynamic</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">irq</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">priority</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">routine</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parameter</span></span><span class="p"><span class="pre">)</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parameter</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_irq_connect_dynamic" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Arch-specific hook to install a dynamic interrupt.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>irq</strong> – IRQ line number </p></li>
<li><p><strong>priority</strong> – Interrupt priority </p></li>
<li><p><strong>routine</strong> – Interrupt service routine </p></li>
<li><p><strong>parameter</strong> – ISR parameter </p></li>
<li><p><strong>flags</strong> – Arch-specific IRQ configuration flag</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The vector assigned to this interrupt </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_irq_allocate">
<span class="target" id="group__arch-irq_1gaac8f60e7dfc5ce3222372798e96316ae"></span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_irq_allocate</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_irq_allocate" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Arch-specific hook for allocating IRQs. </p>
<p>Note: disable/enable IRQ relevantly inside the implementation of such function to avoid concurrency issues. Also, an allocated IRQ is assumed to be used thus a following <div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#group__arch-irq_1ga5c85d7bf54a83190ed27587dc5a01de5"><span class="std std-ref">arch_irq_is_used()</span></a> should return true.</p>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The newly allocated IRQ or UINT_MAX on error. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_irq_set_used">
<span class="target" id="group__arch-irq_1ga5f0942bd035c50c9d2d91ada472f37c4"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_irq_set_used</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">irq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_irq_set_used" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Arch-specific hook for declaring an IRQ being used. </p>
<p>Note: disable/enable IRQ relevantly inside the implementation of such function to avoid concurrency issues.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>irq</strong> – the IRQ to declare being used </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_irq_is_used">
<span class="target" id="group__arch-irq_1ga5c85d7bf54a83190ed27587dc5a01de5"></span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_irq_is_used</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">irq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_irq_is_used" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Arch-specific hook for checking if an IRQ is being used already. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>irq</strong> – the IRQ to check</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>true if being, false otherwise </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_is_in_isr">
<span class="target" id="group__arch-irq_1ga1dda03646da3989f08a3bad1b258c691"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_is_in_isr</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_is_in_isr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test if the current context is in interrupt context</p>
<p>XXX: This is inconsistently handled among arches wrt exception context See: #17656</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>true if we are in interrupt context </p>
</dd>
</dl>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="userspace">
<h3>Userspace<a class="headerlink" href="#userspace" title="Permalink to this headline">¶</a></h3>
<dl>
<dt class="sig sig-object cpp">
<span class="target" id="group__arch-userspace"></span><em><span class="pre">group</span></em> <span class="sig-name descname"><span class="pre">arch-userspace</span></span></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.arch_syscall_invoke0">
<span class="target" id="group__arch-userspace_1ga5e9ab24b9c980e327903fbe3f5bd97f3"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_syscall_invoke0</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">call_id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_syscall_invoke0" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Invoke a system call with 0 arguments.</p>
<p>No general-purpose register state other than return value may be preserved when transitioning from supervisor mode back down to user mode for security reasons.</p>
<p>It is required that all arguments be stored in registers when elevating privileges from user to supervisor mode.</p>
<p>Processing of the syscall takes place on a separate kernel stack. Interrupts should be enabled when invoking the system call marshallers from the dispatch table. Thread preemption may occur when handling system calls.</p>
<p>Call ids are untrusted and must be bounds-checked, as the value is used to index the system call dispatch table, containing function pointers to the specific system call code.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>call_id</strong> – System call ID </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Return value of the system call. Void system calls return 0 here. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_syscall_invoke1">
<span class="target" id="group__arch-userspace_1ga4cfb3b2b38e5afca889e8b9765d6c3df"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_syscall_invoke1</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">arg1</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">call_id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_syscall_invoke1" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Invoke a system call with 1 argument.</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#group__arch-userspace_1ga5e9ab24b9c980e327903fbe3f5bd97f3"><span class="std std-ref">arch_syscall_invoke0()</span></a></p>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arg1</strong> – First argument to the system call. </p></li>
<li><p><strong>call_id</strong> – System call ID, will be bounds-checked and used to reference kernel-side dispatch table </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Return value of the system call. Void system calls return 0 here. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_syscall_invoke2">
<span class="target" id="group__arch-userspace_1ga1e78f1022aaf10e88727b142b56d4ef0"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_syscall_invoke2</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">arg1</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">arg2</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">call_id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_syscall_invoke2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Invoke a system call with 2 arguments.</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#group__arch-userspace_1ga5e9ab24b9c980e327903fbe3f5bd97f3"><span class="std std-ref">arch_syscall_invoke0()</span></a></p>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arg1</strong> – First argument to the system call. </p></li>
<li><p><strong>arg2</strong> – Second argument to the system call. </p></li>
<li><p><strong>call_id</strong> – System call ID, will be bounds-checked and used to reference kernel-side dispatch table </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Return value of the system call. Void system calls return 0 here. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_syscall_invoke3">
<span class="target" id="group__arch-userspace_1gaacb1c66a1b7bf2293fea269f6b5e1c7e"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_syscall_invoke3</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">arg1</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">arg2</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">arg3</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">call_id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_syscall_invoke3" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Invoke a system call with 3 arguments.</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#group__arch-userspace_1ga5e9ab24b9c980e327903fbe3f5bd97f3"><span class="std std-ref">arch_syscall_invoke0()</span></a></p>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arg1</strong> – First argument to the system call. </p></li>
<li><p><strong>arg2</strong> – Second argument to the system call. </p></li>
<li><p><strong>arg3</strong> – Third argument to the system call. </p></li>
<li><p><strong>call_id</strong> – System call ID, will be bounds-checked and used to reference kernel-side dispatch table </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Return value of the system call. Void system calls return 0 here. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_syscall_invoke4">
<span class="target" id="group__arch-userspace_1ga0ba3ae2290827385b226ebdbf3de3b53"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_syscall_invoke4</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">arg1</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">arg2</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">arg3</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">arg4</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">call_id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_syscall_invoke4" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Invoke a system call with 4 arguments.</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#group__arch-userspace_1ga5e9ab24b9c980e327903fbe3f5bd97f3"><span class="std std-ref">arch_syscall_invoke0()</span></a></p>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arg1</strong> – First argument to the system call. </p></li>
<li><p><strong>arg2</strong> – Second argument to the system call. </p></li>
<li><p><strong>arg3</strong> – Third argument to the system call. </p></li>
<li><p><strong>arg4</strong> – Fourth argument to the system call. </p></li>
<li><p><strong>call_id</strong> – System call ID, will be bounds-checked and used to reference kernel-side dispatch table </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Return value of the system call. Void system calls return 0 here. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_syscall_invoke5">
<span class="target" id="group__arch-userspace_1ga9971c78bc8f579a0dadf84225dc0c3ff"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_syscall_invoke5</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">arg1</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">arg2</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">arg3</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">arg4</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">arg5</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">call_id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_syscall_invoke5" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Invoke a system call with 5 arguments.</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#group__arch-userspace_1ga5e9ab24b9c980e327903fbe3f5bd97f3"><span class="std std-ref">arch_syscall_invoke0()</span></a></p>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arg1</strong> – First argument to the system call. </p></li>
<li><p><strong>arg2</strong> – Second argument to the system call. </p></li>
<li><p><strong>arg3</strong> – Third argument to the system call. </p></li>
<li><p><strong>arg4</strong> – Fourth argument to the system call. </p></li>
<li><p><strong>arg5</strong> – Fifth argument to the system call. </p></li>
<li><p><strong>call_id</strong> – System call ID, will be bounds-checked and used to reference kernel-side dispatch table </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Return value of the system call. Void system calls return 0 here. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_syscall_invoke6">
<span class="target" id="group__arch-userspace_1gac6cae2197637993a86b6ec6803b5742b"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_syscall_invoke6</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">arg1</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">arg2</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">arg3</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">arg4</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">arg5</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">arg6</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">call_id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_syscall_invoke6" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Invoke a system call with 6 arguments.</p>
<p><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#group__arch-userspace_1ga5e9ab24b9c980e327903fbe3f5bd97f3"><span class="std std-ref">arch_syscall_invoke0()</span></a></p>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arg1</strong> – First argument to the system call. </p></li>
<li><p><strong>arg2</strong> – Second argument to the system call. </p></li>
<li><p><strong>arg3</strong> – Third argument to the system call. </p></li>
<li><p><strong>arg4</strong> – Fourth argument to the system call. </p></li>
<li><p><strong>arg5</strong> – Fifth argument to the system call. </p></li>
<li><p><strong>arg6</strong> – Sixth argument to the system call. </p></li>
<li><p><strong>call_id</strong> – System call ID, will be bounds-checked and used to reference kernel-side dispatch table </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Return value of the system call. Void system calls return 0 here. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_is_user_context">
<span class="target" id="group__arch-userspace_1ga89ab53a218add419e37f89c1f5fd955f"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_is_user_context</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_is_user_context" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Indicate whether we are currently running in user mode</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>true if the CPU is currently running with user permissions </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_mem_domain_max_partitions_get">
<span class="target" id="group__arch-userspace_1ga71542fcc679a94ad9ea60d7ac46da361"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_mem_domain_max_partitions_get</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_mem_domain_max_partitions_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the maximum number of partitions for a memory domain. </p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Max number of partitions, or -1 if there is no limit </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_buffer_validate">
<span class="target" id="group__arch-userspace_1ga1532ef5705aa71f0f93899abca0939da"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_buffer_validate</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">write</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_buffer_validate" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check memory region permissions. </p>
<p>Given a memory region, return whether the current memory management hardware configuration would allow a user thread to read/write that region. Used by system calls to validate buffers coming in from userspace.</p>
<p>Notes: The function is guaranteed to never return validation success, if the entire buffer area is not user accessible.</p>
<p>The function is guaranteed to correctly validate the permissions of the supplied buffer, if the user access permissions of the entire buffer are enforced by a single, enabled memory management region.</p>
<p>In some architectures the validation will always return failure if the supplied memory buffer spans multiple enabled memory management regions (even if all such regions permit user access).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>0 size buffer has undefined behavior.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>addr</strong> – start address of the buffer </p></li>
<li><p><strong>size</strong> – the size of the buffer </p></li>
<li><p><strong>write</strong> – If nonzero, additionally check if the area is writable. Otherwise, just check if the memory can be read.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>nonzero if the permissions don’t match. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_virt_region_align">
<span class="target" id="group__arch-userspace_1ga48be2412ba65ec550ded63e2f1a0470f"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_virt_region_align</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">phys</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_virt_region_align" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the optimal virtual region alignment to optimize the MMU table layout</p>
<p>Some MMU HW requires some region to be aligned to some of the intermediate block alignment in order to reduce table usage. This call returns the optimal virtual address alignment in order to permit such optimization in the following MMU mapping call.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>phys</strong> – <strong>[in]</strong> Physical address of region to be mapped, aligned to MMU_PAGE_SIZE </p></li>
<li><p><strong>size</strong> – <strong>[in]</strong> Size of region to be mapped, aligned to MMU_PAGE_SIZE</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><p><strong>alignment</strong> – to apply on the virtual address of this region </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_user_mode_enter">
<span class="target" id="group__arch-userspace_1ga447daa0454a90a7a3a247de01e522567"></span><span class="pre">FUNC_NORETURN</span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_user_mode_enter</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">k_thread_entry_t</span></span><span class="w"> </span><span class="n"><span class="pre">user_entry</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p1</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p2</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p3</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_user_mode_enter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Perform a one-way transition from supervisor to kernel mode.</p>
<p>Implementations of this function must do the following:</p>
<p><ul class="simple">
<li><p>Reset the thread’s stack pointer to a suitable initial value. We do not need any prior context since this is a one-way operation.</p></li>
<li><p>Set up any kernel stack region for the CPU to use during privilege elevation</p></li>
<li><p>Put the CPU in whatever its equivalent of user mode is</p></li>
<li><p>Transfer execution to <a class="reference internal" href="#group__arch-threads_1gade449838e445fa8201266e38215c616c"><span class="std std-ref">arch_new_thread()</span></a> passing along all the supplied arguments, in user mode.</p></li>
</ul>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>user_entry</strong> – Entry point to start executing as a user thread </p></li>
<li><p><strong>p1</strong> – 1st parameter to user thread </p></li>
<li><p><strong>p2</strong> – 2nd parameter to user thread </p></li>
<li><p><strong>p3</strong> – 3rd parameter to user thread </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_syscall_oops">
<span class="target" id="group__arch-userspace_1gad53908f229d7e2c333574b009493644b"></span><span class="pre">FUNC_NORETURN</span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_syscall_oops</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ssf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_syscall_oops" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Induce a kernel oops that appears to come from a specific location. </p>
<p>Normally, k_oops() generates an exception that appears to come from the call site of the k_oops() itself.</p>
<p>However, when validating arguments to a system call, if there are problems we want the oops to appear to come from where the system call was invoked and not inside the validation function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ssf</strong> – System call stack frame pointer. This gets passed as an argument to _k_syscall_handler_t functions and its contents are completely architecture specific. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_user_string_nlen">
<span class="target" id="group__arch-userspace_1ga174c4f356fe315c523cefbf513858c9c"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_user_string_nlen</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">maxsize</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">err</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_user_string_nlen" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Safely take the length of a potentially bad string. </p>
<p>This must not fault, instead the err parameter must have -1 written to it. This function otherwise should work exactly like libc strnlen(). On success *err should be set to 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s</strong> – String to measure </p></li>
<li><p><strong>maxsize</strong> – Max length of the string </p></li>
<li><p><strong>err</strong> – Error value to write </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Length of the string, not counting NULL byte, up to maxsize </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_mem_coherent">
<span class="target" id="group__arch-userspace_1ga8c6bb0f6730c115689452b016ac1761f"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_mem_coherent</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_mem_coherent" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Detect memory coherence type. </p>
<p>Required when ARCH_HAS_COHERENCE is true. This function returns true if the byte pointed to lies within an architecture-defined “coherence region” (typically implemented with uncached memory) and can safely be used in multiprocessor code without explicit flush or invalidate operations.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The result is for only the single byte at the specified address, this API is not required to check region boundaries or to expect aligned pointers. The expectation is that the code above will have queried the appropriate address(es). </p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_cohere_stacks">
<span class="target" id="group__arch-userspace_1ga306e9d0e5f8094cb75686f1c43d068a9"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_cohere_stacks</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../../reference/kernel/threads/index.html#c.k_thread" title="k_thread"><span class="n"><span class="pre">k_thread</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old_thread</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old_switch_handle</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../../reference/kernel/threads/index.html#c.k_thread" title="k_thread"><span class="n"><span class="pre">k_thread</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new_thread</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_cohere_stacks" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Ensure cache coherence prior to context switch. </p>
<p>Required when ARCH_HAS_COHERENCE is true. On cache-incoherent multiprocessor architectures, thread stacks are cached by default for performance reasons. They must therefore be flushed appropriately on context switch. The rules are:</p>
<p><ol class="loweralpha simple">
<li><p>The region containing live data in the old stack (generally the bytes between the current stack pointer and the top of the stack memory) must be flushed to underlying storage so a new CPU that runs the same thread sees the correct data. This must happen before the assignment of the switch_handle field in the thread struct which signals the completion of context switch.</p></li>
<li><p>Any data areas to be read from the new stack (generally the same as the live region when it was saved) should be invalidated (and NOT flushed!) in the data cache. This is because another CPU may have run or re-initialized the thread since this CPU suspended it, and any data present in cache will be stale.</p></li>
</ol>
</p>
<p><ul class="simple">
<li><p>old_thread The old thread to be flushed before being allowed to run on other CPUs. </p></li>
<li><p>old_switch_handle The switch handle to be stored into old_thread (it will not be valid until the cache is flushed so is not present yet). This will be NULL if inside z_swap() (because the <a class="reference internal" href="#group__arch-threads_1gab411d82ce5b60f062171f5a19e33e025"><span class="std std-ref">arch_switch()</span></a> has not saved it yet). </p></li>
<li><p>new_thread The new thread to be invalidated before it runs locally. </p></li>
</ul>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The kernel will call this function during interrupt exit when a new thread has been chosen to run, and also immediately before entering <a class="reference internal" href="#group__arch-threads_1gab411d82ce5b60f062171f5a19e33e025"><span class="std std-ref">arch_switch()</span></a> to effect a code-driven context switch. In the latter case, it is very likely that more data will be written to the old_thread stack region after this function returns but before the completion of the switch. Simply flushing naively here is not sufficient on many architectures and coordination with the <a class="reference internal" href="#group__arch-threads_1gab411d82ce5b60f062171f5a19e33e025"><span class="std std-ref">arch_switch()</span></a> implementation is likely required.</p>
</div>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="id2">
<h3>Memory Management<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<dl>
<dt class="sig sig-object cpp">
<span class="target" id="group__arch-mmu"></span><em><span class="pre">group</span></em> <span class="sig-name descname"><span class="pre">arch-mmu</span></span></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-defines">Defines</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.ARCH_DATA_PAGE_ACCESSED">
<span class="target" id="group__arch-mmu_1ga38cfc7602d259972cdd0b557ab26c2b4"></span><span class="sig-name descname"><span class="n"><span class="pre">ARCH_DATA_PAGE_ACCESSED</span></span></span><a class="headerlink" href="#c.ARCH_DATA_PAGE_ACCESSED" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Bit indicating the data page was accessed since the value was last cleared.</p>
<p>Used by marking eviction algorithms. Safe to set this if uncertain.</p>
<p>This bit is undefined if ARCH_DATA_PAGE_LOADED is not set. </p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.ARCH_DATA_PAGE_DIRTY">
<span class="target" id="group__arch-mmu_1ga4a60b63f47f88db455d67c33ef7bb85d"></span><span class="sig-name descname"><span class="n"><span class="pre">ARCH_DATA_PAGE_DIRTY</span></span></span><a class="headerlink" href="#c.ARCH_DATA_PAGE_DIRTY" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Bit indicating the data page, if evicted, will need to be paged out.</p>
<p>Set if the data page was modified since it was last paged out, or if it has never been paged out before. Safe to set this if uncertain.</p>
<p>This bit is undefined if ARCH_DATA_PAGE_LOADED is not set. </p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.ARCH_DATA_PAGE_LOADED">
<span class="target" id="group__arch-mmu_1gae76ce742aca8b4ac12907a2bfce98b0e"></span><span class="sig-name descname"><span class="n"><span class="pre">ARCH_DATA_PAGE_LOADED</span></span></span><a class="headerlink" href="#c.ARCH_DATA_PAGE_LOADED" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Bit indicating that the data page is loaded into a physical page frame.</p>
<p>If un-set, the data page is paged out or not mapped. </p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.ARCH_DATA_PAGE_NOT_MAPPED">
<span class="target" id="group__arch-mmu_1ga843c53394b00d80b1649a6224557a56a"></span><span class="sig-name descname"><span class="n"><span class="pre">ARCH_DATA_PAGE_NOT_MAPPED</span></span></span><a class="headerlink" href="#c.ARCH_DATA_PAGE_NOT_MAPPED" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>If ARCH_DATA_PAGE_LOADED is un-set, this will indicate that the page is not mapped at all. This bit is undefined if ARCH_DATA_PAGE_LOADED is set. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-enums">Enums</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.arch_page_location">
<span class="target" id="group__arch-mmu_1ga65e10c80055d7e695add000f2ccfbb0b"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_page_location</span></span></span><a class="headerlink" href="#c.arch_page_location" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><em>Values:</em></p>
<dl class="c enumerator">
<dt class="sig sig-object c" id="c.arch_page_location.ARCH_PAGE_LOCATION_PAGED_OUT">
<span class="target" id="group__arch-mmu_1gga65e10c80055d7e695add000f2ccfbb0bacf9e624eac380ea2bfa37632c4d17a3a"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ARCH_PAGE_LOCATION_PAGED_OUT</span></span></span><a class="headerlink" href="#c.arch_page_location.ARCH_PAGE_LOCATION_PAGED_OUT" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.arch_page_location.ARCH_PAGE_LOCATION_PAGED_IN">
<span class="target" id="group__arch-mmu_1gga65e10c80055d7e695add000f2ccfbb0bae378a008f497ae10ab50cab06f8c36db"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ARCH_PAGE_LOCATION_PAGED_IN</span></span></span><a class="headerlink" href="#c.arch_page_location.ARCH_PAGE_LOCATION_PAGED_IN" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.arch_page_location.ARCH_PAGE_LOCATION_BAD">
<span class="target" id="group__arch-mmu_1gga65e10c80055d7e695add000f2ccfbb0ba7ff70acdf02345b5fa4c42ed2b2adde9"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ARCH_PAGE_LOCATION_BAD</span></span></span><a class="headerlink" href="#c.arch_page_location.ARCH_PAGE_LOCATION_BAD" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.arch_mem_map">
<span class="target" id="group__arch-mmu_1ga627bee468e54bb2d5ebe6ac53bb7fc94"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_mem_map</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">virt</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">phys</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_mem_map" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Map physical memory into the virtual address space</p>
<p>This is a low-level interface to mapping pages into the address space. Behavior when providing unaligned addresses/sizes is undefined, these are assumed to be aligned to CONFIG_MMU_PAGE_SIZE.</p>
<p>The core kernel handles all management of the virtual address space; by the time we invoke this function, we know exactly where this mapping will be established. If the page tables already had mappings installed for the virtual memory region, these will be overwritten.</p>
<p>If the target architecture supports multiple page sizes, currently only the smallest page size will be used.</p>
<p>The memory range itself is never accessed by this operation.</p>
<p>This API must be safe to call in ISRs or exception handlers. Calls to this API are assumed to be serialized, and indeed all usage will originate from kernel/mm.c which handles virtual memory management.</p>
<p>Architectures are expected to pre-allocate page tables for the entire address space, as defined by CONFIG_KERNEL_VM_BASE and CONFIG_KERNEL_VM_SIZE. This operation should never require any kind of allocation for paging structures.</p>
<p>Validation of arguments should be done via assertions.</p>
<p>This API is part of infrastructure still under development and may change.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>virt</strong> – Page-aligned Destination virtual address to map </p></li>
<li><p><strong>phys</strong> – Page-aligned Source physical address to map </p></li>
<li><p><strong>size</strong> – Page-aligned size of the mapped memory region in bytes </p></li>
<li><p><strong>flags</strong> – Caching, access and control flags, see K_MAP_* macros </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_mem_unmap">
<span class="target" id="group__arch-mmu_1ga8783e1d292510477b3816b6686d7d8cd"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_mem_unmap</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_mem_unmap" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Remove mappings for a provided virtual address range</p>
<p>This is a low-level interface for un-mapping pages from the address space. When this completes, the relevant page table entries will be updated as if no mapping was ever made for that memory range. No previous context needs to be preserved. This function must update mappings in all active page tables.</p>
<p>Behavior when providing unaligned addresses/sizes is undefined, these are assumed to be aligned to CONFIG_MMU_PAGE_SIZE.</p>
<p>Behavior when providing an address range that is not already mapped is undefined.</p>
<p>This function should never require memory allocations for paging structures, and it is not necessary to free any paging structures. Empty page tables due to all contained entries being un-mapped may remain in place.</p>
<p>Implementations must invalidate TLBs as necessary.</p>
<p>This API is part of infrastructure still under development and may change.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>addr</strong> – Page-aligned base virtual address to un-map </p></li>
<li><p><strong>size</strong> – Page-aligned region size </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_page_phys_get">
<span class="target" id="group__arch-mmu_1gaa31a233dab4ad575a9a969de10965200"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_page_phys_get</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">virt</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">phys</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_page_phys_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the mapped physical memory address from virtual address.</p>
<p>The function only needs to query the current set of page tables as the information it reports must be common to all of them if multiple page tables are in use. If multiple page tables are active it is unnecessary to iterate over all of them.</p>
<p>Unless otherwise specified, virtual pages have the same mappings across all page tables. Calling this function on data pages that are exceptions to this rule (such as the scratch page) is undefined behavior. Just check the currently installed page tables and return the information in that.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>virt</strong> – Page-aligned virtual address </p></li>
<li><p><strong>phys</strong> – <strong>[out]</strong> Mapped physical address (can be NULL if only checking if virtual address is mapped)</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>0</strong> – if mapping is found and valid </p></li>
<li><p><strong>-EFAULT</strong> – if virtual address is not mapped </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_reserved_pages_update">
<span class="target" id="group__arch-mmu_1ga229fa5699ad47951235af494f3d2a06a"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_reserved_pages_update</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_reserved_pages_update" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Update page frame database with reserved pages</p>
<p>Some page frames within system RAM may not be available for use. A good example of this is reserved regions in the first megabyte on PC-like systems.</p>
<p>Implementations of this function should mark all relavent entries in z_page_frames with K_PAGE_FRAME_RESERVED. This function is called at early system initialization with mm_lock held. </p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_mem_page_out">
<span class="target" id="group__arch-mmu_1ga4c13ffab5b5a5f8c93971c4d3b51bd8f"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_mem_page_out</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">location</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_mem_page_out" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Update all page tables for a paged-out data page</p>
<p>This function:<ul class="simple">
<li><p>Sets the data page virtual address to trigger a fault if accessed that can be distinguished from access violations or un-mapped pages.</p></li>
<li><p>Saves the provided location value so that it can retrieved for that data page in the page fault handler.</p></li>
<li><p>The location value semantics are undefined here but the value will be always be page-aligned. It could be 0.</p></li>
</ul>
</p>
<p>If multiple page tables are in use, this must update all page tables. This function is called with interrupts locked.</p>
<p>Calling this function on data pages which are already paged out is undefined behavior.</p>
<p>This API is part of infrastructure still under development and may change. </p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_mem_page_in">
<span class="target" id="group__arch-mmu_1ga3c446aea862e37d479a809582322b3ae"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_mem_page_in</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">phys</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_mem_page_in" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Update all page tables for a paged-in data page</p>
<p>This function:<ul class="simple">
<li><p>Maps the specified virtual data page address to the provided physical page frame address, such that future memory accesses will function as expected. Access and caching attributes are undisturbed.</p></li>
<li><p>Clears any accounting for “accessed” and “dirty” states.</p></li>
</ul>
</p>
<p>If multiple page tables are in use, this must update all page tables. This function is called with interrupts locked.</p>
<p>Calling this function on data pages which are already paged in is undefined behavior.</p>
<p>This API is part of infrastructure still under development and may change. </p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_mem_scratch">
<span class="target" id="group__arch-mmu_1gae4e82c3100b08bdfdcd9361d316735a1"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_mem_scratch</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">phys</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_mem_scratch" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Update current page tables for a temporary mapping</p>
<p>Map a physical page frame address to a special virtual address Z_SCRATCH_PAGE, with read/write access to supervisor mode, such that when this function returns, the calling context can read/write the page frame’s contents from the Z_SCRATCH_PAGE address.</p>
<p>This mapping only needs to be done on the current set of page tables, as it is only used for a short period of time exclusively by the caller. This function is called with interrupts locked.</p>
<p>This API is part of infrastructure still under development and may change. </p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_page_location_get">
<span class="target" id="group__arch-mmu_1ga74b3ce1173b91a8f82c25ef89f9fbbc0"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><a class="reference internal" href="#c.arch_page_location" title="arch_page_location"><span class="n"><span class="pre">arch_page_location</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_page_location_get</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">location</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_page_location_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetch location information about a page at a particular address</p>
<p>The function only needs to query the current set of page tables as the information it reports must be common to all of them if multiple page tables are in use. If multiple page tables are active it is unnecessary to iterate over all of them. This may allow certain types of optimizations (such as reverse page table mapping on x86).</p>
<p>This function is called with interrupts locked, so that the reported information can’t become stale while decisions are being made based on it.</p>
<p>Unless otherwise specified, virtual data pages have the same mappings across all page tables. Calling this function on data pages that are exceptions to this rule (such as the scratch page) is undefined behavior. Just check the currently installed page tables and return the information in that.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>addr</strong> – Virtual data page address that took the page fault </p></li>
<li><p><strong>location</strong> – <strong>[out]</strong> In the case of ARCH_PAGE_FAULT_PAGED_OUT, the backing store location value used to retrieve the data page. In the case of ARCH_PAGE_FAULT_PAGED_IN, the physical address the page is mapped to. </p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ARCH_PAGE_FAULT_PAGED_OUT</strong> – The page was evicted to the backing store. </p></li>
<li><p><strong>ARCH_PAGE_FAULT_PAGED_IN</strong> – The data page is resident in memory. </p></li>
<li><p><strong>ARCH_PAGE_FAULT_BAD</strong> – The page is un-mapped or otherwise has had invalid access </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_page_info_get">
<span class="target" id="group__arch-mmu_1gab32a4bb6b3d44c126d63a473caf28b70"></span><span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_page_info_get</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">location</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">clear_accessed</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_page_info_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve page characteristics from the page table(s)</p>
<p>The architecture is responsible for maintaining “accessed” and “dirty” states of data pages to support marking eviction algorithms. This can either be directly supported by hardware or emulated by modifying protection policy to generate faults on reads or writes. In all cases the architecture must maintain this information in some way.</p>
<p>For the provided virtual address, report the logical OR of the accessed and dirty states for the relevant entries in all active page tables in the system if the page is mapped and not paged out.</p>
<p>If clear_accessed is true, the ARCH_DATA_PAGE_ACCESSED flag will be reset. This function will report its prior state. If multiple page tables are in use, this function clears accessed state in all of them.</p>
<p>This function is called with interrupts locked, so that the reported information can’t become stale while decisions are being made based on it.</p>
<p>The return value may have other bits set which the caller must ignore.</p>
<p>Clearing accessed state for data pages that are not ARCH_DATA_PAGE_LOADED is undefined behavior.</p>
<p>ARCH_DATA_PAGE_DIRTY and ARCH_DATA_PAGE_ACCESSED bits in the return value are only significant if ARCH_DATA_PAGE_LOADED is set, otherwise ignore them.</p>
<p>ARCH_DATA_PAGE_NOT_MAPPED bit in the return value is only significant if ARCH_DATA_PAGE_LOADED is un-set, otherwise ignore it.</p>
<p>Unless otherwise specified, virtual data pages have the same mappings across all page tables. Calling this function on data pages that are exceptions to this rule (such as the scratch page) is undefined behavior.</p>
<p>This API is part of infrastructure still under development and may change.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>addr</strong> – Virtual address to look up in page tables </p></li>
<li><p><strong>location</strong> – <strong>[out]</strong> If non-NULL, updated with either physical page frame address or backing store location depending on ARCH_DATA_PAGE_LOADED state. This is not touched if ARCH_DATA_PAGE_NOT_MAPPED. </p></li>
<li><p><strong>clear_accessed</strong> – Whether to clear ARCH_DATA_PAGE_ACCESSED state </p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><p><strong>Value</strong> – with ARCH_DATA_PAGE_* bits set reflecting the data page configuration </p>
</dd>
</dl>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="miscellaneous-architecture-apis">
<h3>Miscellaneous Architecture APIs<a class="headerlink" href="#miscellaneous-architecture-apis" title="Permalink to this headline">¶</a></h3>
<dl>
<dt class="sig sig-object cpp">
<span class="target" id="group__arch-misc"></span><em><span class="pre">group</span></em> <span class="sig-name descname"><span class="pre">arch-misc</span></span></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.arch_printk_char_out">
<span class="target" id="group__arch-misc_1ga6860efc93b8ba35911cfb0afbe372623"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_printk_char_out</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_printk_char_out" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Early boot console output hook</p>
<p>Definition of this function is optional. If implemented, any invocation of printk() (or logging calls with CONFIG_LOG_MODE_MINIMAL which are backed by printk) will default to sending characters to this function. It is useful for early boot debugging before main serial or console drivers come up.</p>
<p>This can be overridden at runtime with __printk_hook_install().</p>
<p>The default __weak implementation of this does nothing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>c</strong> – Character to print </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The character printed </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_kernel_init">
<span class="target" id="group__arch-misc_1ga62cc65268b396d2683e47c09c9b62af5"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_kernel_init</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_kernel_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Architecture-specific kernel initialization hook</p>
<p>This function is invoked near the top of _Cstart, for additional architecture-specific setup before the rest of the kernel is brought up.</p>
<p>TODO: Deprecate, most arches are using a prep_c() function to do the same thing in a simpler way </p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_nop">
<span class="target" id="group__arch-misc_1gabb087b9e158824121212d65646ae4154"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_nop</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_nop" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Do nothing and return. Yawn. </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="gdb-stub-apis">
<h3>GDB Stub APIs<a class="headerlink" href="#gdb-stub-apis" title="Permalink to this headline">¶</a></h3>
<dl>
<dt class="sig sig-object cpp">
<span class="target" id="group__arch-gdbstub"></span><em><span class="pre">group</span></em> <span class="sig-name descname"><span class="pre">arch-gdbstub</span></span></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.arch_gdb_init">
<span class="target" id="group__arch-gdbstub_1ga21c8a32d35c4d267b8306d595ff1d726"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_gdb_init</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_gdb_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Architecture layer debug start. </p>
<p>This function is called by <code class="docutils literal notranslate"><span class="pre">gdb_init()</span></code> </p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_gdb_continue">
<span class="target" id="group__arch-gdbstub_1ga9c130421feeee919651828511743b346"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_gdb_continue</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_gdb_continue" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Continue running program. </p>
<p>Continue software execution. </p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_gdb_step">
<span class="target" id="group__arch-gdbstub_1ga2aa577d5e55c8b739e2be6187336aaf0"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_gdb_step</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_gdb_step" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Continue with one step. </p>
<p>Continue software execution until reaches the next statement. </p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_gdb_reg_readall">
<span class="target" id="group__arch-gdbstub_1ga5317106a8022bea2a0d42af0789cc016"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_gdb_reg_readall</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">gdb_ctx</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">buflen</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_gdb_reg_readall" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Read all registers, and outputs as hexadecimal string. </p>
<p>This reads all CPU registers and outputs as hexadecimal string. The output string must be parsable by GDB.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ctx</strong> – GDB context </p></li>
<li><p><strong>buf</strong> – Buffer to output hexadecimal string. </p></li>
<li><p><strong>buflen</strong> – Length of buffer.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Length of hexadecimal string written. Return 0 if error or not supported. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_gdb_reg_writeall">
<span class="target" id="group__arch-gdbstub_1ga0ef78d7e193e98549d9665632e53d5ca"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_gdb_reg_writeall</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">gdb_ctx</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">hex</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">hexlen</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_gdb_reg_writeall" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Take a hexadecimal string and update all registers. </p>
<p>This takes in a hexadecimal string as presented from GDB, and updates all CPU registers with new values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ctx</strong> – GDB context </p></li>
<li><p><strong>hex</strong> – Input hexadecimal string. </p></li>
<li><p><strong>hexlen</strong> – Length of hexadecimal string.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Length of hexadecimal string parsed. Return 0 if error or not supported. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_gdb_reg_readone">
<span class="target" id="group__arch-gdbstub_1gaa3216e9f381f974c374a6399af5cdba5"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_gdb_reg_readone</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">gdb_ctx</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">buflen</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">regno</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_gdb_reg_readone" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Read one register, and outputs as hexadecimal string. </p>
<p>This reads one CPU register and outputs as hexadecimal string. The output string must be parsable by GDB.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ctx</strong> – GDB context </p></li>
<li><p><strong>buf</strong> – Buffer to output hexadecimal string. </p></li>
<li><p><strong>buflen</strong> – Length of buffer. </p></li>
<li><p><strong>regno</strong> – Register number</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Length of hexadecimal string written. Return 0 if error or not supported. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_gdb_reg_writeone">
<span class="target" id="group__arch-gdbstub_1gad717b520d774294bbda78a56cddcaeff"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_gdb_reg_writeone</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">gdb_ctx</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">hex</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">hexlen</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">regno</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_gdb_reg_writeone" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Take a hexadecimal string and update one register. </p>
<p>This takes in a hexadecimal string as presented from GDB, and updates one CPU registers with new value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ctx</strong> – GDB context </p></li>
<li><p><strong>hex</strong> – Input hexadecimal string. </p></li>
<li><p><strong>hexlen</strong> – Length of hexadecimal string. </p></li>
<li><p><strong>regno</strong> – Register number</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Length of hexadecimal string parsed. Return 0 if error or not supported. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_gdb_add_breakpoint">
<span class="target" id="group__arch-gdbstub_1gab6f42110cf2340132bf2b3916810c01d"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_gdb_add_breakpoint</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">gdb_ctx</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="n"><span class="pre">type</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">kind</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_gdb_add_breakpoint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add breakpoint or watchpoint. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ctx</strong> – GDB context </p></li>
<li><p><strong>type</strong> – Breakpoint or watchpoint type </p></li>
<li><p><strong>addr</strong> – Address of breakpoint or watchpoint </p></li>
<li><p><strong>kind</strong> – Size of breakpoint/watchpoint in bytes</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>0</strong> – Operation successful </p></li>
<li><p><strong>-1</strong> – Error encountered </p></li>
<li><p><strong>-2</strong> – Not supported </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.arch_gdb_remove_breakpoint">
<span class="target" id="group__arch-gdbstub_1ga734041433f69030ad98439d10ef56ad6"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_gdb_remove_breakpoint</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">gdb_ctx</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="n"><span class="pre">type</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">kind</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_gdb_remove_breakpoint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Remove breakpoint or watchpoint. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ctx</strong> – GDB context </p></li>
<li><p><strong>type</strong> – Breakpoint or watchpoint type </p></li>
<li><p><strong>addr</strong> – Address of breakpoint or watchpoint </p></li>
<li><p><strong>kind</strong> – Size of breakpoint/watchpoint in bytes</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>0</strong> – Operation successful </p></li>
<li><p><strong>-1</strong> – Error encountered </p></li>
<li><p><strong>-2</strong> – Not supported </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
</dd></dl>

</div>
</div>
</div>


           </div>
          </div>

          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; <a href="../../copyright.html">Copyright</a> 2015-2022 Zephyr Project members and individual contributors.
      <span class="lastupdated">Last updated on Mar 05, 2022.
      </span></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>