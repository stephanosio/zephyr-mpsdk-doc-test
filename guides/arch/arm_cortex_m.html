<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Arm Cortex-M Developer Guide &mdash; Zephyr Project Documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/custom.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/tabs.css" type="text/css" />
    <link rel="shortcut icon" href="../../_static/favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script type="module" src="../../_static/js/dark-mode-toggle.min.mjs"></script>
        <script src="https://www.googletagmanager.com/gtag/js?id=UA-831873-47"></script>
        <script src="../../_static/js/ga-tracker.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="copyright" title="Copyright" href="../../copyright.html" />
    <link rel="next" title="x86 Developer Guide" href="x86.html" />
    <link rel="prev" title="Zephyr support status on ARC processors" href="arc-support-status.html" />
  <meta name="color-scheme" content="dark light">
  
  <link rel="stylesheet" href="../../_static/css/light.css" type="text/css" media="(prefers-color-scheme: light)"/>
  <link rel="stylesheet" href="../../_static/css/dark.css" type="text/css" media="(prefers-color-scheme: dark)"/>

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html">
            <img src="../../_static/logo.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                3.0.0-rc3
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
  
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Zephyr Project</span>
      v: latest
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl>
        <dt>Document Release Versions</dt>
        
          <dd><a href="/">latest</a></dd>
        
          <dd><a href="/2.7.0/">2.7.0</a></dd>
        
          <dd><a href="/2.6.0/">2.6.0</a></dd>
        
          <dd><a href="/2.5.0/">2.5.0</a></dd>
        
          <dd><a href="/2.4.0/">2.4.0</a></dd>
        
          <dd><a href="/2.3.0/">2.3.0</a></dd>
        
          <dd><a href="/1.14.1/">1.14.1</a></dd>
        
      </dl>
      <dl>
        <dt>Downloads</dt>
        
        <dd><a href="/latest/zephyr.pdf">PDF</a></dd>
      </dl>
      <dl>
        <dt>zephyrproject.org Links</dt>
          <dd>
            <a href="https://www.zephyrproject.org/">Project Home</a>
          </dd>
          <dd>
            <a href="https://github.com/zephyrproject-rtos/sdk-ng/releases">SDK</a>
          </dd>
          <dd>
            <a href="https://github.com/zephyrproject-rtos/zephyr/releases">Releases</a>
          </dd>
      </dl>
    </div>
  </div>
  
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../introduction/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/index.html">Getting Started Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/index.html">Contribution Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../development_process/index.html">Development and Contribution Process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../build/index.html">Build and Configuration Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../application/index.html">Application Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/index.html">API Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">User and Developer Guides</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../beyond-GSG.html">Beyond the Getting Started Guide</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Architecture-related Guides</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="arc-support-status.html">Zephyr support status on ARC processors</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Arm Cortex-M Developer Guide</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#key-supported-features">Key supported features</a></li>
<li class="toctree-l4"><a class="reference internal" href="#os-features">OS features</a></li>
<li class="toctree-l4"><a class="reference internal" href="#misc">Misc</a></li>
<li class="toctree-l4"><a class="reference internal" href="#linking-cortex-m-applications">Linking Cortex-M applications</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cmsis">CMSIS</a></li>
<li class="toctree-l4"><a class="reference internal" href="#testing">Testing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#qemu">QEMU</a></li>
<li class="toctree-l4"><a class="reference internal" href="#maintainers-collaborators">Maintainers &amp; Collaborators</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="x86.html">x86 Developer Guide</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../bluetooth/index.html">Bluetooth</a></li>
<li class="toctree-l2"><a class="reference internal" href="../docs/index.html">Documentation Generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../coccinelle.html">Coccinelle</a></li>
<li class="toctree-l2"><a class="reference internal" href="../code-relocation.html">Code And Data Relocation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crypto/index.html">Cryptography</a></li>
<li class="toctree-l2"><a class="reference internal" href="../flash_debug/index.html">Flashing and Hardware Debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="../debug_tools/index.html">Debugging and Tracing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_mgmt/index.html">Device Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dts/index.html">Devicetree Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../env_vars.html">Environment Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pinctrl/index.html">Pin Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pm/index.html">Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../emulator/index.html">Peripheral and Hardware Emulators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules.html">Modules (External projects)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../networking/index.html">Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../platformio/index.html">Using with PlatformIO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../portability/index.html">OS Abstraction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../porting/index.html">Porting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../smf/index.html">State Machine Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../test/index.html">Testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tfm/index.html">Trusted Firmware-M</a></li>
<li class="toctree-l2"><a class="reference internal" href="../west/index.html">West (Zephyrâ€™s meta-tool)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../optimizations/index.html">Optimizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../zephyr_cmake_package.html">Zephyr CMake Package</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../samples/index.html">Samples and Demos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../boards/index.html">Supported Boards</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../releases/index.html">Release Notes</a></li>
</ul>

  
  <div class="toctree-wrapper compound">
    <p class="caption"><span class="caption-text">Reference</span></p>
    <ul>
      
      <li class="toctree-l1">
        <a class="reference internal" href="/latest/doxygen/html/index.html">API</a>
      </li>
      
      <li class="toctree-l1">
        <a class="reference internal" href="/latest/reference/kconfig/index.html">Kconfig Options</a>
      </li>
      
      <li class="toctree-l1">
        <a class="reference internal" href="/latest/reference/devicetree/bindings.html">Devicetree Bindings</a>
      </li>
      
    </ul>
  </div>
  

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Zephyr Project</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
  <!-- Docs / Latest -->
  
  

  <li><a href="../../index.html">Docs / Latest</a> &raquo;</li>
  
     <li><a href="../index.html">User and Developer Guides</a> &raquo;</li>
  
     <li><a href="index.html">Architecture-related Guides</a> &raquo;</li>
  
  <li>Arm Cortex-M Developer Guide</li>


  <li class="wy-breadcrumbs-aside">
    <dark-mode-toggle id="dark-mode-toggle" appearance="toggle" permanent="true"/>
  </li>
  <li class="wy-breadcrumbs-aside">
      
      
        <a href="https://github.com/zephyrproject-rtos/zephyr/blob/main/doc/guides/arch/arm_cortex_m.rst" class="fa fa-github"> Open on GitHub</a>
      
    
  </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
  
    <div class="wy-alert wy-alert-danger">
     This is the documentation for the latest (main) development branch of
     Zephyr. If you are looking for the documentation of previous releases, use
     the drop-down menu on the left and select the desired version.
    </div>
  
  
           <div itemprop="articleBody">
             
  <div class="section" id="arm-cortex-m-developer-guide">
<span id="id1"></span><h1>Arm Cortex-M Developer Guide<a class="headerlink" href="#arm-cortex-m-developer-guide" title="Permalink to this headline">Â¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">Â¶</a></h2>
<p>This page contains detailed information about the status of the Arm Cortex-M
architecture porting in the Zephyr RTOS and describes key aspects when
developing Zephyr applications for Arm Cortex-M-based platforms.</p>
</div>
<div class="section" id="key-supported-features">
<h2>Key supported features<a class="headerlink" href="#key-supported-features" title="Permalink to this headline">Â¶</a></h2>
<p>The table below summarizes the status of key OS features in the different
Arm Cortex-M implementation variants.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 21%" />
<col style="width: 23%" />
<col style="width: 11%" />
<col style="width: 6%" />
<col style="width: 5%" />
<col style="width: 7%" />
<col style="width: 5%" />
<col style="width: 6%" />
<col style="width: 8%" />
<col style="width: 8%" />
</colgroup>
<tbody>
<tr class="row-odd"><td></td>
<td></td>
<td colspan="8"><p><strong>Processor families</strong></p></td>
</tr>
<tr class="row-even"><td><p>Architecture variant</p></td>
<td></td>
<td colspan="2"><p>Arm v6-M</p></td>
<td colspan="3"><p>Arm v7-M</p></td>
<td colspan="2"><p>Arm v8-M</p></td>
<td><p>Arm v8.1-M</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p><strong>M0/M1</strong></p></td>
<td><p><strong>M0+</strong></p></td>
<td><p><strong>M3</strong></p></td>
<td><p><strong>M4</strong></p></td>
<td><p><strong>M7</strong></p></td>
<td><p><strong>M23</strong></p></td>
<td><p><strong>M33</strong></p></td>
<td><p><strong>M55</strong></p></td>
</tr>
<tr class="row-even"><td><p><strong>OS Features</strong></p></td>
<td></td>
<td colspan="8"></td>
</tr>
<tr class="row-odd"><td><p>Programmable fault
IRQ priorities</p></td>
<td></td>
<td><p>Y</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td><p>Single-thread kernel support</p></td>
<td></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>Thread local storage support</p></td>
<td></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td><p>Interrupt handling</p></td>
<td></td>
<td colspan="8"></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>Regular interrupts</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>Dynamic interrupts</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>Direct  interrupts</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>Zero Latency interrupts</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>CPU idling</p></td>
<td></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td><p>Native system timer (SysTick)</p></td>
<td></td>
<td><p>N <a class="footnote-reference brackets" href="#f1" id="id2">1</a></p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>Memory protection</p></td>
<td></td>
<td colspan="8"></td>
</tr>
<tr class="row-even"><td></td>
<td><p>User mode</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>HW stack protection (MPU)</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>HW-assisted stack limit checking</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>Y <a class="footnote-reference brackets" href="#f2" id="id3">2</a></p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>HW-assisted null-pointer
dereference detection</p></td>
<td></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td><p>HW-assisted atomic operations</p></td>
<td></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>Support for non-cacheable regions</p></td>
<td></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td><p>Execute SRAM functions</p></td>
<td></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>Floating Point Services</p></td>
<td></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td><p>DSP ISA</p></td>
<td></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>Trusted-Execution</p></td>
<td colspan="9"></td>
</tr>
<tr class="row-even"><td></td>
<td><p>Native TrustZone-M support</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>TF-M integration</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
</tr>
<tr class="row-even"><td><p>Code relocation</p></td>
<td></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>SW-based vector table relaying</p></td>
<td></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td><p>HW-assisted timing functions</p></td>
<td></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
</tbody>
</table>
<div class="section" id="notes">
<h3>Notes<a class="headerlink" href="#notes" title="Permalink to this headline">Â¶</a></h3>
<dl class="footnote brackets">
<dt class="label" id="f1"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p>SysTick is optional in Cortex-M1</p>
</dd>
<dt class="label" id="f2"><span class="brackets"><a class="fn-backref" href="#id3">2</a></span></dt>
<dd><p>Stack limit checking only in Secure builds in Cortex-M23</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="os-features">
<h2>OS features<a class="headerlink" href="#os-features" title="Permalink to this headline">Â¶</a></h2>
<div class="section" id="threads">
<h3>Threads<a class="headerlink" href="#threads" title="Permalink to this headline">Â¶</a></h3>
<div class="section" id="thread-stack-alignment">
<h4>Thread stack alignment<a class="headerlink" href="#thread-stack-alignment" title="Permalink to this headline">Â¶</a></h4>
<p>Each Zephyr thread is defined with its own stack memory. By default, Cortex-M enforces a double word thread stack alignment, see
<a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_STACK_ALIGN_DOUBLE_WORD"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_STACK_ALIGN_DOUBLE_WORD</span></code></a>. If MPU-based HW-assisted stack overflow detection (<a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_MPU_STACK_GUARD"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_MPU_STACK_GUARD</span></code></a>)
is enabled, thread stacks need to be aligned with a larger value, reflected by <a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_ARM_MPU_REGION_MIN_ALIGN_AND_SIZE"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_ARM_MPU_REGION_MIN_ALIGN_AND_SIZE</span></code></a>.
In Arm v6-M and Arm v7-M architecture variants, thread stacks are additionally required to be align with a value equal to their size,
in applications that need to support user mode (<a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_USERSPACE"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_USERSPACE</span></code></a>). The thread stack sizes in that case need to be a power
of two. This is all reflected by <a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_MPU_REQUIRES_POWER_OF_TWO_ALIGNMENT"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_MPU_REQUIRES_POWER_OF_TWO_ALIGNMENT</span></code></a>, that is enforced in Arm v6-M and Arm v7-M
builds with user mode support.</p>
</div>
<div class="section" id="stack-pointers">
<h4>Stack pointers<a class="headerlink" href="#stack-pointers" title="Permalink to this headline">Â¶</a></h4>
<p>While executing in thread mode the processor is using the Process Stack Pointer (PSP). The processor uses the Main Stack Pointer (MSP)
while executing in handler mode, that is, while servicing exceptions and HW interrupts. Using PSP in thread mode <em>facilitates thread
stack pointer manipulation</em> during thread context switching, without affecting the current execution context flow in
handler mode.</p>
<p>In Arm Cortex-M builds a single interrupt stack memory is shared among exceptions and interrupts. The size of the interrupt stack needs
to be selected taking into consideration nested interrupts, each pushing an additional stack frame. Deverlopers can modify the interrupt
stack size using <a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_ISR_STACK_SIZE"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_ISR_STACK_SIZE</span></code></a>.</p>
<p>The interrupt stack is also used during early boot so the kernel can initialize the main threadâ€™s stack before switching to the main thread.</p>
</div>
</div>
<div class="section" id="thread-context-switching">
<h3>Thread context switching<a class="headerlink" href="#thread-context-switching" title="Permalink to this headline">Â¶</a></h3>
<p>In Arm Cortex-M builds, the PendSV exception is used in order to trigger a context switch to a different thread.
PendSV exception is always present in Cortex-M implementations. PendSV is configured with the lowest possible
interrupt priority level, in all Cortex-M variants. The main reasons for that design are</p>
<ul class="simple">
<li><p>to utilize the tail chaining feature of Cortex-M processors, and thus limit the number of context switch
operations that occur.</p></li>
<li><p>to not impact the interrupt latency observed by HW interrupts.</p></li>
</ul>
<p>As a result, context switch in Cortex-M is non-atomic, i.e. it may be <em>preempted</em> by HW interrupts,
however, a context-switch operation must be completed before a new thread context-switch may start.</p>
<p>Typically a thread context-switch will perform the following operations</p>
<ul>
<li><p>When switching-out the current thread, the processor stores</p>
<blockquote>
<div><ul>
<li><p>the callee-saved registers (R4 - R11) in the threadâ€™s container for callee-saved registers,
which is located in kernel memory</p></li>
<li><p>the threadâ€™s current operation <em>mode</em></p>
<blockquote>
<div><ul class="simple">
<li><p>user or privileged execution mode</p></li>
<li><p>presense of an active floating point context</p></li>
<li><p>the EXC_RETURN value of the current handler context (PendSV)</p></li>
</ul>
</div></blockquote>
</li>
<li><p>the floating point callee-saved registers (S16 - S31) in the threadâ€™s container for FP
callee-saved registers, if the current thread has an active FP context</p></li>
<li><p>the PSP of the current thread which points to the beginning of the current threadâ€™s exception
stack frame. The latter contains the caller-saved context and the return address of the switched-out
thread.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>When switching-in a new thread the processor</p>
<blockquote>
<div><ul class="simple">
<li><p>restores the new threadâ€™s callee-saved registers from the threadâ€™s
container for callee-saved registers</p></li>
<li><p>restores the new threadâ€™s operation <em>mode</em></p></li>
<li><p>restores the FP callee-saved registers if the switched-in thread had
an active FP context before being switched-out</p></li>
<li><p>re-programs the dynamic MPU regions to allow a user thread access its stack and application
memories, and/or programs a stack-overflow MPU guard at the bottom of the threadâ€™s
privileged stack</p></li>
<li><p>restores the PSP for the incoming thread and re-programs the stack pointer limit
register (if applicable, see <a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_BUILTIN_STACK_GUARD"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_BUILTIN_STACK_GUARD</span></code></a>)</p></li>
<li><p>optionally does a stack limit checking for the switched-in thread, if
sentinel-based stack limit checking is enabled (see <a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_STACK_SENTINEL"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_STACK_SENTINEL</span></code></a>).</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<p>PendSV exception return sequence restores the new threadâ€™s caller-saved registers and the
return address, as part of unstacking the exception stack frame.</p>
<p>The implementation of the context-switch mechanism is present in
<code class="file docutils literal notranslate"><span class="pre">arch/arm/core/aarch32/swap_helper.S</span></code>.</p>
<div class="section" id="stack-limit-checking-arm-v8-m">
<h4>Stack limit checking (Arm v8-M)<a class="headerlink" href="#stack-limit-checking-arm-v8-m" title="Permalink to this headline">Â¶</a></h4>
<p>Armv8-M and Armv8.1-M variants support stack limit checking using the MSPLIM and PSPLIM
core registers. The feature is enabled when <a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_BUILTIN_STACK_GUARD"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_BUILTIN_STACK_GUARD</span></code></a> is set.
When stack limit checking is enabled, both the threadâ€™s privileged or user stack, as well
as the interrupt stack are guarded by PSPLIM and MSPLIM registers, respectively. MSPLIM is
configured <em>once</em> during kernel boot, while PSLIM is re-programmed during every thread
context-switch or during system calls, when the thread switches from using its default
stack to using its privileged stack, and vice versa. PSPLIM re-programming</p>
<ul class="simple">
<li><p>has a relatively low runtime overhead (programming is done with MSR instructions)</p></li>
<li><p>does not impact interrupt latency</p></li>
<li><p>does not require any memory areas to be reserved for stack guards</p></li>
<li><p>does not make use of MPU regions</p></li>
</ul>
<p>It is, therefore, considered as a lightweight but very efficient stack overflow
detection mechanism in Cortex-M applications.</p>
<p>Stack overflows trigger the dedicated UsageFault exception provided by Arm v8-M.</p>
</div>
</div>
<div class="section" id="interrupt-handling-features">
<h3>Interrupt handling features<a class="headerlink" href="#interrupt-handling-features" title="Permalink to this headline">Â¶</a></h3>
<p>This section describes certain aspects around exception and interrupt
handling in Arm Cortex-M.</p>
<div class="section" id="interrupt-priority-levels">
<h4>Interrupt priority levels<a class="headerlink" href="#interrupt-priority-levels" title="Permalink to this headline">Â¶</a></h4>
<p>The number of available (configurable) interrupt priority levels is
determined by the number of implemented interrupt priority bits in
NVIC; this needs to be described for each Cortex-M platform using
DeviceTree:</p>
<div class="highlight-devicetree notranslate"><div class="highlight"><pre><span></span><span class="o">&amp;</span><span class="na">nvic</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">arm</span><span class="p">,</span><span class="n">num-irq-priority-bits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;#</span><span class="na">priority</span><span class="o">-</span><span class="na">bits</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="reserved-priority-levels">
<h4>Reserved priority levels<a class="headerlink" href="#reserved-priority-levels" title="Permalink to this headline">Â¶</a></h4>
<p>A number of interrupt priority levels are reserved for the OS.</p>
<p>By design, system fault exceptions have the highest priority level. In
<em>Baseline</em> Cortex-M, this is actually enforced by hardware, as HardFault
is the only available processor fault exception, and its priority is
higher than any configurable exception priority.</p>
<p>In <em>Mainline</em> Cortex-M, the available fault exceptions (e.g. MemManageFault,
UsageFault, etc.) are assigned the highest <em>configurable</em> priority level.
(<a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_CPU_CORTEX_M_HAS_PROGRAMMABLE_FAULT_PRIOS"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_CPU_CORTEX_M_HAS_PROGRAMMABLE_FAULT_PRIOS</span></code></a> signifies explicitly
that the Cortex-M implementation supports configurable fault priorities.)</p>
<p>This priority level is never shared with HW interrupts (an exception to
this rule is described below). As a result, processor faults occurring in regular
ISRs will be handled by the corresponding fault handler and will not escalate to
a HardFault, <em>similar to processor faults occurring in thread mode</em>.</p>
<p>SVC exception is normally configured with the highest conigurable priority level
(an exception to this rule will be described below).
SVCs are used by the Zephyr kernel to dispatch system calls, trigger runtime
system errors (e.g. Kernel oops or panic), or implement IRQ offloading.</p>
<p>In Baseline Cortex-M the priority level of SVC may be shared with other exceptions
or HW interrupts that are also given the highest configurable priority level (As a
result of this, kernel runtime errors during interrupt handling will escalate to
HardFault. Additional logic in the fault handling routines ensures that such
runtime errors are detected successfully).</p>
<p>In Mainline Cortex-M, however, the SVC priority level is <em>reserved</em>, thus normally it
is only shared with the fault exceptions of configurable priority. This simplifies the
fault handling routines in Mainline Cortex-M architecture, since runtime kernel errors
are serviced by the SVC handler (i.e no HardFault escalation, even if the kernel errors
occur in ISR context).</p>
<p>HW interrupts in Mainline Cortex-M builds are allocated a priority level lower than the SVC.</p>
<p>One exception to the above rules is when Zephyr applications support Zero Latency Interrupts
(ZLIs). Such interrupts are designed to have a priority level higher than any HW or system
interrupt. If the ZLI feature is enabled in Mainline Cortex-M builds (see
<a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_ZERO_LATENCY_IRQS"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_ZERO_LATENCY_IRQS</span></code></a>), then</p>
<ul class="simple">
<li><p>ZLIs are assigned the highest configurable priority level</p></li>
<li><p>SVCs are assigned the second highest configurable priority level</p></li>
<li><p>Regular HW interrupts are assigned priority levels lower than SVC.</p></li>
</ul>
<p>The priority level configuration in Cortex-M is implemented in
<code class="file docutils literal notranslate"><span class="pre">include/arch/arm/aarch32/exc.h</span></code>.</p>
</div>
<div class="section" id="locking-and-unlocking-irqs">
<h4>Locking and unlocking IRQs<a class="headerlink" href="#locking-and-unlocking-irqs" title="Permalink to this headline">Â¶</a></h4>
<p>In Baseline Cortex-M locking interrupts is implemented using the PRIMASK register.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">arch_irq_lock</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>will set the PRIMASK register to 1, eventually, masking all IRQs with configurable
priority. While this fulfils the OS requirement of locking interrupts, the consequence
is that kernel runtime errors (triggering SVCs) will escalate to HardFault.</p>
<p>In Mainline Cortex-M locking interrupts is implemented using the BASEPRI register (Mainline
Cortex-M builds select <a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_CPU_CORTEX_M_HAS_BASEPRI"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_CPU_CORTEX_M_HAS_BASEPRI</span></code></a> to signify that BASEPRI register is
implemented.). By modifying BASEPRI (or BASEPRI_MAX) arch_irq_lock() masks all system and HW
interrupts with the exception of</p>
<ul class="simple">
<li><p>SVCs</p></li>
<li><p>processor faults</p></li>
<li><p>ZLIs</p></li>
</ul>
<p>This allows zero latency interrupts to be triggered inside OS critical sections.
Additionally, this allows system (processor and kernel) faults to be handled by Zephyr
in <em>exactly the same way</em>, regardless of whether IRQs have been locked or not when the
error occurs. It also allows for system calls to be dispatched while IRQs are locked.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mainline Cortex-M fault handling is designed and configured in a way that all processor
and kernel faults are handled by the corresponding exception handlers and never result
in HardFault escalation. In other words, a HardFault may only occur in Zephyr applications
that have modified the default fault handling configurations. The main reason for this
design was to reserve the HardFault exception for handling exceptional error conditions
in safety critical applications.</p>
</div>
</div>
<div class="section" id="dynamic-direct-interrupts">
<h4>Dynamic direct interrupts<a class="headerlink" href="#dynamic-direct-interrupts" title="Permalink to this headline">Â¶</a></h4>
<p>Cortex-M builds support the installation of direct interrupt service routines during
runtime. Direct interrupts are designed for performance-critical interrupt
handling and do not go through all of the common Zephyr interrupt handling
code.</p>
<p>Direct dynamic interrupts are enabled via switching on
<a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_DYNAMIC_DIRECT_INTERRUPTS"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_DYNAMIC_DIRECT_INTERRUPTS</span></code></a>.</p>
<p>Note that enabling direct dynamic interrupts requires enabling support for
dynamic interrupts in the kernel, as well (see <a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_DYNAMIC_INTERRUPTS"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_DYNAMIC_INTERRUPTS</span></code></a>).</p>
</div>
<div class="section" id="zero-latency-interrupts">
<h4>Zero Latency interrupts<a class="headerlink" href="#zero-latency-interrupts" title="Permalink to this headline">Â¶</a></h4>
<p>As described above, in Mainline Cortex-M applications, the Zephyr kernel reserves
the highest configurable interrupt priority level for its own use (SVC). SVCs will
not be masked by interrupt locking. Zero-latency interrupt can be used to set up
an interrupt at the highest interrupt priority which will not be blocked by interrupt
locking. To use the ZLI feature <a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_ZERO_LATENCY_IRQS"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_ZERO_LATENCY_IRQS</span></code></a> needs to be enabled.</p>
<p>Zero latency IRQs have minimal interrupt latency, as they will always preempt regular HW
or system interrupts.</p>
<p>Note, however, that since ZLI ISRs will run at a priority level higher than the kernel
exceptions they <strong>cannot use</strong> any kernel functionality. Additionally, since the ZLI
interrupt priority level is equal to processor fault priority level, faults occurring
in ZLI ISRs will escalate to HardFault and will not be handled in the same way as regular
processor faults. Developers need to be aware of this limitation.</p>
</div>
</div>
<div class="section" id="cpu-idling">
<h3>CPU Idling<a class="headerlink" href="#cpu-idling" title="Permalink to this headline">Â¶</a></h3>
<p>The Cortex-M architecture port implements both k_cpu_idle()
and k_cpu_atomic_idle(). The implementation is present in
<code class="file docutils literal notranslate"><span class="pre">arch/arm/core/aarch32/cpu_idle.S</span></code>.</p>
<p>In both implementations, the processor
will attempt to put the core to low power mode.
In k_cpu_idle() the processor ends up executing WFI (Wait For Interrupt)
instruction, while in k_cpu_atomic_idle() the processor will
execute a WFE (Wait For Event) instruction.</p>
<p>When using the CPU idling API in Cortex-M it is important to note the
following:</p>
<ul class="simple">
<li><p>Both k_cpu_idle() and k_cpu_atomic_idle() are <em>assumed</em> to be invoked
with interrupts locked. This is taken care of by the kernel if the APIs
are called by the idle thread.</p></li>
<li><p>After waking up from low power mode, both functions will <em>restore</em>
interrupts unconditionally, that is, regardless of the interrupt lock
status before the CPU idle API was called.</p></li>
</ul>
<p>The Zephyr CPU Idling mechanism is detailed in <a class="reference internal" href="../../reference/kernel/other/cpu_idle.html#cpu-idle"><span class="std std-ref">CPU Idling</span></a>.</p>
</div>
<div class="section" id="memory-protection-features">
<h3>Memory protection features<a class="headerlink" href="#memory-protection-features" title="Permalink to this headline">Â¶</a></h3>
<p>This section describes certain aspects around memory protection features
in Arm Cortex-M applications.</p>
<div class="section" id="user-mode-system-calls">
<h4>User mode system calls<a class="headerlink" href="#user-mode-system-calls" title="Permalink to this headline">Â¶</a></h4>
<p>User mode is supported in Cortex-M platforms that implement the standard (Arm) MPU
or a similar core peripheral logic for memory access policy configuration and
control, such as the NXP MPU for Kinetis platforms. (Currently,
<a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_ARCH_HAS_USERSPACE"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_ARCH_HAS_USERSPACE</span></code></a> is selected if <a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_ARM_MPU"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_ARM_MPU</span></code></a> is enabled
by the user in the board default Kconfig settings).</p>
<p>A thread performs a system call by triggering a (synchronous) SVC exception, where</p>
<ul class="simple">
<li><p>up to 5 arguments are placed on registers R1 - R5</p></li>
<li><p>system call ID is placed on register R6.</p></li>
</ul>
<p>The SVC Handler will branch to the system call preparation logic, which will perform
the following operations</p>
<ul class="simple">
<li><p>switch the threadâ€™s PSP to point to the beginning of the threadâ€™s privileged
stack area, optionally reprogramming the PSPLIM if stack limit checking is enabled</p></li>
<li><p>modify CONTROL register to switch to privileged mode</p></li>
<li><p>modify the return address in the SVC exception stack frame, so that after exception
return the system call dispatcher is executed (in thread privileged mode)</p></li>
</ul>
<p>Once the system call execution is completed the system call dispatcher will restore the
userâ€™s original PSP and PSPLIM and switch the CONTROL register back to unprivileged mode
before returning back to the caller of the system call.</p>
<p>System calls execute in thread mode and can be preempted by interrupts at any time. A
thread may also be context-switched-out while doing a system call; the system call will
resume as soon as the thread is switched-in again.</p>
<p>The system call dispatcher executes at SVC priority, therefore it cannot be preempted
by HW interrupts (with the exception of ZLIs), which may observe some additional interrupt
latency if they occur during a system call preparation.</p>
</div>
<div class="section" id="mpu-assisted-stack-overflow-detection">
<h4>MPU-assisted stack overflow detection<a class="headerlink" href="#mpu-assisted-stack-overflow-detection" title="Permalink to this headline">Â¶</a></h4>
<p>Cortex-M platforms with MPU may enable <a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_MPU_STACK_GUARD"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_MPU_STACK_GUARD</span></code></a> to enable the MPU-based
stack overflow detection mechanism. The following points need to be considered when enabling the
MPU stack guards</p>
<ul class="simple">
<li><p>stack overflows are triggering processor faults as soon as they occur</p></li>
<li><p>the mechanism is essential for detecting stack overflows in supervisor threads, or
user threads in privileged mode; stack overflows in threads in user mode will always be
detected regardless of <a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_MPU_STACK_GUARD"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_MPU_STACK_GUARD</span></code></a> being set.</p></li>
<li><p>stack overflows are always detected, however, the mechanism does not guarantee that
no memory corruption occurs when supervisor threads overflow their stack memory</p></li>
<li><p><a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_MPU_STACK_GUARD"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_MPU_STACK_GUARD</span></code></a> will normally reserve one MPU region for programming
the stack guard (in certain Arm v8-M configurations with <a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_MPU_GAP_FILLING"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_MPU_GAP_FILLING</span></code></a>
enabled 2 MPU regions are required to implement the guard feature)</p></li>
<li><p>MPU guards are re-programmed at every context-switch, adding a small overhead to the
thread swap routine. Compared, however, to the <a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_BUILTIN_STACK_GUARD"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_BUILTIN_STACK_GUARD</span></code></a> feature,
no re-programming occurs during system calls.</p></li>
<li><p>When <a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_HW_STACK_PROTECTION"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_HW_STACK_PROTECTION</span></code></a> is enabled on Arm v8-M platforms the native
stack limit checking mechanism is used by default instead of the MPU-based stack overflow
detection mechanism; users may override this setting by manually enabling <a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_MPU_STACK_GUARD"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_MPU_STACK_GUARD</span></code></a>
in these scenarios.</p></li>
</ul>
</div>
</div>
<div class="section" id="memory-map-and-mpu-considerations">
<h3>Memory map and MPU considerations<a class="headerlink" href="#memory-map-and-mpu-considerations" title="Permalink to this headline">Â¶</a></h3>
<div class="section" id="fixed-mpu-regions">
<h4>Fixed MPU regions<a class="headerlink" href="#fixed-mpu-regions" title="Permalink to this headline">Â¶</a></h4>
<p>By default, when <a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_ARM_MPU"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_ARM_MPU</span></code></a> is enabled a set of <em>fixed</em> MPU regions
are programmed during system boot.</p>
<ul class="simple">
<li><p>One MPU region programs the entire flash area as read-execute.
User can override this setting by enabling <a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_MPU_ALLOW_FLASH_WRITE"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_MPU_ALLOW_FLASH_WRITE</span></code></a>,
which programs the flash with RWX permissions. If <a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_USERSPACE"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_USERSPACE</span></code></a> is
enabled unprivileged access on the entire flash area is allowed.</p></li>
<li><p>One MPU region programs the entire SRAM area with privileged-only
RW permissions. That is, an  MPU region is utilized to disallow execute permissions on
SRAM. (An exception to this setting is when <a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_MPU_GAP_FILLING"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_MPU_GAP_FILLING</span></code></a> is disabled (Arm v8-M only);
in that case no SRAM MPU programming is done so the access is determined by the default
Arm memory map policies, allowing for privileged-only RWX permissions on SRAM).</p></li>
</ul>
<p>The above MPU regions are defined in <code class="file docutils literal notranslate"><span class="pre">soc/arm/common/arm_mpu_regions.c</span></code>.
Alternative MPU configurations are allowed by enabling <a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_CPU_HAS_CUSTOM_FIXED_SOC_MPU_REGIONS"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_CPU_HAS_CUSTOM_FIXED_SOC_MPU_REGIONS</span></code></a>.
When enabled, this option signifies that the Cortex-M SoC will define and
configure its own fixed MPU regions in the SoC definition.</p>
</div>
<div class="section" id="static-mpu-regions">
<h4>Static MPU regions<a class="headerlink" href="#static-mpu-regions" title="Permalink to this headline">Â¶</a></h4>
<p>Additional <em>static</em> MPU regions may be programmed once during system boot. These regions
are required to enable certain features</p>
<ul class="simple">
<li><p>a RX region to allow execution from SRAM, when <a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_ARCH_HAS_RAMFUNC_SUPPORT"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_ARCH_HAS_RAMFUNC_SUPPORT</span></code></a> is
enabled and users have defined functions to execute from SRAM.</p></li>
<li><p>a RX region for relocating text sections to SRAM, when <a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_CODE_DATA_RELOCATION_SRAM"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_CODE_DATA_RELOCATION_SRAM</span></code></a> is enabled</p></li>
<li><p>a no-cache region to allow for a none-cacheable SRAM area, when <a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_NOCACHE_MEMORY"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_NOCACHE_MEMORY</span></code></a> is enabled</p></li>
<li><p>a possibly unprivileged RW region for GCOV code coverage accounting area, when <a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_COVERAGE_GCOV"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_COVERAGE_GCOV</span></code></a> is enabled</p></li>
<li><p>a no-access region to implement null pointer dereference detection, when <a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_NULL_POINTER_EXCEPTION_DETECTION_MPU"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_NULL_POINTER_EXCEPTION_DETECTION_MPU</span></code></a> is enabled</p></li>
</ul>
<p>The boundaries of these static MPU regions are derived from symbols exposed by the linker, in
<code class="file docutils literal notranslate"><span class="pre">include/linker/linker-defs.h</span></code>.</p>
</div>
<div class="section" id="dynamic-mpu-regions">
<h4>Dynamic MPU regions<a class="headerlink" href="#dynamic-mpu-regions" title="Permalink to this headline">Â¶</a></h4>
<p>Certain thread-specific MPU regions may be re-programmed dynamically, at each thread context switch:</p>
<ul class="simple">
<li><p>an unprivileged RW region for the current threadâ€™s stack area (for user threads)</p></li>
<li><p>a read-only region for the MPU stack guard</p></li>
<li><p>unprivileged RW regions for the partitions of the currentl threadâ€™s application memory
domain.</p></li>
</ul>
</div>
<div class="section" id="considerations">
<h4>Considerations<a class="headerlink" href="#considerations" title="Permalink to this headline">Â¶</a></h4>
<p>The number of available MPU regions for a Cortex-M platform is a limited resource.
Most platforms have 8 MPU regions, while some Cortex-M33 or Cortex-M7 platforms may
have up to 16 MPU regions. Therefore there is a relatively strict limitation on how
many fixed, static and dynamic MPU regions may be programmed simultaneously. For platforms
with 8 available MPU regions it might not be possible to enable all the aforementioned
features that require MPU region programming. In most practical applications, however,
only a certain set of features is required and 8 MPU regions are, in many cases, sufficient.</p>
<p>In Arm v8-M processors the MPU architecture does not allow programmed MPU regions to
overlap. <a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_MPU_GAP_FILLING"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_MPU_GAP_FILLING</span></code></a> controls whether the fixed MPU region
covering the entire SRAM is programmed. When it does, a full SRAM area partitioning
is required, in order to program the  static and the dynamic MPU regions. This increases
the total number of required MPU regions. When <a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_MPU_GAP_FILLING"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_MPU_GAP_FILLING</span></code></a> is not
enabled the fixed MPU region convering the entire SRAM is not programmed, thus, the static
and dynamic regions are simply programmed on top of the always-existing background region
(full-SRAM partitioning is not required).
Note, however, that the background SRAM region allows execution from SRAM, so when
<a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_MPU_GAP_FILLING"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_MPU_GAP_FILLING</span></code></a> is not set Zephyr is not protected against attacks
that attempt to execute malicious code from SRAM.</p>
</div>
</div>
<div class="section" id="floating-point-services">
<h3>Floating point Services<a class="headerlink" href="#floating-point-services" title="Permalink to this headline">Â¶</a></h3>
<p>Both unshared and shared FP registers mode are supported in Cortex-M (see
<a class="reference internal" href="../../reference/kernel/other/float.html#float-v2"><span class="std std-ref">Floating Point Services</span></a> for more details).</p>
<p>When FPU support is enabled in the build
(<a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_FPU"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_FPU</span></code></a> is enabled), the
sharing FP registers mode (<a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_FPU_SHARING"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_FPU_SHARING</span></code></a>)
is enabled by default. This is done as some compiler configurations
may activate a floating point context by generating FP instructions
for any thread, regardless of whether floating point calculations are
performed, and that context must be preserved when switching such
threads in and out.</p>
<p>The developers can still disable the FP sharing mode in their
application projects, and switch to Unshared FP registers mode,
if it is guaranteed that the image code does not generate FP
instructions outside the single thread context that is allowed
(and supposed) to do so.</p>
<p>Under FPU sharing mode, the callee-saved FPU registers are saved
and restored in context-switch, if the corresponding threads have
an active FP context. This adds some runtime overhead on the swap
routine. In addition to the runtime overhead, the sharing FPU mode</p>
<ul class="simple">
<li><p>requires additional memory for each thread to save the callee-saved
FP registers</p></li>
<li><p>requires additional stack memory for each thread, to stack the caller-saved
FP registers, upon exception entry, if an FP context is active. Note, however,
that since lazy stacking is enabled, there is no runtime overhead of FP context
stacking in regular interrupts (FP state preservation is only activated in the
swap routine in PendSV interrupt).</p></li>
</ul>
</div>
</div>
<div class="section" id="misc">
<h2>Misc<a class="headerlink" href="#misc" title="Permalink to this headline">Â¶</a></h2>
<div class="section" id="chain-loadable-images">
<h3>Chain-loadable images<a class="headerlink" href="#chain-loadable-images" title="Permalink to this headline">Â¶</a></h3>
<p>Cortex-M applications may either be standalone images or chain-loadable, for instance,
by a bootloader. Application images chain-loadable by bootloaders (or other applications)
normally occupy a specific area in the flash denoted as their <em>code partition</em>.
<a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_USE_DT_CODE_PARTITION"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_USE_DT_CODE_PARTITION</span></code></a> will ensure that a Zephyr chain-loadable image
will be linked into its code partition, specified in DeviceTree.</p>
<div class="section" id="hw-initialization-at-boot">
<h4>HW initialization at boot<a class="headerlink" href="#hw-initialization-at-boot" title="Permalink to this headline">Â¶</a></h4>
<p>In order to boot properly, chain-loaded applications may require that the core Arm
hardware registers and peripherals are initialized in their reset values. Enabling
<a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_INIT_ARCH_HW_AT_BOOT"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_INIT_ARCH_HW_AT_BOOT</span></code></a> Zephyr to force the initialization of the
internal Cortex-M architectural state during boot to the reset values as specified
by the corresponding Arm architecture manual.</p>
</div>
<div class="section" id="software-vector-relaying">
<h4>Software vector relaying<a class="headerlink" href="#software-vector-relaying" title="Permalink to this headline">Â¶</a></h4>
<p>In Cortex-M platforms that implement the VTOR register (see <a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_CPU_CORTEX_M_HAS_VTOR"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_CPU_CORTEX_M_HAS_VTOR</span></code></a>),
chain-loadable images relocate the Cortex-M vector table by updating the VTOR register with the offset
of the image vector table.</p>
<p>Baseline Cortex-M platforms without VTOR register might not be able to relocate their
vector table which remains at a fixed location. Therefore, a chain-loadable image will
require an alternative way to route HW interrupts and system exeptions to its own vector
table; this is achieved with software vector relaying.</p>
<p>When a bootloader image enables <a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_SW_VECTOR_RELAY"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_SW_VECTOR_RELAY</span></code></a>
it is able to relay exceptions and interrupts based on a vector table
pointer that is set by the chain-loadable application. The latter sets
the <a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_SW_VECTOR_RELAY_CLIENT"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_SW_VECTOR_RELAY_CLIENT</span></code></a> option to instruct the boot
sequence to set the vector table pointer in SRAM so that the bootloader can
forward the exceptions and interrupts to the chain-loadable imageâ€™s software
vector table.</p>
<p>While this feature is intended for processors without VTOR register, it
may also be used in Mainline Cortex-M platforms.</p>
</div>
</div>
<div class="section" id="code-relocation">
<h3>Code relocation<a class="headerlink" href="#code-relocation" title="Permalink to this headline">Â¶</a></h3>
<p>Cortex-M support the code relocation feature. When
<a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_CODE_DATA_RELOCATION_SRAM"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_CODE_DATA_RELOCATION_SRAM</span></code></a> is selected,
Zephyr will relocate .text, data and .bss sections
from the specified files and place it in SRAM. It is
possible to relocate only parts of the code sections
into SRAM, without relocating the whole image text
and data sections. More details on the code relocation
feature can be found in <a class="reference internal" href="../code-relocation.html#code-data-relocation"><span class="std std-ref">Code And Data Relocation</span></a>.</p>
</div>
</div>
<div class="section" id="linking-cortex-m-applications">
<h2>Linking Cortex-M applications<a class="headerlink" href="#linking-cortex-m-applications" title="Permalink to this headline">Â¶</a></h2>
<p>Most Cortex-M platforms make use of the default Cortex-M
GCC linker script in <code class="file docutils literal notranslate"><span class="pre">include/arch/arm/aarch32/cortex-m/scripts/linked.ld</span></code>,
although it is possible for platforms to use a custom linker
script as well.</p>
</div>
<div class="section" id="cmsis">
<h2>CMSIS<a class="headerlink" href="#cmsis" title="Permalink to this headline">Â¶</a></h2>
<p>Cortex-M CMSIS headers are hosted in a standalone module repository:
<a class="reference external" href="https://github.com/zephyrproject-rtos/cmsis">zephyrproject-rtos/cmsis</a>.</p>
<p><a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_CPU_CORTEX_M"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_CPU_CORTEX_M</span></code></a> selects <a class="reference internal" href="../../reference/kconfig/dummy-syms.html#std-kconfig-CONFIG_HAS_CMSIS_CORE"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_HAS_CMSIS_CORE</span></code></a> to signify that
CMSIS headers are available for all supported Cortex-M variants.</p>
</div>
<div class="section" id="testing">
<h2>Testing<a class="headerlink" href="#testing" title="Permalink to this headline">Â¶</a></h2>
<p>A list of unit tests for the Cortex-M porting and miscellaneous features
is present in <code class="file docutils literal notranslate"><span class="pre">tests/arch/arm/</span></code>. The tests suites are continuously
extended and new test suites are added, in an effort to increase the coverage
of the Cortex-M architecture support in Zephyr.</p>
</div>
<div class="section" id="qemu">
<h2>QEMU<a class="headerlink" href="#qemu" title="Permalink to this headline">Â¶</a></h2>
<p>We use QEMU to verify the implemented features of the Cortex-M architecture port in Zephyr.
Adequate coverage is achieved by defining and utilizing a list of QEMU targets,
each with a specific architecture variant and Arm peripheral support list.</p>
<p>The table below lists the QEMU platform targets defined in Zephyr
along with the corresponding Cortex-M implementation variant and the peripherals
these targets emulate.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 27%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 13%" />
<col style="width: 14%" />
<col style="width: 13%" />
</colgroup>
<tbody>
<tr class="row-odd"><td></td>
<td colspan="5"><p><strong>QEMU target</strong></p></td>
</tr>
<tr class="row-even"><td><p>Architecture variant</p></td>
<td><p>Arm v6-M</p></td>
<td colspan="2"><p>Arm v7-M</p></td>
<td><p>Arm v8-M</p></td>
<td><p>Arm v8.1-M</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p><strong>qemu_cortex_m0</strong></p></td>
<td><p><strong>qemu_cortex_m3</strong></p></td>
<td><p><strong>mps2_an385</strong></p></td>
<td><p><strong>mps2_an521</strong></p></td>
<td><p><strong>mps3_an547</strong></p></td>
</tr>
<tr class="row-even"><td><p><strong>Emulated features</strong></p></td>
<td colspan="5"></td>
</tr>
<tr class="row-odd"><td><p>NVIC</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td><p>BASEPRI</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>SysTick</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td><p>MPU</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>FPU</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
</tr>
<tr class="row-even"><td><p>SPLIM</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>TrustZone-M</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="maintainers-collaborators">
<h2>Maintainers &amp; Collaborators<a class="headerlink" href="#maintainers-collaborators" title="Permalink to this headline">Â¶</a></h2>
<p>The status of the Arm Cortex-M architecture port in Zephyr is: <em>maintained</em>.
The updated list of maintainers and collaborators for Cortex-M can be found
in <code class="file docutils literal notranslate"><span class="pre">MAINTAINERS.yml</span></code>.</p>
</div>
</div>


           </div>
          </div>

          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; <a href="../../copyright.html">Copyright</a> 2015-2021 Zephyr Project members and individual contributors.
      <span class="lastupdated">Last updated on Feb 21, 2022.
      </span></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>