<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Memory Protection Design &mdash; Zephyr Project Documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/custom.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/tabs.css" type="text/css" />
    <link rel="shortcut icon" href="../../_static/favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script type="module" src="../../_static/js/dark-mode-toggle.min.mjs"></script>
        <script src="https://www.googletagmanager.com/gtag/js?id=UA-831873-47"></script>
        <script src="../../_static/js/ga-tracker.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="copyright" title="Copyright" href="../../copyright.html" />
    <link rel="next" title="Kernel Objects" href="kernelobjects.html" />
    <link rel="prev" title="Overview" href="overview.html" />
  <meta name="color-scheme" content="dark light">
  
  <link rel="stylesheet" href="../../_static/css/light.css" type="text/css" media="(prefers-color-scheme: light)"/>
  <link rel="stylesheet" href="../../_static/css/dark.css" type="text/css" media="(prefers-color-scheme: dark)"/>

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html">
            <img src="../../_static/logo.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                3.0.99
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
  
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Zephyr Project</span>
      v: latest
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl>
        <dt>Document Release Versions</dt>
        
          <dd><a href="/">latest</a></dd>
        
          <dd><a href="/3.0.0/">3.0.0</a></dd>
        
          <dd><a href="/2.7.0/">2.7.0</a></dd>
        
          <dd><a href="/2.6.0/">2.6.0</a></dd>
        
          <dd><a href="/2.5.0/">2.5.0</a></dd>
        
          <dd><a href="/2.4.0/">2.4.0</a></dd>
        
          <dd><a href="/2.3.0/">2.3.0</a></dd>
        
          <dd><a href="/1.14.1/">1.14.1</a></dd>
        
      </dl>
      <dl>
        <dt>Downloads</dt>
        
        <dd><a href="/latest/zephyr.pdf">PDF</a></dd>
      </dl>
      <dl>
        <dt>zephyrproject.org Links</dt>
          <dd>
            <a href="https://www.zephyrproject.org/">Project Home</a>
          </dd>
          <dd>
            <a href="https://github.com/zephyrproject-rtos/sdk-ng/releases">SDK</a>
          </dd>
          <dd>
            <a href="https://github.com/zephyrproject-rtos/zephyr/releases">Releases</a>
          </dd>
      </dl>
    </div>
  </div>
  
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../introduction/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/index.html">Getting Started Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/index.html">Contribution Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../development_process/index.html">Development and Contribution Process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guides/build/index.html">Build and Configuration Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../application/index.html">Application Development</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../api/index.html">API Status and Guidelines</a></li>
<li class="toctree-l2"><a class="reference internal" href="../audio/index.html">Audio</a></li>
<li class="toctree-l2"><a class="reference internal" href="../misc/notify.html">Asynchronous Notifications</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bluetooth/index.html">Bluetooth</a></li>
<li class="toctree-l2"><a class="reference internal" href="../canbus/index.html">Controller Area Network (CAN)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crypto/index.html">Crypto</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devicetree/index.html">Devicetree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../drivers/index.html">Device Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../display/index.html">Display Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../edac/index.html">Error Detection And Correction (EDAC)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../file_system/index.html">File Systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../iterable_sections/index.html">Iterable Sections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../misc/formatted_output.html">Formatted Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kernel/index.html">Kernel Services</a></li>
<li class="toctree-l2"><a class="reference internal" href="../libc/index.html">C standard library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../logging/index.html">Logging</a></li>
<li class="toctree-l2"><a class="reference internal" href="../memory_management/index.html">Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../misc/index.html">Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data_structures/index.html">Data Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modbus/index.html">Modbus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../networking/index.html">Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../peripherals/index.html">Peripherals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pinctrl/index.html">Pin Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pm/index.html">Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../random/index.html">Random Number Generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../resource_management/index.html">Resource Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../shell/index.html">Shell</a></li>
<li class="toctree-l2"><a class="reference internal" href="../storage/index.html">Storage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../task_wdt/index.html">Task Watchdog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../misc/timeutil.html">Time Utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usb/index.html">USB device support</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">User Mode</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Memory Protection Design</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#boot-time-memory-configuration">Boot Time Memory Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hardware-stack-overflow">Hardware Stack Overflow</a></li>
<li class="toctree-l4"><a class="reference internal" href="#thread-stack">Thread Stack</a></li>
<li class="toctree-l4"><a class="reference internal" href="#thread-resource-pools">Thread Resource Pools</a></li>
<li class="toctree-l4"><a class="reference internal" href="#memory-domains">Memory Domains</a></li>
<li class="toctree-l4"><a class="reference internal" href="#configuration-options">Configuration Options</a></li>
<li class="toctree-l4"><a class="reference internal" href="#api-reference">API Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="kernelobjects.html">Kernel Objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="syscalls.html">System Calls</a></li>
<li class="toctree-l3"><a class="reference internal" href="mpu_stack_objects.html">MPU Stack Objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="mpu_userspace.html">MPU Backed Userspace</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../util/index.html">Utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../settings/index.html">Settings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../timing_functions/index.html">Executing Time Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../virtualization/index.html">Virtualization</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../guides/index.html">User and Developer Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../samples/index.html">Samples and Demos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../boards/index.html">Supported Boards</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../releases/index.html">Release Notes</a></li>
</ul>

  
  <div class="toctree-wrapper compound">
    <p class="caption"><span class="caption-text">Reference</span></p>
    <ul>
      
      <li class="toctree-l1">
        <a class="reference internal" href="/latest/doxygen/html/index.html">API</a>
      </li>
      
      <li class="toctree-l1">
        <a class="reference internal" href="/latest/kconfig.html">Kconfig Options</a>
      </li>
      
      <li class="toctree-l1">
        <a class="reference internal" href="/latest/reference/devicetree/bindings.html">Devicetree Bindings</a>
      </li>
      
    </ul>
  </div>
  

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Zephyr Project</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
  <!-- Docs / Latest -->
  
  

  <li><a href="../../index.html">Docs / Latest</a> &raquo;</li>
  
     <li><a href="../index.html">API Reference</a> &raquo;</li>
  
     <li><a href="index.html">User Mode</a> &raquo;</li>
  
  <li>Memory Protection Design</li>


  <li class="wy-breadcrumbs-aside">
    <dark-mode-toggle id="dark-mode-toggle" appearance="toggle" permanent="true"/>
  </li>
  <li class="wy-breadcrumbs-aside">
      
      
        <a href="https://github.com/zephyrproject-rtos/zephyr/blob/main/doc/reference/usermode/memory_domain.rst" class="fa fa-github"> Open on GitHub</a>
      
    
  </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
  
    <div class="wy-alert wy-alert-danger">
     This is the documentation for the latest (main) development branch of
     Zephyr. If you are looking for the documentation of previous releases, use
     the drop-down menu on the left and select the desired version.
    </div>
  
  
           <div itemprop="articleBody">
             
  <div class="section" id="memory-protection-design">
<span id="memory-domain"></span><h1>Memory Protection Design<a class="headerlink" href="#memory-protection-design" title="Permalink to this headline">¶</a></h1>
<p>Zephyr’s memory protection design is geared towards microcontrollers with MPU
(Memory Protection Unit) hardware. We do support some architectures, such as x86,
which have a paged MMU (Memory Management Unit), but in that case the MMU is
used like an MPU with an identity page table.</p>
<p>All of the discussion below will be using MPU terminology; systems with MMUs
can be considered to have an MPU with an unlimited number of programmable
regions.</p>
<p>There are a few different levels on how memory access is configured when
Zephyr memory protection features are enabled, which we will describe here:</p>
<div class="section" id="boot-time-memory-configuration">
<h2>Boot Time Memory Configuration<a class="headerlink" href="#boot-time-memory-configuration" title="Permalink to this headline">¶</a></h2>
<p>This is the configuration of the MPU after the kernel has started up. It should
contain the following:</p>
<ul class="simple">
<li><p>Any configuration of memory regions which need to have special caching or
write-back policies for basic hardware and driver function. Note that most
MPUs have the concept of a default memory access policy map, which can be
enabled as a “background” mapping for any area of memory that doesn’t
have an MPU region configuring it. It is strongly recommended to use this
to maximize the number of available MPU regions for the end user. On
ARMv7-M/ARMv8-M this is called the System Address Map, other CPUs may
have similar capabilities.</p></li>
<li><p>A read-only, executable region or regions for program text and ro-data, that
is accessible to user mode. This could be further sub-divided into a
read-only region for ro-data, and a read-only, executable region for text, but
this will require an additional MPU region. This is required so that
threads running in user mode can read ro-data and fetch instructions.</p></li>
<li><p>Depending on configuration, user-accessible read-write regions to support
extra features like GCOV, HEP, etc.</p></li>
</ul>
<p>Assuming there is a background map which allows supervisor mode to access any
memory it needs, and regions are defined which grant user mode access to
text/ro-data, this is sufficient for the boot time configuration.</p>
</div>
<div class="section" id="hardware-stack-overflow">
<h2>Hardware Stack Overflow<a class="headerlink" href="#hardware-stack-overflow" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="../../kconfig.html#CONFIG_HW_STACK_PROTECTION" title="CONFIG_HW_STACK_PROTECTION"><code class="xref kconfig kconfig-option docutils literal notranslate"><span class="pre">CONFIG_HW_STACK_PROTECTION</span></code></a> is an optional feature which detects stack
buffer overflows when the system is running in supervisor mode. This
catches issues when the entire stack buffer has overflowed, and not
individual stack frames, use compiler-assisted <a class="reference internal" href="../../kconfig.html#CONFIG_STACK_CANARIES" title="CONFIG_STACK_CANARIES"><code class="xref kconfig kconfig-option docutils literal notranslate"><span class="pre">CONFIG_STACK_CANARIES</span></code></a>
for that.</p>
<p>Like any crash in supervisor mode, no guarantees can be made about the overall
health of the system after a supervisor mode stack overflow, and any instances
of this should be treated as a serious error. However it’s still very useful to
know when these overflows happen, as without robust detection logic the system
will either crash in mysterious ways or behave in an undefined manner when the
stack buffer overflows.</p>
<p>Some systems implement this feature by creating at runtime a ‘guard’ MPU region
which is set to be read-only and is at either the beginning or immediately
preceding the supervisor mode stack buffer.  If the stack overflows an
exception will be generated.</p>
<p>This feature is optional and is not required to catch stack overflows in user
mode; disabling this may free 1-2 MPU regions depending on the MPU design.</p>
<p>Other systems may have dedicated CPU support for catching stack overflows
and no extra MPU regions will be required.</p>
</div>
<div class="section" id="thread-stack">
<h2>Thread Stack<a class="headerlink" href="#thread-stack" title="Permalink to this headline">¶</a></h2>
<p>Any thread running in user mode will need access to its own stack buffer.
On context switch into a user mode thread, a dedicated MPU region will be
programmed with the bounds of the stack buffer. A thread exceeding its stack
buffer will start pushing data onto memory it doesn’t have access to and a
memory access violation exception will be generated.</p>
</div>
<div class="section" id="thread-resource-pools">
<h2>Thread Resource Pools<a class="headerlink" href="#thread-resource-pools" title="Permalink to this headline">¶</a></h2>
<p>A small subset of kernel APIs, invoked as system calls, require heap memory
allocations. This memory is used only by the kernel and is not accessible
directly by user mode. In order to use these system calls, invoking threads
must assign themselves to a resource pool, which is a k_mem_pool object.
Memory is drawn from a thread’s resource pool using <code class="xref c c-func docutils literal notranslate"><span class="pre">z_thread_malloc()</span></code>
and freed with <a class="reference internal" href="../kernel/memory/heap.html#c.k_free" title="k_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_free()</span></code></a>.</p>
<p>The APIs which use resource pools are as follows, with any alternatives
noted for users who do not want heap allocations within their application:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="../kernel/data_passing/stacks.html#c.k_stack_alloc_init" title="k_stack_alloc_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_stack_alloc_init()</span></code></a> sets up a k_stack with its storage
buffer allocated out of a resource pool instead of a buffer provided by the
user. An alternative is to declare k_stacks that are automatically
initialized at boot with <a class="reference internal" href="../kernel/data_passing/stacks.html#c.K_STACK_DEFINE" title="K_STACK_DEFINE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">K_STACK_DEFINE()</span></code></a>, or to initialize the
k_stack in supervisor mode with <a class="reference internal" href="../kernel/data_passing/stacks.html#c.k_stack_init" title="k_stack_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_stack_init()</span></code></a>.</p></li>
<li><p><a class="reference internal" href="../kernel/data_passing/pipes.html#c.k_pipe_alloc_init" title="k_pipe_alloc_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_pipe_alloc_init()</span></code></a> sets up a k_pipe object with its
storage buffer allocated out of a resource pool instead of a buffer provided
by the user. An alternative is to declare k_pipes that are automatically
initialized at boot with <a class="reference internal" href="../kernel/data_passing/pipes.html#c.K_PIPE_DEFINE" title="K_PIPE_DEFINE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">K_PIPE_DEFINE()</span></code></a>, or to initialize the
k_pipe in supervisor mode with <a class="reference internal" href="../kernel/data_passing/pipes.html#c.k_pipe_init" title="k_pipe_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_pipe_init()</span></code></a>.</p></li>
<li><p><a class="reference internal" href="../kernel/data_passing/message_queues.html#c.k_msgq_alloc_init" title="k_msgq_alloc_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_msgq_alloc_init()</span></code></a> sets up a k_msgq object with its
storage buffer allocated out of a resource pool instead of a buffer provided
by the user. An alternative is to declare a k_msgq that is automatically
initialized at boot with <a class="reference internal" href="../kernel/data_passing/message_queues.html#c.K_MSGQ_DEFINE" title="K_MSGQ_DEFINE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">K_MSGQ_DEFINE()</span></code></a>, or to initialize the
k_msgq in supervisor mode with <a class="reference internal" href="../kernel/data_passing/message_queues.html#c.k_msgq_init" title="k_msgq_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_msgq_init()</span></code></a>.</p></li>
<li><p><a class="reference internal" href="../kernel/other/polling.html#c.k_poll" title="k_poll"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_poll()</span></code></a> when invoked from user mode, needs to make a kernel-side
copy of the provided events array while waiting for an event. This copy is
freed when <a class="reference internal" href="../kernel/other/polling.html#c.k_poll" title="k_poll"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_poll()</span></code></a> returns for any reason.</p></li>
<li><p><a class="reference internal" href="../kernel/data_passing/queues.html#c.k_queue_alloc_prepend" title="k_queue_alloc_prepend"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_queue_alloc_prepend()</span></code></a> and <a class="reference internal" href="../kernel/data_passing/queues.html#c.k_queue_alloc_append" title="k_queue_alloc_append"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_queue_alloc_append()</span></code></a>
allocate a container structure to place the data in, since the internal
bookkeeping information that defines the queue cannot be placed in the
memory provided by the user.</p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">k_object_alloc()</span></code> allows for entire kernel objects to be
dynamically allocated at runtime and a usable pointer to them returned to
the caller.</p></li>
</ul>
</div></blockquote>
<p>The relevant API is <a class="reference internal" href="../kernel/threads/index.html#c.k_thread_heap_assign" title="k_thread_heap_assign"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_thread_heap_assign()</span></code></a> which assigns
a k_heap to draw these allocations from for the target thread.</p>
<p>If the system heap is enabled, then the system heap may be used with
<a class="reference internal" href="../kernel/threads/index.html#c.k_thread_system_pool_assign" title="k_thread_system_pool_assign"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_thread_system_pool_assign()</span></code></a>, but it is preferable for different
logical applications running on the system to have their own pools.</p>
</div>
<div class="section" id="memory-domains">
<h2>Memory Domains<a class="headerlink" href="#memory-domains" title="Permalink to this headline">¶</a></h2>
<p>The kernel ensures that any user thread will have access to its own stack
buffer, plus program text and read-only data. The memory domain APIs are the
way to grant access to additional blocks of memory to a user thread.</p>
<p>Conceptually, a memory domain is a collection of some number of memory
partitions. The maximum number of memory partitions in a domain
is limited by the number of available MPU regions. This is why it is important
to minimize the number of boot-time MPU regions.</p>
<p>Memory domains are <em>not</em> intended to control access to memory from supervisor
mode. In some cases this may be unavoidable; for example some architectures do
not allow for the definition of regions which are read-only to user mode but
read-write to supervisor mode. A great deal of care must be taken when working
with such regions to not unintentionally cause the kernel to crash when
accessing such a region. Any attempt to use memory domain APIs to control
supervisor mode access is at best undefined behavior; supervisor mode access
policy is only intended to be controlled by boot-time memory regions.</p>
<p>Memory domain APIs are only available to supervisor mode. The only control
user mode has over memory domains is that any user thread’s child threads
will automatically become members of the parent’s domain.</p>
<p>All threads are members of a memory domain, including supervisor threads
(even though this has no implications on their memory access). There is a
default domain <code class="docutils literal notranslate"><span class="pre">k_mem_domain_default</span></code> which will be assigned to threads if
they have not been specifically assigned to a domain, or inherited a memory
domain membership from their parent thread. The main thread starts as a
member of the default domain.</p>
<div class="section" id="memory-partitions">
<h3>Memory Partitions<a class="headerlink" href="#memory-partitions" title="Permalink to this headline">¶</a></h3>
<p>Each memory partition consists of a memory address, a size,
and access attributes. It is intended that memory partitions are used to
control access to system memory. Defining memory partitions are subject
to the following constraints:</p>
<ul class="simple">
<li><p>The partition must represent a memory region that can be programmed by
the underlying memory management hardware, and needs to conform to any
underlying hardware constraints. For example, many MPU-based systems require
that partitions be sized to some power of two, and aligned to their own
size. For MMU-based systems, the partition must be aligned to a page and
the size some multiple of the page size.</p></li>
<li><p>Partitions within the same memory domain may not overlap each other. There is
no notion of precedence among partitions within a memory domain.  Partitions
within a memory domain are assumed to have a higher precedence than any
boot-time memory regions, however whether a memory domain partition can
overlap a boot-time memory region is architecture specific.</p></li>
<li><p>The same partition may be specified in multiple memory domains. For example
there may be a shared memory area that multiple domains grant access to.</p></li>
<li><p>Care must be taken in determining what memory to expose in a partition.
It is not appropriate to provide direct user mode access to any memory
containing private kernel data.</p></li>
<li><p>Memory domain partitions are intended to control access to system RAM.
Configuration of memory partitions which do not correspond to RAM
may not be supported by the architecture; this is true for MMU-based systems.</p></li>
</ul>
<p>There are two ways to define memory partitions: either manually or
automatically.</p>
<div class="section" id="manual-memory-partitions">
<h4>Manual Memory Partitions<a class="headerlink" href="#manual-memory-partitions" title="Permalink to this headline">¶</a></h4>
<p>The following code declares a global array <code class="docutils literal notranslate"><span class="pre">buf</span></code>, and then declares
a read-write partition for it which may be added to a domain:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint8_t</span><span class="w"> </span><span class="nf">__aligned</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span><span class="w"></span>

<span class="n">K_MEM_PARTITION_DEFINE</span><span class="p">(</span><span class="n">my_partition</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span><span class="w"></span>
<span class="w">                       </span><span class="n">K_MEM_PARTITION_P_RW_U_RW</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>This does not scale particularly well when we are trying to contain multiple
objects spread out across several C files into a single partition.</p>
</div>
<div class="section" id="automatic-memory-partitions">
<h4>Automatic Memory Partitions<a class="headerlink" href="#automatic-memory-partitions" title="Permalink to this headline">¶</a></h4>
<p>Automatic memory partitions are created by the build system. All globals
which need to be placed inside a partition are tagged with their destination
partition. The build system will then coalesce all of these into a single
contiguous block of memory, zero any BSS variables at boot, and define
a memory partition of appropriate base address and size which contains all
the tagged data.</p>
<div class="figure align-center" id="id1">
<img alt="Automatic Memory Domain build flow" src="../../_images/auto_mem_domain.png" />
<p class="caption"><span class="caption-number">Fig. 17 </span><span class="caption-text">Automatic Memory Domain build flow</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
<p>Automatic memory partitions are only configured as read-write
regions. They are defined with <code class="xref c c-macro docutils literal notranslate"><span class="pre">K_APPMEM_PARTITION_DEFINE()</span></code>.
Global variables are then routed to this partition using
<code class="xref c c-macro docutils literal notranslate"><span class="pre">K_APP_DMEM()</span></code> for initialized data and <code class="xref c c-macro docutils literal notranslate"><span class="pre">K_APP_BMEM()</span></code> for
BSS.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;app_memory/app_memdomain.h&gt;</span><span class="cp"></span>

<span class="cm">/* Declare a k_mem_partition &quot;my_partition&quot; that is read-write to</span>
<span class="cm"> * user mode. Note that we do not specify a base address or size.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="n">K_APPMEM_PARTITION_DEFINE</span><span class="p">(</span><span class="n">my_partition</span><span class="p">);</span><span class="w"></span>

<span class="cm">/* The global variable var1 will be inside the bounds of my_partition</span>
<span class="cm"> * and be initialized with 37 at boot.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="n">K_APP_DMEM</span><span class="p">(</span><span class="n">my_partition</span><span class="p">)</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">var1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">37</span><span class="p">;</span><span class="w"></span>

<span class="cm">/* The global variable var2 will be inside the bounds of my_partition</span>
<span class="cm"> * and be zeroed at boot size K_APP_BMEM() was used, indicating a BSS</span>
<span class="cm"> * variable.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="n">K_APP_BMEM</span><span class="p">(</span><span class="n">my_partition</span><span class="p">)</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">var2</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>The build system will ensure that the base address of <code class="docutils literal notranslate"><span class="pre">my_partition</span></code> will
be properly aligned, and the total size of the region conforms to the memory
management hardware requirements, adding padding if necessary.</p>
<p>If multiple partitions are being created, a variadic preprocessor macro can be
used as provided in <code class="docutils literal notranslate"><span class="pre">app_macro_support.h</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">FOR_EACH</span><span class="p">(</span><span class="n">K_APPMEM_PARTITION_DEFINE</span><span class="p">,</span><span class="w"> </span><span class="n">part0</span><span class="p">,</span><span class="w"> </span><span class="n">part1</span><span class="p">,</span><span class="w"> </span><span class="n">part2</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<div class="section" id="automatic-partitions-for-static-library-globals">
<h5>Automatic Partitions for Static Library Globals<a class="headerlink" href="#automatic-partitions-for-static-library-globals" title="Permalink to this headline">¶</a></h5>
<p>The build-time logic for setting up automatic memory partitions is in
<code class="docutils literal notranslate"><span class="pre">scripts/gen_app_partitions.py</span></code>. If a static library is linked into Zephyr,
it is possible to route all the globals in that library to a specific
memory partition with the <code class="docutils literal notranslate"><span class="pre">--library</span></code> argument.</p>
<p>For example, if the Newlib C library is enabled, the Newlib globals all need
to be placed in <code class="docutils literal notranslate"><span class="pre">z_libc_partition</span></code>. The invocation of the script in the
top-level <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> adds the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>gen_app_partitions.py ... --library libc.a z_libc_partition ..
</pre></div>
</div>
<p>For pre-compiled libraries there is no support for expressing this in the
project-level configuration or build files; the toplevel <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> must
be edited.</p>
<p>For Zephyr libraries created using <code class="docutils literal notranslate"><span class="pre">zephyr_library</span></code> or <code class="docutils literal notranslate"><span class="pre">zephyr_library_named</span></code>
the <code class="docutils literal notranslate"><span class="pre">zephyr_library_app_memory</span></code> function can be used to specify the memory
partition where all globals in the library should be placed.</p>
</div>
</div>
<div class="section" id="pre-defined-memory-partitions">
<h4>Pre-defined Memory Partitions<a class="headerlink" href="#pre-defined-memory-partitions" title="Permalink to this headline">¶</a></h4>
<p>There are a few memory partitions which are pre-defined by the system:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">z_malloc_partition</span></code> - This partition contains the system-wide pool of
memory used by libc malloc(). Due to possible starvation issues, it is
not recommended to draw heap memory from a global pool, instead
it is better to define various sys_heap objects and assign them
to specific memory domains.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">z_libc_partition</span></code> - Contains globals required by the C library and runtime.
Required when using either the Minimal C library or the Newlib C Library.
Required when option:<cite>CONFIG_STACK_CANARIES</cite> is enabled.</p></li>
</ul>
</div></blockquote>
<p>Library-specific partitions are listed in <code class="docutils literal notranslate"><span class="pre">include/app_memory/partitions.h</span></code>.
For example, to use the MBEDTLS library from user mode, the
<code class="docutils literal notranslate"><span class="pre">k_mbedtls_partition</span></code> must be added to the domain.</p>
</div>
</div>
<div class="section" id="memory-domain-usage">
<h3>Memory Domain Usage<a class="headerlink" href="#memory-domain-usage" title="Permalink to this headline">¶</a></h3>
<div class="section" id="create-a-memory-domain">
<h4>Create a Memory Domain<a class="headerlink" href="#create-a-memory-domain" title="Permalink to this headline">¶</a></h4>
<p>A memory domain is defined using a variable of type
<a class="reference internal" href="#c.k_mem_domain" title="k_mem_domain"><code class="xref c c-struct docutils literal notranslate"><span class="pre">k_mem_domain</span></code></a>. It must then be initialized by calling
<a class="reference internal" href="#c.k_mem_domain_init" title="k_mem_domain_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_mem_domain_init()</span></code></a>.</p>
<p>The following code defines and initializes an empty memory domain.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">k_mem_domain</span><span class="w"> </span><span class="n">app0_domain</span><span class="p">;</span><span class="w"></span>

<span class="n">k_mem_domain_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">app0_domain</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="add-memory-partitions-into-a-memory-domain">
<h4>Add Memory Partitions into a Memory Domain<a class="headerlink" href="#add-memory-partitions-into-a-memory-domain" title="Permalink to this headline">¶</a></h4>
<p>There are two ways to add memory partitions into a memory domain.</p>
<p>This first code sample shows how to add memory partitions while creating
a memory domain.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* the start address of the MPU region needs to align with its size */</span><span class="w"></span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="nf">__aligned</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="n">app0_buf</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span><span class="w"></span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="nf">__aligned</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="n">app1_buf</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span><span class="w"></span>

<span class="n">K_MEM_PARTITION_DEFINE</span><span class="p">(</span><span class="n">app0_part0</span><span class="p">,</span><span class="w"> </span><span class="n">app0_buf</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">app0_buf</span><span class="p">),</span><span class="w"></span>
<span class="w">                       </span><span class="n">K_MEM_PARTITION_P_RW_U_RW</span><span class="p">);</span><span class="w"></span>

<span class="n">K_MEM_PARTITION_DEFINE</span><span class="p">(</span><span class="n">app0_part1</span><span class="p">,</span><span class="w"> </span><span class="n">app1_buf</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">app1_buf</span><span class="p">),</span><span class="w"></span>
<span class="w">                       </span><span class="n">K_MEM_PARTITION_P_RW_U_RO</span><span class="p">);</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">k_mem_partition</span><span class="w"> </span><span class="o">*</span><span class="n">app0_parts</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">app0_part0</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">app0_part1</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="n">k_mem_domain_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">app0_domain</span><span class="p">,</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">app0_parts</span><span class="p">),</span><span class="w"> </span><span class="n">app0_parts</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>This second code sample shows how to add memory partitions into an initialized
memory domain one by one.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* the start address of the MPU region needs to align with its size */</span><span class="w"></span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="nf">__aligned</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="n">app0_buf</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span><span class="w"></span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="nf">__aligned</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="n">app1_buf</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span><span class="w"></span>

<span class="n">K_MEM_PARTITION_DEFINE</span><span class="p">(</span><span class="n">app0_part0</span><span class="p">,</span><span class="w"> </span><span class="n">app0_buf</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">app0_buf</span><span class="p">),</span><span class="w"></span>
<span class="w">                       </span><span class="n">K_MEM_PARTITION_P_RW_U_RW</span><span class="p">);</span><span class="w"></span>

<span class="n">K_MEM_PARTITION_DEFINE</span><span class="p">(</span><span class="n">app0_part1</span><span class="p">,</span><span class="w"> </span><span class="n">app1_buf</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">app1_buf</span><span class="p">),</span><span class="w"></span>
<span class="w">                       </span><span class="n">K_MEM_PARTITION_P_RW_U_RO</span><span class="p">);</span><span class="w"></span>

<span class="n">k_mem_domain_add_partition</span><span class="p">(</span><span class="o">&amp;</span><span class="n">app0_domain</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">app0_part0</span><span class="p">);</span><span class="w"></span>
<span class="n">k_mem_domain_add_partition</span><span class="p">(</span><span class="o">&amp;</span><span class="n">app0_domain</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">app0_part1</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The maximum number of memory partitions is limited by the maximum
number of MPU regions or the maximum number of MMU tables.</p>
</div>
</div>
<div class="section" id="memory-domain-assignment">
<h4>Memory Domain Assignment<a class="headerlink" href="#memory-domain-assignment" title="Permalink to this headline">¶</a></h4>
<p>Any thread may join a memory domain, and any memory domain may have multiple
threads assigned to it. Threads are assigned to memory domains with an API
call:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">k_mem_domain_add_thread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">app0_domain</span><span class="p">,</span><span class="w"> </span><span class="n">app_thread_id</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>If the thread was already a member of some other domain (including the
default domain), it will be removed from it in favor of the new one.</p>
<p>In addition, if a thread is a member of a memory domain, and it creates a
child thread, that thread will belong to the domain as well.</p>
</div>
<div class="section" id="remove-a-memory-partition-from-a-memory-domain">
<h4>Remove a Memory Partition from a Memory Domain<a class="headerlink" href="#remove-a-memory-partition-from-a-memory-domain" title="Permalink to this headline">¶</a></h4>
<p>The following code shows how to remove a memory partition from a memory
domain.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">k_mem_domain_remove_partition</span><span class="p">(</span><span class="o">&amp;</span><span class="n">app0_domain</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">app0_part1</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The k_mem_domain_remove_partition() API finds the memory partition
that matches the given parameter and removes that partition from the
memory domain.</p>
</div>
<div class="section" id="available-partition-attributes">
<h4>Available Partition Attributes<a class="headerlink" href="#available-partition-attributes" title="Permalink to this headline">¶</a></h4>
<p>When defining a partition, we need to set access permission attributes
to the partition. Since the access control of memory partitions relies on
either an MPU or MMU, the available partition attributes would be architecture
dependent.</p>
<p>The complete list of available partition attributes for a specific architecture
is found in the architecture-specific include file
<code class="docutils literal notranslate"><span class="pre">include/arch/&lt;arch</span> <span class="pre">name&gt;/arch.h</span></code>, (for example, <code class="docutils literal notranslate"><span class="pre">include/arch/arm/aarch32/arch.h</span></code>.)
Some examples of partition attributes are:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Denote partition is privileged read/write, unprivileged read/write */</span><span class="w"></span>
<span class="n">K_MEM_PARTITION_P_RW_U_RW</span><span class="w"></span>
<span class="cm">/* Denote partition is privileged read/write, unprivileged read-only */</span><span class="w"></span>
<span class="n">K_MEM_PARTITION_P_RW_U_RO</span><span class="w"></span>
</pre></div>
</div>
<p>In almost all cases <code class="docutils literal notranslate"><span class="pre">K_MEM_PARTITION_P_RW_U_RW</span></code> is the right choice.</p>
</div>
</div>
</div>
<div class="section" id="configuration-options">
<h2>Configuration Options<a class="headerlink" href="#configuration-options" title="Permalink to this headline">¶</a></h2>
<p>Related configuration options:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../../kconfig.html#CONFIG_MAX_DOMAIN_PARTITIONS" title="CONFIG_MAX_DOMAIN_PARTITIONS"><code class="xref kconfig kconfig-option docutils literal notranslate"><span class="pre">CONFIG_MAX_DOMAIN_PARTITIONS</span></code></a></p></li>
</ul>
</div>
<div class="section" id="api-reference">
<h2>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h2>
<p>The following memory domain APIs are provided by <a class="reference external" href="https://github.com/zephyrproject-rtos/zephyr/blob/main/include/kernel.h">include/kernel.h</a>:</p>
<dl>
<dt class="sig sig-object cpp">
<span class="target" id="group__mem__domain__apis"></span><em><span class="pre">group</span></em> <span class="sig-name descname"><span class="pre">mem_domain_apis</span></span></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-defines">Defines</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.K_MEM_PARTITION_DEFINE">
<span class="target" id="group__mem__domain__apis_1ga4360fd595cb3fe3a10b58c12ae2b7ece"></span><span class="sig-name descname"><span class="n"><span class="pre">K_MEM_PARTITION_DEFINE</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">name</span></span>, <span class="n"><span class="pre">start</span></span>, <span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">attr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.K_MEM_PARTITION_DEFINE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Statically declare a memory partition. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.k_mem_domain_init">
<span class="target" id="group__mem__domain__apis_1ga8a987bc85c02925685fe87213fe26c5a"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_mem_domain_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_mem_domain" title="k_mem_domain"><span class="n"><span class="pre">k_mem_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">domain</span></span>, <span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="n"><span class="pre">num_parts</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_mem_partition" title="k_mem_partition"><span class="n"><span class="pre">k_mem_partition</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parts</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_mem_domain_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a memory domain. </p>
<p>Initialize a memory domain with given name and memory partitions.</p>
<p>See documentation for <a class="reference internal" href="#group__mem__domain__apis_1ga07da0cf76f8db54373b88d40be63b138"><span class="std std-ref">k_mem_domain_add_partition()</span></a> for details about partition constraints.</p>
<p>Do not call <a class="reference internal" href="#group__mem__domain__apis_1ga8a987bc85c02925685fe87213fe26c5a"><span class="std std-ref">k_mem_domain_init()</span></a> on the same memory domain more than once, doing so is undefined behavior.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain</strong> – The memory domain to be initialized. </p></li>
<li><p><strong>num_parts</strong> – The number of array items of “parts” parameter. </p></li>
<li><p><strong>parts</strong> – An array of pointers to the memory partitions. Can be NULL if num_parts is zero.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>0</strong> – if successful </p></li>
<li><p><strong>-EINVAL</strong> – if invalid parameters supplied </p></li>
<li><p><strong>-ENOMEM</strong> – if insufficient memory </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_mem_domain_add_partition">
<span class="target" id="group__mem__domain__apis_1ga07da0cf76f8db54373b88d40be63b138"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_mem_domain_add_partition</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_mem_domain" title="k_mem_domain"><span class="n"><span class="pre">k_mem_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">domain</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_mem_partition" title="k_mem_partition"><span class="n"><span class="pre">k_mem_partition</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">part</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_mem_domain_add_partition" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add a memory partition into a memory domain. </p>
<p>Add a memory partition into a memory domain. Partitions must conform to the following constraints:</p>
<p><ul class="simple">
<li><p>Partitions in the same memory domain may not overlap each other.</p></li>
<li><p>Partitions must not be defined which expose private kernel data structures or kernel objects.</p></li>
<li><p>The starting address alignment, and the partition size must conform to the constraints of the underlying memory management hardware, which varies per architecture.</p></li>
<li><p>Memory domain partitions are only intended to control access to memory from user mode threads.</p></li>
<li><p>If CONFIG_EXECUTE_XOR_WRITE is enabled, the partition must not allow both writes and execution.</p></li>
</ul>
</p>
<p>Violating these constraints may lead to CPU exceptions or undefined behavior.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain</strong> – The memory domain to be added a memory partition. </p></li>
<li><p><strong>part</strong> – The memory partition to be added</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>0</strong> – if successful </p></li>
<li><p><strong>-EINVAL</strong> – if invalid parameters supplied </p></li>
<li><p><strong>-ENOSPC</strong> – if no free partition slots available </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_mem_domain_remove_partition">
<span class="target" id="group__mem__domain__apis_1gada4f8ce609d6b720ee88e11544555fc2"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_mem_domain_remove_partition</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_mem_domain" title="k_mem_domain"><span class="n"><span class="pre">k_mem_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">domain</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_mem_partition" title="k_mem_partition"><span class="n"><span class="pre">k_mem_partition</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">part</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_mem_domain_remove_partition" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Remove a memory partition from a memory domain. </p>
<p>Remove a memory partition from a memory domain.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain</strong> – The memory domain to be removed a memory partition. </p></li>
<li><p><strong>part</strong> – The memory partition to be removed</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>0</strong> – if successful </p></li>
<li><p><strong>-EINVAL</strong> – if invalid parameters supplied </p></li>
<li><p><strong>-ENOENT</strong> – if no matching partition found </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_mem_domain_add_thread">
<span class="target" id="group__mem__domain__apis_1ga7b4d6148d9375f020a268961d5afde2d"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_mem_domain_add_thread</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_mem_domain" title="k_mem_domain"><span class="n"><span class="pre">k_mem_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">domain</span></span>, <span class="n"><span class="pre">k_tid_t</span></span><span class="w"> </span><span class="n"><span class="pre">thread</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_mem_domain_add_thread" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add a thread into a memory domain. </p>
<p>Add a thread into a memory domain. It will be removed from whatever memory domain it previously belonged to.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain</strong> – The memory domain that the thread is going to be added into. </p></li>
<li><p><strong>thread</strong> – ID of thread going to be added into the memory domain.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0 if successful, fails otherwise. </p>
</dd>
</dl>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-variables">Variables</p>
<dl class="c var">
<dt class="sig sig-object c" id="c.k_mem_domain_default">
<span class="target" id="group__mem__domain__apis_1ga3613abdb546a66059fa3f621a2ebd41a"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_mem_domain" title="k_mem_domain"><span class="n"><span class="pre">k_mem_domain</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_mem_domain_default</span></span></span><a class="headerlink" href="#c.k_mem_domain_default" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Default memory domain</p>
<p>All threads are a member of some memory domain, even if running in supervisor mode. Threads belong to this default memory domain if they haven’t been added to or inherited membership from some other domain.</p>
<p>This memory domain has the z_libc_partition partition for the C library added to it if exists. </p>
</dd></dl>

</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.k_mem_partition">
<span class="target" id="structk__mem__partition"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_mem_partition</span></span></span><a class="headerlink" href="#c.k_mem_partition" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="docutils container">
<em>#include &lt;mem_domain.h&gt;</em></div>
<p>Memory Partition. </p>
<p>A memory partition is a region of memory in the linear address space with a specific access policy.</p>
<p>The alignment of the starting address, and the alignment of the size value may have varying requirements based on the capabilities of the underlying memory management hardware; arbitrary values are unlikely to work. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="c var">
<dt class="sig sig-object c" id="c.k_mem_partition.start">
<span class="target" id="structk__mem__partition_1a654d19bfd6a1154f410ac6f3c481c5b7"></span><span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">start</span></span></span><a class="headerlink" href="#c.k_mem_partition.start" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>start address of memory partition </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.k_mem_partition.size">
<span class="target" id="structk__mem__partition_1ab3cb68302158f3dced41dbff4cbb226c"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">size</span></span></span><a class="headerlink" href="#c.k_mem_partition.size" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>size of memory partition </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.k_mem_partition.attr">
<span class="target" id="structk__mem__partition_1ada951ba1ec9429c98c16761e3093eedb"></span><span class="n"><span class="pre">k_mem_partition_attr_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">attr</span></span></span><a class="headerlink" href="#c.k_mem_partition.attr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>attribute of memory partition </p>
</dd></dl>

</div>
</dd></dl>

<dl class="c struct">
<dt class="sig sig-object c" id="c.k_mem_domain">
<span class="target" id="structk__mem__domain"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_mem_domain</span></span></span><a class="headerlink" href="#c.k_mem_domain" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="docutils container">
<em>#include &lt;mem_domain.h&gt;</em></div>
<p>Memory Domain. </p>
<p>A memory domain is a collection of memory partitions, used to represent a user thread’s access policy for the linear addresss space. A thread may be a member of only one memory domain, but any memory domain may have multiple threads that are members.</p>
<p>Supervisor threads may also be a member of a memory domain; this has no implications on their memory access but can be useful as any child threads inherit the memory domain membership of the parent.</p>
<p>A user thread belonging to a memory domain with no active partitions will have guaranteed access to its own stack buffer, program text, and read-only data. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="c var">
<dt class="sig sig-object c" id="c.k_mem_domain.partitions">
<span class="target" id="structk__mem__domain_1a48cbffd5f2e85bee1b4b5b02b753980e"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_mem_partition" title="k_mem_partition"><span class="n"><span class="pre">k_mem_partition</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">partitions</span></span></span><span class="p"><span class="pre">[</span></span><span class="n"><span class="pre">CONFIG_MAX_DOMAIN_PARTITIONS</span></span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#c.k_mem_domain.partitions" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>partitions in the domain </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.k_mem_domain.mem_domain_q">
<span class="target" id="structk__mem__domain_1afc3d3a778e84fe98d778f548d707929a"></span><a class="reference internal" href="../data_structures/dlist.html#c.sys_dlist_t" title="sys_dlist_t"><span class="n"><span class="pre">sys_dlist_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mem_domain_q</span></span></span><a class="headerlink" href="#c.k_mem_domain.mem_domain_q" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Doubly linked list of member threads </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.k_mem_domain.num_partitions">
<span class="target" id="structk__mem__domain_1abc876ea435863315f66631e28e49ab8a"></span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">num_partitions</span></span></span><a class="headerlink" href="#c.k_mem_domain.num_partitions" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>number of active partitions in the domain </p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
          </div>

          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; <a href="../../copyright.html">Copyright</a> 2015-2022 Zephyr Project members and individual contributors.
      <span class="lastupdated">Last updated on Mar 05, 2022.
      </span></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>