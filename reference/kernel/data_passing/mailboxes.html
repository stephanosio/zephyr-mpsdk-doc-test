<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mailboxes &mdash; Zephyr Project Documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/tabs.css" type="text/css" />
    <link rel="shortcut icon" href="../../../_static/favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script type="module" src="../../../_static/js/dark-mode-toggle.min.mjs"></script>
        <script src="https://www.googletagmanager.com/gtag/js?id=UA-831873-47"></script>
        <script src="../../../_static/js/ga-tracker.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="copyright" title="Copyright" href="../../../copyright.html" />
    <link rel="next" title="Pipes" href="pipes.html" />
    <link rel="prev" title="Message Queues" href="message_queues.html" />
  <meta name="color-scheme" content="dark light">
  
  <link rel="stylesheet" href="../../../_static/css/light.css" type="text/css" media="(prefers-color-scheme: light)"/>
  <link rel="stylesheet" href="../../../_static/css/dark.css" type="text/css" media="(prefers-color-scheme: dark)"/>

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html">
            <img src="../../../_static/logo.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                3.0.0-rc3
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
  
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Zephyr Project</span>
      v: latest
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl>
        <dt>Document Release Versions</dt>
        
          <dd><a href="/">latest</a></dd>
        
          <dd><a href="/2.7.0/">2.7.0</a></dd>
        
          <dd><a href="/2.6.0/">2.6.0</a></dd>
        
          <dd><a href="/2.5.0/">2.5.0</a></dd>
        
          <dd><a href="/2.4.0/">2.4.0</a></dd>
        
          <dd><a href="/2.3.0/">2.3.0</a></dd>
        
          <dd><a href="/1.14.1/">1.14.1</a></dd>
        
      </dl>
      <dl>
        <dt>Downloads</dt>
        
        <dd><a href="/latest/zephyr.pdf">PDF</a></dd>
      </dl>
      <dl>
        <dt>zephyrproject.org Links</dt>
          <dd>
            <a href="https://www.zephyrproject.org/">Project Home</a>
          </dd>
          <dd>
            <a href="https://github.com/zephyrproject-rtos/sdk-ng/releases">SDK</a>
          </dd>
          <dd>
            <a href="https://github.com/zephyrproject-rtos/zephyr/releases">Releases</a>
          </dd>
      </dl>
    </div>
  </div>
  
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../introduction/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/index.html">Getting Started Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contribute/index.html">Contribution Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../development_process/index.html">Development and Contribution Process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/build/index.html">Build and Configuration Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../application/index.html">Application Development</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../api/index.html">API Status and Guidelines</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../audio/index.html">Audio</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/notify.html">Asynchronous Notifications</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../bluetooth/index.html">Bluetooth</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../canbus/index.html">Controller Area Network (CAN)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../crypto/index.html">Crypto</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devicetree/index.html">Devicetree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../drivers/index.html">Device Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../display/index.html">Display Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../edac/index.html">Error Detection And Correction (EDAC)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../file_system/index.html">File Systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../iterable_sections/index.html">Iterable Sections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/formatted_output.html">Formatted Output</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">Kernel Services</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../index.html#scheduling-interrupts-and-synchronization">Scheduling, Interrupts, and Synchronization</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../index.html#data-passing">Data Passing</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="queues.html">Queues</a></li>
<li class="toctree-l4"><a class="reference internal" href="fifos.html">FIFOs</a></li>
<li class="toctree-l4"><a class="reference internal" href="lifos.html">LIFOs</a></li>
<li class="toctree-l4"><a class="reference internal" href="stacks.html">Stacks</a></li>
<li class="toctree-l4"><a class="reference internal" href="message_queues.html">Message Queues</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">Mailboxes</a></li>
<li class="toctree-l4"><a class="reference internal" href="pipes.html">Pipes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../index.html#memory-management">Memory Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="../index.html#timing">Timing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../index.html#other">Other</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../libc/index.html">C standard library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../logging/index.html">Logging</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../memory_management/index.html">Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/index.html">Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../data_structures/index.html">Data Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../modbus/index.html">Modbus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../networking/index.html">Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../peripherals/index.html">Peripherals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../pinctrl/index.html">Pin Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../pm/index.html">Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../random/index.html">Random Number Generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../resource_management/index.html">Resource Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../shell/index.html">Shell</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../storage/index.html">Storage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../task_wdt/index.html">Task Watchdog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/timeutil.html">Time Utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../usb/index.html">USB device support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../usermode/index.html">User Mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../util/index.html">Utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../settings/index.html">Settings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../timing_functions/index.html">Executing Time Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../virtualization/index.html">Virtualization</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/index.html">User and Developer Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../security/index.html">Security</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../samples/index.html">Samples and Demos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../boards/index.html">Supported Boards</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../releases/index.html">Release Notes</a></li>
</ul>

  
  <div class="toctree-wrapper compound">
    <p class="caption"><span class="caption-text">Reference</span></p>
    <ul>
      
      <li class="toctree-l1">
        <a class="reference internal" href="/latest/doxygen/html/index.html">API</a>
      </li>
      
      <li class="toctree-l1">
        <a class="reference internal" href="/latest/reference/kconfig/index.html">Kconfig Options</a>
      </li>
      
      <li class="toctree-l1">
        <a class="reference internal" href="/latest/reference/devicetree/bindings.html">Devicetree Bindings</a>
      </li>
      
    </ul>
  </div>
  

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Zephyr Project</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
  <!-- Docs / Latest -->
  
  

  <li><a href="../../../index.html">Docs / Latest</a> &raquo;</li>
  
     <li><a href="../../index.html">API Reference</a> &raquo;</li>
  
     <li><a href="../index.html">Kernel Services</a> &raquo;</li>
  
  <li>Mailboxes</li>


  <li class="wy-breadcrumbs-aside">
    <dark-mode-toggle id="dark-mode-toggle" appearance="toggle" permanent="true"/>
  </li>
  <li class="wy-breadcrumbs-aside">
      
      
        <a href="https://github.com/zephyrproject-rtos/zephyr/blob/main/doc/reference/kernel/data_passing/mailboxes.rst" class="fa fa-github"> Open on GitHub</a>
      
    
  </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
  
    <div class="wy-alert wy-alert-danger">
     This is the documentation for the latest (main) development branch of
     Zephyr. If you are looking for the documentation of previous releases, use
     the drop-down menu on the left and select the desired version.
    </div>
  
  
           <div itemprop="articleBody">
             
  <div class="section" id="mailboxes">
<span id="mailboxes-v2"></span><h1>Mailboxes<a class="headerlink" href="#mailboxes" title="Permalink to this headline">¶</a></h1>
<p>A <em class="dfn">mailbox</em> is a kernel object that provides enhanced message queue
capabilities that go beyond the capabilities of a message queue object.
A mailbox allows threads to send and receive messages of any size
synchronously or asynchronously.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#concepts" id="id1">Concepts</a></p>
<ul>
<li><p><a class="reference internal" href="#message-format" id="id2">Message Format</a></p></li>
<li><p><a class="reference internal" href="#message-lifecycle" id="id3">Message Lifecycle</a></p></li>
<li><p><a class="reference internal" href="#thread-compatibility" id="id4">Thread Compatibility</a></p></li>
<li><p><a class="reference internal" href="#message-flow-control" id="id5">Message Flow Control</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#implementation" id="id6">Implementation</a></p>
<ul>
<li><p><a class="reference internal" href="#defining-a-mailbox" id="id7">Defining a Mailbox</a></p></li>
<li><p><a class="reference internal" href="#message-descriptors" id="id8">Message Descriptors</a></p></li>
<li><p><a class="reference internal" href="#sending-a-message" id="id9">Sending a Message</a></p></li>
<li><p><a class="reference internal" href="#receiving-a-message" id="id10">Receiving a Message</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#suggested-uses" id="id11">Suggested Uses</a></p></li>
<li><p><a class="reference internal" href="#configuration-options" id="id12">Configuration Options</a></p></li>
<li><p><a class="reference internal" href="#api-reference" id="id13">API Reference</a></p></li>
</ul>
</div>
<div class="section" id="concepts">
<h2><a class="toc-backref" href="#id1">Concepts</a><a class="headerlink" href="#concepts" title="Permalink to this headline">¶</a></h2>
<p>Any number of mailboxes can be defined (limited only by available RAM). Each
mailbox is referenced by its memory address.</p>
<p>A mailbox has the following key properties:</p>
<ul class="simple">
<li><p>A <strong>send queue</strong> of messages that have been sent but not yet received.</p></li>
<li><p>A <strong>receive queue</strong> of threads that are waiting to receive a message.</p></li>
</ul>
<p>A mailbox must be initialized before it can be used. This sets both of its
queues to empty.</p>
<p>A mailbox allows threads, but not ISRs, to exchange messages.
A thread that sends a message is known as the <strong>sending thread</strong>,
while a thread that receives the message is known as the <strong>receiving thread</strong>.
Each message may be received by only one thread (i.e. point-to-multipoint and
broadcast messaging is not supported).</p>
<p>Messages exchanged using a mailbox are handled non-anonymously,
allowing both threads participating in an exchange to know
(and even specify) the identity of the other thread.</p>
<div class="section" id="message-format">
<h3><a class="toc-backref" href="#id2">Message Format</a><a class="headerlink" href="#message-format" title="Permalink to this headline">¶</a></h3>
<p>A <strong>message descriptor</strong> is a data structure that specifies where a message’s
data is located, and how the message is to be handled by the mailbox.
Both the sending thread and the receiving thread supply a message descriptor
when accessing a mailbox. The mailbox uses the message descriptors to perform
a message exchange between compatible sending and receiving threads.
The mailbox also updates certain message descriptor fields during the exchange,
allowing both threads to know what has occurred.</p>
<p>A mailbox message contains zero or more bytes of <strong>message data</strong>.
The size and format of the message data is application-defined, and can vary
from one message to the next. There are two forms of message data:</p>
<ul class="simple">
<li><p>A <strong>message buffer</strong> is an area of memory provided by the thread
that sends or receives the message. An array or structure variable
can often be used for this purpose.</p></li>
<li><p>A <strong>message block</strong> is an area of memory allocated from a memory pool.</p></li>
</ul>
<p>A message may <em>not</em> have both a message buffer and a message block.
A message that has neither form of message data is called an <strong>empty message</strong>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A message whose message buffer or memory block exists, but contains
zero bytes of actual data, is <em>not</em> an empty message.</p>
</div>
</div>
<div class="section" id="message-lifecycle">
<h3><a class="toc-backref" href="#id3">Message Lifecycle</a><a class="headerlink" href="#message-lifecycle" title="Permalink to this headline">¶</a></h3>
<p>The life cycle of a message is straightforward. A message is created when
it is given to a mailbox by the sending thread. The message is then owned
by the mailbox until it is given to a receiving thread. The receiving thread
may retrieve the message data when it receives the message from the mailbox,
or it may perform data retrieval during a second, subsequent mailbox operation.
Only when data retrieval has occurred is the message deleted by the mailbox.</p>
</div>
<div class="section" id="thread-compatibility">
<h3><a class="toc-backref" href="#id4">Thread Compatibility</a><a class="headerlink" href="#thread-compatibility" title="Permalink to this headline">¶</a></h3>
<p>A sending thread can specify the address of the thread to which the message
is sent, or send it to any thread by specifying <code class="xref c c-macro docutils literal notranslate"><span class="pre">K_ANY</span></code>.
Likewise, a receiving thread can specify the address of the thread from which
it wishes to receive a message, or it can receive a message from any thread
by specifying <code class="xref c c-macro docutils literal notranslate"><span class="pre">K_ANY</span></code>.
A message is exchanged only when the requirements of both the sending thread
and receiving thread are satisfied; such threads are said to be <strong>compatible</strong>.</p>
<p>For example, if thread A sends a message to thread B (and only thread B)
it will be received by thread B if thread B tries to receive a message
from thread A or if thread B tries to receive from any thread.
The exchange will not occur if thread B tries to receive a message
from thread C. The message can never be received by thread C,
even if it tries to receive a message from thread A (or from any thread).</p>
</div>
<div class="section" id="message-flow-control">
<h3><a class="toc-backref" href="#id5">Message Flow Control</a><a class="headerlink" href="#message-flow-control" title="Permalink to this headline">¶</a></h3>
<p>Mailbox messages can be exchanged <strong>synchronously</strong> or <strong>asynchronously</strong>.
In a synchronous exchange, the sending thread blocks until the message
has been fully processed by the receiving thread. In an asynchronous exchange,
the sending thread does not wait until the message has been received
by another thread before continuing; this allows the sending thread to do
other work (such as gather data that will be used in the next message)
<em>before</em> the message is given to a receiving thread and fully processed.
The technique used for a given message exchange is determined
by the sending thread.</p>
<p>The synchronous exchange technique provides an implicit form of flow control,
preventing a sending thread from generating messages faster than they can be
consumed by receiving threads. The asynchronous exchange technique provides an
explicit form of flow control, which allows a sending thread to determine
if a previously sent message still exists before sending a subsequent message.</p>
</div>
</div>
<div class="section" id="implementation">
<h2><a class="toc-backref" href="#id6">Implementation</a><a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="defining-a-mailbox">
<h3><a class="toc-backref" href="#id7">Defining a Mailbox</a><a class="headerlink" href="#defining-a-mailbox" title="Permalink to this headline">¶</a></h3>
<p>A mailbox is defined using a variable of type <a class="reference internal" href="#c.k_mbox" title="k_mbox"><code class="xref c c-struct docutils literal notranslate"><span class="pre">k_mbox</span></code></a>.
It must then be initialized by calling <a class="reference internal" href="#c.k_mbox_init" title="k_mbox_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_mbox_init()</span></code></a>.</p>
<p>The following code defines and initializes an empty mailbox.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">k_mbox</span><span class="w"> </span><span class="n">my_mailbox</span><span class="p">;</span><span class="w"></span>

<span class="n">k_mbox_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_mailbox</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Alternatively, a mailbox can be defined and initialized at compile time
by calling <a class="reference internal" href="#c.K_MBOX_DEFINE" title="K_MBOX_DEFINE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">K_MBOX_DEFINE</span></code></a>.</p>
<p>The following code has the same effect as the code segment above.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">K_MBOX_DEFINE</span><span class="p">(</span><span class="n">my_mailbox</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="message-descriptors">
<h3><a class="toc-backref" href="#id8">Message Descriptors</a><a class="headerlink" href="#message-descriptors" title="Permalink to this headline">¶</a></h3>
<p>A message descriptor is a structure of type <a class="reference internal" href="#c.k_mbox_msg" title="k_mbox_msg"><code class="xref c c-struct docutils literal notranslate"><span class="pre">k_mbox_msg</span></code></a>.
Only the fields listed below should be used; any other fields are for
internal mailbox use only.</p>
<dl class="simple">
<dt><em>info</em></dt><dd><p>A 32-bit value that is exchanged by the message sender and receiver,
and whose meaning is defined by the application. This exchange is
bi-directional, allowing the sender to pass a value to the receiver
during any message exchange, and allowing the receiver to pass a value
to the sender during a synchronous message exchange.</p>
</dd>
<dt><em>size</em></dt><dd><p>The message data size, in bytes. Set it to zero when sending an empty
message, or when sending a message buffer or message block with no
actual data. When receiving a message, set it to the maximum amount
of data desired, or to zero if the message data is not wanted.
The mailbox updates this field with the actual number of data bytes
exchanged once the message is received.</p>
</dd>
<dt><em>tx_data</em></dt><dd><p>A pointer to the sending thread’s message buffer. Set it to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>
when sending a memory block, or when sending an empty message.
Leave this field uninitialized when receiving a message.</p>
</dd>
<dt><em>tx_block</em></dt><dd><p>The descriptor for the sending thread’s memory block. Set tx_block.data
to <code class="docutils literal notranslate"><span class="pre">NULL</span></code> when sending an empty message. Leave this field
uninitialized when sending a message buffer, or when receiving a message.</p>
</dd>
<dt><em>tx_target_thread</em></dt><dd><p>The address of the desired receiving thread. Set it to <code class="xref c c-macro docutils literal notranslate"><span class="pre">K_ANY</span></code>
to allow any thread to receive the message. Leave this field uninitialized
when receiving a message. The mailbox updates this field with
the actual receiver’s address once the message is received.</p>
</dd>
<dt><em>rx_source_thread</em></dt><dd><p>The address of the desired sending thread. Set it to <code class="xref c c-macro docutils literal notranslate"><span class="pre">K_ANY</span></code>
to receive a message sent by any thread. Leave this field uninitialized
when sending a message. The mailbox updates this field
with the actual sender’s address when the message is put into
the mailbox.</p>
</dd>
</dl>
</div>
<div class="section" id="sending-a-message">
<h3><a class="toc-backref" href="#id9">Sending a Message</a><a class="headerlink" href="#sending-a-message" title="Permalink to this headline">¶</a></h3>
<p>A thread sends a message by first creating its message data, if any.
A message buffer is typically used when the data volume is small,
and the cost of copying the data is less than the cost of allocating
and freeing a message block.</p>
<p>Next, the sending thread creates a message descriptor that characterizes
the message to be sent, as described in the previous section.</p>
<p>Finally, the sending thread calls a mailbox send API to initiate the
message exchange. The message is immediately given to a compatible receiving
thread, if one is currently waiting. Otherwise, the message is added
to the mailbox’s send queue.</p>
<p>Any number of messages may exist simultaneously on a send queue.
The messages in the send queue are sorted according to the priority
of the sending thread. Messages of equal priority are sorted so that
the oldest message can be received first.</p>
<p>For a synchronous send operation, the operation normally completes when a
receiving thread has both received the message and retrieved the message data.
If the message is not received before the waiting period specified by the
sending thread is reached, the message is removed from the mailbox’s send queue
and the send operation fails. When a send operation completes successfully
the sending thread can examine the message descriptor to determine
which thread received the message, how much data was exchanged,
and the application-defined info value supplied by the receiving thread.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A synchronous send operation may block the sending thread indefinitely,
even when the thread specifies a maximum waiting period.
The waiting period only limits how long the mailbox waits
before the message is received by another thread. Once a message is received
there is <em>no</em> limit to the time the receiving thread may take to retrieve
the message data and unblock the sending thread.</p>
</div>
<p>For an asynchronous send operation, the operation always completes immediately.
This allows the sending thread to continue processing regardless of whether the
message is given to a receiving thread immediately or added to the send queue.
The sending thread may optionally specify a semaphore that the mailbox gives
when the message is deleted by the mailbox, for example, when the message
has been received and its data retrieved by a receiving thread.
The use of a semaphore allows the sending thread to easily implement
a flow control mechanism that ensures that the mailbox holds no more than
an application-specified number of messages from a sending thread
(or set of sending threads) at any point in time.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A thread that sends a message asynchronously has no way to determine
which thread received the message, how much data was exchanged, or the
application-defined info value supplied by the receiving thread.</p>
</div>
<div class="section" id="sending-an-empty-message">
<h4>Sending an Empty Message<a class="headerlink" href="#sending-an-empty-message" title="Permalink to this headline">¶</a></h4>
<p>This code uses a mailbox to synchronously pass 4 byte random values
to any consuming thread that wants one. The message “info” field is
large enough to carry the information being exchanged, so the data
portion of the message isn’t used.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">producer_thread</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">k_mbox_msg</span><span class="w"> </span><span class="n">send_msg</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* generate random value to send */</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">random_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sys_rand32_get</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* prepare to send empty message */</span><span class="w"></span>
<span class="w">        </span><span class="n">send_msg</span><span class="p">.</span><span class="n">info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">random_value</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">send_msg</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">send_msg</span><span class="p">.</span><span class="n">tx_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">send_msg</span><span class="p">.</span><span class="n">tx_block</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">send_msg</span><span class="p">.</span><span class="n">tx_target_thread</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">K_ANY</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* send message and wait until a consumer receives it */</span><span class="w"></span>
<span class="w">        </span><span class="n">k_mbox_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_mailbox</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">send_msg</span><span class="p">,</span><span class="w"> </span><span class="n">K_FOREVER</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="sending-data-using-a-message-buffer">
<h4>Sending Data Using a Message Buffer<a class="headerlink" href="#sending-data-using-a-message-buffer" title="Permalink to this headline">¶</a></h4>
<p>This code uses a mailbox to synchronously pass variable-sized requests
from a producing thread to any consuming thread that wants it.
The message “info” field is used to exchange information about
the maximum size message buffer that each thread can handle.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">producer_thread</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">buffer</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">buffer_bytes_used</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">k_mbox_msg</span><span class="w"> </span><span class="n">send_msg</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* generate data to send */</span><span class="w"></span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="w">        </span><span class="n">buffer_bytes_used</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">source</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_bytes_used</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* prepare to send message */</span><span class="w"></span>
<span class="w">        </span><span class="n">send_msg</span><span class="p">.</span><span class="n">info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer_bytes_used</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">send_msg</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer_bytes_used</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">send_msg</span><span class="p">.</span><span class="n">tx_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">send_msg</span><span class="p">.</span><span class="n">tx_block</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">send_msg</span><span class="p">.</span><span class="n">tx_target_thread</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">K_ANY</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* send message and wait until a consumer receives it */</span><span class="w"></span>
<span class="w">        </span><span class="n">k_mbox_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_mailbox</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">send_msg</span><span class="p">,</span><span class="w"> </span><span class="n">K_FOREVER</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* info, size, and tx_target_thread fields have been updated */</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* verify that message data was fully received */</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">send_msg</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">buffer_bytes_used</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;some message data dropped during transfer!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;receiver only had room for %d bytes&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">send_msg</span><span class="p">.</span><span class="n">info</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="sending-data-using-a-message-block">
<h4>Sending Data Using a Message Block<a class="headerlink" href="#sending-data-using-a-message-block" title="Permalink to this headline">¶</a></h4>
<p>This code uses a mailbox to send asynchronous messages. A semaphore is used
to hold off the sending of a new message until the previous message
has been consumed, so that a backlog of messages doesn’t build up
when the consuming thread is unable to keep up.</p>
<p>The message data is stored in a memory block obtained from a memory pool,
thereby eliminating unneeded data copying when exchanging large messages.
The memory pool contains only two blocks: one block gets filled with
data while the previously sent block is being processed</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* define a semaphore, indicating that no message has been sent */</span><span class="w"></span>
<span class="n">K_SEM_DEFINE</span><span class="p">(</span><span class="n">my_sem</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>

<span class="cm">/* define a memory pool containing 2 blocks of 4096 bytes */</span><span class="w"></span>
<span class="n">K_MEM_POOL_DEFINE</span><span class="p">(</span><span class="n">my_pool</span><span class="p">,</span><span class="w"> </span><span class="mi">4096</span><span class="p">,</span><span class="w"> </span><span class="mi">4096</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">producer_thread</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">k_mbox_msg</span><span class="w"> </span><span class="n">send_msg</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">volatile</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">hw_buffer</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* allocate a memory block to hold the message data */</span><span class="w"></span>
<span class="w">        </span><span class="n">k_mem_pool_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_pool</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">send_msg</span><span class="p">.</span><span class="n">tx_block</span><span class="p">,</span><span class="w"> </span><span class="mi">4096</span><span class="p">,</span><span class="w"> </span><span class="n">K_FOREVER</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* keep overwriting the hardware-generated data in the block    */</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* until the previous message has been received by the consumer */</span><span class="w"></span>
<span class="w">        </span><span class="k">do</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">memcpy</span><span class="p">(</span><span class="n">send_msg</span><span class="p">.</span><span class="n">tx_block</span><span class="p">.</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">hw_buffer</span><span class="p">,</span><span class="w"> </span><span class="mi">4096</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">k_sem_take</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_sem</span><span class="p">,</span><span class="w"> </span><span class="n">K_NO_WAIT</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* finish preparing to send message */</span><span class="w"></span>
<span class="w">        </span><span class="n">send_msg</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4096</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">send_msg</span><span class="p">.</span><span class="n">tx_target_thread</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">K_ANY</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* send message containing most current data and loop around */</span><span class="w"></span>
<span class="w">        </span><span class="n">k_mbox_async_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_mailbox</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">send_msg</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">my_sem</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="receiving-a-message">
<h3><a class="toc-backref" href="#id10">Receiving a Message</a><a class="headerlink" href="#receiving-a-message" title="Permalink to this headline">¶</a></h3>
<p>A thread receives a message by first creating a message descriptor that
characterizes the message it wants to receive. It then calls one of the
mailbox receive APIs. The mailbox searches its send queue and takes the message
from the first compatible thread it finds. If no compatible thread exists,
the receiving thread may choose to wait for one. If no compatible thread
appears before the waiting period specified by the receiving thread is reached,
the receive operation fails.
Once a receive operation completes successfully the receiving thread
can examine the message descriptor to determine which thread sent the message,
how much data was exchanged,
and the application-defined info value supplied by the sending thread.</p>
<p>Any number of receiving threads may wait simultaneously on a mailboxes’
receive queue. The threads are sorted according to their priority;
threads of equal priority are sorted so that the one that started waiting
first can receive a message first.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Receiving threads do not always receive messages in a first in, first out
(FIFO) order, due to the thread compatibility constraints specified by the
message descriptors. For example, if thread A waits to receive a message
only from thread X and then thread B waits to receive a message from
thread Y, an incoming message from thread Y to any thread will be given
to thread B and thread A will continue to wait.</p>
</div>
<p>The receiving thread controls both the quantity of data it retrieves from an
incoming message and where the data ends up. The thread may choose to take
all of the data in the message, to take only the initial part of the data,
or to take no data at all. Similarly, the thread may choose to have the data
copied into a message buffer of its choice or to have it placed in a message
block. A message buffer is typically used when the volume of data
involved is small, and the cost of copying the data is less than the cost
of allocating and freeing a memory pool block.</p>
<p>The following sections outline various approaches a receiving thread may use
when retrieving message data.</p>
<div class="section" id="retrieving-data-at-receive-time">
<h4>Retrieving Data at Receive Time<a class="headerlink" href="#retrieving-data-at-receive-time" title="Permalink to this headline">¶</a></h4>
<p>The most straightforward way for a thread to retrieve message data is to
specify a message buffer when the message is received. The thread indicates
both the location of the message buffer (which must not be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>)
and its size.</p>
<p>The mailbox copies the message’s data to the message buffer as part of the
receive operation. If the message buffer is not big enough to contain all of the
message’s data, any uncopied data is lost. If the message is not big enough
to fill all of the buffer with data, the unused portion of the message buffer is
left unchanged. In all cases the mailbox updates the receiving thread’s
message descriptor to indicate how many data bytes were copied (if any).</p>
<p>The immediate data retrieval technique is best suited for small messages
where the maximum size of a message is known in advance.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This technique can be used when the message data is actually located
in a memory block supplied by the sending thread. The mailbox copies
the data into the message buffer specified by the receiving thread, then
frees the message block back to its memory pool. This allows
a receiving thread to retrieve message data without having to know
whether the data was sent using a message buffer or a message block.</p>
</div>
<p>The following code uses a mailbox to process variable-sized requests from any
producing thread, using the immediate data retrieval technique. The message
“info” field is used to exchange information about the maximum size
message buffer that each thread can handle.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">consumer_thread</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">k_mbox_msg</span><span class="w"> </span><span class="n">recv_msg</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">buffer</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">total</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* prepare to receive message */</span><span class="w"></span>
<span class="w">        </span><span class="n">recv_msg</span><span class="p">.</span><span class="n">info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">recv_msg</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">recv_msg</span><span class="p">.</span><span class="n">rx_source_thread</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">K_ANY</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* get a data item, waiting as long as needed */</span><span class="w"></span>
<span class="w">        </span><span class="n">k_mbox_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_mailbox</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">recv_msg</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">K_FOREVER</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* info, size, and rx_source_thread fields have been updated */</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* verify that message data was fully received */</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">recv_msg</span><span class="p">.</span><span class="n">info</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">recv_msg</span><span class="p">.</span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;some message data dropped during transfer!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;sender tried to send %d bytes&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">recv_msg</span><span class="p">.</span><span class="n">info</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* compute sum of all message bytes (from 0 to 100 of them) */</span><span class="w"></span>
<span class="w">        </span><span class="n">total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">recv_msg</span><span class="p">.</span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">total</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="retrieving-data-later-using-a-message-buffer">
<h4>Retrieving Data Later Using a Message Buffer<a class="headerlink" href="#retrieving-data-later-using-a-message-buffer" title="Permalink to this headline">¶</a></h4>
<p>A receiving thread may choose to defer message data retrieval at the time
the message is received, so that it can retrieve the data into a message buffer
at a later time.
The thread does this by specifying a message buffer location of <code class="docutils literal notranslate"><span class="pre">NULL</span></code>
and a size indicating the maximum amount of data it is willing to retrieve
later.</p>
<p>The mailbox does not copy any message data as part of the receive operation.
However, the mailbox still updates the receiving thread’s message descriptor
to indicate how many data bytes are available for retrieval.</p>
<p>The receiving thread must then respond as follows:</p>
<ul class="simple">
<li><p>If the message descriptor size is zero, then either the sender’s message
contained no data or the receiving thread did not want to receive any data.
The receiving thread does not need to take any further action, since
the mailbox has already completed data retrieval and deleted the message.</p></li>
<li><p>If the message descriptor size is non-zero and the receiving thread still
wants to retrieve the data, the thread must call <a class="reference internal" href="#c.k_mbox_data_get" title="k_mbox_data_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_mbox_data_get()</span></code></a>
and supply a message buffer large enough to hold the data. The mailbox copies
the data into the message buffer and deletes the message.</p></li>
<li><p>If the message descriptor size is non-zero and the receiving thread does <em>not</em>
want to retrieve the data, the thread must call <a class="reference internal" href="#c.k_mbox_data_get" title="k_mbox_data_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_mbox_data_get()</span></code></a>.
and specify a message buffer of <code class="docutils literal notranslate"><span class="pre">NULL</span></code>. The mailbox deletes
the message without copying the data.</p></li>
</ul>
<p>The subsequent data retrieval technique is suitable for applications where
immediate retrieval of message data is undesirable. For example, it can be
used when memory limitations make it impractical for the receiving thread to
always supply a message buffer capable of holding the largest possible
incoming message.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This technique can be used when the message data is actually located
in a memory block supplied by the sending thread. The mailbox copies
the data into the message buffer specified by the receiving thread, then
frees the message block back to its memory pool. This allows
a receiving thread to retrieve message data without having to know
whether the data was sent using a message buffer or a message block.</p>
</div>
<p>The following code uses a mailbox’s deferred data retrieval mechanism
to get message data from a producing thread only if the message meets
certain criteria, thereby eliminating unneeded data copying. The message
“info” field supplied by the sender is used to classify the message.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">consumer_thread</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">k_mbox_msg</span><span class="w"> </span><span class="n">recv_msg</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">buffer</span><span class="p">[</span><span class="mi">10000</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* prepare to receive message */</span><span class="w"></span>
<span class="w">        </span><span class="n">recv_msg</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10000</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">recv_msg</span><span class="p">.</span><span class="n">rx_source_thread</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">K_ANY</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* get message, but not its data */</span><span class="w"></span>
<span class="w">        </span><span class="n">k_mbox_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_mailbox</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">recv_msg</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">K_FOREVER</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* get message data for only certain types of messages */</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_message_type_ok</span><span class="p">(</span><span class="n">recv_msg</span><span class="p">.</span><span class="n">info</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="cm">/* retrieve message data and delete the message */</span><span class="w"></span>
<span class="w">            </span><span class="n">k_mbox_data_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recv_msg</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">);</span><span class="w"></span>

<span class="w">            </span><span class="cm">/* process data in &quot;buffer&quot; */</span><span class="w"></span>
<span class="w">            </span><span class="p">...</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="cm">/* ignore message data and delete the message */</span><span class="w"></span>
<span class="w">            </span><span class="n">k_mbox_data_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recv_msg</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="retrieving-data-later-using-a-message-block">
<h4>Retrieving Data Later Using a Message Block<a class="headerlink" href="#retrieving-data-later-using-a-message-block" title="Permalink to this headline">¶</a></h4>
<p>A receiving thread may choose to retrieve message data into a memory block,
rather than a message buffer. This is done in much the same way as retrieving
data subsequently into a message buffer — the receiving thread first
receives the message without its data, then retrieves the data by calling
<code class="xref c c-func docutils literal notranslate"><span class="pre">k_mbox_data_block_get()</span></code>. The mailbox fills in the block descriptor
supplied by the receiving thread, allowing the thread to access the data.
The mailbox also deletes the received message, since data retrieval
has been completed. The receiving thread is then responsible for freeing
the message block back to the memory pool when the data is no longer needed.</p>
<p>This technique is best suited for applications where the message data has
been sent using a memory block.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This technique can be used when the message data is located in a message
buffer supplied by the sending thread. The mailbox automatically allocates
a memory block and copies the message data into it. However, this is much
less efficient than simply retrieving the data into a message buffer
supplied by the receiving thread. In addition, the receiving thread
must be designed to handle cases where the data retrieval operation fails
because the mailbox cannot allocate a suitable message block from the memory
pool. If such cases are possible, the receiving thread must either try
retrieving the data at a later time or instruct the mailbox to delete
the message without retrieving the data.</p>
</div>
<p>The following code uses a mailbox to receive messages sent using a memory block,
thereby eliminating unneeded data copying when processing a large message.
(The messages may be sent synchronously or asynchronously.)</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* define a memory pool containing 1 block of 10000 bytes */</span><span class="w"></span>
<span class="n">K_MEM_POOL_DEFINE</span><span class="p">(</span><span class="n">my_pool</span><span class="p">,</span><span class="w"> </span><span class="mi">10000</span><span class="p">,</span><span class="w"> </span><span class="mi">10000</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">consumer_thread</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">k_mbox_msg</span><span class="w"> </span><span class="n">recv_msg</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">k_mem_block</span><span class="w"> </span><span class="n">recv_block</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">total</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">data_ptr</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* prepare to receive message */</span><span class="w"></span>
<span class="w">        </span><span class="n">recv_msg</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10000</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">recv_msg</span><span class="p">.</span><span class="n">rx_source_thread</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">K_ANY</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* get message, but not its data */</span><span class="w"></span>
<span class="w">        </span><span class="n">k_mbox_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_mailbox</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">recv_msg</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">K_FOREVER</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* get message data as a memory block and discard message */</span><span class="w"></span>
<span class="w">        </span><span class="n">k_mbox_data_block_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recv_msg</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">my_pool</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">recv_block</span><span class="p">,</span><span class="w"> </span><span class="n">K_FOREVER</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* compute sum of all message bytes in memory block */</span><span class="w"></span>
<span class="w">        </span><span class="n">total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">data_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)(</span><span class="n">recv_block</span><span class="p">.</span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">recv_msg</span><span class="p">.</span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">total</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">data_ptr</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* release memory block containing data */</span><span class="w"></span>
<span class="w">        </span><span class="n">k_mem_pool_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recv_block</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An incoming message that was sent using a message buffer is also processed
correctly by this algorithm, since the mailbox automatically allocates
a memory block from the memory pool and fills it with the message data.
However, the performance benefit of using the memory block approach is lost.</p>
</div>
</div>
</div>
</div>
<div class="section" id="suggested-uses">
<h2><a class="toc-backref" href="#id11">Suggested Uses</a><a class="headerlink" href="#suggested-uses" title="Permalink to this headline">¶</a></h2>
<p>Use a mailbox to transfer data items between threads whenever the capabilities
of a message queue are insufficient.</p>
</div>
<div class="section" id="configuration-options">
<h2><a class="toc-backref" href="#id12">Configuration Options</a><a class="headerlink" href="#configuration-options" title="Permalink to this headline">¶</a></h2>
<p>Related configuration options:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../../kconfig/dummy-syms.html#std-kconfig-CONFIG_NUM_MBOX_ASYNC_MSGS"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_NUM_MBOX_ASYNC_MSGS</span></code></a></p></li>
</ul>
</div>
<div class="section" id="api-reference">
<h2><a class="toc-backref" href="#id13">API Reference</a><a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h2>
<dl>
<dt class="sig sig-object cpp">
<span class="target" id="group__mailbox__apis"></span><em><span class="pre">group</span></em> <span class="sig-name descname"><span class="pre">mailbox_apis</span></span></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-defines">Defines</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.K_MBOX_DEFINE">
<span class="target" id="group__mailbox__apis_1gab55cba898db47113a06641c01f3e3714"></span><span class="sig-name descname"><span class="n"><span class="pre">K_MBOX_DEFINE</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.K_MBOX_DEFINE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Statically define and initialize a mailbox. </p>
<p>The mailbox is to be accessed outside the module where it is defined using:</p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">struct</span> <span class="n">k_mbox</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span> 
</pre></div>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> – Name of the mailbox. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.k_mbox_init">
<span class="target" id="group__mailbox__apis_1ga686f20c199a9e971822d8279d175d8c2"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_mbox_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_mbox" title="k_mbox"><span class="n"><span class="pre">k_mbox</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mbox</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_mbox_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a mailbox. </p>
<p>This routine initializes a mailbox object, prior to its first use.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mbox</strong> – Address of the mailbox. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_mbox_put">
<span class="target" id="group__mailbox__apis_1gaa1e5cdd992d8b9be11f82254e1886ed2"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_mbox_put</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_mbox" title="k_mbox"><span class="n"><span class="pre">k_mbox</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mbox</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_mbox_msg" title="k_mbox_msg"><span class="n"><span class="pre">k_mbox_msg</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tx_msg</span></span>, <a class="reference internal" href="../timing/clocks.html#c.k_timeout_t" title="k_timeout_t"><span class="n"><span class="pre">k_timeout_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">timeout</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_mbox_put" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Send a mailbox message in a synchronous manner. </p>
<p>This routine sends a message to <em>mbox</em> and waits for a receiver to both receive and process it. The message data may be in a buffer, in a memory pool block, or non-existent (i.e. an empty message).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mbox</strong> – Address of the mailbox. </p></li>
<li><p><strong>tx_msg</strong> – Address of the transmit message descriptor. </p></li>
<li><p><strong>timeout</strong> – Waiting period for the message to be received, or one of the special values K_NO_WAIT and K_FOREVER. Once the message has been received, this routine waits as long as necessary for the message to be completely processed.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>0</strong> – Message sent. </p></li>
<li><p><strong>-ENOMSG</strong> – Returned without waiting. </p></li>
<li><p><strong>-EAGAIN</strong> – Waiting period timed out. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_mbox_async_put">
<span class="target" id="group__mailbox__apis_1gadd60f7b760371c0a141a1e4da253a0f0"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_mbox_async_put</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_mbox" title="k_mbox"><span class="n"><span class="pre">k_mbox</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mbox</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_mbox_msg" title="k_mbox_msg"><span class="n"><span class="pre">k_mbox_msg</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tx_msg</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">k_sem</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sem</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_mbox_async_put" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Send a mailbox message in an asynchronous manner. </p>
<p>This routine sends a message to <em>mbox</em> without waiting for a receiver to process it. The message data may be in a buffer, in a memory pool block, or non-existent (i.e. an empty message). Optionally, the semaphore <em>sem</em> will be given when the message has been both received and completely processed by the receiver.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mbox</strong> – Address of the mailbox. </p></li>
<li><p><strong>tx_msg</strong> – Address of the transmit message descriptor. </p></li>
<li><p><strong>sem</strong> – Address of a semaphore, or NULL if none is needed. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_mbox_get">
<span class="target" id="group__mailbox__apis_1ga2ea91154620b139dbed1ad949b97c3ef"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_mbox_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_mbox" title="k_mbox"><span class="n"><span class="pre">k_mbox</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mbox</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_mbox_msg" title="k_mbox_msg"><span class="n"><span class="pre">k_mbox_msg</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rx_msg</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buffer</span></span>, <a class="reference internal" href="../timing/clocks.html#c.k_timeout_t" title="k_timeout_t"><span class="n"><span class="pre">k_timeout_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">timeout</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_mbox_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Receive a mailbox message. </p>
<p>This routine receives a message from <em>mbox</em>, then optionally retrieves its data and disposes of the message.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mbox</strong> – Address of the mailbox. </p></li>
<li><p><strong>rx_msg</strong> – Address of the receive message descriptor. </p></li>
<li><p><strong>buffer</strong> – Address of the buffer to receive data, or NULL to defer data retrieval and message disposal until later. </p></li>
<li><p><strong>timeout</strong> – Waiting period for a message to be received, or one of the special values K_NO_WAIT and K_FOREVER.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>0</strong> – Message received. </p></li>
<li><p><strong>-ENOMSG</strong> – Returned without waiting. </p></li>
<li><p><strong>-EAGAIN</strong> – Waiting period timed out. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_mbox_data_get">
<span class="target" id="group__mailbox__apis_1ga3d19e648e67f109609259543c9a01d6e"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_mbox_data_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_mbox_msg" title="k_mbox_msg"><span class="n"><span class="pre">k_mbox_msg</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rx_msg</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_mbox_data_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve mailbox message data into a buffer. </p>
<p>This routine completes the processing of a received message by retrieving its data into a buffer, then disposing of the message.</p>
<p>Alternatively, this routine can be used to dispose of a received message without retrieving its data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rx_msg</strong> – Address of the receive message descriptor. </p></li>
<li><p><strong>buffer</strong> – Address of the buffer to receive data, or NULL to discard the data. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.k_mbox_msg">
<span class="target" id="structk__mbox__msg"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_mbox_msg</span></span></span><a class="headerlink" href="#c.k_mbox_msg" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="docutils container">
<em>#include &lt;kernel.h&gt;</em></div>
<p>Mailbox Message Structure. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="c var">
<dt class="sig sig-object c" id="c.k_mbox_msg.size">
<span class="target" id="structk__mbox__msg_1aeabf45e9599a64852a1cfd656b1ece8e"></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">size</span></span></span><a class="headerlink" href="#c.k_mbox_msg.size" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>size of message (in bytes) </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.k_mbox_msg.info">
<span class="target" id="structk__mbox__msg_1aa79f2bf71431b474ec4551ade4d7a8dd"></span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">info</span></span></span><a class="headerlink" href="#c.k_mbox_msg.info" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>application-defined information value </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.k_mbox_msg.tx_data">
<span class="target" id="structk__mbox__msg_1a74b0edeed4c44cb5932eb292efc9d9c2"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">tx_data</span></span></span><a class="headerlink" href="#c.k_mbox_msg.tx_data" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>sender’s message data buffer </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.k_mbox_msg.tx_block">
<span class="target" id="structk__mbox__msg_1a3d29864697b86a2f36300c65f25b28f3"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">k_mem_block</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">tx_block</span></span></span><a class="headerlink" href="#c.k_mbox_msg.tx_block" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>message data block descriptor </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.k_mbox_msg.rx_source_thread">
<span class="target" id="structk__mbox__msg_1a9eb145a242ac66e80d90286d83fe7a61"></span><span class="n"><span class="pre">k_tid_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rx_source_thread</span></span></span><a class="headerlink" href="#c.k_mbox_msg.rx_source_thread" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>source thread id </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.k_mbox_msg.tx_target_thread">
<span class="target" id="structk__mbox__msg_1a73236acb7d27bb0233f5abb7214fb19c"></span><span class="n"><span class="pre">k_tid_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">tx_target_thread</span></span></span><a class="headerlink" href="#c.k_mbox_msg.tx_target_thread" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>target thread id </p>
</dd></dl>

</div>
</dd></dl>

<dl class="c struct">
<dt class="sig sig-object c" id="c.k_mbox">
<span class="target" id="structk__mbox"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_mbox</span></span></span><a class="headerlink" href="#c.k_mbox" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="docutils container">
<em>#include &lt;kernel.h&gt;</em></div>
<p>Mailbox Structure. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="c var">
<dt class="sig sig-object c" id="c.k_mbox.tx_msg_queue">
<span class="target" id="structk__mbox_1a0bca912a50120707ddafa66d740ade96"></span><span class="n"><span class="pre">_wait_q_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">tx_msg_queue</span></span></span><a class="headerlink" href="#c.k_mbox.tx_msg_queue" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Transmit messages queue </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.k_mbox.rx_msg_queue">
<span class="target" id="structk__mbox_1a808a14c31892a2d042cdb0723a2956e2"></span><span class="n"><span class="pre">_wait_q_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rx_msg_queue</span></span></span><a class="headerlink" href="#c.k_mbox.rx_msg_queue" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Receive message queue </p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
          </div>

          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; <a href="../../../copyright.html">Copyright</a> 2015-2021 Zephyr Project members and individual contributors.
      <span class="lastupdated">Last updated on Feb 21, 2022.
      </span></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>