<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Workqueue Threads &mdash; Zephyr Project Documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/tabs.css" type="text/css" />
    <link rel="shortcut icon" href="../../../_static/favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script type="module" src="../../../_static/js/dark-mode-toggle.min.mjs"></script>
        <script src="https://www.googletagmanager.com/gtag/js?id=UA-831873-47"></script>
        <script src="../../../_static/js/ga-tracker.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="copyright" title="Copyright" href="../../../copyright.html" />
    <link rel="next" title="Zephyr Without Threads" href="nothread.html" />
    <link rel="prev" title="System Threads" href="system_threads.html" />
  <meta name="color-scheme" content="dark light">
  
  <link rel="stylesheet" href="../../../_static/css/light.css" type="text/css" media="(prefers-color-scheme: light)"/>
  <link rel="stylesheet" href="../../../_static/css/dark.css" type="text/css" media="(prefers-color-scheme: dark)"/>

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html">
            <img src="../../../_static/logo.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                3.0.0-rc3
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
  
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Zephyr Project</span>
      v: latest
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl>
        <dt>Document Release Versions</dt>
        
          <dd><a href="/">latest</a></dd>
        
          <dd><a href="/2.7.0/">2.7.0</a></dd>
        
          <dd><a href="/2.6.0/">2.6.0</a></dd>
        
          <dd><a href="/2.5.0/">2.5.0</a></dd>
        
          <dd><a href="/2.4.0/">2.4.0</a></dd>
        
          <dd><a href="/2.3.0/">2.3.0</a></dd>
        
          <dd><a href="/1.14.1/">1.14.1</a></dd>
        
      </dl>
      <dl>
        <dt>Downloads</dt>
        
        <dd><a href="/latest/zephyr.pdf">PDF</a></dd>
      </dl>
      <dl>
        <dt>zephyrproject.org Links</dt>
          <dd>
            <a href="https://www.zephyrproject.org/">Project Home</a>
          </dd>
          <dd>
            <a href="https://github.com/zephyrproject-rtos/sdk-ng/releases">SDK</a>
          </dd>
          <dd>
            <a href="https://github.com/zephyrproject-rtos/zephyr/releases">Releases</a>
          </dd>
      </dl>
    </div>
  </div>
  
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../introduction/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/index.html">Getting Started Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contribute/index.html">Contribution Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../development_process/index.html">Development and Contribution Process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/build/index.html">Build and Configuration Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../application/index.html">Application Development</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../api/index.html">API Status and Guidelines</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../audio/index.html">Audio</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/notify.html">Asynchronous Notifications</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../bluetooth/index.html">Bluetooth</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../canbus/index.html">Controller Area Network (CAN)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../crypto/index.html">Crypto</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devicetree/index.html">Devicetree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../drivers/index.html">Device Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../display/index.html">Display Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../edac/index.html">Error Detection And Correction (EDAC)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../file_system/index.html">File Systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../iterable_sections/index.html">Iterable Sections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/formatted_output.html">Formatted Output</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">Kernel Services</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="../index.html#scheduling-interrupts-and-synchronization">Scheduling, Interrupts, and Synchronization</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="index.html">Threads</a></li>
<li class="toctree-l4"><a class="reference internal" href="../scheduling/index.html">Scheduling</a></li>
<li class="toctree-l4"><a class="reference internal" href="system_threads.html">System Threads</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">Workqueue Threads</a></li>
<li class="toctree-l4"><a class="reference internal" href="nothread.html">Zephyr Without Threads</a></li>
<li class="toctree-l4"><a class="reference internal" href="../other/interrupts.html">Interrupts</a></li>
<li class="toctree-l4"><a class="reference internal" href="../other/polling.html">Polling API</a></li>
<li class="toctree-l4"><a class="reference internal" href="../synchronization/semaphores.html">Semaphores</a></li>
<li class="toctree-l4"><a class="reference internal" href="../synchronization/mutexes.html">Mutexes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../synchronization/condvar.html">Condition Variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="../synchronization/events.html">Events</a></li>
<li class="toctree-l4"><a class="reference internal" href="../smp/smp.html">Symmetric Multiprocessing</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../index.html#data-passing">Data Passing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../index.html#memory-management">Memory Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="../index.html#timing">Timing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../index.html#other">Other</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../libc/index.html">C standard library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../logging/index.html">Logging</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../memory_management/index.html">Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/index.html">Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../data_structures/index.html">Data Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../modbus/index.html">Modbus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../networking/index.html">Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../peripherals/index.html">Peripherals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../pinctrl/index.html">Pin Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../pm/index.html">Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../random/index.html">Random Number Generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../resource_management/index.html">Resource Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../shell/index.html">Shell</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../storage/index.html">Storage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../task_wdt/index.html">Task Watchdog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/timeutil.html">Time Utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../usb/index.html">USB device support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../usermode/index.html">User Mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../util/index.html">Utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../settings/index.html">Settings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../timing_functions/index.html">Executing Time Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../virtualization/index.html">Virtualization</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/index.html">User and Developer Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../security/index.html">Security</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../samples/index.html">Samples and Demos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../boards/index.html">Supported Boards</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../releases/index.html">Release Notes</a></li>
</ul>

  
  <div class="toctree-wrapper compound">
    <p class="caption"><span class="caption-text">Reference</span></p>
    <ul>
      
      <li class="toctree-l1">
        <a class="reference internal" href="/latest/doxygen/html/index.html">API</a>
      </li>
      
      <li class="toctree-l1">
        <a class="reference internal" href="/latest/reference/kconfig/index.html">Kconfig Options</a>
      </li>
      
      <li class="toctree-l1">
        <a class="reference internal" href="/latest/reference/devicetree/bindings.html">Devicetree Bindings</a>
      </li>
      
    </ul>
  </div>
  

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Zephyr Project</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
  <!-- Docs / Latest -->
  
  

  <li><a href="../../../index.html">Docs / Latest</a> &raquo;</li>
  
     <li><a href="../../index.html">API Reference</a> &raquo;</li>
  
     <li><a href="../index.html">Kernel Services</a> &raquo;</li>
  
  <li>Workqueue Threads</li>


  <li class="wy-breadcrumbs-aside">
    <dark-mode-toggle id="dark-mode-toggle" appearance="toggle" permanent="true"/>
  </li>
  <li class="wy-breadcrumbs-aside">
      
      
        <a href="https://github.com/zephyrproject-rtos/zephyr/blob/main/doc/reference/kernel/threads/workqueue.rst" class="fa fa-github"> Open on GitHub</a>
      
    
  </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
  
    <div class="wy-alert wy-alert-danger">
     This is the documentation for the latest (main) development branch of
     Zephyr. If you are looking for the documentation of previous releases, use
     the drop-down menu on the left and select the desired version.
    </div>
  
  
           <div itemprop="articleBody">
             
  <div class="section" id="workqueue-threads">
<span id="workqueues-v2"></span><h1>Workqueue Threads<a class="headerlink" href="#workqueue-threads" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#work-item-lifecycle" id="id1">Work Item Lifecycle</a></p></li>
<li><p><a class="reference internal" href="#delayable-work" id="id2">Delayable Work</a></p></li>
<li><p><a class="reference internal" href="#triggered-work" id="id3">Triggered Work</a></p></li>
<li><p><a class="reference internal" href="#system-workqueue" id="id4">System Workqueue</a></p></li>
<li><p><a class="reference internal" href="#how-to-use-workqueues" id="id5">How to Use Workqueues</a></p></li>
<li><p><a class="reference internal" href="#workqueue-best-practices" id="id6">Workqueue Best Practices</a></p></li>
<li><p><a class="reference internal" href="#suggested-uses" id="id7">Suggested Uses</a></p></li>
<li><p><a class="reference internal" href="#configuration-options" id="id8">Configuration Options</a></p></li>
<li><p><a class="reference internal" href="#api-reference" id="id9">API Reference</a></p></li>
</ul>
</div>
<p>A <em class="dfn">workqueue</em> is a kernel object that uses a dedicated thread to process
work items in a first in, first out manner. Each work item is processed by
calling the function specified by the work item. A workqueue is typically
used by an ISR or a high-priority thread to offload non-urgent processing
to a lower-priority thread so it does not impact time-sensitive processing.</p>
<p>Any number of workqueues can be defined (limited only by available RAM). Each
workqueue is referenced by its memory address.</p>
<p>A workqueue has the following key properties:</p>
<ul class="simple">
<li><p>A <strong>queue</strong> of work items that have been added, but not yet processed.</p></li>
<li><p>A <strong>thread</strong> that processes the work items in the queue. The priority of the
thread is configurable, allowing it to be either cooperative or preemptive
as required.</p></li>
</ul>
<p>Regardless of workqueue thread priority the workqueue thread will yield
between each submitted work item, to prevent a cooperative workqueue from
starving other threads.</p>
<p>A workqueue must be initialized before it can be used. This sets its queue to
empty and spawns the workqueue’s thread.  The thread runs forever, but sleeps
when no work items are available.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The behavior described here is changed from the Zephyr workqueue
implementation used prior to release 2.6.  Among the changes are:</p>
<ul class="simple">
<li><p>Precise tracking of the status of cancelled work items, so that the
caller need not be concerned that an item may be processing when the
cancellation returns.  Checking of return values on cancellation is still
required.</p></li>
<li><p>Direct submission of delayable work items to the queue with
<a class="reference internal" href="../timing/clocks.html#c.K_NO_WAIT" title="K_NO_WAIT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">K_NO_WAIT</span></code></a> rather than always going through the timeout API,
which could introduce delays.</p></li>
<li><p>The ability to wait until a work item has completed or a queue has been
drained.</p></li>
<li><p>Finer control of behavior when scheduling a delayable work item,
specifically allowing a previous deadline to remain unchanged when a work
item is scheduled again.</p></li>
<li><p>Safe handling of work item resubmission when the item is being processed
on another workqueue.</p></li>
</ul>
<p>Using the return values of <a class="reference internal" href="#c.k_work_busy_get" title="k_work_busy_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_busy_get()</span></code></a> or
<a class="reference internal" href="#c.k_work_is_pending" title="k_work_is_pending"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_is_pending()</span></code></a>, or measurements of remaining time until
delayable work is scheduled, should be avoided to prevent race conditions
of the type observed with the previous implementation.  See also <a class="reference internal" href="#workqueue-best-practices">Workqueue
Best Practices</a>.</p>
</div>
<div class="section" id="work-item-lifecycle">
<h2><a class="toc-backref" href="#id1">Work Item Lifecycle</a><a class="headerlink" href="#work-item-lifecycle" title="Permalink to this headline">¶</a></h2>
<p>Any number of <strong>work items</strong> can be defined. Each work item is referenced
by its memory address.</p>
<p>A work item is assigned a <strong>handler function</strong>, which is the function
executed by the workqueue’s thread when the work item is processed. This
function accepts a single argument, which is the address of the work item
itself.  The work item also maintains information about its status.</p>
<p>A work item must be initialized before it can be used. This records the work
item’s handler function and marks it as not pending.</p>
<p>A work item may be <strong>queued</strong> (<a class="reference internal" href="#c.&#64;119.K_WORK_QUEUED" title="K_WORK_QUEUED"><code class="xref c c-macro docutils literal notranslate"><span class="pre">K_WORK_QUEUED</span></code></a>) by submitting it to a
workqueue by an ISR or a thread.  Submitting a work item appends the work item
to the workqueue’s queue.  Once the workqueue’s thread has processed all of
the preceding work items in its queue the thread will remove the next work
item from the queue and invoke the work item’s handler function. Depending on
the scheduling priority of the workqueue’s thread, and the work required by
other items in the queue, a queued work item may be processed quickly or it
may remain in the queue for an extended period of time.</p>
<p>A delayable work item may be <strong>scheduled</strong> (<a class="reference internal" href="#c.&#64;119.K_WORK_DELAYED" title="K_WORK_DELAYED"><code class="xref c c-macro docutils literal notranslate"><span class="pre">K_WORK_DELAYED</span></code></a>) to a
workqueue; see <a class="reference internal" href="#delayable-work">Delayable Work</a>.</p>
<p>A work item will be <strong>running</strong> (<a class="reference internal" href="#c.&#64;119.K_WORK_RUNNING" title="K_WORK_RUNNING"><code class="xref c c-macro docutils literal notranslate"><span class="pre">K_WORK_RUNNING</span></code></a>) when it is running
on a work queue, and may also be <strong>canceling</strong> (<a class="reference internal" href="#c.&#64;119.K_WORK_CANCELING" title="K_WORK_CANCELING"><code class="xref c c-macro docutils literal notranslate"><span class="pre">K_WORK_CANCELING</span></code></a>)
if it started running before a thread has requested that it be cancelled.</p>
<p>A work item can be in multiple states; for example it can be:</p>
<ul class="simple">
<li><p>running on a queue;</p></li>
<li><p>marked canceling (because a thread used <a class="reference internal" href="#c.k_work_cancel_sync" title="k_work_cancel_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_cancel_sync()</span></code></a> to
wait until the work item completed);</p></li>
<li><p>queued to run again on the same queue;</p></li>
<li><p>scheduled to be submitted to a (possibly different) queue</p></li>
</ul>
<p><em>all simultaneously</em>.  A work item that is in any of these states is <strong>pending</strong>
(<a class="reference internal" href="#c.k_work_is_pending" title="k_work_is_pending"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_is_pending()</span></code></a>) or <strong>busy</strong> (<a class="reference internal" href="#c.k_work_busy_get" title="k_work_busy_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_busy_get()</span></code></a>).</p>
<p>A handler function can use any kernel API available to threads. However,
operations that are potentially blocking (e.g. taking a semaphore) must be
used with care, since the workqueue cannot process subsequent work items in
its queue until the handler function finishes executing.</p>
<p>The single argument that is passed to a handler function can be ignored if it
is not required. If the handler function requires additional information about
the work it is to perform, the work item can be embedded in a larger data
structure. The handler function can then use the argument value to compute the
address of the enclosing data structure with <a class="reference internal" href="../../util/index.html#c.CONTAINER_OF" title="CONTAINER_OF"><code class="xref c c-macro docutils literal notranslate"><span class="pre">CONTAINER_OF</span></code></a>, and
thereby obtain access to the additional information it needs.</p>
<p>A work item is typically initialized once and then submitted to a specific
workqueue whenever work needs to be performed. If an ISR or a thread attempts
to submit a work item that is already queued the work item is not affected;
the work item remains in its current place in the workqueue’s queue, and
the work is only performed once.</p>
<p>A handler function is permitted to re-submit its work item argument
to the workqueue, since the work item is no longer queued at that time.
This allows the handler to execute work in stages, without unduly delaying
the processing of other work items in the workqueue’s queue.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>A pending work item <em>must not</em> be altered until the item has been processed
by the workqueue thread. This means a work item must not be re-initialized
while it is busy. Furthermore, any additional information the work item’s
handler function needs to perform its work must not be altered until
the handler function has finished executing.</p>
</div>
</div>
<div class="section" id="delayable-work">
<span id="k-delayable-work"></span><h2><a class="toc-backref" href="#id2">Delayable Work</a><a class="headerlink" href="#delayable-work" title="Permalink to this headline">¶</a></h2>
<p>An ISR or a thread may need to schedule a work item that is to be processed
only after a specified period of time, rather than immediately. This can be
done by <strong>scheduling</strong> a <strong>delayable work item</strong> to be submitted to a
workqueue at a future time.</p>
<p>A delayable work item contains a standard work item but adds fields that
record when and where the item should be submitted.</p>
<p>A delayable work item is initialized and scheduled to a workqueue in a similar
manner to a standard work item, although different kernel APIs are used.  When
the schedule request is made the kernel initiates a timeout mechanism that is
triggered after the specified delay has elapsed. Once the timeout occurs the
kernel submits the work item to the specified workqueue, where it remains
queued until it is processed in the standard manner.</p>
<p>Note that work handler used for delayable still receives a pointer to the
underlying non-delayable work structure, which is not publicly accessible from
<a class="reference internal" href="#c.k_work_delayable" title="k_work_delayable"><code class="xref c c-struct docutils literal notranslate"><span class="pre">k_work_delayable</span></code></a>.  To get access to an object that contains the
delayable work object use this idiom:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">work_handler</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">k_work</span><span class="w"> </span><span class="o">*</span><span class="n">work</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">k_work_delayable</span><span class="w"> </span><span class="o">*</span><span class="n">dwork</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k_work_delayable_from_work</span><span class="p">(</span><span class="n">work</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">work_context</span><span class="w"> </span><span class="o">*</span><span class="n">ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CONTAINER_OF</span><span class="p">(</span><span class="n">dwork</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">work_context</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                </span><span class="n">timed_work</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="triggered-work">
<h2><a class="toc-backref" href="#id3">Triggered Work</a><a class="headerlink" href="#triggered-work" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#c.k_work_poll_submit" title="k_work_poll_submit"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_poll_submit()</span></code></a> interface schedules a triggered work
item in response to a <strong>poll event</strong> (see <a class="reference internal" href="../other/polling.html#polling-v2"><span class="std std-ref">Polling API</span></a>), that will
call a user-defined function when a monitored resource becomes available
or poll signal is raised, or a timeout occurs.
In contrast to <a class="reference internal" href="../other/polling.html#c.k_poll" title="k_poll"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_poll()</span></code></a>, the triggered work does not require
a dedicated thread waiting or actively polling for a poll event.</p>
<p>A triggered work item is a standard work item that has the following
added properties:</p>
<ul class="simple">
<li><p>A pointer to an array of poll events that will trigger work item
submissions to the workqueue</p></li>
<li><p>A size of the array containing poll events.</p></li>
</ul>
<p>A triggered work item is initialized and submitted to a workqueue in a similar
manner to a standard work item, although dedicated kernel APIs are used.
When a submit request is made, the kernel begins observing kernel objects
specified by the poll events. Once at least one of the observed kernel
object’s changes state, the work item is submitted to the specified workqueue,
where it remains queued until it is processed in the standard manner.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>The triggered work item as well as the referenced array of poll events
have to be valid and cannot be modified for a complete triggered work
item lifecycle, from submission to work item execution or cancellation.</p>
</div>
<p>An ISR or a thread may <strong>cancel</strong> a triggered work item it has submitted
as long as it is still waiting for a poll event. In such case, the kernel
stops waiting for attached poll events and the specified work is not executed.
Otherwise the cancellation cannot be performed.</p>
</div>
<div class="section" id="system-workqueue">
<h2><a class="toc-backref" href="#id4">System Workqueue</a><a class="headerlink" href="#system-workqueue" title="Permalink to this headline">¶</a></h2>
<p>The kernel defines a workqueue known as the <em>system workqueue</em>, which is
available to any application or kernel code that requires workqueue support.
The system workqueue is optional, and only exists if the application makes
use of it.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Additional workqueues should only be defined when it is not possible
to submit new work items to the system workqueue, since each new workqueue
incurs a significant cost in memory footprint. A new workqueue can be
justified if it is not possible for its work items to co-exist with
existing system workqueue work items without an unacceptable impact;
for example, if the new work items perform blocking operations that
would delay other system workqueue processing to an unacceptable degree.</p>
</div>
</div>
<div class="section" id="how-to-use-workqueues">
<h2><a class="toc-backref" href="#id5">How to Use Workqueues</a><a class="headerlink" href="#how-to-use-workqueues" title="Permalink to this headline">¶</a></h2>
<div class="section" id="defining-and-controlling-a-workqueue">
<h3>Defining and Controlling a Workqueue<a class="headerlink" href="#defining-and-controlling-a-workqueue" title="Permalink to this headline">¶</a></h3>
<p>A workqueue is defined using a variable of type <a class="reference internal" href="#c.k_work_q" title="k_work_q"><code class="xref c c-struct docutils literal notranslate"><span class="pre">k_work_q</span></code></a>.
The workqueue is initialized by defining the stack area used by its
thread, initializing the <a class="reference internal" href="#c.k_work_q" title="k_work_q"><code class="xref c c-struct docutils literal notranslate"><span class="pre">k_work_q</span></code></a>, either zeroing its
memory or calling <a class="reference internal" href="#c.k_work_queue_init" title="k_work_queue_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_queue_init()</span></code></a>, and then calling
<a class="reference internal" href="#c.k_work_queue_start" title="k_work_queue_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_queue_start()</span></code></a>. The stack area must be defined using
<a class="reference internal" href="index.html#c.K_THREAD_STACK_DEFINE" title="K_THREAD_STACK_DEFINE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">K_THREAD_STACK_DEFINE</span></code></a> to ensure it is properly set up in
memory.</p>
<p>The following code defines and initializes a workqueue:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define MY_STACK_SIZE 512</span>
<span class="cp">#define MY_PRIORITY 5</span>

<span class="n">K_THREAD_STACK_DEFINE</span><span class="p">(</span><span class="n">my_stack_area</span><span class="p">,</span><span class="w"> </span><span class="n">MY_STACK_SIZE</span><span class="p">);</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">k_work_q</span><span class="w"> </span><span class="n">my_work_q</span><span class="p">;</span><span class="w"></span>

<span class="n">k_work_queue_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_work_q</span><span class="p">);</span><span class="w"></span>

<span class="n">k_work_queue_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_work_q</span><span class="p">,</span><span class="w"> </span><span class="n">my_stack_area</span><span class="p">,</span><span class="w"></span>
<span class="w">                   </span><span class="n">K_THREAD_STACK_SIZEOF</span><span class="p">(</span><span class="n">my_stack_area</span><span class="p">),</span><span class="w"> </span><span class="n">MY_PRIORITY</span><span class="p">,</span><span class="w"></span>
<span class="w">                   </span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>In addition the queue identity and certain behavior related to thread
rescheduling can be controlled by the optional final parameter; see
<a class="reference internal" href="#c.k_work_queue_start" title="k_work_queue_start"><code class="xref c c-struct docutils literal notranslate"><span class="pre">k_work_queue_start()</span></code></a> for details.</p>
<p>The following API can be used to interact with a workqueue:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#c.k_work_queue_drain" title="k_work_queue_drain"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_queue_drain()</span></code></a> can be used to block the caller until the
work queue has no items left.  Work items resubmitted from the workqueue
thread are accepted while a queue is draining, but work items from any other
thread or ISR are rejected.  The restriction on submitting more work can be
extended past the completion of the drain operation in order to allow the
blocking thread to perform additional work while the queue is “plugged”.
Note that draining a queue has no effect on scheduling or processing
delayable items, but if the queue is plugged and the deadline expires the
item will silently fail to be submitted.</p></li>
<li><p><a class="reference internal" href="#c.k_work_queue_unplug" title="k_work_queue_unplug"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_queue_unplug()</span></code></a> removes any previous block on submission to
the queue due to a previous drain operation.</p></li>
</ul>
</div>
<div class="section" id="submitting-a-work-item">
<h3>Submitting a Work Item<a class="headerlink" href="#submitting-a-work-item" title="Permalink to this headline">¶</a></h3>
<p>A work item is defined using a variable of type <a class="reference internal" href="#c.k_work" title="k_work"><code class="xref c c-struct docutils literal notranslate"><span class="pre">k_work</span></code></a>.  It must
be initialized by calling <a class="reference internal" href="#c.k_work_init" title="k_work_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_init()</span></code></a>, unless it is defined using
<a class="reference internal" href="#c.K_WORK_DEFINE" title="K_WORK_DEFINE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">K_WORK_DEFINE</span></code></a> in which case initialization is performed at
compile-time.</p>
<p>An initialized work item can be submitted to the system workqueue by
calling <a class="reference internal" href="#c.k_work_submit" title="k_work_submit"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_submit()</span></code></a>, or to a specified workqueue by
calling <a class="reference internal" href="#c.k_work_submit_to_queue" title="k_work_submit_to_queue"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_submit_to_queue()</span></code></a>.</p>
<p>The following code demonstrates how an ISR can offload the printing
of error messages to the system workqueue. Note that if the ISR attempts
to resubmit the work item while it is still queued, the work item is left
unchanged and the associated error message will not be printed.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">device_info</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">k_work</span><span class="w"> </span><span class="n">work</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">name</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">my_device</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">my_isr</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">error</span><span class="w"> </span><span class="n">detected</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">k_work_submit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_device</span><span class="p">.</span><span class="n">work</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">print_error</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">k_work</span><span class="w"> </span><span class="o">*</span><span class="n">item</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">device_info</span><span class="w"> </span><span class="o">*</span><span class="n">the_device</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="n">CONTAINER_OF</span><span class="p">(</span><span class="n">item</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">device_info</span><span class="p">,</span><span class="w"> </span><span class="n">work</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">printk</span><span class="p">(</span><span class="s">&quot;Got error on device %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">the_device</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/* initialize name info for a device */</span><span class="w"></span>
<span class="n">strcpy</span><span class="p">(</span><span class="n">my_device</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;FOO_dev&quot;</span><span class="p">);</span><span class="w"></span>

<span class="cm">/* initialize work item for printing device&#39;s error messages */</span><span class="w"></span>
<span class="n">k_work_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_device</span><span class="p">.</span><span class="n">work</span><span class="p">,</span><span class="w"> </span><span class="n">print_error</span><span class="p">);</span><span class="w"></span>

<span class="cm">/* install my_isr() as interrupt handler for the device (not shown) */</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<p>The following API can be used to check the status of or synchronize with the
work item:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#c.k_work_busy_get" title="k_work_busy_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_busy_get()</span></code></a> returns a snapshot of flags indicating work item
state.  A zero value indicates the work is not scheduled, submitted, being
executed, or otherwise still being referenced by the workqueue
infrastructure.</p></li>
<li><p><a class="reference internal" href="#c.k_work_is_pending" title="k_work_is_pending"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_is_pending()</span></code></a> is a helper that indicates <code class="docutils literal notranslate"><span class="pre">true</span></code> if and only
if the work is scheduled, queued, or running.</p></li>
<li><p><a class="reference internal" href="#c.k_work_flush" title="k_work_flush"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_flush()</span></code></a> may be invoked from threads to block until the work
item has completed.  It returns immediately if the work is not pending.</p></li>
<li><p><a class="reference internal" href="#c.k_work_cancel" title="k_work_cancel"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_cancel()</span></code></a> attempts to prevent the work item from being
executed.  This may or may not be successful. This is safe to invoke
from ISRs.</p></li>
<li><p><a class="reference internal" href="#c.k_work_cancel_sync" title="k_work_cancel_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_cancel_sync()</span></code></a> may be invoked from threads to block until
the work completes; it will return immediately if the cancellation was
successful or not necessary (the work wasn’t submitted or running).  This
can be used after <a class="reference internal" href="#c.k_work_cancel" title="k_work_cancel"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_cancel()</span></code></a> is invoked (from an ISR)` to
confirm completion of an ISR-initiated cancellation.</p></li>
</ul>
</div>
<div class="section" id="scheduling-a-delayable-work-item">
<h3>Scheduling a Delayable Work Item<a class="headerlink" href="#scheduling-a-delayable-work-item" title="Permalink to this headline">¶</a></h3>
<p>A delayable work item is defined using a variable of type
<a class="reference internal" href="#c.k_work_delayable" title="k_work_delayable"><code class="xref c c-struct docutils literal notranslate"><span class="pre">k_work_delayable</span></code></a>. It must be initialized by calling
<a class="reference internal" href="#c.k_work_init_delayable" title="k_work_init_delayable"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_init_delayable()</span></code></a>.</p>
<p>For delayed work there are two common use cases, depending on whether a
deadline should be extended if a new event occurs. An example is collecting
data that comes in asynchronously, e.g. characters from a UART associated with
a keyboard.  There are two APIs that submit work after a delay:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#c.k_work_schedule" title="k_work_schedule"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_schedule()</span></code></a> (or <a class="reference internal" href="#c.k_work_schedule_for_queue" title="k_work_schedule_for_queue"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_schedule_for_queue()</span></code></a>)
schedules work to be executed at a specific time or after a delay.  Further
attempts to schedule the same item with this API before the delay completes
will not change the time at which the item will be submitted to its queue.
Use this if the policy is to keep collecting data until a specified delay
since the <strong>first</strong> unprocessed data was received;</p></li>
<li><p><a class="reference internal" href="#c.k_work_reschedule" title="k_work_reschedule"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_reschedule()</span></code></a> (or <a class="reference internal" href="#c.k_work_reschedule_for_queue" title="k_work_reschedule_for_queue"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_reschedule_for_queue()</span></code></a>)
unconditionally sets the deadline for the work, replacing any previous
incomplete delay and changing the destination queue if necessary.  Use this
if the policy is to keep collecting data until a specified delay since the
<strong>last</strong> unprocessed data was received.</p></li>
</ul>
<p>If the work item is not scheduled both APIs behave the same.  If
<a class="reference internal" href="../timing/clocks.html#c.K_NO_WAIT" title="K_NO_WAIT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">K_NO_WAIT</span></code></a> is specified as the delay the behavior is as if the item
was immediately submitted directly to the target queue, without waiting for a
minimal timeout (unless <a class="reference internal" href="#c.k_work_schedule" title="k_work_schedule"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_schedule()</span></code></a> is used and a previous
delay has not completed).</p>
<p>Both also have variants that allow
control of the queue used for submission.</p>
<p>The helper function <a class="reference internal" href="#c.k_work_delayable_from_work" title="k_work_delayable_from_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_delayable_from_work()</span></code></a> can be used to get
a pointer to the containing <a class="reference internal" href="#c.k_work_delayable" title="k_work_delayable"><code class="xref c c-struct docutils literal notranslate"><span class="pre">k_work_delayable</span></code></a> from a pointer to
<a class="reference internal" href="#c.k_work" title="k_work"><code class="xref c c-struct docutils literal notranslate"><span class="pre">k_work</span></code></a> that is passed to a work handler function.</p>
<p>The following additional API can be used to check the status of or synchronize
with the work item:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#c.k_work_delayable_busy_get" title="k_work_delayable_busy_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_delayable_busy_get()</span></code></a> is the analog to <a class="reference internal" href="#c.k_work_busy_get" title="k_work_busy_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_busy_get()</span></code></a>
for delayable work.</p></li>
<li><p><a class="reference internal" href="#c.k_work_delayable_is_pending" title="k_work_delayable_is_pending"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_delayable_is_pending()</span></code></a> is the analog to
<a class="reference internal" href="#c.k_work_is_pending" title="k_work_is_pending"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_is_pending()</span></code></a> for delayable work.</p></li>
<li><p><a class="reference internal" href="#c.k_work_flush_delayable" title="k_work_flush_delayable"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_flush_delayable()</span></code></a> is the analog to <a class="reference internal" href="#c.k_work_flush" title="k_work_flush"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_flush()</span></code></a>
for delayable work.</p></li>
<li><p><a class="reference internal" href="#c.k_work_cancel_delayable" title="k_work_cancel_delayable"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_cancel_delayable()</span></code></a> is the analog to
<a class="reference internal" href="#c.k_work_cancel" title="k_work_cancel"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_cancel()</span></code></a> for delayable work; similarly with
<a class="reference internal" href="#c.k_work_cancel_delayable_sync" title="k_work_cancel_delayable_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_cancel_delayable_sync()</span></code></a>.</p></li>
</ul>
</div>
<div class="section" id="synchronizing-with-work-items">
<h3>Synchronizing with Work Items<a class="headerlink" href="#synchronizing-with-work-items" title="Permalink to this headline">¶</a></h3>
<p>While the state of both regular and delayable work items can be determined
from any context using <a class="reference internal" href="#c.k_work_busy_get" title="k_work_busy_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_busy_get()</span></code></a> and
<a class="reference internal" href="#c.k_work_delayable_busy_get" title="k_work_delayable_busy_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_delayable_busy_get()</span></code></a> some use cases require synchronizing
with work items after they’ve been submitted.  <a class="reference internal" href="#c.k_work_flush" title="k_work_flush"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_flush()</span></code></a>,
<a class="reference internal" href="#c.k_work_cancel_sync" title="k_work_cancel_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_cancel_sync()</span></code></a>, and <a class="reference internal" href="#c.k_work_cancel_delayable_sync" title="k_work_cancel_delayable_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_cancel_delayable_sync()</span></code></a>
can be invoked from thread context to wait until the requested state has been
reached.</p>
<p>These APIs must be provided with a <a class="reference internal" href="#c.k_work_sync" title="k_work_sync"><code class="xref c c-struct docutils literal notranslate"><span class="pre">k_work_sync</span></code></a> object that has no
application-inspectable components but is needed to provide the
synchronization objects.  These objects should not be allocated on a stack if
the code is expected to work on architectures with
<a class="reference internal" href="../../kconfig/dummy-syms.html#std-kconfig-CONFIG_KERNEL_COHERENCE"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_KERNEL_COHERENCE</span></code></a>.</p>
</div>
</div>
<div class="section" id="workqueue-best-practices">
<h2><a class="toc-backref" href="#id6">Workqueue Best Practices</a><a class="headerlink" href="#workqueue-best-practices" title="Permalink to this headline">¶</a></h2>
<div class="section" id="avoid-race-conditions">
<h3>Avoid Race Conditions<a class="headerlink" href="#avoid-race-conditions" title="Permalink to this headline">¶</a></h3>
<p>Sometimes the data a work item must process is naturally thread-safe, for
example when it’s put into a <code class="xref c c-struct docutils literal notranslate"><span class="pre">k_queue</span></code> by some thread and processed
in the work thread. More often external synchronization is required to avoid
data races: cases where the work thread might inspect or manipulate shared
state that’s being accessed by another thread or interrupt.  Such state might
be a flag indicating that work needs to be done, or a shared object that is
filled by an ISR or thread and read by the work handler.</p>
<p>For simple flags <a class="reference internal" href="../other/atomic.html#atomic-v2"><span class="std std-ref">Atomic Services</span></a> may be sufficient.  In other cases spin
locks (<code class="xref c c-struct docutils literal notranslate"><span class="pre">k_spinlock_t</span></code>) or thread-aware locks (<code class="xref c c-struct docutils literal notranslate"><span class="pre">k_sem</span></code>,
<a class="reference internal" href="../synchronization/mutexes.html#c.k_mutex" title="k_mutex"><code class="xref c c-struct docutils literal notranslate"><span class="pre">k_mutex</span></code></a> , …) may be used to ensure data races don’t occur.</p>
<p>If the selected lock mechanism can <a class="reference internal" href="../../api/terminology.html#api-term-sleep"><span class="std std-ref">sleep</span></a> then allowing the
work thread to sleep will starve other work queue items, which may need to
make progress in order to get the lock released. Work handlers should try to
take the lock with its no-wait path. For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">work_handler</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">work</span><span class="w"> </span><span class="o">*</span><span class="n">work</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">work_context</span><span class="w"> </span><span class="o">*</span><span class="n">parent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CONTAINER_OF</span><span class="p">(</span><span class="n">work</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">work_context</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                   </span><span class="n">work_item</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">k_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span><span class="w"> </span><span class="n">K_NO_WAIT</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="cm">/* NB: Submit will fail if the work item is being cancelled. */</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">k_work_submit</span><span class="p">(</span><span class="n">work</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* do stuff under lock */</span><span class="w"></span>
<span class="w">        </span><span class="n">k_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* do stuff without lock */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Be aware that if the lock is held by a thread with a lower priority than the
work queue the resubmission may starve the thread that would release the lock,
causing the application to fail.  Where the idiom above is required a
delayable work item is preferred, and the work should be (re-)scheduled with a
non-zero delay to allow the thread holding the lock to make progress.</p>
<p>Note that submitting from the work handler can fail if the work item had been
cancelled.  Generally this is acceptable, since the cancellation will complete
once the handler finishes.  If it is not, the code above must take other steps
to notify the application that the work could not be performed.</p>
<p>Work items in isolation are self-locking, so you don’t need to hold an
external lock just to submit or schedule them. Even if you use external state
protected by such a lock to prevent further resubmission, it’s safe to do the
resubmit as long as you’re sure that eventually the item will take its lock
and check that state to determine whether it should do anything.  Where a
delayable work item is being rescheduled in its handler due to inability to
take the lock some other self-locking state, such as an atomic flag set by the
application/driver when the cancel is initiated, would be required to detect
the cancellation and avoid the cancelled work item being submitted again after
the deadline.</p>
</div>
<div class="section" id="check-return-values">
<h3>Check Return Values<a class="headerlink" href="#check-return-values" title="Permalink to this headline">¶</a></h3>
<p>All work API functions return status of the underlying operation, and in many
cases it is important to verify that the intended result was obtained.</p>
<ul class="simple">
<li><p>Submitting a work item (<a class="reference internal" href="#c.k_work_submit_to_queue" title="k_work_submit_to_queue"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_submit_to_queue()</span></code></a>) can fail if the
work is being cancelled or the queue is not accepting new items.  If this
happens the work will not be executed, which could cause a subsystem that is
animated by work handler activity to become non-responsive.</p></li>
<li><p>Asynchronous cancellation (<a class="reference internal" href="#c.k_work_cancel" title="k_work_cancel"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_cancel()</span></code></a> or
<a class="reference internal" href="#c.k_work_cancel_delayable" title="k_work_cancel_delayable"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_cancel_delayable()</span></code></a>) can complete while the work item is still
being run by a handler.  Proceeding to manipulate state shared with the work
handler will result in data races that can cause failures.</p></li>
</ul>
<p>Many race conditions have been present in Zephyr code because the results of
an operation were not checked.</p>
<p>There may be good reason to believe that a return value indicating that the
operation did not complete as expected is not a problem.  In those cases the
code should clearly document this, by (1) casting the return value to <code class="docutils literal notranslate"><span class="pre">void</span></code>
to indicate that the result is intentionally ignored, and (2) documenting what
happens in the unexpected case.  For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* If this fails, the work handler will check pub-&gt;active and</span>
<span class="cm"> * exit without transmitting.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">k_work_cancel_delayable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pub</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>However in such a case the following code must still avoid data races, as it
cannot guarantee that the work thread is not accessing work-related state.</p>
</div>
<div class="section" id="don-t-optimize-prematurely">
<h3>Don’t Optimize Prematurely<a class="headerlink" href="#don-t-optimize-prematurely" title="Permalink to this headline">¶</a></h3>
<p>The workqueue API is designed to be safe when invoked from multiple threads
and interrupts. Attempts to externally inspect a work item’s state and make
decisions based on the result are likely to create new problems.</p>
<p>So when new work comes in, just submit it. Don’t attempt to “optimize” by
checking whether the work item is already submitted by inspecting snapshot
state with <a class="reference internal" href="#c.k_work_is_pending" title="k_work_is_pending"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_is_pending()</span></code></a> or <a class="reference internal" href="#c.k_work_busy_get" title="k_work_busy_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_busy_get()</span></code></a>, or
checking for a non-zero delay from
<a class="reference internal" href="#c.k_work_delayable_remaining_get" title="k_work_delayable_remaining_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_delayable_remaining_get()</span></code></a>. Those checks are fragile: a “busy”
indication can be obsolete by the time the test is returned, and a “not-busy”
indication can also be wrong if work is submitted from multiple contexts, or
(for delayable work) if the deadline has completed but the work is still in
queued or running state.</p>
<p>A general best practice is to always maintain in shared state some condition
that can be checked by the handler to confirm whether there is work to be
done.  This way you can use the work handler as the standard cleanup path:
rather than having to deal with cancellation and cleanup at points where items
are submitted, you may be able to have everything done in the work handler
itself.</p>
<p>A rare case where you could safely use <a class="reference internal" href="#c.k_work_is_pending" title="k_work_is_pending"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_is_pending()</span></code></a> is as a
check to avoid invoking <a class="reference internal" href="#c.k_work_flush" title="k_work_flush"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_flush()</span></code></a> or
<a class="reference internal" href="#c.k_work_cancel_sync" title="k_work_cancel_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_work_cancel_sync()</span></code></a>, if you are <em>certain</em> that nothing else might
submit the work while you’re checking (generally because you’re holding a lock
that prevents access to state used for submission).</p>
</div>
</div>
<div class="section" id="suggested-uses">
<h2><a class="toc-backref" href="#id7">Suggested Uses</a><a class="headerlink" href="#suggested-uses" title="Permalink to this headline">¶</a></h2>
<p>Use the system workqueue to defer complex interrupt-related processing from an
ISR to a shared thread. This allows the interrupt-related processing to be
done promptly without compromising the system’s ability to respond to
subsequent interrupts, and does not require the application to define and
manage an additional thread to do the processing.</p>
</div>
<div class="section" id="configuration-options">
<h2><a class="toc-backref" href="#id8">Configuration Options</a><a class="headerlink" href="#configuration-options" title="Permalink to this headline">¶</a></h2>
<p>Related configuration options:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../../kconfig/dummy-syms.html#std-kconfig-CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE</span></code></a></p></li>
<li><p><a class="reference internal" href="../../kconfig/dummy-syms.html#std-kconfig-CONFIG_SYSTEM_WORKQUEUE_PRIORITY"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_SYSTEM_WORKQUEUE_PRIORITY</span></code></a></p></li>
<li><p><a class="reference internal" href="../../kconfig/dummy-syms.html#std-kconfig-CONFIG_SYSTEM_WORKQUEUE_NO_YIELD"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_SYSTEM_WORKQUEUE_NO_YIELD</span></code></a></p></li>
</ul>
</div>
<div class="section" id="api-reference">
<h2><a class="toc-backref" href="#id9">API Reference</a><a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h2>
<dl>
<dt class="sig sig-object cpp">
<span class="target" id="group__workqueue__apis"></span><em><span class="pre">group</span></em> <span class="sig-name descname"><span class="pre">workqueue_apis</span></span></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-defines">Defines</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.K_WORK_DELAYABLE_DEFINE">
<span class="target" id="group__workqueue__apis_1ga893b281f3d2bc0088650536899e17903"></span><span class="sig-name descname"><span class="n"><span class="pre">K_WORK_DELAYABLE_DEFINE</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">work</span></span>, <span class="n"><span class="pre">work_handler</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.K_WORK_DELAYABLE_DEFINE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a statically-defined delayable work item. </p>
<p>This macro can be used to initialize a statically-defined delayable work item, prior to its first use. For example,</p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">K_WORK_DELAYABLE_DEFINE</span><span class="p">(</span><span class="o">&lt;</span><span class="n">dwork</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">work_handler</span><span class="o">&gt;</span><span class="p">);</span> 
</pre></div>
</div>
</p>
<p>Note that if the runtime dependencies support initialization with <a class="reference internal" href="#group__workqueue__apis_1ga2876c5d82fb2340a093bc4d689a55465"><span class="std std-ref">k_work_init_delayable()</span></a> using that will eliminate the initialized object in ROM that is produced by this macro and copied in at system startup.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>work</strong> – Symbol name for delayable work item object </p></li>
<li><p><strong>work_handler</strong> – Function to invoke each time work item is processed. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.K_WORK_USER_DEFINE">
<span class="target" id="group__workqueue__apis_1ga4f3eac1fc56d5c9c21a3afa9b964b0bf"></span><span class="sig-name descname"><span class="n"><span class="pre">K_WORK_USER_DEFINE</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">work</span></span>, <span class="n"><span class="pre">work_handler</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.K_WORK_USER_DEFINE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a statically-defined user work item. </p>
<p>This macro can be used to initialize a statically-defined user work item, prior to its first use. For example,</p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">K_WORK_USER_DEFINE</span><span class="p">(</span><span class="o">&lt;</span><span class="n">work</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">work_handler</span><span class="o">&gt;</span><span class="p">);</span> 
</pre></div>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>work</strong> – Symbol name for work item object </p></li>
<li><p><strong>work_handler</strong> – Function to invoke each time work item is processed. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.K_WORK_DEFINE">
<span class="target" id="group__workqueue__apis_1gaf8e003eefa5dd66ba883688f9d39c333"></span><span class="sig-name descname"><span class="n"><span class="pre">K_WORK_DEFINE</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">work</span></span>, <span class="n"><span class="pre">work_handler</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.K_WORK_DEFINE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a statically-defined work item. </p>
<p>This macro can be used to initialize a statically-defined workqueue work item, prior to its first use. For example,</p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">K_WORK_DEFINE</span><span class="p">(</span><span class="o">&lt;</span><span class="n">work</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">work_handler</span><span class="o">&gt;</span><span class="p">);</span> 
</pre></div>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>work</strong> – Symbol name for work item object </p></li>
<li><p><strong>work_handler</strong> – Function to invoke each time work item is processed. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.K_DELAYED_WORK_DEFINE">
<span class="target" id="group__workqueue__apis_1ga41c8a64e854c6cca3a6956079cce2826"></span><span class="sig-name descname"><span class="n"><span class="pre">K_DELAYED_WORK_DEFINE</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">work</span></span>, <span class="n"><span class="pre">work_handler</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.K_DELAYED_WORK_DEFINE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a statically-defined delayed work item. </p>
<p>This macro can be used to initialize a statically-defined workqueue delayed work item, prior to its first use. For example,</p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">K_DELAYED_WORK_DEFINE</span><span class="p">(</span><span class="o">&lt;</span><span class="n">work</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">work_handler</span><span class="o">&gt;</span><span class="p">);</span> 
</pre></div>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>work</strong> – Symbol name for delayed work item object </p></li>
<li><p><strong>work_handler</strong> – Function to invoke each time work item is processed. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-typedefs">Typedefs</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.k_work_handler_t">
<span class="target" id="group__workqueue__apis_1ga5add9ef0dce306a08413c4140fc0bdda"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">k_work_handler_t</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work" title="k_work"><span class="n"><span class="pre">k_work</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="p"><span class="pre">)</span></span><a class="headerlink" href="#c.k_work_handler_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The signature for a work item handler function. </p>
<p>The function will be invoked by the thread animating a work queue.</p>
<dl class="field-list simple">
<dt class="field-odd">Param work</dt>
<dd class="field-odd"><p>the work item that provided the handler. </p>
</dd>
</dl>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.k_work_user_handler_t">
<span class="target" id="group__workqueue__apis_1gafdb3f5f2225b3d5d1fe682cb97f3b328"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">k_work_user_handler_t</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">k_work_user</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="p"><span class="pre">)</span></span><a class="headerlink" href="#c.k_work_user_handler_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Work item handler function type for user work queues. </p>
<p>A work item’s handler function is executed by a user workqueue’s thread when the work item is processed by the workqueue.</p>
<dl class="field-list simple">
<dt class="field-odd">Param work</dt>
<dd class="field-odd"><p>Address of the work item. </p>
</dd>
</dl>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-enums">Enums</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.&#64;119">
<span class="target" id="group__workqueue__apis_1ga15b3bbe041870ee299f7e042b0305e3c"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">[anonymous]</span></span></span><a class="headerlink" href="#c.@119" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><em>Values:</em></p>
<dl class="c enumerator">
<dt class="sig sig-object c" id="c.&#64;119.K_WORK_RUNNING">
<span class="target" id="group__workqueue__apis_1gga15b3bbe041870ee299f7e042b0305e3cac6bee9a104cf6ee3853579f5eb15c165"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">K_WORK_RUNNING</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><a class="reference internal" href="../../util/index.html#c.BIT" title="BIT"><span class="n"><span class="pre">BIT</span></span></a><span class="p"><span class="pre">(</span></span><span class="n"><span class="pre">K_WORK_RUNNING_BIT</span></span><span class="p"><span class="pre">)</span></span><a class="headerlink" href="#c.@119.K_WORK_RUNNING" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Flag indicating a work item that is running under a work queue thread. </p>
<p>Accessed via <a class="reference internal" href="#group__workqueue__apis_1gaba8a8734768d768b433f9d8490e7df7b"><span class="std std-ref">k_work_busy_get()</span></a>. May co-occur with other flags. </p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.&#64;119.K_WORK_CANCELING">
<span class="target" id="group__workqueue__apis_1gga15b3bbe041870ee299f7e042b0305e3ca9fdc4327489bcdcca3de0ee9eed6b732"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">K_WORK_CANCELING</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><a class="reference internal" href="../../util/index.html#c.BIT" title="BIT"><span class="n"><span class="pre">BIT</span></span></a><span class="p"><span class="pre">(</span></span><span class="n"><span class="pre">K_WORK_CANCELING_BIT</span></span><span class="p"><span class="pre">)</span></span><a class="headerlink" href="#c.@119.K_WORK_CANCELING" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Flag indicating a work item that is being canceled. </p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   <span class="n">Accessed</span> <span class="n">via</span> <span class="n">k_work_busy_get</span><span class="p">()</span><span class="o">.</span>  <span class="n">May</span> <span class="n">co</span><span class="o">-</span><span class="n">occur</span> <span class="k">with</span> <span class="n">other</span> <span class="n">flags</span><span class="o">.</span>
</pre></div>
</div>
 </p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.&#64;119.K_WORK_QUEUED">
<span class="target" id="group__workqueue__apis_1gga15b3bbe041870ee299f7e042b0305e3caa7f8855bc9931bff79062ce53b06eb85"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">K_WORK_QUEUED</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><a class="reference internal" href="../../util/index.html#c.BIT" title="BIT"><span class="n"><span class="pre">BIT</span></span></a><span class="p"><span class="pre">(</span></span><span class="n"><span class="pre">K_WORK_QUEUED_BIT</span></span><span class="p"><span class="pre">)</span></span><a class="headerlink" href="#c.@119.K_WORK_QUEUED" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Flag indicating a work item that has been submitted to a queue but has not started running. </p>
<p>Accessed via <a class="reference internal" href="#group__workqueue__apis_1gaba8a8734768d768b433f9d8490e7df7b"><span class="std std-ref">k_work_busy_get()</span></a>. May co-occur with other flags. </p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.&#64;119.K_WORK_DELAYED">
<span class="target" id="group__workqueue__apis_1gga15b3bbe041870ee299f7e042b0305e3cab4bf9e74435077b2bbfe1de1f4e80aed"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">K_WORK_DELAYED</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><a class="reference internal" href="../../util/index.html#c.BIT" title="BIT"><span class="n"><span class="pre">BIT</span></span></a><span class="p"><span class="pre">(</span></span><span class="n"><span class="pre">K_WORK_DELAYED_BIT</span></span><span class="p"><span class="pre">)</span></span><a class="headerlink" href="#c.@119.K_WORK_DELAYED" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Flag indicating a delayed work item that is scheduled for submission to a queue. </p>
<p>Accessed via <a class="reference internal" href="#group__workqueue__apis_1gaba8a8734768d768b433f9d8490e7df7b"><span class="std std-ref">k_work_busy_get()</span></a>. May co-occur with other flags. </p>
</dd></dl>

</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_init">
<span class="target" id="group__workqueue__apis_1gaf20080884a2893d39cd8e862b34a2a30"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work" title="k_work"><span class="n"><span class="pre">k_work</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span>, <a class="reference internal" href="#c.k_work_handler_t" title="k_work_handler_t"><span class="n"><span class="pre">k_work_handler_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">handler</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a (non-delayable) work structure. </p>
<p>This must be invoked before submitting a work structure for the first time. It need not be invoked again on the same work structure. It can be re-invoked to change the associated handler, but this must be done when the work item is idle.</p>
<p><dl class="simple">
<dt><strong>Function properties (list may not be complete)</strong></dt><dd><p><span> <a class="reference internal" href="../../api/terminology.html#api-term-isr-ok"><span class="std std-ref">isr-ok</span></a></span> </p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>work</strong> – the work structure to be initialized.</p></li>
<li><p><strong>handler</strong> – the handler to be invoked by the work item. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_busy_get">
<span class="target" id="group__workqueue__apis_1gaba8a8734768d768b433f9d8490e7df7b"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_busy_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work" title="k_work"><span class="n"><span class="pre">k_work</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_busy_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Busy state flags from the work item. </p>
<p>A zero return value indicates the work item appears to be idle.</p>
<p><dl class="simple">
<dt><strong>Function properties (list may not be complete)</strong></dt><dd><p><span> <a class="reference internal" href="../../api/terminology.html#api-term-isr-ok"><span class="std std-ref">isr-ok</span></a></span> </p>
</dd>
</dl>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a live snapshot of state, which may change before the result is checked. Use locks where appropriate.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>work</strong> – pointer to the work item.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a mask of flags K_WORK_DELAYED, K_WORK_QUEUED, K_WORK_RUNNING, and K_WORK_CANCELING. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_is_pending">
<span class="target" id="group__workqueue__apis_1ga0d1d2e1d2ba2e89a560a1bdc5365d9e0"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_is_pending</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work" title="k_work"><span class="n"><span class="pre">k_work</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_is_pending" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test whether a work item is currently pending. </p>
<p>Wrapper to determine whether a work item is in a non-idle dstate.</p>
<p><dl class="simple">
<dt><strong>Function properties (list may not be complete)</strong></dt><dd><p><span> <a class="reference internal" href="../../api/terminology.html#api-term-isr-ok"><span class="std std-ref">isr-ok</span></a></span> </p>
</dd>
</dl>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a live snapshot of state, which may change before the result is checked. Use locks where appropriate.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>work</strong> – pointer to the work item.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>true if and only if <a class="reference internal" href="#group__workqueue__apis_1gaba8a8734768d768b433f9d8490e7df7b"><span class="std std-ref">k_work_busy_get()</span></a> returns a non-zero value. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_submit_to_queue">
<span class="target" id="group__workqueue__apis_1ga5353e76f73db070614f50d06d292d05c"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_submit_to_queue</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work_q" title="k_work_q"><span class="n"><span class="pre">k_work_q</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">queue</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work" title="k_work"><span class="n"><span class="pre">k_work</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_submit_to_queue" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Submit a work item to a queue. </p>
<p><dl class="simple">
<dt><strong>Function properties (list may not be complete)</strong></dt><dd><p><span> <a class="reference internal" href="../../api/terminology.html#api-term-isr-ok"><span class="std std-ref">isr-ok</span></a></span> </p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>queue</strong> – pointer to the work queue on which the item should run. If NULL the queue from the most recent submission will be used.</p></li>
<li><p><strong>work</strong> – pointer to the work item.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>0</strong> – if work was already submitted to a queue </p></li>
<li><p><strong>1</strong> – if work was not submitted and has been queued to <code class="docutils literal notranslate"><span class="pre">queue</span></code> </p></li>
<li><p><strong>2</strong> – if work was running and has been queued to the queue that was running it </p></li>
<li><p><strong>-EBUSY</strong> – <ul>
<li><p>if work submission was rejected because the work item is cancelling; or</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">queue</span></code> is draining; or</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">queue</span></code> is plugged. </p></li>
</ul>
</p></li>
<li><p><strong>-EINVAL</strong> – if <code class="docutils literal notranslate"><span class="pre">queue</span></code> is null and the work item has never been run. </p></li>
<li><p><strong>-ENODEV</strong> – if <code class="docutils literal notranslate"><span class="pre">queue</span></code> has not been started. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_submit">
<span class="target" id="group__workqueue__apis_1gace61b59575093d7442f39ccb7be686d7"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_submit</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work" title="k_work"><span class="n"><span class="pre">k_work</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_submit" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Submit a work item to the system queue. </p>
<p><dl class="simple">
<dt><strong>Function properties (list may not be complete)</strong></dt><dd><p><span> <a class="reference internal" href="../../api/terminology.html#api-term-isr-ok"><span class="std std-ref">isr-ok</span></a></span> </p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>work</strong> – pointer to the work item.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>as with <a class="reference internal" href="#group__workqueue__apis_1ga5353e76f73db070614f50d06d292d05c"><span class="std std-ref">k_work_submit_to_queue()</span></a>. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_flush">
<span class="target" id="group__workqueue__apis_1gabd1cda459bab538fb2d6dfd84a73b253"></span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_flush</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work" title="k_work"><span class="n"><span class="pre">k_work</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work_sync" title="k_work_sync"><span class="n"><span class="pre">k_work_sync</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sync</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_flush" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wait for last-submitted instance to complete. </p>
<p>Resubmissions may occur while waiting, including chained submissions (from within the handler).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Be careful of caller and work queue thread relative priority. If this function sleeps it will not return until the work queue thread completes the tasks that allow this thread to resume.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Behavior is undefined if this function is invoked on <code class="docutils literal notranslate"><span class="pre">work</span></code> from a work queue running <code class="docutils literal notranslate"><span class="pre">work</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>work</strong> – pointer to the work item.</p></li>
<li><p><strong>sync</strong> – pointer to an opaque item containing state related to the pending cancellation. The object must persist until the call returns, and be accessible from both the caller thread and the work queue thread. The object must not be used for any other flush or cancel operation until this one completes. On architectures with CONFIG_KERNEL_COHERENCE the object must be allocated in coherent memory.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>true</strong> – if call had to wait for completion </p></li>
<li><p><strong>false</strong> – if work was already idle </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_cancel">
<span class="target" id="group__workqueue__apis_1ga389fe2a8fb20f9bd593cf8d990727078"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_cancel</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work" title="k_work"><span class="n"><span class="pre">k_work</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_cancel" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Cancel a work item. </p>
<p>This attempts to prevent a pending (non-delayable) work item from being processed by removing it from the work queue. If the item is being processed, the work item will continue to be processed, but resubmissions are rejected until cancellation completes.</p>
<p>If this returns zero cancellation is complete, otherwise something (probably a work queue thread) is still referencing the item.</p>
<p>See also <a class="reference internal" href="#group__workqueue__apis_1gab2b05cfe3af08f7d32c3946fa1c808f9"><span class="std std-ref">k_work_cancel_sync()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Function properties (list may not be complete)</strong></dt><dd><p><span> <a class="reference internal" href="../../api/terminology.html#api-term-isr-ok"><span class="std std-ref">isr-ok</span></a></span> </p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>work</strong> – pointer to the work item.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the <a class="reference internal" href="#group__workqueue__apis_1gaba8a8734768d768b433f9d8490e7df7b"><span class="std std-ref">k_work_busy_get()</span></a> status indicating the state of the item after all cancellation steps performed by this call are completed. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_cancel_sync">
<span class="target" id="group__workqueue__apis_1gab2b05cfe3af08f7d32c3946fa1c808f9"></span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_cancel_sync</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work" title="k_work"><span class="n"><span class="pre">k_work</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work_sync" title="k_work_sync"><span class="n"><span class="pre">k_work_sync</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sync</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_cancel_sync" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Cancel a work item and wait for it to complete. </p>
<p>Same as <a class="reference internal" href="#group__workqueue__apis_1ga389fe2a8fb20f9bd593cf8d990727078"><span class="std std-ref">k_work_cancel()</span></a> but does not return until cancellation is complete. This can be invoked by a thread after <a class="reference internal" href="#group__workqueue__apis_1ga389fe2a8fb20f9bd593cf8d990727078"><span class="std std-ref">k_work_cancel()</span></a> to synchronize with a previous cancellation.</p>
<p>On return the work structure will be idle unless something submits it after the cancellation was complete.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Be careful of caller and work queue thread relative priority. If this function sleeps it will not return until the work queue thread completes the tasks that allow this thread to resume.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Behavior is undefined if this function is invoked on <code class="docutils literal notranslate"><span class="pre">work</span></code> from a work queue running <code class="docutils literal notranslate"><span class="pre">work</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>work</strong> – pointer to the work item.</p></li>
<li><p><strong>sync</strong> – pointer to an opaque item containing state related to the pending cancellation. The object must persist until the call returns, and be accessible from both the caller thread and the work queue thread. The object must not be used for any other flush or cancel operation until this one completes. On architectures with CONFIG_KERNEL_COHERENCE the object must be allocated in coherent memory.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>true</strong> – if work was pending (call had to wait for cancellation of a running handler to complete, or scheduled or submitted operations were cancelled); </p></li>
<li><p><strong>false</strong> – otherwise </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_queue_init">
<span class="target" id="group__workqueue__apis_1gada77d818ea9e4d07c14a960872ed5492"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_queue_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work_q" title="k_work_q"><span class="n"><span class="pre">k_work_q</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">queue</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_queue_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a work queue structure. </p>
<p>This must be invoked before starting a work queue structure for the first time. It need not be invoked again on the same work queue structure.</p>
<p><dl class="simple">
<dt><strong>Function properties (list may not be complete)</strong></dt><dd><p><span> <a class="reference internal" href="../../api/terminology.html#api-term-isr-ok"><span class="std std-ref">isr-ok</span></a></span> </p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>queue</strong> – the queue structure to be initialized. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_queue_start">
<span class="target" id="group__workqueue__apis_1gadfc56554f9bfe7b52309d79660188593"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_queue_start</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work_q" title="k_work_q"><span class="n"><span class="pre">k_work_q</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">queue</span></span>, <span class="n"><span class="pre">k_thread_stack_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">stack</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">stack_size</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">prio</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work_queue_config" title="k_work_queue_config"><span class="n"><span class="pre">k_work_queue_config</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cfg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_queue_start" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a work queue. </p>
<p>This configures the work queue thread and starts it running. The function should not be re-invoked on a queue.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>queue</strong> – pointer to the queue structure. It must be initialized in zeroed/bss memory or with <a class="reference internal" href="#group__workqueue__apis_1gada77d818ea9e4d07c14a960872ed5492"><span class="std std-ref">k_work_queue_init</span></a> before use.</p></li>
<li><p><strong>stack</strong> – pointer to the work thread stack area.</p></li>
<li><p><strong>stack_size</strong> – size of the the work thread stack area, in bytes.</p></li>
<li><p><strong>prio</strong> – initial thread priority</p></li>
<li><p><strong>cfg</strong> – optional additional configuration parameters. Pass <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if not required, to use the defaults documented in <a class="reference internal" href="#structk__work__queue__config"><span class="std std-ref">k_work_queue_config</span></a>. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_queue_thread_get">
<span class="target" id="group__workqueue__apis_1ga0b8b496f7e7bd82d08590a07293e38d7"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">k_tid_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_queue_thread_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work_q" title="k_work_q"><span class="n"><span class="pre">k_work_q</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">queue</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_queue_thread_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Access the thread that animates a work queue. </p>
<p>This is necessary to grant a work queue thread access to things the work items it will process are expected to use.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>queue</strong> – pointer to the queue structure.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the thread associated with the work queue. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_queue_drain">
<span class="target" id="group__workqueue__apis_1ga0fefe3e0225ac99b47b250849f6cd863"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_queue_drain</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work_q" title="k_work_q"><span class="n"><span class="pre">k_work_q</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">queue</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">plug</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_queue_drain" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wait until the work queue has drained, optionally plugging it. </p>
<p>This blocks submission to the work queue except when coming from queue thread, and blocks the caller until no more work items are available in the queue.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">plug</span></code> is true then submission will continue to be blocked after the drain operation completes until <a class="reference internal" href="#group__workqueue__apis_1gaa0463bb79af3ec470f7d3be02052139f"><span class="std std-ref">k_work_queue_unplug()</span></a> is invoked.</p>
<p>Note that work items that are delayed are not yet associated with their work queue. They must be cancelled externally if a goal is to ensure the work queue remains empty. The <code class="docutils literal notranslate"><span class="pre">plug</span></code> feature can be used to prevent delayed items from being submitted after the drain completes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>queue</strong> – pointer to the queue structure.</p></li>
<li><p><strong>plug</strong> – if true the work queue will continue to block new submissions after all items have drained.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>1</strong> – if call had to wait for the drain to complete </p></li>
<li><p><strong>0</strong> – if call did not have to wait </p></li>
<li><p><strong>negative</strong> – if wait was interrupted or failed </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_queue_unplug">
<span class="target" id="group__workqueue__apis_1gaa0463bb79af3ec470f7d3be02052139f"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_queue_unplug</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work_q" title="k_work_q"><span class="n"><span class="pre">k_work_q</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">queue</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_queue_unplug" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Release a work queue to accept new submissions. </p>
<p>This releases the block on new submissions placed when <a class="reference internal" href="#group__workqueue__apis_1ga0fefe3e0225ac99b47b250849f6cd863"><span class="std std-ref">k_work_queue_drain()</span></a> is invoked with the <code class="docutils literal notranslate"><span class="pre">plug</span></code> option enabled. If this is invoked before the drain completes new items may be submitted as soon as the drain completes.</p>
<p><dl class="simple">
<dt><strong>Function properties (list may not be complete)</strong></dt><dd><p><span> <a class="reference internal" href="../../api/terminology.html#api-term-isr-ok"><span class="std std-ref">isr-ok</span></a></span> </p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>queue</strong> – pointer to the queue structure.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>0</strong> – if successfully unplugged </p></li>
<li><p><strong>-EALREADY</strong> – if the work queue was not plugged. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_init_delayable">
<span class="target" id="group__workqueue__apis_1ga2876c5d82fb2340a093bc4d689a55465"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_init_delayable</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work_delayable" title="k_work_delayable"><span class="n"><span class="pre">k_work_delayable</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dwork</span></span>, <a class="reference internal" href="#c.k_work_handler_t" title="k_work_handler_t"><span class="n"><span class="pre">k_work_handler_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">handler</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_init_delayable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a delayable work structure. </p>
<p>This must be invoked before scheduling a delayable work structure for the first time. It need not be invoked again on the same work structure. It can be re-invoked to change the associated handler, but this must be done when the work item is idle.</p>
<p><dl class="simple">
<dt><strong>Function properties (list may not be complete)</strong></dt><dd><p><span> <a class="reference internal" href="../../api/terminology.html#api-term-isr-ok"><span class="std std-ref">isr-ok</span></a></span> </p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dwork</strong> – the delayable work structure to be initialized.</p></li>
<li><p><strong>handler</strong> – the handler to be invoked by the work item. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_delayable_from_work">
<span class="target" id="group__workqueue__apis_1gabcb822a03ce7ea9ee1ed046afe31ffca"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work_delayable" title="k_work_delayable"><span class="n"><span class="pre">k_work_delayable</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">k_work_delayable_from_work</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work" title="k_work"><span class="n"><span class="pre">k_work</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_delayable_from_work" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the parent delayable work structure from a work pointer. </p>
<p>This function is necessary when a <code class="docutils literal notranslate"><span class="pre">k_work_handler_t</span></code> function is passed to <a class="reference internal" href="#group__workqueue__apis_1ga17f863c9f6ff2fb41dc0f3b7de4fdf23"><span class="std std-ref">k_work_schedule_for_queue()</span></a> and the handler needs to access data from the container of the containing <code class="docutils literal notranslate"><a class="reference internal" href="#structk__work__delayable"><span class="std std-ref"><span class="pre">k_work_delayable</span></span></a></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>work</strong> – Address passed to the work handler</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Address of the containing <code class="docutils literal notranslate"><a class="reference internal" href="#structk__work__delayable"><span class="std std-ref"><span class="pre">k_work_delayable</span></span></a></code> structure. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_delayable_busy_get">
<span class="target" id="group__workqueue__apis_1ga1b76969667844f0981d348c9c671bc9f"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_delayable_busy_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work_delayable" title="k_work_delayable"><span class="n"><span class="pre">k_work_delayable</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dwork</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_delayable_busy_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Busy state flags from the delayable work item. </p>
<p><dl class="simple">
<dt><strong>Function properties (list may not be complete)</strong></dt><dd><p><span> <a class="reference internal" href="../../api/terminology.html#api-term-isr-ok"><span class="std std-ref">isr-ok</span></a></span> </p>
</dd>
</dl>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a live snapshot of state, which may change before the result can be inspected. Use locks where appropriate.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dwork</strong> – pointer to the delayable work item.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a mask of flags K_WORK_DELAYED, K_WORK_QUEUED, K_WORK_RUNNING, and K_WORK_CANCELING. A zero return value indicates the work item appears to be idle. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_delayable_is_pending">
<span class="target" id="group__workqueue__apis_1ga66e598dbc73f653cbfec03c21168df2e"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_delayable_is_pending</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work_delayable" title="k_work_delayable"><span class="n"><span class="pre">k_work_delayable</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dwork</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_delayable_is_pending" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test whether a delayed work item is currently pending. </p>
<p>Wrapper to determine whether a delayed work item is in a non-idle state.</p>
<p><dl class="simple">
<dt><strong>Function properties (list may not be complete)</strong></dt><dd><p><span> <a class="reference internal" href="../../api/terminology.html#api-term-isr-ok"><span class="std std-ref">isr-ok</span></a></span> </p>
</dd>
</dl>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a live snapshot of state, which may change before the result can be inspected. Use locks where appropriate.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dwork</strong> – pointer to the delayable work item.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>true if and only if <a class="reference internal" href="#group__workqueue__apis_1ga1b76969667844f0981d348c9c671bc9f"><span class="std std-ref">k_work_delayable_busy_get()</span></a> returns a non-zero value. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_delayable_expires_get">
<span class="target" id="group__workqueue__apis_1ga1772c37bc62b86180d5cf48fe3037624"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="../timing/clocks.html#c.k_ticks_t" title="k_ticks_t"><span class="n"><span class="pre">k_ticks_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_delayable_expires_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work_delayable" title="k_work_delayable"><span class="n"><span class="pre">k_work_delayable</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dwork</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_delayable_expires_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the absolute tick count at which a scheduled delayable work will be submitted. </p>
<p><dl class="simple">
<dt><strong>Function properties (list may not be complete)</strong></dt><dd><p><span> <a class="reference internal" href="../../api/terminology.html#api-term-isr-ok"><span class="std std-ref">isr-ok</span></a></span> </p>
</dd>
</dl>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a live snapshot of state, which may change before the result can be inspected. Use locks where appropriate.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dwork</strong> – pointer to the delayable work item.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the tick count when the timer that will schedule the work item will expire, or the current tick count if the work is not scheduled. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_delayable_remaining_get">
<span class="target" id="group__workqueue__apis_1gabce78598a014f3ed87730fe6a9fe61b4"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="../timing/clocks.html#c.k_ticks_t" title="k_ticks_t"><span class="n"><span class="pre">k_ticks_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_delayable_remaining_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work_delayable" title="k_work_delayable"><span class="n"><span class="pre">k_work_delayable</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dwork</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_delayable_remaining_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the number of ticks until a scheduled delayable work will be submitted. </p>
<p><dl class="simple">
<dt><strong>Function properties (list may not be complete)</strong></dt><dd><p><span> <a class="reference internal" href="../../api/terminology.html#api-term-isr-ok"><span class="std std-ref">isr-ok</span></a></span> </p>
</dd>
</dl>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a live snapshot of state, which may change before the result can be inspected. Use locks where appropriate.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dwork</strong> – pointer to the delayable work item.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the number of ticks until the timer that will schedule the work item will expire, or zero if the item is not scheduled. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_schedule_for_queue">
<span class="target" id="group__workqueue__apis_1ga17f863c9f6ff2fb41dc0f3b7de4fdf23"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_schedule_for_queue</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work_q" title="k_work_q"><span class="n"><span class="pre">k_work_q</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">queue</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work_delayable" title="k_work_delayable"><span class="n"><span class="pre">k_work_delayable</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dwork</span></span>, <a class="reference internal" href="../timing/clocks.html#c.k_timeout_t" title="k_timeout_t"><span class="n"><span class="pre">k_timeout_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">delay</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_schedule_for_queue" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Submit an idle work item to a queue after a delay. </p>
<p>Unlike <a class="reference internal" href="#group__workqueue__apis_1gabf5db091eac19b19a4e12c0cb381f0a8"><span class="std std-ref">k_work_reschedule_for_queue()</span></a> this is a no-op if the work item is already scheduled or submitted, even if <code class="docutils literal notranslate"><span class="pre">delay</span></code> is <code class="docutils literal notranslate"><span class="pre">K_NO_WAIT</span></code>.</p>
<p><dl class="simple">
<dt><strong>Function properties (list may not be complete)</strong></dt><dd><p><span> <a class="reference internal" href="../../api/terminology.html#api-term-isr-ok"><span class="std std-ref">isr-ok</span></a></span> </p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>queue</strong> – the queue on which the work item should be submitted after the delay.</p></li>
<li><p><strong>dwork</strong> – pointer to the delayable work item.</p></li>
<li><p><strong>delay</strong> – the time to wait before submitting the work item. If <code class="docutils literal notranslate"><span class="pre">K_NO_WAIT</span></code> and the work is not pending this is equivalent to <a class="reference internal" href="#group__workqueue__apis_1ga5353e76f73db070614f50d06d292d05c"><span class="std std-ref">k_work_submit_to_queue()</span></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>0</strong> – if work was already scheduled or submitted. </p></li>
<li><p><strong>1</strong> – if work has been scheduled. </p></li>
<li><p><strong>-EBUSY</strong> – if <code class="docutils literal notranslate"><span class="pre">delay</span></code> is <code class="docutils literal notranslate"><span class="pre">K_NO_WAIT</span></code> and <a class="reference internal" href="#group__workqueue__apis_1ga5353e76f73db070614f50d06d292d05c"><span class="std std-ref">k_work_submit_to_queue()</span></a> fails with this code. </p></li>
<li><p><strong>-EINVAL</strong> – if <code class="docutils literal notranslate"><span class="pre">delay</span></code> is <code class="docutils literal notranslate"><span class="pre">K_NO_WAIT</span></code> and <a class="reference internal" href="#group__workqueue__apis_1ga5353e76f73db070614f50d06d292d05c"><span class="std std-ref">k_work_submit_to_queue()</span></a> fails with this code. </p></li>
<li><p><strong>-ENODEV</strong> – if <code class="docutils literal notranslate"><span class="pre">delay</span></code> is <code class="docutils literal notranslate"><span class="pre">K_NO_WAIT</span></code> and <a class="reference internal" href="#group__workqueue__apis_1ga5353e76f73db070614f50d06d292d05c"><span class="std std-ref">k_work_submit_to_queue()</span></a> fails with this code. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_schedule">
<span class="target" id="group__workqueue__apis_1ga5c113ea2bc8e8e5cd7a5c8bc5ec595d3"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_schedule</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work_delayable" title="k_work_delayable"><span class="n"><span class="pre">k_work_delayable</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dwork</span></span>, <a class="reference internal" href="../timing/clocks.html#c.k_timeout_t" title="k_timeout_t"><span class="n"><span class="pre">k_timeout_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">delay</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_schedule" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Submit an idle work item to the system work queue after a delay. </p>
<p>This is a thin wrapper around <a class="reference internal" href="#group__workqueue__apis_1ga17f863c9f6ff2fb41dc0f3b7de4fdf23"><span class="std std-ref">k_work_schedule_for_queue()</span></a>, with all the API characteristcs of that function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dwork</strong> – pointer to the delayable work item.</p></li>
<li><p><strong>delay</strong> – the time to wait before submitting the work item. If <code class="docutils literal notranslate"><span class="pre">K_NO_WAIT</span></code> this is equivalent to <a class="reference internal" href="#group__workqueue__apis_1ga5353e76f73db070614f50d06d292d05c"><span class="std std-ref">k_work_submit_to_queue()</span></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>as with <a class="reference internal" href="#group__workqueue__apis_1ga17f863c9f6ff2fb41dc0f3b7de4fdf23"><span class="std std-ref">k_work_schedule_for_queue()</span></a>. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_reschedule_for_queue">
<span class="target" id="group__workqueue__apis_1gabf5db091eac19b19a4e12c0cb381f0a8"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_reschedule_for_queue</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work_q" title="k_work_q"><span class="n"><span class="pre">k_work_q</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">queue</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work_delayable" title="k_work_delayable"><span class="n"><span class="pre">k_work_delayable</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dwork</span></span>, <a class="reference internal" href="../timing/clocks.html#c.k_timeout_t" title="k_timeout_t"><span class="n"><span class="pre">k_timeout_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">delay</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_reschedule_for_queue" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reschedule a work item to a queue after a delay. </p>
<p>Unlike <a class="reference internal" href="#group__workqueue__apis_1ga17f863c9f6ff2fb41dc0f3b7de4fdf23"><span class="std std-ref">k_work_schedule_for_queue()</span></a> this function can change the deadline of a scheduled work item, and will schedule a work item that isn’t idle (e.g. is submitted or running). This function does not affect (“unsubmit”) a work item that has been submitted to a queue.</p>
<p><dl class="simple">
<dt><strong>Function properties (list may not be complete)</strong></dt><dd><p><span> <a class="reference internal" href="../../api/terminology.html#api-term-isr-ok"><span class="std std-ref">isr-ok</span></a></span> </p>
</dd>
</dl>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If delay is <code class="docutils literal notranslate"><span class="pre">K_NO_WAIT</span></code> (“no delay”) the return values are as with <a class="reference internal" href="#group__workqueue__apis_1ga5353e76f73db070614f50d06d292d05c"><span class="std std-ref">k_work_submit_to_queue()</span></a>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>queue</strong> – the queue on which the work item should be submitted after the delay.</p></li>
<li><p><strong>dwork</strong> – pointer to the delayable work item.</p></li>
<li><p><strong>delay</strong> – the time to wait before submitting the work item. If <code class="docutils literal notranslate"><span class="pre">K_NO_WAIT</span></code> this is equivalent to <a class="reference internal" href="#group__workqueue__apis_1ga5353e76f73db070614f50d06d292d05c"><span class="std std-ref">k_work_submit_to_queue()</span></a> after canceling any previous scheduled submission.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>0</strong> – if delay is <code class="docutils literal notranslate"><span class="pre">K_NO_WAIT</span></code> and work was already on a queue </p></li>
<li><p><strong>1</strong> – if<ul>
<li><p>delay is <code class="docutils literal notranslate"><span class="pre">K_NO_WAIT</span></code> and work was not submitted but has now been queued to <code class="docutils literal notranslate"><span class="pre">queue</span></code>; or</p></li>
<li><p>delay not <code class="docutils literal notranslate"><span class="pre">K_NO_WAIT</span></code> and work has been scheduled </p></li>
</ul>
</p></li>
<li><p><strong>2</strong> – if delay is <code class="docutils literal notranslate"><span class="pre">K_NO_WAIT</span></code> and work was running and has been queued to the queue that was running it </p></li>
<li><p><strong>-EBUSY</strong> – if <code class="docutils literal notranslate"><span class="pre">delay</span></code> is <code class="docutils literal notranslate"><span class="pre">K_NO_WAIT</span></code> and <a class="reference internal" href="#group__workqueue__apis_1ga5353e76f73db070614f50d06d292d05c"><span class="std std-ref">k_work_submit_to_queue()</span></a> fails with this code. </p></li>
<li><p><strong>-EINVAL</strong> – if <code class="docutils literal notranslate"><span class="pre">delay</span></code> is <code class="docutils literal notranslate"><span class="pre">K_NO_WAIT</span></code> and <a class="reference internal" href="#group__workqueue__apis_1ga5353e76f73db070614f50d06d292d05c"><span class="std std-ref">k_work_submit_to_queue()</span></a> fails with this code. </p></li>
<li><p><strong>-ENODEV</strong> – if <code class="docutils literal notranslate"><span class="pre">delay</span></code> is <code class="docutils literal notranslate"><span class="pre">K_NO_WAIT</span></code> and <a class="reference internal" href="#group__workqueue__apis_1ga5353e76f73db070614f50d06d292d05c"><span class="std std-ref">k_work_submit_to_queue()</span></a> fails with this code. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_reschedule">
<span class="target" id="group__workqueue__apis_1gaacaab408fb7c848d466ad1f069dfa648"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_reschedule</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work_delayable" title="k_work_delayable"><span class="n"><span class="pre">k_work_delayable</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dwork</span></span>, <a class="reference internal" href="../timing/clocks.html#c.k_timeout_t" title="k_timeout_t"><span class="n"><span class="pre">k_timeout_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">delay</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_reschedule" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reschedule a work item to the system work queue after a delay. </p>
<p>This is a thin wrapper around <a class="reference internal" href="#group__workqueue__apis_1gabf5db091eac19b19a4e12c0cb381f0a8"><span class="std std-ref">k_work_reschedule_for_queue()</span></a>, with all the API characteristcs of that function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dwork</strong> – pointer to the delayable work item.</p></li>
<li><p><strong>delay</strong> – the time to wait before submitting the work item.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>as with <a class="reference internal" href="#group__workqueue__apis_1gabf5db091eac19b19a4e12c0cb381f0a8"><span class="std std-ref">k_work_reschedule_for_queue()</span></a>. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_flush_delayable">
<span class="target" id="group__workqueue__apis_1gad47d54e513030304be2600d75b1a965f"></span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_flush_delayable</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work_delayable" title="k_work_delayable"><span class="n"><span class="pre">k_work_delayable</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dwork</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work_sync" title="k_work_sync"><span class="n"><span class="pre">k_work_sync</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sync</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_flush_delayable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Flush delayable work. </p>
<p>If the work is scheduled, it is immediately submitted. Then the caller blocks until the work completes, as with <a class="reference internal" href="#group__workqueue__apis_1gabd1cda459bab538fb2d6dfd84a73b253"><span class="std std-ref">k_work_flush()</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Be careful of caller and work queue thread relative priority. If this function sleeps it will not return until the work queue thread completes the tasks that allow this thread to resume.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Behavior is undefined if this function is invoked on <code class="docutils literal notranslate"><span class="pre">dwork</span></code> from a work queue running <code class="docutils literal notranslate"><span class="pre">dwork</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dwork</strong> – pointer to the delayable work item.</p></li>
<li><p><strong>sync</strong> – pointer to an opaque item containing state related to the pending cancellation. The object must persist until the call returns, and be accessible from both the caller thread and the work queue thread. The object must not be used for any other flush or cancel operation until this one completes. On architectures with CONFIG_KERNEL_COHERENCE the object must be allocated in coherent memory.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>true</strong> – if call had to wait for completion </p></li>
<li><p><strong>false</strong> – if work was already idle </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_cancel_delayable">
<span class="target" id="group__workqueue__apis_1ga92355914ee178d4c3e848a1946bed3e4"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_cancel_delayable</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work_delayable" title="k_work_delayable"><span class="n"><span class="pre">k_work_delayable</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dwork</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_cancel_delayable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Cancel delayable work. </p>
<p>Similar to <a class="reference internal" href="#group__workqueue__apis_1ga389fe2a8fb20f9bd593cf8d990727078"><span class="std std-ref">k_work_cancel()</span></a> but for delayable work. If the work is scheduled or submitted it is canceled. This function does not wait for the cancellation to complete.</p>
<p><dl class="simple">
<dt><strong>Function properties (list may not be complete)</strong></dt><dd><p><span> <a class="reference internal" href="../../api/terminology.html#api-term-isr-ok"><span class="std std-ref">isr-ok</span></a></span> </p>
</dd>
</dl>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The work may still be running when this returns. Use <a class="reference internal" href="#group__workqueue__apis_1gad47d54e513030304be2600d75b1a965f"><span class="std std-ref">k_work_flush_delayable()</span></a> or <a class="reference internal" href="#group__workqueue__apis_1ga7e7ec237648556fc16bfda8d35f7cd86"><span class="std std-ref">k_work_cancel_delayable_sync()</span></a> to ensure it is not running.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Canceling delayable work does not prevent rescheduling it. It does prevent submitting it until the cancellation completes.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dwork</strong> – pointer to the delayable work item.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the <a class="reference internal" href="#group__workqueue__apis_1ga1b76969667844f0981d348c9c671bc9f"><span class="std std-ref">k_work_delayable_busy_get()</span></a> status indicating the state of the item after all cancellation steps performed by this call are completed. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_cancel_delayable_sync">
<span class="target" id="group__workqueue__apis_1ga7e7ec237648556fc16bfda8d35f7cd86"></span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_cancel_delayable_sync</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work_delayable" title="k_work_delayable"><span class="n"><span class="pre">k_work_delayable</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dwork</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work_sync" title="k_work_sync"><span class="n"><span class="pre">k_work_sync</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sync</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_cancel_delayable_sync" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Cancel delayable work and wait. </p>
<p>Like <a class="reference internal" href="#group__workqueue__apis_1ga92355914ee178d4c3e848a1946bed3e4"><span class="std std-ref">k_work_cancel_delayable()</span></a> but waits until the work becomes idle.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Canceling delayable work does not prevent rescheduling it. It does prevent submitting it until the cancellation completes.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Be careful of caller and work queue thread relative priority. If this function sleeps it will not return until the work queue thread completes the tasks that allow this thread to resume.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Behavior is undefined if this function is invoked on <code class="docutils literal notranslate"><span class="pre">dwork</span></code> from a work queue running <code class="docutils literal notranslate"><span class="pre">dwork</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dwork</strong> – pointer to the delayable work item.</p></li>
<li><p><strong>sync</strong> – pointer to an opaque item containing state related to the pending cancellation. The object must persist until the call returns, and be accessible from both the caller thread and the work queue thread. The object must not be used for any other flush or cancel operation until this one completes. On architectures with CONFIG_KERNEL_COHERENCE the object must be allocated in coherent memory.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>true</strong> – if work was not idle (call had to wait for cancellation of a running handler to complete, or scheduled or submitted operations were cancelled); </p></li>
<li><p><strong>false</strong> – otherwise </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_pending">
<span class="target" id="group__workqueue__apis_1ga7ab20a3405d7132870ee5e4b5610bfe3"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_pending</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work" title="k_work"><span class="n"><span class="pre">k_work</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_pending" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_q_start">
<span class="target" id="group__workqueue__apis_1gad4b913b161ebf5958f7c42ed5e1a6c25"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_q_start</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work_q" title="k_work_q"><span class="n"><span class="pre">k_work_q</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work_q</span></span>, <span class="n"><span class="pre">k_thread_stack_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">stack</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">stack_size</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">prio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_q_start" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_delayed_work_init">
<span class="target" id="group__workqueue__apis_1gaf484b980ae3dbbd620b96e883c4b4fe6"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_delayed_work_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_delayed_work" title="k_delayed_work"><span class="n"><span class="pre">k_delayed_work</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span>, <a class="reference internal" href="#c.k_work_handler_t" title="k_work_handler_t"><span class="n"><span class="pre">k_work_handler_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">handler</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_delayed_work_init" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_delayed_work_submit_to_queue">
<span class="target" id="group__workqueue__apis_1ga9d96cee1aa79b9fd01aa3ea7892f74d0"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_delayed_work_submit_to_queue</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work_q" title="k_work_q"><span class="n"><span class="pre">k_work_q</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work_q</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_delayed_work" title="k_delayed_work"><span class="n"><span class="pre">k_delayed_work</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span>, <a class="reference internal" href="../timing/clocks.html#c.k_timeout_t" title="k_timeout_t"><span class="n"><span class="pre">k_timeout_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">delay</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_delayed_work_submit_to_queue" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_delayed_work_submit">
<span class="target" id="group__workqueue__apis_1gabc2b985a4edddd17d1a7406d69167e0c"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_delayed_work_submit</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_delayed_work" title="k_delayed_work"><span class="n"><span class="pre">k_delayed_work</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span>, <a class="reference internal" href="../timing/clocks.html#c.k_timeout_t" title="k_timeout_t"><span class="n"><span class="pre">k_timeout_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">delay</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_delayed_work_submit" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_delayed_work_cancel">
<span class="target" id="group__workqueue__apis_1ga00189a735a3a557118c035b7d69feeb0"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_delayed_work_cancel</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_delayed_work" title="k_delayed_work"><span class="n"><span class="pre">k_delayed_work</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_delayed_work_cancel" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_delayed_work_pending">
<span class="target" id="group__workqueue__apis_1ga47b86afff751340829339566a9932f72"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_delayed_work_pending</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_delayed_work" title="k_delayed_work"><span class="n"><span class="pre">k_delayed_work</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_delayed_work_pending" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_delayed_work_remaining_get">
<span class="target" id="group__workqueue__apis_1ga3c5c9af0fb7c0518a87e04f110c27105"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="n"><span class="pre">int32_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_delayed_work_remaining_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_delayed_work" title="k_delayed_work"><span class="n"><span class="pre">k_delayed_work</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_delayed_work_remaining_get" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_delayed_work_expires_ticks">
<span class="target" id="group__workqueue__apis_1gacbde6358fe7676d8a6bcf286e7802997"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="../timing/clocks.html#c.k_ticks_t" title="k_ticks_t"><span class="n"><span class="pre">k_ticks_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_delayed_work_expires_ticks</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_delayed_work" title="k_delayed_work"><span class="n"><span class="pre">k_delayed_work</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_delayed_work_expires_ticks" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_delayed_work_remaining_ticks">
<span class="target" id="group__workqueue__apis_1ga1d0f51e16f52308bb258bf63b4b26915"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="../timing/clocks.html#c.k_ticks_t" title="k_ticks_t"><span class="n"><span class="pre">k_ticks_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_delayed_work_remaining_ticks</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_delayed_work" title="k_delayed_work"><span class="n"><span class="pre">k_delayed_work</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_delayed_work_remaining_ticks" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_user_init">
<span class="target" id="group__workqueue__apis_1ga9de9c7a7f13cc6b325e5453e34afe62d"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_user_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">k_work_user</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span>, <a class="reference internal" href="#c.k_work_user_handler_t" title="k_work_user_handler_t"><span class="n"><span class="pre">k_work_user_handler_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">handler</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_user_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a userspace work item. </p>
<p>This routine initializes a user workqueue work item, prior to its first use.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>work</strong> – Address of work item. </p></li>
<li><p><strong>handler</strong> – Function to invoke each time work item is processed. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_user_is_pending">
<span class="target" id="group__workqueue__apis_1ga58d05d4127e4cd51104a1f1a87f626cd"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_user_is_pending</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">k_work_user</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_user_is_pending" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if a userspace work item is pending. </p>
<p>This routine indicates if user work item <em>work</em> is pending in a workqueue’s queue.</p>
<p><dl class="simple">
<dt><strong>Function properties (list may not be complete)</strong></dt><dd><p><span> <a class="reference internal" href="../../api/terminology.html#api-term-isr-ok"><span class="std std-ref">isr-ok</span></a></span> </p>
</dd>
</dl>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Checking if the work is pending gives no guarantee that the work will still be pending when this information is used. It is up to the caller to make sure that this information is used in a safe manner.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>work</strong> – Address of work item.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>true if work item is pending, or false if it is not pending. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_user_submit_to_queue">
<span class="target" id="group__workqueue__apis_1ga50ae1f6f74c0bc0a41dbbf789fff8856"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_user_submit_to_queue</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">k_work_user_q</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work_q</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">k_work_user</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_user_submit_to_queue" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Submit a work item to a user mode workqueue. </p>
<p>Submits a work item to a workqueue that runs in user mode. A temporary memory allocation is made from the caller’s resource pool which is freed once the worker thread consumes the <a class="reference internal" href="#structk__work"><span class="std std-ref">k_work</span></a> item. The workqueue thread must have memory access to the <a class="reference internal" href="#structk__work"><span class="std std-ref">k_work</span></a> item being submitted. The caller must have permission granted on the work_q parameter’s queue object.</p>
<p><dl class="simple">
<dt><strong>Function properties (list may not be complete)</strong></dt><dd><p><span> <a class="reference internal" href="../../api/terminology.html#api-term-isr-ok"><span class="std std-ref">isr-ok</span></a></span> </p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>work_q</strong> – Address of workqueue. </p></li>
<li><p><strong>work</strong> – Address of work item.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>-EBUSY</strong> – if the work item was already in some workqueue </p></li>
<li><p><strong>-ENOMEM</strong> – if no memory for thread resource pool allocation </p></li>
<li><p><strong>0</strong> – Success </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_user_queue_start">
<span class="target" id="group__workqueue__apis_1ga3091bc8fab5311252e41634a97a18589"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_user_queue_start</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">k_work_user_q</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work_q</span></span>, <span class="n"><span class="pre">k_thread_stack_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">stack</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">stack_size</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">prio</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_user_queue_start" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Start a workqueue in user mode. </p>
<p>This works identically to <a class="reference internal" href="#group__workqueue__apis_1gadfc56554f9bfe7b52309d79660188593"><span class="std std-ref">k_work_queue_start()</span></a> except it is callable from user mode, and the worker thread created will run in user mode. The caller must have permissions granted on both the work_q parameter’s thread and queue objects, and the same restrictions on priority apply as <a class="reference internal" href="index.html#group__thread__apis_1gad5b0bff3102f1656089f5875d999a367"><span class="std std-ref">k_thread_create()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>work_q</strong> – Address of workqueue. </p></li>
<li><p><strong>stack</strong> – Pointer to work queue thread’s stack space, as defined by <a class="reference internal" href="index.html#group__thread__stack__api_1gac5368ce24fdeab3863b5c8dee2ebd955"><span class="std std-ref">K_THREAD_STACK_DEFINE()</span></a> </p></li>
<li><p><strong>stack_size</strong> – Size of the work queue thread’s stack (in bytes), which should either be the same constant passed to <a class="reference internal" href="index.html#group__thread__stack__api_1gac5368ce24fdeab3863b5c8dee2ebd955"><span class="std std-ref">K_THREAD_STACK_DEFINE()</span></a> or the value of <a class="reference internal" href="index.html#group__thread__stack__api_1ga775f8e6b4144cfdd24f3261b6db64150"><span class="std std-ref">K_THREAD_STACK_SIZEOF()</span></a>. </p></li>
<li><p><strong>prio</strong> – Priority of the work queue’s thread. </p></li>
<li><p><strong>name</strong> – optional thread name. If not null a copy is made into the thread’s name buffer. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_poll_init">
<span class="target" id="group__workqueue__apis_1ga371dab33a40622bea19b07d852863443"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_poll_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">k_work_poll</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span>, <a class="reference internal" href="#c.k_work_handler_t" title="k_work_handler_t"><span class="n"><span class="pre">k_work_handler_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">handler</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_poll_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a triggered work item. </p>
<p>This routine initializes a workqueue triggered work item, prior to its first use.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>work</strong> – Address of triggered work item. </p></li>
<li><p><strong>handler</strong> – Function to invoke each time work item is processed. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_poll_submit_to_queue">
<span class="target" id="group__workqueue__apis_1ga0abafd7f851e42fd3572c8438e600a53"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_poll_submit_to_queue</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.k_work_q" title="k_work_q"><span class="n"><span class="pre">k_work_q</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work_q</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">k_work_poll</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../other/polling.html#c.k_poll_event" title="k_poll_event"><span class="n"><span class="pre">k_poll_event</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">events</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">num_events</span></span>, <a class="reference internal" href="../timing/clocks.html#c.k_timeout_t" title="k_timeout_t"><span class="n"><span class="pre">k_timeout_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">timeout</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_poll_submit_to_queue" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Submit a triggered work item. </p>
<p>This routine schedules work item <em>work</em> to be processed by workqueue <em>work_q</em> when one of the given <em>events</em> is signaled. The routine initiates internal poller for the work item and then returns to the caller. Only when one of the watched events happen the work item is actually submitted to the workqueue and becomes pending.</p>
<p>Submitting a previously submitted triggered work item that is still waiting for the event cancels the existing submission and reschedules it the using the new event list. Note that this behavior is inherently subject to race conditions with the pre-existing triggered work item and work queue, so care must be taken to synchronize such resubmissions externally.</p>
<p><dl class="simple">
<dt><strong>Function properties (list may not be complete)</strong></dt><dd><p><span> <a class="reference internal" href="../../api/terminology.html#api-term-isr-ok"><span class="std std-ref">isr-ok</span></a></span> </p>
</dd>
</dl>
</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Provided array of events as well as a triggered work item must be placed in persistent memory (valid until work handler execution or work cancellation) and cannot be modified after submission.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>work_q</strong> – Address of workqueue. </p></li>
<li><p><strong>work</strong> – Address of delayed work item. </p></li>
<li><p><strong>events</strong> – An array of events which trigger the work. </p></li>
<li><p><strong>num_events</strong> – The number of events in the array. </p></li>
<li><p><strong>timeout</strong> – Timeout after which the work will be scheduled for execution even if not triggered.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>0</strong> – Work item started watching for events. </p></li>
<li><p><strong>-EINVAL</strong> – Work item is being processed or has completed its work. </p></li>
<li><p><strong>-EADDRINUSE</strong> – Work item is pending on a different workqueue. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_poll_submit">
<span class="target" id="group__workqueue__apis_1gad9f222e46d72c4f98739395a0c8bb4ea"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_poll_submit</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">k_work_poll</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../other/polling.html#c.k_poll_event" title="k_poll_event"><span class="n"><span class="pre">k_poll_event</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">events</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">num_events</span></span>, <a class="reference internal" href="../timing/clocks.html#c.k_timeout_t" title="k_timeout_t"><span class="n"><span class="pre">k_timeout_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">timeout</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_poll_submit" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Submit a triggered work item to the system workqueue. </p>
<p>This routine schedules work item <em>work</em> to be processed by system workqueue when one of the given <em>events</em> is signaled. The routine initiates internal poller for the work item and then returns to the caller. Only when one of the watched events happen the work item is actually submitted to the workqueue and becomes pending.</p>
<p>Submitting a previously submitted triggered work item that is still waiting for the event cancels the existing submission and reschedules it the using the new event list. Note that this behavior is inherently subject to race conditions with the pre-existing triggered work item and work queue, so care must be taken to synchronize such resubmissions externally.</p>
<p><dl class="simple">
<dt><strong>Function properties (list may not be complete)</strong></dt><dd><p><span> <a class="reference internal" href="../../api/terminology.html#api-term-isr-ok"><span class="std std-ref">isr-ok</span></a></span> </p>
</dd>
</dl>
</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Provided array of events as well as a triggered work item must not be modified until the item has been processed by the workqueue.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>work</strong> – Address of delayed work item. </p></li>
<li><p><strong>events</strong> – An array of events which trigger the work. </p></li>
<li><p><strong>num_events</strong> – The number of events in the array. </p></li>
<li><p><strong>timeout</strong> – Timeout after which the work will be scheduled for execution even if not triggered.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>0</strong> – Work item started watching for events. </p></li>
<li><p><strong>-EINVAL</strong> – Work item is being processed or has completed its work. </p></li>
<li><p><strong>-EADDRINUSE</strong> – Work item is pending on a different workqueue. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_work_poll_cancel">
<span class="target" id="group__workqueue__apis_1ga2a19547d04dc1a202e80b752e3177215"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_poll_cancel</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">k_work_poll</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_work_poll_cancel" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Cancel a triggered work item. </p>
<p>This routine cancels the submission of triggered work item <em>work</em>. A triggered work item can only be canceled if no event triggered work submission.</p>
<p><dl class="simple">
<dt><strong>Function properties (list may not be complete)</strong></dt><dd><p><span> <a class="reference internal" href="../../api/terminology.html#api-term-isr-ok"><span class="std std-ref">isr-ok</span></a></span> </p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>work</strong> – Address of delayed work item.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>0</strong> – Work item canceled. </p></li>
<li><p><strong>-EINVAL</strong> – Work item is being processed or has completed its work. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.k_work">
<span class="target" id="structk__work"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work</span></span></span><a class="headerlink" href="#c.k_work" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="docutils container">
<em>#include &lt;kernel.h&gt;</em></div>
<p>A structure used to submit work. </p>
</dd></dl>

<dl class="c struct">
<dt class="sig sig-object c" id="c.k_work_delayable">
<span class="target" id="structk__work__delayable"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_delayable</span></span></span><a class="headerlink" href="#c.k_work_delayable" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="docutils container">
<em>#include &lt;kernel.h&gt;</em></div>
<p>A structure used to submit work after a delay. </p>
</dd></dl>

<dl class="c struct">
<dt class="sig sig-object c" id="c.k_work_sync">
<span class="target" id="structk__work__sync"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_sync</span></span></span><a class="headerlink" href="#c.k_work_sync" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="docutils container">
<em>#include &lt;kernel.h&gt;</em></div>
<p>A structure holding internal state for a pending synchronous operation on a work item or queue. </p>
<p>Instances of this type are provided by the caller for invocation of <a class="reference internal" href="#group__workqueue__apis_1gabd1cda459bab538fb2d6dfd84a73b253"><span class="std std-ref">k_work_flush()</span></a>, <a class="reference internal" href="#group__workqueue__apis_1gab2b05cfe3af08f7d32c3946fa1c808f9"><span class="std std-ref">k_work_cancel_sync()</span></a> and sibling flush and cancel APIs. A referenced object must persist until the call returns, and be accessible from both the caller thread and the work queue thread.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If CONFIG_KERNEL_COHERENCE is enabled the object must be allocated in coherent memory; see <a class="reference internal" href="../../../guides/porting/arch.html#group__arch-userspace_1ga8c6bb0f6730c115689452b016ac1761f"><span class="std std-ref">arch_mem_coherent()</span></a>. The stack on these architectures is generally not coherent. be stack-allocated. Violations are detected by runtime assertion. </p>
</div>
</dd></dl>

<dl class="c struct">
<dt class="sig sig-object c" id="c.k_work_queue_config">
<span class="target" id="structk__work__queue__config"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_queue_config</span></span></span><a class="headerlink" href="#c.k_work_queue_config" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="docutils container">
<em>#include &lt;kernel.h&gt;</em></div>
<p>A structure holding optional configuration items for a work queue. </p>
<p>This structure, and values it references, are not retained by <a class="reference internal" href="#group__workqueue__apis_1gadfc56554f9bfe7b52309d79660188593"><span class="std std-ref">k_work_queue_start()</span></a>. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="c var">
<dt class="sig sig-object c" id="c.k_work_queue_config.name">
<span class="target" id="structk__work__queue__config_1a0929d83372efff6798bc69bb7ca1eaaa"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">name</span></span></span><a class="headerlink" href="#c.k_work_queue_config.name" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The name to be given to the work queue thread.</p>
<p>If left null the thread will not have a name. </p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.k_work_queue_config.no_yield">
<span class="target" id="structk__work__queue__config_1afcf64d6e69d1ddfff8cbd749dafa4d13"></span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">no_yield</span></span></span><a class="headerlink" href="#c.k_work_queue_config.no_yield" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Control whether the work queue thread should yield between items.</p>
<p>Yielding between items helps guarantee the work queue thread does not starve other threads, including cooperative ones released by a work item. This is the default behavior.</p>
<p>Set this to <code class="docutils literal notranslate"><span class="pre">true</span></code> to prevent the work queue thread from yielding between items. This may be appropriate when a sequence of items should complete without yielding control. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="c struct">
<dt class="sig sig-object c" id="c.k_work_q">
<span class="target" id="structk__work__q"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_work_q</span></span></span><a class="headerlink" href="#c.k_work_q" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="docutils container">
<em>#include &lt;kernel.h&gt;</em></div>
<p>A structure used to hold work until it can be processed. </p>
</dd></dl>

<dl class="c struct">
<dt class="sig sig-object c" id="c.k_delayed_work">
<span class="target" id="structk__delayed__work"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_delayed_work</span></span></span><a class="headerlink" href="#c.k_delayed_work" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="docutils container">
<em>#include &lt;kernel.h&gt;</em></div>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
          </div>

          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; <a href="../../../copyright.html">Copyright</a> 2015-2021 Zephyr Project members and individual contributors.
      <span class="lastupdated">Last updated on Feb 21, 2022.
      </span></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>