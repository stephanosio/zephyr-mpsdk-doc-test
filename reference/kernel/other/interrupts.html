<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Interrupts &mdash; Zephyr Project Documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/tabs.css" type="text/css" />
    <link rel="shortcut icon" href="../../../_static/favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script type="module" src="../../../_static/js/dark-mode-toggle.min.mjs"></script>
        <script src="https://www.googletagmanager.com/gtag/js?id=UA-831873-47"></script>
        <script src="../../../_static/js/ga-tracker.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="copyright" title="Copyright" href="../../../copyright.html" />
    <link rel="next" title="Polling API" href="polling.html" />
    <link rel="prev" title="Zephyr Without Threads" href="../threads/nothread.html" />
  <meta name="color-scheme" content="dark light">
  
  <link rel="stylesheet" href="../../../_static/css/light.css" type="text/css" media="(prefers-color-scheme: light)"/>
  <link rel="stylesheet" href="../../../_static/css/dark.css" type="text/css" media="(prefers-color-scheme: dark)"/>

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html">
            <img src="../../../_static/logo.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                3.0.0-rc3
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
  
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Zephyr Project</span>
      v: latest
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl>
        <dt>Document Release Versions</dt>
        
          <dd><a href="/">latest</a></dd>
        
          <dd><a href="/2.7.0/">2.7.0</a></dd>
        
          <dd><a href="/2.6.0/">2.6.0</a></dd>
        
          <dd><a href="/2.5.0/">2.5.0</a></dd>
        
          <dd><a href="/2.4.0/">2.4.0</a></dd>
        
          <dd><a href="/2.3.0/">2.3.0</a></dd>
        
          <dd><a href="/1.14.1/">1.14.1</a></dd>
        
      </dl>
      <dl>
        <dt>Downloads</dt>
        
        <dd><a href="/latest/zephyr.pdf">PDF</a></dd>
      </dl>
      <dl>
        <dt>zephyrproject.org Links</dt>
          <dd>
            <a href="https://www.zephyrproject.org/">Project Home</a>
          </dd>
          <dd>
            <a href="https://github.com/zephyrproject-rtos/sdk-ng/releases">SDK</a>
          </dd>
          <dd>
            <a href="https://github.com/zephyrproject-rtos/zephyr/releases">Releases</a>
          </dd>
      </dl>
    </div>
  </div>
  
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../introduction/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/index.html">Getting Started Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contribute/index.html">Contribution Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../development_process/index.html">Development and Contribution Process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/build/index.html">Build and Configuration Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../application/index.html">Application Development</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../api/index.html">API Status and Guidelines</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../audio/index.html">Audio</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/notify.html">Asynchronous Notifications</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../bluetooth/index.html">Bluetooth</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../canbus/index.html">Controller Area Network (CAN)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../crypto/index.html">Crypto</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devicetree/index.html">Devicetree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../drivers/index.html">Device Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../display/index.html">Display Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../edac/index.html">Error Detection And Correction (EDAC)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../file_system/index.html">File Systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../iterable_sections/index.html">Iterable Sections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/formatted_output.html">Formatted Output</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">Kernel Services</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="../index.html#scheduling-interrupts-and-synchronization">Scheduling, Interrupts, and Synchronization</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="../threads/index.html">Threads</a></li>
<li class="toctree-l4"><a class="reference internal" href="../scheduling/index.html">Scheduling</a></li>
<li class="toctree-l4"><a class="reference internal" href="../threads/system_threads.html">System Threads</a></li>
<li class="toctree-l4"><a class="reference internal" href="../threads/workqueue.html">Workqueue Threads</a></li>
<li class="toctree-l4"><a class="reference internal" href="../threads/nothread.html">Zephyr Without Threads</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">Interrupts</a></li>
<li class="toctree-l4"><a class="reference internal" href="polling.html">Polling API</a></li>
<li class="toctree-l4"><a class="reference internal" href="../synchronization/semaphores.html">Semaphores</a></li>
<li class="toctree-l4"><a class="reference internal" href="../synchronization/mutexes.html">Mutexes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../synchronization/condvar.html">Condition Variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="../synchronization/events.html">Events</a></li>
<li class="toctree-l4"><a class="reference internal" href="../smp/smp.html">Symmetric Multiprocessing</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../index.html#data-passing">Data Passing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../index.html#memory-management">Memory Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="../index.html#timing">Timing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../index.html#other">Other</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../libc/index.html">C standard library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../logging/index.html">Logging</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../memory_management/index.html">Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/index.html">Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../data_structures/index.html">Data Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../modbus/index.html">Modbus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../networking/index.html">Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../peripherals/index.html">Peripherals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../pinctrl/index.html">Pin Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../pm/index.html">Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../random/index.html">Random Number Generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../resource_management/index.html">Resource Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../shell/index.html">Shell</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../storage/index.html">Storage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../task_wdt/index.html">Task Watchdog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/timeutil.html">Time Utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../usb/index.html">USB device support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../usermode/index.html">User Mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../util/index.html">Utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../settings/index.html">Settings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../timing_functions/index.html">Executing Time Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../virtualization/index.html">Virtualization</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/index.html">User and Developer Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../security/index.html">Security</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../samples/index.html">Samples and Demos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../boards/index.html">Supported Boards</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../releases/index.html">Release Notes</a></li>
</ul>

  
  <div class="toctree-wrapper compound">
    <p class="caption"><span class="caption-text">Reference</span></p>
    <ul>
      
      <li class="toctree-l1">
        <a class="reference internal" href="/latest/doxygen/html/index.html">API</a>
      </li>
      
      <li class="toctree-l1">
        <a class="reference internal" href="/latest/reference/kconfig/index.html">Kconfig Options</a>
      </li>
      
      <li class="toctree-l1">
        <a class="reference internal" href="/latest/reference/devicetree/bindings.html">Devicetree Bindings</a>
      </li>
      
    </ul>
  </div>
  

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Zephyr Project</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
  <!-- Docs / Latest -->
  
  

  <li><a href="../../../index.html">Docs / Latest</a> &raquo;</li>
  
     <li><a href="../../index.html">API Reference</a> &raquo;</li>
  
     <li><a href="../index.html">Kernel Services</a> &raquo;</li>
  
  <li>Interrupts</li>


  <li class="wy-breadcrumbs-aside">
    <dark-mode-toggle id="dark-mode-toggle" appearance="toggle" permanent="true"/>
  </li>
  <li class="wy-breadcrumbs-aside">
      
      
        <a href="https://github.com/zephyrproject-rtos/zephyr/blob/main/doc/reference/kernel/other/interrupts.rst" class="fa fa-github"> Open on GitHub</a>
      
    
  </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
  
    <div class="wy-alert wy-alert-danger">
     This is the documentation for the latest (main) development branch of
     Zephyr. If you are looking for the documentation of previous releases, use
     the drop-down menu on the left and select the desired version.
    </div>
  
  
           <div itemprop="articleBody">
             
  <div class="section" id="interrupts">
<span id="interrupts-v2"></span><h1>Interrupts<a class="headerlink" href="#interrupts" title="Permalink to this headline">¶</a></h1>
<p>An <em class="dfn">interrupt service routine</em> (ISR) is a function that executes
asynchronously in response to a hardware or software interrupt.
An ISR normally preempts the execution of the current thread,
allowing the response to occur with very low overhead.
Thread execution resumes only once all ISR work has been completed.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#concepts" id="id1">Concepts</a></p>
<ul>
<li><p><a class="reference internal" href="#multi-level-interrupt-handling" id="id2">Multi-level Interrupt handling</a></p></li>
<li><p><a class="reference internal" href="#preventing-interruptions" id="id3">Preventing Interruptions</a></p></li>
<li><p><a class="reference internal" href="#offloading-isr-work" id="id4">Offloading ISR Work</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#implementation" id="id5">Implementation</a></p>
<ul>
<li><p><a class="reference internal" href="#defining-a-regular-isr" id="id6">Defining a regular ISR</a></p></li>
<li><p><a class="reference internal" href="#defining-a-direct-isr" id="id7">Defining a ‘direct’ ISR</a></p></li>
<li><p><a class="reference internal" href="#implementation-details" id="id8">Implementation Details</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#suggested-uses" id="id9">Suggested Uses</a></p></li>
<li><p><a class="reference internal" href="#configuration-options" id="id10">Configuration Options</a></p></li>
<li><p><a class="reference internal" href="#api-reference" id="id11">API Reference</a></p></li>
</ul>
</div>
<div class="section" id="concepts">
<h2><a class="toc-backref" href="#id1">Concepts</a><a class="headerlink" href="#concepts" title="Permalink to this headline">¶</a></h2>
<p>Any number of ISRs can be defined (limited only by available RAM), subject to
the constraints imposed by underlying hardware.</p>
<p>An ISR has the following key properties:</p>
<ul class="simple">
<li><p>An <strong>interrupt request (IRQ) signal</strong> that triggers the ISR.</p></li>
<li><p>A <strong>priority level</strong> associated with the IRQ.</p></li>
<li><p>An <strong>interrupt handler function</strong> that is invoked to handle the interrupt.</p></li>
<li><p>An <strong>argument value</strong> that is passed to that function.</p></li>
</ul>
<p>An <abbr title="Interrupt Descriptor Table">IDT</abbr> or a vector table is used
to associate a given interrupt source with a given ISR.
Only a single ISR can be associated with a specific IRQ at any given time.</p>
<p>Multiple ISRs can utilize the same function to process interrupts,
allowing a single function to service a device that generates
multiple types of interrupts or to service multiple devices
(usually of the same type). The argument value passed to an ISR’s function
allows the function to determine which interrupt has been signaled.</p>
<p>The kernel provides a default ISR for all unused IDT entries. This ISR
generates a fatal system error if an unexpected interrupt is signaled.</p>
<p>The kernel supports <strong>interrupt nesting</strong>. This allows an ISR to be preempted
in mid-execution if a higher priority interrupt is signaled. The lower
priority ISR resumes execution once the higher priority ISR has completed
its processing.</p>
<p>An ISR’s interrupt handler function executes in the kernel’s <strong>interrupt
context</strong>. This context has its own dedicated stack area (or, on some
architectures, stack areas). The size of the interrupt context stack must be
capable of handling the execution of multiple concurrent ISRs if interrupt
nesting support is enabled.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Many kernel APIs can be used only by threads, and not by ISRs. In cases
where a routine may be invoked by both threads and ISRs the kernel
provides the <a class="reference internal" href="#c.k_is_in_isr" title="k_is_in_isr"><code class="xref c c-func docutils literal notranslate"><span class="pre">k_is_in_isr()</span></code></a> API to allow the routine to
alter its behavior depending on whether it is executing as part of
a thread or as part of an ISR.</p>
</div>
<div class="section" id="multi-level-interrupt-handling">
<span id="multi-level-interrupts"></span><h3><a class="toc-backref" href="#id2">Multi-level Interrupt handling</a><a class="headerlink" href="#multi-level-interrupt-handling" title="Permalink to this headline">¶</a></h3>
<p>A hardware platform can support more interrupt lines than natively-provided
through the use of one or more nested interrupt controllers.  Sources of
hardware interrupts are combined into one line that is then routed to
the parent controller.</p>
<p>If nested interrupt controllers are supported, <a class="reference internal" href="../../kconfig/dummy-syms.html#std-kconfig-CONFIG_MULTI_LEVEL_INTERRUPTS"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_MULTI_LEVEL_INTERRUPTS</span></code></a>
should be set to 1, and <a class="reference internal" href="../../kconfig/dummy-syms.html#std-kconfig-CONFIG_2ND_LEVEL_INTERRUPTS"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_2ND_LEVEL_INTERRUPTS</span></code></a> and
<a class="reference internal" href="../../kconfig/dummy-syms.html#std-kconfig-CONFIG_3RD_LEVEL_INTERRUPTS"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_3RD_LEVEL_INTERRUPTS</span></code></a> configured as well, based on the
hardware architecture.</p>
<p>A unique 32-bit interrupt number is assigned with information
embedded in it to select and invoke the correct Interrupt
Service Routine (ISR). Each interrupt level is given a byte within this 32-bit
number, providing support for up to four interrupt levels using this arch, as
illustrated and explained below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>          9             2   0
    _ _ _ _ _ _ _ _ _ _ _ _ _         (LEVEL 1)
  5       |         A   |
_ _ _ _ _ _ _         _ _ _ _ _ _ _   (LEVEL 2)
  |   C                       B
_ _ _ _ _ _ _                         (LEVEL 3)
        D
</pre></div>
</div>
<p>There are three interrupt levels shown here.</p>
<ul class="simple">
<li><p>‘-‘ means interrupt line and is numbered from 0 (right most).</p></li>
<li><p>LEVEL 1 has 12 interrupt lines, with two lines (2 and 9) connected
to nested controllers and one device ‘A’ on line 4.</p></li>
<li><p>One of the LEVEL 2 controllers has interrupt line 5 connected to
a LEVEL 3 nested controller and one device ‘C’ on line 3.</p></li>
<li><p>The other LEVEL 2 controller has no nested controllers but has one
device ‘B’ on line 2.</p></li>
<li><p>The LEVEL 3 controller has one device ‘D’ on line 2.</p></li>
</ul>
<p>Here’s how unique interrupt numbers are generated for each
hardware interrupt.  Let’s consider four interrupts shown above
as A, B, C, and D:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>A -&gt; 0x00000004
B -&gt; 0x00000302
C -&gt; 0x00000409
D -&gt; 0x00030609
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The bit positions for LEVEL 2 and onward are offset by 1, as 0 means that
interrupt number is not present for that level. For our example, the LEVEL 3
controller has device D on line 2, connected to the LEVEL 2 controller’s line
5, that is connected to the LEVEL 1 controller’s line 9 (2 -&gt; 5 -&gt; 9).
Because of the encoding offset for LEVEL 2 and onward, device D is given the
number 0x00030609.</p>
</div>
</div>
<div class="section" id="preventing-interruptions">
<h3><a class="toc-backref" href="#id3">Preventing Interruptions</a><a class="headerlink" href="#preventing-interruptions" title="Permalink to this headline">¶</a></h3>
<p>In certain situations it may be necessary for the current thread to
prevent ISRs from executing while it is performing time-sensitive
or critical section operations.</p>
<p>A thread may temporarily prevent all IRQ handling in the system using
an <strong>IRQ lock</strong>. This lock can be applied even when it is already in effect,
so routines can use it without having to know if it is already in effect.
The thread must unlock its IRQ lock the same number of times it was locked
before interrupts can be once again processed by the kernel while the thread
is running.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>The IRQ lock is thread-specific. If thread A locks out interrupts
then performs an operation that puts itself to sleep (e.g. sleeping
for N milliseconds), the thread’s IRQ lock no longer applies once
thread A is swapped out and the next ready thread B starts to
run.</p>
<p>This means that interrupts can be processed while thread B is
running unless thread B has also locked out interrupts using its own
IRQ lock.  (Whether interrupts can be processed while the kernel is
switching between two threads that are using the IRQ lock is
architecture-specific.)</p>
<p>When thread A eventually becomes the current thread once again, the kernel
re-establishes thread A’s IRQ lock. This ensures thread A won’t be
interrupted until it has explicitly unlocked its IRQ lock.</p>
<p>If thread A does not sleep but does make a higher-priority thread B
ready, the IRQ lock will inhibit any preemption that would otherwise
occur.  Thread B will not run until the next <a class="reference internal" href="../scheduling/index.html#scheduling-v2"><span class="std std-ref">reschedule point</span></a> reached after releasing the IRQ lock.</p>
</div>
<p>Alternatively, a thread may temporarily <strong>disable</strong> a specified IRQ
so its associated ISR does not execute when the IRQ is signaled.
The IRQ must be subsequently <strong>enabled</strong> to permit the ISR to execute.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Disabling an IRQ prevents <em>all</em> threads in the system from being preempted
by the associated ISR, not just the thread that disabled the IRQ.</p>
</div>
<div class="section" id="zero-latency-interrupts">
<h4>Zero Latency Interrupts<a class="headerlink" href="#zero-latency-interrupts" title="Permalink to this headline">¶</a></h4>
<p>Preventing interruptions by applying an IRQ lock may increase the observed
interrupt latency. A high interrupt latency, however, may not be acceptable
for certain low-latency use-cases.</p>
<p>The kernel addresses such use-cases by allowing interrupts with critical
latency constraints to execute at a priority level that cannot be blocked
by interrupt locking. These interrupts are defined as
<em>zero-latency interrupts</em>. The support for zero-latency interrupts requires
<a class="reference internal" href="../../kconfig/dummy-syms.html#std-kconfig-CONFIG_ZERO_LATENCY_IRQS"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_ZERO_LATENCY_IRQS</span></code></a> to be enabled. In addition to that, the
flag <code class="xref c c-macro docutils literal notranslate"><span class="pre">IRQ_ZERO_LATENCY</span></code> must be passed to <a class="reference internal" href="#c.IRQ_CONNECT" title="IRQ_CONNECT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">IRQ_CONNECT</span></code></a> or
<a class="reference internal" href="#c.IRQ_DIRECT_CONNECT" title="IRQ_DIRECT_CONNECT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">IRQ_DIRECT_CONNECT</span></code></a> macros to configure the particular interrupt
with zero latency.</p>
<p>Zero-latency interrupts are expected to be used to manage hardware events
directly, and not to interoperate with the kernel code at all. They should
treat all kernel APIs as undefined behavior (i.e. an application that uses the
APIs inside a zero-latency interrupt context is responsible for directly
verifying correct behavior). Zero-latency interrupts may not modify any data
inspected by kernel APIs invoked from normal Zephyr contexts and shall not
generate exceptions that need to be handled synchronously (e.g. kernel panic).</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Zero-latency interrupts are supported on an architecture-specific basis.
The feature is currently implemented in the ARM Cortex-M architecture
variant.</p>
</div>
</div>
</div>
<div class="section" id="offloading-isr-work">
<h3><a class="toc-backref" href="#id4">Offloading ISR Work</a><a class="headerlink" href="#offloading-isr-work" title="Permalink to this headline">¶</a></h3>
<p>An ISR should execute quickly to ensure predictable system operation.
If time consuming processing is required the ISR should offload some or all
processing to a thread, thereby restoring the kernel’s ability to respond
to other interrupts.</p>
<p>The kernel supports several mechanisms for offloading interrupt-related
processing to a thread.</p>
<ul class="simple">
<li><p>An ISR can signal a helper thread to do interrupt-related processing
using a kernel object, such as a FIFO, LIFO, or semaphore.</p></li>
<li><p>An ISR can instruct the system workqueue thread to execute a work item.
(See <a class="reference internal" href="../threads/workqueue.html#workqueues-v2"><span class="std std-ref">Workqueue Threads</span></a>.)</p></li>
</ul>
<p>When an ISR offloads work to a thread, there is typically a single context
switch to that thread when the ISR completes, allowing interrupt-related
processing to continue almost immediately. However, depending on the
priority of the thread handling the offload, it is possible that
the currently executing cooperative thread or other higher-priority threads
may execute before the thread handling the offload is scheduled.</p>
</div>
</div>
<div class="section" id="implementation">
<h2><a class="toc-backref" href="#id5">Implementation</a><a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="defining-a-regular-isr">
<h3><a class="toc-backref" href="#id6">Defining a regular ISR</a><a class="headerlink" href="#defining-a-regular-isr" title="Permalink to this headline">¶</a></h3>
<p>An ISR is defined at runtime by calling <a class="reference internal" href="#c.IRQ_CONNECT" title="IRQ_CONNECT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">IRQ_CONNECT</span></code></a>. It must
then be enabled by calling <a class="reference internal" href="#c.irq_enable" title="irq_enable"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_enable()</span></code></a>.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>IRQ_CONNECT() is not a C function and does some inline assembly magic
behind the scenes. All its arguments must be known at build time.
Drivers that have multiple instances may need to define per-instance
config functions to configure each instance of the interrupt.</p>
</div>
<p>The following code defines and enables an ISR.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define MY_DEV_IRQ  24       </span><span class="cm">/* device uses IRQ 24 */</span><span class="cp"></span>
<span class="cp">#define MY_DEV_PRIO  2       </span><span class="cm">/* device uses interrupt priority 2 */</span><span class="cp"></span>
<span class="cm">/* argument passed to my_isr(), in this case a pointer to the device */</span><span class="w"></span>
<span class="cp">#define MY_ISR_ARG  DEVICE_GET(my_device)</span>
<span class="cp">#define MY_IRQ_FLAGS 0       </span><span class="cm">/* IRQ flags */</span><span class="cp"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">my_isr</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="p">...</span><span class="w"> </span><span class="cm">/* ISR code */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">my_isr_installer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="p">...</span><span class="w"></span>
<span class="w">   </span><span class="n">IRQ_CONNECT</span><span class="p">(</span><span class="n">MY_DEV_IRQ</span><span class="p">,</span><span class="w"> </span><span class="n">MY_DEV_PRIO</span><span class="p">,</span><span class="w"> </span><span class="n">my_isr</span><span class="p">,</span><span class="w"> </span><span class="n">MY_ISR_ARG</span><span class="p">,</span><span class="w"> </span><span class="n">MY_IRQ_FLAGS</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">irq_enable</span><span class="p">(</span><span class="n">MY_DEV_IRQ</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Since the <a class="reference internal" href="#c.IRQ_CONNECT" title="IRQ_CONNECT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">IRQ_CONNECT</span></code></a> macro requires that all its parameters be
known at build time, in some cases this may not be acceptable. It is also
possible to install interrupts at runtime with
<a class="reference internal" href="#c.irq_connect_dynamic" title="irq_connect_dynamic"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_connect_dynamic()</span></code></a>. It is used in exactly the same way as
<a class="reference internal" href="#c.IRQ_CONNECT" title="IRQ_CONNECT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">IRQ_CONNECT</span></code></a>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">my_isr_installer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="p">...</span><span class="w"></span>
<span class="w">   </span><span class="n">irq_connect_dynamic</span><span class="p">(</span><span class="n">MY_DEV_IRQ</span><span class="p">,</span><span class="w"> </span><span class="n">MY_DEV_PRIO</span><span class="p">,</span><span class="w"> </span><span class="n">my_isr</span><span class="p">,</span><span class="w"> </span><span class="n">MY_ISR_ARG</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">MY_IRQ_FLAGS</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">irq_enable</span><span class="p">(</span><span class="n">MY_DEV_IRQ</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Dynamic interrupts require the <a class="reference internal" href="../../kconfig/dummy-syms.html#std-kconfig-CONFIG_DYNAMIC_INTERRUPTS"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_DYNAMIC_INTERRUPTS</span></code></a> option to
be enabled. Removing or re-configuring a dynamic interrupt is currently
unsupported.</p>
</div>
<div class="section" id="defining-a-direct-isr">
<h3><a class="toc-backref" href="#id7">Defining a ‘direct’ ISR</a><a class="headerlink" href="#defining-a-direct-isr" title="Permalink to this headline">¶</a></h3>
<p>Regular Zephyr interrupts introduce some overhead which may be unacceptable
for some low-latency use-cases. Specifically:</p>
<ul class="simple">
<li><p>The argument to the ISR is retrieved and passed to the ISR</p></li>
<li><p>If power management is enabled and the system was idle, all the hardware
will be resumed from low-power state before the ISR is executed, which can be
very time-consuming</p></li>
<li><p>Although some architectures will do this in hardware, other architectures
need to switch to the interrupt stack in code</p></li>
<li><p>After the interrupt is serviced, the OS then performs some logic to
potentially make a scheduling decision.</p></li>
</ul>
<p>Zephyr supports so-called ‘direct’ interrupts, which are installed via
<a class="reference internal" href="#c.IRQ_DIRECT_CONNECT" title="IRQ_DIRECT_CONNECT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">IRQ_DIRECT_CONNECT</span></code></a>. These direct interrupts have some special
implementation requirements and a reduced feature set; see the definition
of <a class="reference internal" href="#c.IRQ_DIRECT_CONNECT" title="IRQ_DIRECT_CONNECT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">IRQ_DIRECT_CONNECT</span></code></a> for details.</p>
<p>The following code demonstrates a direct ISR:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define MY_DEV_IRQ  24       </span><span class="cm">/* device uses IRQ 24 */</span><span class="cp"></span>
<span class="cp">#define MY_DEV_PRIO  2       </span><span class="cm">/* device uses interrupt priority 2 */</span><span class="cp"></span>
<span class="cm">/* argument passed to my_isr(), in this case a pointer to the device */</span><span class="w"></span>
<span class="cp">#define MY_IRQ_FLAGS 0       </span><span class="cm">/* IRQ flags */</span><span class="cp"></span>

<span class="n">ISR_DIRECT_DECLARE</span><span class="p">(</span><span class="n">my_isr</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">do_stuff</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="n">ISR_DIRECT_PM</span><span class="p">();</span><span class="w"> </span><span class="cm">/* PM done after servicing interrupt for best latency */</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="cm">/* We should check if scheduling decision should be made */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">my_isr_installer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="p">...</span><span class="w"></span>
<span class="w">   </span><span class="n">IRQ_DIRECT_CONNECT</span><span class="p">(</span><span class="n">MY_DEV_IRQ</span><span class="p">,</span><span class="w"> </span><span class="n">MY_DEV_PRIO</span><span class="p">,</span><span class="w"> </span><span class="n">my_isr</span><span class="p">,</span><span class="w"> </span><span class="n">MY_IRQ_FLAGS</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">irq_enable</span><span class="p">(</span><span class="n">MY_DEV_IRQ</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Installation of dynamic direct interrupts is supported on an
architecture-specific basis. (The feature is currently implemented in
ARM Cortex-M architecture variant. Dynamic direct interrupts feature is
exposed to the user via an ARM-only API.)</p>
</div>
<div class="section" id="implementation-details">
<h3><a class="toc-backref" href="#id8">Implementation Details</a><a class="headerlink" href="#implementation-details" title="Permalink to this headline">¶</a></h3>
<p>Interrupt tables are set up at build time using some special build tools.  The
details laid out here apply to all architectures except x86, which are
covered in the <a class="reference internal" href="#x86-details">x86 Details</a> section below.</p>
<p>Any invocation of <a class="reference internal" href="#c.IRQ_CONNECT" title="IRQ_CONNECT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">IRQ_CONNECT</span></code></a> will declare an instance of
struct _isr_list which is placed in a special .intList section:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">_isr_list</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/** IRQ line number */</span><span class="w"></span>
<span class="w">    </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">irq</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="cm">/** Flags for this IRQ, see ISR_FLAG_* definitions */</span><span class="w"></span>
<span class="w">    </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="cm">/** ISR to call */</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">func</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="cm">/** Parameter for non-direct IRQs */</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">param</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>Zephyr is built in two phases; the first phase of the build produces
<code class="docutils literal notranslate"><span class="pre">${ZEPHYR_PREBUILT_EXECUTABLE}</span></code>.elf which contains all the entries in
the .intList section preceded by a header:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">spurious_irq_handler</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">sw_irq_handler</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">num_isrs</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">num_vectors</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">_isr_list</span><span class="w"> </span><span class="n">isrs</span><span class="p">[];</span><span class="w">  </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="n">num_isrs</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>This data consisting of the header and instances of struct _isr_list inside
<code class="docutils literal notranslate"><span class="pre">${ZEPHYR_PREBUILT_EXECUTABLE}</span></code>.elf is then used by the
gen_isr_tables.py script to generate a C file defining a vector table and
software ISR table that are then compiled and linked into the final
application.</p>
<p>The priority level of any interrupt is not encoded in these tables, instead
<a class="reference internal" href="#c.IRQ_CONNECT" title="IRQ_CONNECT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">IRQ_CONNECT</span></code></a> also has a runtime component which programs the desired
priority level of the interrupt to the interrupt controller. Some architectures
do not support the notion of interrupt priority, in which case the priority
argument is ignored.</p>
<div class="section" id="vector-table">
<h4>Vector Table<a class="headerlink" href="#vector-table" title="Permalink to this headline">¶</a></h4>
<p>A vector table is generated when <a class="reference internal" href="../../kconfig/dummy-syms.html#std-kconfig-CONFIG_GEN_IRQ_VECTOR_TABLE"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_GEN_IRQ_VECTOR_TABLE</span></code></a> is
enabled.  This data structure is used natively by the CPU and is simply an
array of function pointers, where each element n corresponds to the IRQ handler
for IRQ line n, and the function pointers are:</p>
<ol class="arabic simple">
<li><p>For ‘direct’ interrupts declared with <a class="reference internal" href="#c.IRQ_DIRECT_CONNECT" title="IRQ_DIRECT_CONNECT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">IRQ_DIRECT_CONNECT</span></code></a>, the
handler function will be placed here.</p></li>
<li><p>For regular interrupts declared with <a class="reference internal" href="#c.IRQ_CONNECT" title="IRQ_CONNECT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">IRQ_CONNECT</span></code></a>, the address
of the common software IRQ handler is placed here. This code does common
kernel interrupt bookkeeping and looks up the ISR and parameter from the
software ISR table.</p></li>
<li><p>For interrupt lines that are not configured at all, the address of the
spurious IRQ handler will be placed here. The spurious IRQ handler
causes a system fatal error if encountered.</p></li>
</ol>
<p>Some architectures (such as the Nios II internal interrupt controller) have a
common entry point for all interrupts and do not support a vector table, in
which case the <a class="reference internal" href="../../kconfig/dummy-syms.html#std-kconfig-CONFIG_GEN_IRQ_VECTOR_TABLE"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_GEN_IRQ_VECTOR_TABLE</span></code></a> option should be
disabled.</p>
<p>Some architectures may reserve some initial vectors for system exceptions
and declare this in a table elsewhere, in which case
CONFIG_GEN_IRQ_START_VECTOR needs to be set to properly offset the indices
in the table.</p>
</div>
<div class="section" id="sw-isr-table">
<h4>SW ISR Table<a class="headerlink" href="#sw-isr-table" title="Permalink to this headline">¶</a></h4>
<p>This is an array of struct _isr_table_entry:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">_isr_table_entry</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">isr</span><span class="p">)(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>This is used by the common software IRQ handler to look up the ISR and its
argument and execute it. The active IRQ line is looked up in an interrupt
controller register and used to index this table.</p>
</div>
<div class="section" id="x86-details">
<h4>x86 Details<a class="headerlink" href="#x86-details" title="Permalink to this headline">¶</a></h4>
<p>The x86 architecture has a special type of vector table called the Interrupt
Descriptor Table (IDT) which must be laid out in a certain way per the x86
processor documentation.  It is still fundamentally a vector table, and the
<a class="reference internal" href="../../../guides/build/index.html#gen-idt-py"><span class="std std-ref">arch/x86/gen_idt.py</span></a> tool uses the .intList section to create it. However, on APIC-based
systems the indexes in the vector table do not correspond to the IRQ line. The
first 32 vectors are reserved for CPU exceptions, and all remaining vectors (up
to index 255) correspond to the priority level, in groups of 16. In this
scheme, interrupts of priority level 0 will be placed in vectors 32-47, level 1
48-63, and so forth. When the <a class="reference internal" href="../../../guides/build/index.html#gen-idt-py"><span class="std std-ref">arch/x86/gen_idt.py</span></a> tool is constructing the IDT, when it
configures an interrupt it will look for a free vector in the appropriate range
for the requested priority level and set the handler there.</p>
<p>On x86 when an interrupt or exception vector is executed by the CPU, there is
no foolproof way to determine which vector was fired, so a software ISR table
indexed by IRQ line is not used. Instead, the <a class="reference internal" href="#c.IRQ_CONNECT" title="IRQ_CONNECT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">IRQ_CONNECT</span></code></a> call
creates a small assembly language function which calls the common interrupt
code in <code class="xref c c-func docutils literal notranslate"><span class="pre">_interrupt_enter()</span></code> with the ISR and parameter as arguments.
It is the address of this assembly interrupt stub which gets placed in the IDT.
For interrupts declared with <a class="reference internal" href="#c.IRQ_DIRECT_CONNECT" title="IRQ_DIRECT_CONNECT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">IRQ_DIRECT_CONNECT</span></code></a> the parameterless
ISR is placed directly in the IDT.</p>
<p>On systems where the position in the vector table corresponds to the
interrupt’s priority level, the interrupt controller needs to know at
runtime what vector is associated with an IRQ line. <a class="reference internal" href="../../../guides/build/index.html#gen-idt-py"><span class="std std-ref">arch/x86/gen_idt.py</span></a> additionally
creates an _irq_to_interrupt_vector array which maps an IRQ line to its
configured vector in the IDT. This is used at runtime by <a class="reference internal" href="#c.IRQ_CONNECT" title="IRQ_CONNECT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">IRQ_CONNECT</span></code></a>
to program the IRQ-to-vector association in the interrupt controller.</p>
<p>For dynamic interrupts, the build must generate some 4-byte dynamic interrupt
stubs, one stub per dynamic interrupt in use. The number of stubs is controlled
by the <a class="reference internal" href="../../kconfig/dummy-syms.html#std-kconfig-CONFIG_X86_DYNAMIC_IRQ_STUBS"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_X86_DYNAMIC_IRQ_STUBS</span></code></a> option. Each stub pushes an
unique identifier which is then used to fetch the appropriate handler function
and parameter out of a table populated when the dynamic interrupt was
connected.</p>
</div>
</div>
</div>
<div class="section" id="suggested-uses">
<h2><a class="toc-backref" href="#id9">Suggested Uses</a><a class="headerlink" href="#suggested-uses" title="Permalink to this headline">¶</a></h2>
<p>Use a regular or direct ISR to perform interrupt processing that requires a
very rapid response, and can be done quickly without blocking.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Interrupt processing that is time consuming, or involves blocking,
should be handed off to a thread. See <a class="reference internal" href="#offloading-isr-work">Offloading ISR Work</a> for
a description of various techniques that can be used in an application.</p>
</div>
</div>
<div class="section" id="configuration-options">
<h2><a class="toc-backref" href="#id10">Configuration Options</a><a class="headerlink" href="#configuration-options" title="Permalink to this headline">¶</a></h2>
<p>Related configuration options:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../../kconfig/dummy-syms.html#std-kconfig-CONFIG_ISR_STACK_SIZE"><code class="xref std std-kconfig docutils literal notranslate"><span class="pre">CONFIG_ISR_STACK_SIZE</span></code></a></p></li>
</ul>
<p>Additional architecture-specific and device-specific configuration options
also exist.</p>
</div>
<div class="section" id="api-reference">
<h2><a class="toc-backref" href="#id11">API Reference</a><a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h2>
<dl>
<dt class="sig sig-object cpp">
<span class="target" id="group__isr__apis"></span><em><span class="pre">group</span></em> <span class="sig-name descname"><span class="pre">isr_apis</span></span></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-defines">Defines</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.IRQ_CONNECT">
<span class="target" id="group__isr__apis_1ga131739d1faf501a15590053817aba984"></span><span class="sig-name descname"><span class="n"><span class="pre">IRQ_CONNECT</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">irq_p</span></span>, <span class="n"><span class="pre">priority_p</span></span>, <span class="n"><span class="pre">isr_p</span></span>, <span class="n"><span class="pre">isr_param_p</span></span>, <span class="n"><span class="pre">flags_p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.IRQ_CONNECT" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize an interrupt handler. </p>
<p>This routine initializes an interrupt handler for an IRQ. The IRQ must be subsequently enabled before the interrupt handler begins servicing interrupts.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Although this routine is invoked at run-time, all of its arguments must be computable by the compiler at build time.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>irq_p</strong> – IRQ line number. </p></li>
<li><p><strong>priority_p</strong> – Interrupt priority. </p></li>
<li><p><strong>isr_p</strong> – Address of interrupt service routine. </p></li>
<li><p><strong>isr_param_p</strong> – Parameter passed to interrupt service routine. </p></li>
<li><p><strong>flags_p</strong> – Architecture-specific IRQ configuration flags.. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.IRQ_DIRECT_CONNECT">
<span class="target" id="group__isr__apis_1gac6c8746ac28da6ce02b24714f4144ff3"></span><span class="sig-name descname"><span class="n"><span class="pre">IRQ_DIRECT_CONNECT</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">irq_p</span></span>, <span class="n"><span class="pre">priority_p</span></span>, <span class="n"><span class="pre">isr_p</span></span>, <span class="n"><span class="pre">flags_p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.IRQ_DIRECT_CONNECT" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a ‘direct’ interrupt handler. </p>
<p>This routine initializes an interrupt handler for an IRQ. The IRQ must be subsequently enabled via <a class="reference internal" href="#group__isr__apis_1ga7ea700ee31e4ff036c997a554dbedfeb"><span class="std std-ref">irq_enable()</span></a> before the interrupt handler begins servicing interrupts.</p>
<p>These ISRs are designed for performance-critical interrupt handling and do not go through common interrupt handling code. They must be implemented in such a way that it is safe to put them directly in the vector table. For ISRs written in C, The <a class="reference internal" href="#group__isr__apis_1gaf86866cd07fd37f381d98866f8874ebf"><span class="std std-ref">ISR_DIRECT_DECLARE()</span></a> macro will do this automatically. For ISRs written in assembly it is entirely up to the developer to ensure that the right steps are taken.</p>
<p>This type of interrupt currently has a few limitations compared to normal Zephyr interrupts:<ul class="simple">
<li><p>No parameters are passed to the ISR.</p></li>
<li><p>No stack switch is done, the ISR will run on the interrupted context’s stack, unless the architecture automatically does the stack switch in HW.</p></li>
<li><p>Interrupt locking state is unchanged from how the HW sets it when the ISR runs. On arches that enter ISRs with interrupts locked, they will remain locked.</p></li>
<li><p>Scheduling decisions are now optional, controlled by the return value of ISRs implemented with the <a class="reference internal" href="#group__isr__apis_1gaf86866cd07fd37f381d98866f8874ebf"><span class="std std-ref">ISR_DIRECT_DECLARE()</span></a> macro</p></li>
<li><p>The call into the OS to exit power management idle state is now optional. Normal interrupts always do this before the ISR is run, but when it runs is now controlled by the placement of a <a class="reference internal" href="#group__isr__apis_1ga3c1327551dfca7818975e3fbf1470227"><span class="std std-ref">ISR_DIRECT_PM()</span></a> macro, or omitted entirely.</p></li>
</ul>
</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Although this routine is invoked at run-time, all of its arguments must be computable by the compiler at build time.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>irq_p</strong> – IRQ line number. </p></li>
<li><p><strong>priority_p</strong> – Interrupt priority. </p></li>
<li><p><strong>isr_p</strong> – Address of interrupt service routine. </p></li>
<li><p><strong>flags_p</strong> – Architecture-specific IRQ configuration flags. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.ISR_DIRECT_HEADER">
<span class="target" id="group__isr__apis_1ga1ab99dbeb50b228001e1fca808cbaeea"></span><span class="sig-name descname"><span class="n"><span class="pre">ISR_DIRECT_HEADER</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.ISR_DIRECT_HEADER" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Common tasks before executing the body of an ISR. </p>
<p>This macro must be at the beginning of all direct interrupts and performs minimal architecture-specific tasks before the ISR itself can run. It takes no arguments and has no return value. </p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.ISR_DIRECT_FOOTER">
<span class="target" id="group__isr__apis_1ga31581157c9dbacf935f0e6a8dd456335"></span><span class="sig-name descname"><span class="n"><span class="pre">ISR_DIRECT_FOOTER</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">check_reschedule</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ISR_DIRECT_FOOTER" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Common tasks before exiting the body of an ISR. </p>
<p>This macro must be at the end of all direct interrupts and performs minimal architecture-specific tasks like EOI. It has no return value.</p>
<p>In a normal interrupt, a check is done at end of interrupt to invoke z_swap() logic if the current thread is preemptible and there is another thread ready to run in the kernel’s ready queue cache. This is now optional and controlled by the check_reschedule argument. If unsure, set to nonzero. On systems that do stack switching and nested interrupt tracking in software, z_swap() should only be called if this was a non-nested interrupt.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>check_reschedule</strong> – If nonzero, additionally invoke scheduling logic </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.ISR_DIRECT_PM">
<span class="target" id="group__isr__apis_1ga3c1327551dfca7818975e3fbf1470227"></span><span class="sig-name descname"><span class="n"><span class="pre">ISR_DIRECT_PM</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.ISR_DIRECT_PM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Perform power management idle exit logic. </p>
<p>This macro may optionally be invoked somewhere in between IRQ_DIRECT_HEADER() and IRQ_DIRECT_FOOTER() invocations. It performs tasks necessary to exit power management idle state. It takes no parameters and returns no arguments. It may be omitted, but be careful! </p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.ISR_DIRECT_DECLARE">
<span class="target" id="group__isr__apis_1gaf86866cd07fd37f381d98866f8874ebf"></span><span class="sig-name descname"><span class="n"><span class="pre">ISR_DIRECT_DECLARE</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ISR_DIRECT_DECLARE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Helper macro to declare a direct interrupt service routine. </p>
<p>This will declare the function in a proper way and automatically include the <a class="reference internal" href="#group__isr__apis_1ga31581157c9dbacf935f0e6a8dd456335"><span class="std std-ref">ISR_DIRECT_FOOTER()</span></a> and <a class="reference internal" href="#group__isr__apis_1ga1ab99dbeb50b228001e1fca808cbaeea"><span class="std std-ref">ISR_DIRECT_HEADER()</span></a> macros. The function should return nonzero status if a scheduling decision should potentially be made. See <a class="reference internal" href="#group__isr__apis_1ga31581157c9dbacf935f0e6a8dd456335"><span class="std std-ref">ISR_DIRECT_FOOTER()</span></a> for more details on the scheduling decision.</p>
<p>For architectures that support ‘regular’ and ‘fast’ interrupt types, where these interrupt types require different assembly language handling of registers by the ISR, this will always generate code for the ‘fast’ interrupt type.</p>
<p>Example usage: <div class="highlight-default notranslate"><div class="highlight"><pre><span></span>ISR_DIRECT_DECLARE(my_isr)
{
        bool done = do_stuff();
        ISR_DIRECT_PM(); // done after do_stuff() due to latency concerns
        if (!done) {
            return 0; // don&#39;t bother checking if we have to z_swap()
        }

        k_sem_give(some_sem);
        return 1;
 }
</pre></div>
</div>
 </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> – symbol name of the ISR </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.irq_lock">
<span class="target" id="group__isr__apis_1ga19fdde73c3b02fcca6cf1d1e67631228"></span><span class="sig-name descname"><span class="n"><span class="pre">irq_lock</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_lock" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Lock interrupts. </p>
<p>This routine disables all interrupts on the CPU. It returns an unsigned integer “lock-out key”, which is an architecture-dependent indicator of whether interrupts were locked prior to the call. The lock-out key must be passed to <a class="reference internal" href="#group__isr__apis_1ga646045943b3b2a130738bcc48867bf57"><span class="std std-ref">irq_unlock()</span></a> to re-enable interrupts.</p>
<p>
This routine can be called recursively, as long as the caller keeps track of each lock-out key that is generated. Interrupts are re-enabled by passing each of the keys to <a class="reference internal" href="#group__isr__apis_1ga646045943b3b2a130738bcc48867bf57"><span class="std std-ref">irq_unlock()</span></a> in the reverse order they were acquired. (That is, each call to <a class="reference internal" href="#group__isr__apis_1ga19fdde73c3b02fcca6cf1d1e67631228"><span class="std std-ref">irq_lock()</span></a> must be balanced by a corresponding call to <a class="reference internal" href="#group__isr__apis_1ga646045943b3b2a130738bcc48867bf57"><span class="std std-ref">irq_unlock()</span></a>.)</p>
<p>This routine can only be invoked from supervisor mode. Some architectures (for example, ARM) will fail silently if invoked from user mode instead of generating an exception.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This routine must also serve as a memory barrier to ensure the uniprocessor implementation of <code class="docutils literal notranslate"><span class="pre">k_spinlock_t</span></code> is correct.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This routine can be called by ISRs or by threads. If it is called by a thread, the interrupt lock is thread-specific; this means that interrupts remain disabled only while the thread is running. If the thread performs an operation that allows another thread to run (for example, giving a semaphore or sleeping for N milliseconds), the interrupt lock no longer applies and interrupts may be re-enabled while other processing occurs. When the thread once again becomes the current thread, the kernel re-establishes its interrupt lock; this ensures the thread won’t be interrupted until it has explicitly released the interrupt lock it established.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The lock-out key should never be used to manually re-enable interrupts or to inspect or manipulate the contents of the CPU’s interrupt bits.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>An architecture-dependent lock-out key representing the “interrupt disable state” prior to the call. </p>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.irq_unlock">
<span class="target" id="group__isr__apis_1ga646045943b3b2a130738bcc48867bf57"></span><span class="sig-name descname"><span class="n"><span class="pre">irq_unlock</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">key</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_unlock" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unlock interrupts. </p>
<p>This routine reverses the effect of a previous call to <a class="reference internal" href="#group__isr__apis_1ga19fdde73c3b02fcca6cf1d1e67631228"><span class="std std-ref">irq_lock()</span></a> using the associated lock-out key. The caller must call the routine once for each time it called <a class="reference internal" href="#group__isr__apis_1ga19fdde73c3b02fcca6cf1d1e67631228"><span class="std std-ref">irq_lock()</span></a>, supplying the keys in the reverse order they were acquired, before interrupts are enabled.</p>
<p>
This routine can only be invoked from supervisor mode. Some architectures (for example, ARM) will fail silently if invoked from user mode instead of generating an exception.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This routine must also serve as a memory barrier to ensure the uniprocessor implementation of <code class="docutils literal notranslate"><span class="pre">k_spinlock_t</span></code> is correct.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Can be called by ISRs.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>key</strong> – Lock-out key generated by <a class="reference internal" href="#group__isr__apis_1ga19fdde73c3b02fcca6cf1d1e67631228"><span class="std std-ref">irq_lock()</span></a>. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.irq_enable">
<span class="target" id="group__isr__apis_1ga7ea700ee31e4ff036c997a554dbedfeb"></span><span class="sig-name descname"><span class="n"><span class="pre">irq_enable</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">irq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_enable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Enable an IRQ. </p>
<p>This routine enables interrupts from source <em>irq</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>irq</strong> – IRQ line. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.irq_disable">
<span class="target" id="group__isr__apis_1ga82c3a15d812f58e0f6525f358d031e6d"></span><span class="sig-name descname"><span class="n"><span class="pre">irq_disable</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">irq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_disable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Disable an IRQ. </p>
<p>This routine disables interrupts from source <em>irq</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>irq</strong> – IRQ line. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.irq_is_enabled">
<span class="target" id="group__isr__apis_1ga71fef3867ba9818cf0a5baf8410a6354"></span><span class="sig-name descname"><span class="n"><span class="pre">irq_is_enabled</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">irq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_is_enabled" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get IRQ enable state. </p>
<p>This routine indicates if interrupts from source <em>irq</em> are enabled.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>irq</strong> – IRQ line.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>interrupt enable state, true or false </p>
</dd>
</dl>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_connect_dynamic">
<span class="target" id="group__isr__apis_1ga4e9915b92b09df49b99bc449f0cc31a1"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_connect_dynamic</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">irq</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">priority</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">routine</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parameter</span></span><span class="p"><span class="pre">)</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parameter</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_connect_dynamic" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Configure a dynamic interrupt.</p>
<p>Use this instead of <a class="reference internal" href="#group__isr__apis_1ga131739d1faf501a15590053817aba984"><span class="std std-ref">IRQ_CONNECT()</span></a> if arguments cannot be known at build time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>irq</strong> – IRQ line number </p></li>
<li><p><strong>priority</strong> – Interrupt priority </p></li>
<li><p><strong>routine</strong> – Interrupt service routine </p></li>
<li><p><strong>parameter</strong> – ISR parameter </p></li>
<li><p><strong>flags</strong> – Arch-specific IRQ configuration flags</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The vector assigned to this interrupt </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.irq_get_level">
<span class="target" id="group__isr__apis_1ga45afd68784e71521606e489d965b1c13"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_get_level</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">irq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_get_level" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_is_in_isr">
<span class="target" id="group__isr__apis_1ga8482b0dd2283d12677a9ebe321667d16"></span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_is_in_isr</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_is_in_isr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Determine if code is running at interrupt level. </p>
<p>This routine allows the caller to customize its actions, depending on whether it is a thread or an ISR.</p>
<p><dl class="simple">
<dt><strong>Function properties (list may not be complete)</strong></dt><dd><p><span> <a class="reference internal" href="../../api/terminology.html#api-term-isr-ok"><span class="std std-ref">isr-ok</span></a></span> </p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>false if invoked by a thread. </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>true if invoked by an ISR. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_is_preempt_thread">
<span class="target" id="group__isr__apis_1ga91e1cf0dc7fc93a3214cadb74ed86666"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_is_preempt_thread</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_is_preempt_thread" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Determine if code is running in a preemptible thread. </p>
<p>This routine allows the caller to customize its actions, depending on whether it can be preempted by another thread. The routine returns a ‘true’ value if all of the following conditions are met:</p>
<p><ul class="simple">
<li><p>The code is running in a thread, not at ISR.</p></li>
<li><p>The thread’s priority is in the preemptible range.</p></li>
<li><p>The thread has not locked the scheduler.</p></li>
</ul>
</p>
<p><dl class="simple">
<dt><strong>Function properties (list may not be complete)</strong></dt><dd><p><span> <a class="reference internal" href="../../api/terminology.html#api-term-isr-ok"><span class="std std-ref">isr-ok</span></a></span> </p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 if invoked by an ISR or by a cooperative thread. </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Non-zero if invoked by a preemptible thread. </p>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.k_is_pre_kernel">
<span class="target" id="group__isr__apis_1gae74e5de996276df767b96d4b50fa47ea"></span><span class="k"><span class="pre">static</span></span><span class="w"> </span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k_is_pre_kernel</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.k_is_pre_kernel" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test whether startup is in the before-main-task phase. </p>
<p>This routine allows the caller to customize its actions, depending on whether it being invoked before the kernel is fully active.</p>
<p><dl class="simple">
<dt><strong>Function properties (list may not be complete)</strong></dt><dd><p><span> <a class="reference internal" href="../../api/terminology.html#api-term-isr-ok"><span class="std std-ref">isr-ok</span></a></span> </p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>true if invoked before post-kernel initialization </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>false if invoked during/after post-kernel initialization </p>
</dd>
</dl>
</dd></dl>

</div>
</dd></dl>

</div>
</div>


           </div>
          </div>

          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; <a href="../../../copyright.html">Copyright</a> 2015-2021 Zephyr Project members and individual contributors.
      <span class="lastupdated">Last updated on Feb 21, 2022.
      </span></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>